/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LastEditLocationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/v1.js
var _state = {};
function v1(options, buf, offset) {
  var _a, _b, _c, _d;
  let bytes;
  const isV6 = (_a = options == null ? void 0 : options._v6) != null ? _a : false;
  if (options) {
    const optionsKeys = Object.keys(options);
    if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
      options = void 0;
    }
  }
  if (options) {
    bytes = v1Bytes((_d = (_c = options.random) != null ? _c : (_b = options.rng) == null ? void 0 : _b.call(options)) != null ? _d : rng(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
  } else {
    const now = Date.now();
    const rnds = rng();
    updateV1State(_state, now, rnds);
    bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
  }
  return buf != null ? buf : unsafeStringify(bytes);
}
function updateV1State(state, now, rnds) {
  var _a, _b;
  (_a = state.msecs) != null ? _a : state.msecs = -Infinity;
  (_b = state.nsecs) != null ? _b : state.nsecs = 0;
  if (now === state.msecs) {
    state.nsecs++;
    if (state.nsecs >= 1e4) {
      state.node = void 0;
      state.nsecs = 0;
    }
  } else if (now > state.msecs) {
    state.nsecs = 0;
  } else if (now < state.msecs) {
    state.node = void 0;
  }
  if (!state.node) {
    state.node = rnds.slice(10, 16);
    state.node[0] |= 1;
    state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
  }
  state.msecs = now;
  return state;
}
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  if (!buf) {
    buf = new Uint8Array(16);
    offset = 0;
  } else {
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
  }
  msecs != null ? msecs : msecs = Date.now();
  nsecs != null ? nsecs : nsecs = 0;
  clockseq != null ? clockseq : clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
  node != null ? node : node = rnds.slice(10, 16);
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  buf[offset++] = tl >>> 24 & 255;
  buf[offset++] = tl >>> 16 & 255;
  buf[offset++] = tl >>> 8 & 255;
  buf[offset++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  buf[offset++] = tmh >>> 8 & 255;
  buf[offset++] = tmh & 255;
  buf[offset++] = tmh >>> 24 & 15 | 16;
  buf[offset++] = tmh >>> 16 & 255;
  buf[offset++] = clockseq >>> 8 | 128;
  buf[offset++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    buf[offset++] = node[n];
  }
  return buf;
}
var v1_default = v1;

// main.ts
var DEFAULT_SETTINGS = {
  identifierSource: "plugin-generated-UUID",
  // Default to the plugin generating the ID.
  generatedIdName: "",
  // User must explicitly provide a name for the ID field.
  userProvidedIdName: "",
  includedFolders: "",
  // Plugin is inactive by default until folders are specified.
  restoringDelayTime: 50,
  // Default delay of 50ms.
  cursorPosition: {}
  // Starts with no saved positions.
};
var PLUGIN_CONSTANTS = {
  COMMANDS: {
    GO_TO_LAST_EDIT: {
      id: "go-to-last-edit-location",
      name: "Go to last edit location"
    },
    SCROLL_TO_CENTER: {
      id: "scroll-cursor-line-to-center",
      name: "Scroll cursor line to center of view"
    }
  },
  DEBOUNCE_SAVE_DELAY: 2e3,
  SETTINGS: {
    TITLES: {
      IDENTIFIER: "Set an unique identifier",
      OPERATES_ON: "Specify where the plugin operates",
      OTHER: "Set restoring options",
      MANAGE_DATA: "Manage data"
    },
    SOURCE_DROPDOWN: {
      name: "Source",
      desc: "Choose the source for the unique note identifier.",
      optionA: "Option A. Plugin generated UUID",
      optionB: "Option B. User provided field",
      optionC: "Option C. File path"
    },
    GENERATED_ID_INPUT: {
      name: "Option A. ID name for plugin generated UUID",
      desc: "Give a field name in which's value the plugin will add the generated UUID (version 1 of RFC 9562, https://www.rfc-editor.org/rfc/rfc9562.html#name-uuid-version-1). \u2022 Required when 'Source' is set to 'Option A'.",
      placeholder: "e.g., uuid or uid or id"
    },
    USER_ID_INPUT: {
      name: "Option B. ID name for user provided field",
      desc: "Choose an existing field name from the front matter to use as an unique ID for the note (e.g., 'created', 'title'). \u2022 The plugin will not generate any field name or value. If the field is not found, the cursor position will not be saved. \u2022 Required when 'Source' is set to 'Option B'.",
      placeholder: "e.g., created or title"
    },
    FILE_PATH_INFO: {
      name: "Option C. File path",
      desc: "The plugin will use the note's relative path in the vault (e.g., 'folder/note.md') as the unique identifier. This is for those who does not use the front matter."
    },
    INCLUDED_FOLDERS: {
      name: "Working folders",
      desc: "Choose folders where the plugin will be active. Provide one path per line. \n\u2022 `Folder` includes only notes inside `Folder`.\n\u2022 `Folder/*` includes notes inside `Folder` and all its subfolders.\n\u2022 `/` includes only notes in the vault's root.\n\u2022 `/*` includes all notes in the entire vault.\n\u2022 If this list is empty, the plugin will not function.",
      placeholder: "e.g.,\n/*\n/\nFolder\nFolder/*"
    },
    RESTORING_DELAY_SLIDER: {
      name: "Restoring delay time",
      desc: "The delay in milliseconds before restoring the cursor position. Increase this if the cursor does not restore consistently."
    },
    CLEANUP_BUTTON: {
      name: "Cleaning up the unnecessary",
      desc: "Remove saved line data for notes that no longer exist or are not in the 'List folders' list above. \u2022 Beware. The stored identifiers other than the current ID set by the above 'source' option will be removed.",
      buttonText: "Remove now",
      buttonTextCleaning: "Cleaning...",
      notice: (count) => `Removed data for ${count} deleted or excluded note(s).`
    }
  }
};
var LastEditLocationPlugin = class extends import_obsidian.Plugin {
  /**
   * This is the entry point of the plugin. It runs when the plugin is loaded (e.g., on Obsidian startup or when enabled by the user).
   */
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: PLUGIN_CONSTANTS.COMMANDS.SCROLL_TO_CENTER.id,
      name: PLUGIN_CONSTANTS.COMMANDS.SCROLL_TO_CENTER.name,
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        editor.scrollIntoView({ from: cursor, to: cursor }, true);
      }
    });
    this.addCommand({
      id: PLUGIN_CONSTANTS.COMMANDS.GO_TO_LAST_EDIT.id,
      name: PLUGIN_CONSTANTS.COMMANDS.GO_TO_LAST_EDIT.name,
      editorCallback: async (editor, view) => {
        const file = view.file;
        if (!file) {
          new import_obsidian.Notice("No active file.");
          return;
        }
        if (!this.isFileIncluded(file)) {
          new import_obsidian.Notice("Last edit location is not active for this file (folder not included).");
          return;
        }
        const uniqueIdentifier = await this.getUniqueIdentifier(file, false);
        const savedPosition = uniqueIdentifier ? this.settings.cursorPosition[uniqueIdentifier] : void 0;
        if (savedPosition && savedPosition.line <= editor.lastLine()) {
          editor.setCursor(savedPosition);
          editor.scrollIntoView({ from: savedPosition, to: savedPosition }, true);
        } else {
          new import_obsidian.Notice("No last edit location found for this file.");
        }
      }
    });
    this.hasBeenRestoredInCurrentSession = /* @__PURE__ */ new Set();
    this.addSettingTab(new LastEditLocationSettingTab(this.app, this));
    this.debouncedSave = (0, import_obsidian.debounce)(() => this.saveSettings(), PLUGIN_CONSTANTS.DEBOUNCE_SAVE_DELAY, true);
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(
        this.app.workspace.on("editor-change", (editor, markdownView) => {
          void this.saveLastEditLocation(editor, markdownView.file);
        })
      );
      this.registerEvent(
        this.app.workspace.on("file-open", async (file) => {
          const uniqueIdentifier = await this.shouldRestoreCursor(file);
          if (uniqueIdentifier) {
            this.restoreLastEditLocation(uniqueIdentifier);
          }
        })
      );
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        void (async () => {
          const uniqueIdentifier = await this.shouldRestoreCursor(activeFile);
          if (uniqueIdentifier) {
            this.restoreLastEditLocation(uniqueIdentifier);
          }
        })();
      }
    });
  }
  /**
   * This function runs when the plugin is disabled.
   * We can use it to clean up any resources, like event listeners or intervals.
   * In this case, `registerEvent` handles listener cleanup automatically, so this can be empty.
   */
  onunload() {
  }
  /**
   * A query function that determines if the cursor should be restored for a given file.
   * @param file The file to check.
   * @returns The unique identifier of the file if the cursor should be restored, otherwise null.
   */
  async shouldRestoreCursor(file) {
    if (!file || !this.isFileIncluded(file)) {
      return null;
    }
    const uniqueIdentifier = await this.getUniqueIdentifier(file, false);
    if (!uniqueIdentifier || this.hasBeenRestoredInCurrentSession.has(uniqueIdentifier)) {
      return null;
    }
    return uniqueIdentifier;
  }
  /**
   * Loads the plugin's data from the `data.json` file in the plugin's directory.
   * `Object.assign` merges the loaded data with the default settings, ensuring that
   * any new settings added in an update will have a default value.
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Saves the plugin's current settings object to the `data.json` file.
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Checks if a given file is located in one of the user-defined included folders.
   * @param file The TFile object to check.
   * @returns True if the file should be included based on the settings, false otherwise.
   */
  isFileIncluded(file) {
    const includedFolders = this.settings.includedFolders.split("\n").map((f) => f.trim()).filter((f) => f);
    if (includedFolders.length === 0) return false;
    if (includedFolders.includes("/*")) return true;
    for (const folder of includedFolders) {
      if (folder === "/") {
        if (!file.path.includes("/")) return true;
      } else if (folder.endsWith("/*")) {
        const basePath = folder.slice(0, -2);
        if (file.path.startsWith(basePath + "/")) return true;
      } else {
        if (file.path.startsWith(folder + "/")) {
          const remainingPath = file.path.substring(folder.length + 1);
          if (!remainingPath.includes("/")) return true;
        }
      }
    }
    return false;
  }
  /**
   * Saves the current cursor's line and character number for the given file.
   * @param editor The active editor instance.
   * @param file The file being edited.
   */
  async saveLastEditLocation(editor, file) {
    if (!file) return;
    if (!this.isFileIncluded(file)) return;
    const uniqueIdentifier = await this.getUniqueIdentifier(file, true);
    if (!uniqueIdentifier) return;
    const cursor = editor.getCursor();
    this.settings.cursorPosition[uniqueIdentifier] = { line: cursor.line, ch: cursor.ch };
    this.debouncedSave();
  }
  /**
   * Restores the cursor to the last known position for a file and centers the view on that line.
   * This function assumes all checks have been passed.
   * @param uniqueIdentifier The unique ID of the file to restore the cursor for.
   */
  restoreLastEditLocation(uniqueIdentifier) {
    window.setTimeout(() => {
      const savedPosition = this.settings.cursorPosition[uniqueIdentifier];
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (savedPosition !== void 0 && view && view.editor) {
        const editor = view.editor;
        if (savedPosition.line <= editor.lastLine()) {
          editor.setCursor({ line: savedPosition.line, ch: savedPosition.ch });
          editor.scrollIntoView({ from: savedPosition, to: savedPosition }, true);
        }
      }
      this.hasBeenRestoredInCurrentSession.add(uniqueIdentifier);
    }, this.settings.restoringDelayTime);
  }
  /**
   * Gets the currently active ID field name based on the user's settings for frontmatter-based options.
   * @returns The active ID field name as a string (e.g., "uuid" or "created"). Returns empty string if not applicable.
   */
  getCurrentIdName() {
    if (this.settings.identifierSource === "plugin-generated-UUID") {
      return this.settings.generatedIdName;
    } else if (this.settings.identifierSource === "user-provided-field") {
      return this.settings.userProvidedIdName;
    }
    return "";
  }
  /**
   * Gets or creates the unique identifier for a file based on the plugin's settings.
   * This can be the file's relative path or a value from its frontmatter.
   * @param file The file to process.
   * @param isIDMissing If true, and the source is 'plugin-generated-UUID', a new UUID will be created and saved to the file if one doesn't exist.
   * @returns A Promise that resolves to the unique ID of the file, or an empty string if none is found/created.
   */
  async getUniqueIdentifier(file, isIDMissing = false) {
    var _a;
    if (this.settings.identifierSource === "file-path") {
      return file.path;
    }
    const idName = this.getCurrentIdName();
    if (!idName) return "";
    if (!isIDMissing) {
      const cache = this.app.metadataCache.getFileCache(file);
      const fmValue = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a[idName];
      return fmValue ? String(fmValue) : "";
    }
    let fileUUID = "";
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (frontmatter == null ? void 0 : frontmatter[idName]) {
        fileUUID = String(frontmatter[idName]);
      } else if (this.settings.identifierSource === "plugin-generated-UUID") {
        const newUUID = v1_default();
        frontmatter[idName] = newUUID;
        fileUUID = newUUID;
      }
    });
    return fileUUID;
  }
};
var LastEditLocationSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  /**
   * This method is called by Obsidian to render the content of the settings tab.
   * It should be used to create all the UI elements for the settings.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.TITLES.IDENTIFIER).setHeading();
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.SOURCE_DROPDOWN.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.SOURCE_DROPDOWN.desc).addDropdown((dropdown) => dropdown.addOption("plugin-generated-UUID", PLUGIN_CONSTANTS.SETTINGS.SOURCE_DROPDOWN.optionA).addOption("user-provided-field", PLUGIN_CONSTANTS.SETTINGS.SOURCE_DROPDOWN.optionB).addOption("file-path", PLUGIN_CONSTANTS.SETTINGS.SOURCE_DROPDOWN.optionC).setValue(this.plugin.settings.identifierSource).onChange(async (value) => {
      this.plugin.settings.identifierSource = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.GENERATED_ID_INPUT.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.GENERATED_ID_INPUT.desc).addText((text) => {
      text.setPlaceholder(PLUGIN_CONSTANTS.SETTINGS.GENERATED_ID_INPUT.placeholder).setValue(this.plugin.settings.generatedIdName).setDisabled(this.plugin.settings.identifierSource !== "plugin-generated-UUID").onChange(async (value) => {
        this.plugin.settings.generatedIdName = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.USER_ID_INPUT.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.USER_ID_INPUT.desc).addText((text) => {
      text.setPlaceholder(PLUGIN_CONSTANTS.SETTINGS.USER_ID_INPUT.placeholder).setValue(this.plugin.settings.userProvidedIdName).setDisabled(this.plugin.settings.identifierSource !== "user-provided-field").onChange(async (value) => {
        this.plugin.settings.userProvidedIdName = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.FILE_PATH_INFO.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.FILE_PATH_INFO.desc);
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.TITLES.OPERATES_ON).setHeading();
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.INCLUDED_FOLDERS.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.INCLUDED_FOLDERS.desc).addTextArea((text) => {
      text.setPlaceholder(PLUGIN_CONSTANTS.SETTINGS.INCLUDED_FOLDERS.placeholder).setValue(this.plugin.settings.includedFolders).onChange(async (value) => {
        this.plugin.settings.includedFolders = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.addClass("last-edit-location-folders-textarea");
    });
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.TITLES.OTHER).setHeading();
    const delaySetting = new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.RESTORING_DELAY_SLIDER.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.RESTORING_DELAY_SLIDER.desc);
    const sliderValueText = delaySetting.controlEl.createSpan({ text: ` ${this.plugin.settings.restoringDelayTime} ms`, cls: "last-edit-location-slider-value" });
    delaySetting.addSlider((slider) => {
      slider.setLimits(10, 1e3, 10).setValue(this.plugin.settings.restoringDelayTime).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.restoringDelayTime = value;
        sliderValueText.setText(` ${value} ms`);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.TITLES.MANAGE_DATA).setHeading();
    new import_obsidian.Setting(containerEl).setName(PLUGIN_CONSTANTS.SETTINGS.CLEANUP_BUTTON.name).setDesc(PLUGIN_CONSTANTS.SETTINGS.CLEANUP_BUTTON.desc).addButton((button) => {
      button.setButtonText(PLUGIN_CONSTANTS.SETTINGS.CLEANUP_BUTTON.buttonText).onClick(async () => {
        var _a;
        button.setButtonText(PLUGIN_CONSTANTS.SETTINGS.CLEANUP_BUTTON.buttonTextCleaning).setDisabled(true);
        const allFiles = this.app.vault.getMarkdownFiles();
        const validIdentifiers = /* @__PURE__ */ new Set();
        const idName = this.plugin.getCurrentIdName();
        for (const file of allFiles) {
          if (this.plugin.isFileIncluded(file)) {
            if (this.plugin.settings.identifierSource === "file-path") {
              validIdentifiers.add(file.path);
            } else if (idName) {
              const cachedFrontmatter = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
              if (cachedFrontmatter && cachedFrontmatter[idName]) {
                validIdentifiers.add(String(cachedFrontmatter[idName]));
              }
            }
          }
        }
        const savedIdentifiers = Object.keys(this.plugin.settings.cursorPosition);
        let cleanedCount = 0;
        for (const savedId of savedIdentifiers) {
          if (!validIdentifiers.has(savedId)) {
            delete this.plugin.settings.cursorPosition[savedId];
            cleanedCount++;
          }
        }
        await this.plugin.saveSettings();
        new import_obsidian.Notice(PLUGIN_CONSTANTS.SETTINGS.CLEANUP_BUTTON.notice(cleanedCount));
        button.setButtonText(PLUGIN_CONSTANTS.SETTINGS.CLEANUP_BUTTON.buttonText).setDisabled(false);
      });
    });
  }
  hide() {
  }
};


/* nosourcemap */