/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __defNormalProp2 = (obj, key2, value2) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key2) && key2 !== except)
        __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key2, value2) => {
  __defNormalProp2(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports2, module2) {
    !function(e) {
      if (typeof exports2 == "object" && typeof module2 != "undefined")
        module2.exports = e();
      else if (typeof define == "function" && define.amd)
        define([], e);
      else {
        (typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = typeof require == "function" && require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n2 = new Error("Cannot find module '" + r + "'");
              throw n2.code = "MODULE_NOT_FOUND", n2;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = typeof require == "function" && require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n2, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = d.getTypeOf(e2) !== "string"; u < e2.length; )
            f = l - u, n2 = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n2 >> 6 : 64, o = 2 < f ? 63 & n2 : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n2, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n2 = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, s !== 64 && (l[h++] = r2), a !== 64 && (l[h++] = n2);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n2 = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n3, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n3, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n2 = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n2("STORE compression");
        }, uncompressWorker: function() {
          return new n2("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n2 = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n3 = 0; n3 < 8; n3++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return e2 !== void 0 && e2.length ? n2.getTypeOf(e2) !== "string" ? function(e3, t3, r2, n3) {
            var i = o, s = n3 + r2;
            e3 ^= -1;
            for (var a = n3; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n3) {
            var i = o, s = n3 + r2;
            e3 ^= -1;
            for (var a = n3; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n2 = null;
        n2 = typeof Promise != "undefined" ? Promise : e("lie"), t.exports = { Promise: n2 };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n2 = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n2 ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n3 = "";
          for (r2 = 0; r2 < t2; r2++)
            n3 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n3;
        }
        function n2(e2, t2, r2, n3, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), i2 === "UNIX" ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n3, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n3) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n3, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n3 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n3 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n2(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n2(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n3 = function(e3, t3, r3, n4, i2) {
            var s2 = I.transformTo("string", i2(n4));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n3, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n2 = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n2(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n4 = u[r3];
                if (!n4)
                  throw new Error(r3 + " is not a valid compression method !");
                return n4;
              }(t3.options.compression, a.compression), n3 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n3).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n2() {
          if (!(this instanceof n2))
            return new n2();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n2();
            for (var t2 in this)
              typeof this[t2] != "function" && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n2.prototype = e("./object")).loadAsync = e("./load"), n2.support = e("./support"), n2.defaults = e("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e2, t2) {
          return new n2().loadAsync(e2, t2);
        }, n2.external = e("./external"), t.exports = n2;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n2 = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n3) {
          return new i.Promise(function(e2, t2) {
            var r2 = n3.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n3.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n3 = 0; n3 < r2.length; n3++)
                t2.push(f(r2[n3]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n3 = 0; n3 < r2.length; n3++) {
              var i2 = r2[n3], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n2.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n2(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n3 = this;
          e2.on("data", function(e3, t3) {
            n3.push(e3) || n3._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n3.emit("error", e3);
          }).on("end", function() {
            n3.push(null);
          });
        }
        e("../utils").inherits(n2, i), n2.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n2;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if (typeof e2 == "number")
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && typeof e2.on == "function" && typeof e2.pause == "function" && typeof e2.resume == "function";
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n3, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || new Date(), s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n3 = _(e2)) && b.call(this, n3, true);
          var a2 = i2 === "string" && s2.binary === false && s2.base64 === false;
          r2 && r2.binary !== void 0 || (s2.binary = !a2), (t2 instanceof c && t2.uncompressedSize === 0 || s2.dir || !t2 || t2.length === 0) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          e2.slice(-1) === "/" && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return e2.slice(-1) !== "/" && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = t2 !== void 0 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return Object.prototype.toString.call(e2) === "[object RegExp]";
        }
        var n2 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n3;
          for (t2 in this.files)
            n3 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n3);
        }, filter: function(r2) {
          var n3 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n3.push(t2);
          }), n3;
        }, file: function(e2, t2, r2) {
          if (arguments.length !== 1)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n3 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n3.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n3 = this.clone();
          return n3.root = t2.name, n3;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || (r2.slice(-1) !== "/" && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n3 = 0; n3 < t2.length; n3++)
              delete this.files[t2[n3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
            var n3 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n3);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n2;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n2 = e("./DataReader");
        function i(e2) {
          n2.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n2), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n3 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n3 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n3 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n3 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), e2 === 0)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n2.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n2 = e("./Uint8ArrayReader");
        function i(e2) {
          n2.call(this, e2);
        }
        e("../utils").inherits(i, n2), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n2 = e("./DataReader");
        function i(e2) {
          n2.call(this, e2);
        }
        e("../utils").inherits(i, n2), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n2 = e("./ArrayReader");
        function i(e2) {
          n2.call(this, e2);
        }
        e("../utils").inherits(i, n2), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), e2 === 0)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n2.getTypeOf(e2);
          return n2.checkSupport(t2), t2 !== "string" || i.uint8array ? t2 === "nodebuffer" ? new o(e2) : i.uint8array ? new h(n2.transformTo("uint8array", e2)) : new s(n2.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n2 = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n2.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n2), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n2 = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n2), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n2.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n2 = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n2.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n2.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n2(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n2.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n2;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n2 = e("../support"), a = e("../external"), o = null;
        if (n2.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n3 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n3.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n3 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n4 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n4), n4 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n3), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n3 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n3 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n3 = "uint8array";
              break;
            case "base64":
              n3 = "string";
          }
          try {
            this._internalType = n3, this._outputType = t2, this._mimeType = r2, h.checkSupport(n3), this._worker = e2.pipe(new i(n3)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return e2 === "data" ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), this._outputType !== "nodebuffer")
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: this._outputType !== "nodebuffer" }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
          r.blob = false;
        else {
          var n2 = new ArrayBuffer(0);
          try {
            r.blob = new Blob([n2], { type: "application/zip" }).size === 0;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n2), r.blob = i.getBlob("application/zip").size === 0;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n2 = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n2.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n2.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n3, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n3 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              (64512 & (r2 = e3.charCodeAt(i2))) == 55296 && i2 + 1 < a2 && (64512 & (n3 = e3.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n3, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n3 = e3[t2++]) < 128)
                a2[r2++] = n3;
              else if (4 < (i2 = u[n3]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n3 &= i2 === 2 ? 31 : i2 === 3 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n3 = n3 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n3 < 65536 ? a2[r2++] = n3 : (n3 -= 65536, a2[r2++] = 55296 | n3 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n3);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n2), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n3 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && (192 & e3[r3]) == 128; )
              r3--;
            return r3 < 0 ? t3 : r3 === 0 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n3 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n3), this.leftOver = t2.subarray(n3, t2.length)) : (i2 = t2.slice(0, n3), this.leftOver = t2.slice(n3, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n2), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n2(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n3.append(t2), n3.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n3 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            t2 === "array" || t2 === "nodebuffer" ? n3.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n3.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n3.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n3 = true;
          if (r2 === "uint8array" ? n3 = i.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (n3 = i.applyCanBeUsed.nodebuffer), n3)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n2, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n2, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n2, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n2, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n2 }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n3 = 0; n3 < t2.length; n3++) {
            var i2 = t2[n3];
            i2 === "." || i2 === "" && n3 !== 0 && n3 !== t2.length - 1 || (i2 === ".." ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return typeof e2 == "string" ? "string" : Object.prototype.toString.call(e2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n3 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n3 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n3;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && r2[t2] === void 0 && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n3, i2, s2) {
          return u.Promise.resolve(e2).then(function(n4) {
            return o.blob && (n4 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n4);
            }) : n4;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? (t2 === "arraybuffer" ? e3 = a.transformTo("uint8array", e3) : t2 === "string" && (s2 ? e3 = h.decode(e3) : n3 && i2 !== true && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n2 = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n3 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n3;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n3 = t2 - r2;
          if (0 < n3)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
          else if (n3 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n2(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n2 = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)) === null)
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), e2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), e2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n2(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n3, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n3 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n3 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (t2 !== null)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n3 = this.findExtraFieldUnicodeComment();
            if (n3 !== null)
              this.fileCommentStr = n3;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n2(e2.value);
            return t2.readInt(1) !== 1 ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n2(e2.value);
            return t2.readInt(1) !== 1 ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n2(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n2.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n3 = (r2 = e2.toLowerCase()) === "string" || r2 === "text";
            r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n3 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n3 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n2.prototype[u[f]] = l;
        t.exports = n2;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n2, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || t2.MessageChannel === void 0)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n2 = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n2 = false;
          }
          l.exports = function(e3) {
            h.push(e3) !== 1 || n2 || r();
          };
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n2 = ["PENDING"];
        function o(e2) {
          if (typeof e2 != "function")
            throw new TypeError("resolver must be a function");
          this.state = n2, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, typeof t2 == "function" && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n3) {
          i(function() {
            var e2;
            try {
              e2 = r2(n3);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && (typeof e2 == "object" || typeof e2 == "function") && typeof t2 == "function")
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n3(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n3);
          });
          s2.status === "error" && n3(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if (typeof t2 != "function")
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if (typeof e2 != "function" && this.state === a || typeof t2 != "function" && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n2 ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if (r2.status === "error")
            return l.reject(e2, r2.value);
          var n3 = r2.value;
          if (n3)
            d(e2, n3);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n3 = e2.queue.length; ++r2 < n3; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if (Object.prototype.toString.call(e2) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var n3 = e2.length, i2 = false;
          if (!n3)
            return this.resolve([]);
          var s2 = new Array(n3), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n3; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n3 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if (Object.prototype.toString.call(e2) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n3 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n3 || (n3 = true, l.resolve(s2, e3));
            }, function(e3) {
              n3 || (n3 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n2 = {};
        (0, e("./lib/utils/common").assign)(n2, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n2;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n3;
            if (n3 = typeof t2.dictionary == "string" ? h.string2buf(t2.dictionary) : u.call(t2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n3)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n2(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n3, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n3 = t2 === ~~t2 ? t2 : t2 === true ? 4 : 0, typeof e2 == "string" ? i2.input = h.string2buf(e2) : u.call(e2) === "[object ArrayBuffer]" ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (i2.avail_out === 0 && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), (r2 = a.deflate(i2, n3)) !== 1 && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            i2.avail_out !== 0 && (i2.avail_in !== 0 || n3 !== 4 && n3 !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || i2.avail_out === 0) && r2 !== 1);
          return n3 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : n3 !== 2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n2, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n2(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n2(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n2 = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, t2.windowBits === 0 && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && (15 & t2.windowBits) == 0 && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n2[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n2[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n3, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n3 = t2 === ~~t2 ? t2 : t2 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof e2 == "string" ? h.input = p.binstring2buf(e2) : _.call(e2) === "[object ArrayBuffer]" ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (h.avail_out === 0 && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = typeof l == "string" ? p.string2buf(l) : _.call(l) === "[object ArrayBuffer]" ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (h.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h.avail_in !== 0 || n3 !== m.Z_FINISH && n3 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), h.avail_in === 0 && h.avail_out === 0 && (f = true);
          } while ((0 < h.avail_in || h.avail_out === 0) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n3 = m.Z_FINISH), n3 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n3 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n2 = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if (typeof r2 != "object")
                throw new TypeError(r2 + "must be non-object");
              for (var n3 in r2)
                r2.hasOwnProperty(n3) && (e2[n3] = r2[n3]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n3, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n3), i2);
          else
            for (var s2 = 0; s2 < n3; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n3, i2, s2, a;
          for (t2 = n3 = 0, r2 = e2.length; t2 < r2; t2++)
            n3 += e2[t2].length;
          for (a = new Uint8Array(n3), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n3, i2) {
          for (var s2 = 0; s2 < n3; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n2);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n2 = 0; n2 < 256; n2++)
          u[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n3 = 0; n3 < t2; n3++)
            r2 += String.fromCharCode(e2[n3]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n3, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n3 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            (64512 & (r2 = e2.charCodeAt(i2))) == 55296 && i2 + 1 < a && (64512 & (n3 = e2.charCodeAt(i2 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (n3 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n3 = t2.length; r2 < n3; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n3, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n3 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n3++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n3++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n3++] = 65533 : i2 < 65536 ? o[n3++] = i2 : (i2 -= 65536, o[n3++] = 55296 | i2 >> 10 & 1023, o[n3++] = 56320 | 1023 & i2);
            }
          return l(o, n3);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && (192 & e2[r2]) == 128; )
            r2--;
          return r2 < 0 ? t2 : r2 === 0 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n2) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n2++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n2) {
          var i = o, s = n2 + r2;
          e2 ^= -1;
          for (var a = n2; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n2 = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n2[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, t2.pending === 0 && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n3, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n3 = S - (c2 - s2), s2 = c2 - S, a2 < n3) {
                if (e2.match_start = t2, o2 <= (a2 = n3))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && --i2 != 0);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n3, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n3 = e2.head[--t2], e2.head[t2] = f2 <= n3 ? n3 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n3 = e2.prev[--t2], e2.prev[t2] = f2 <= n3 ? n3 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (e2.strm.avail_in === 0)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = l2 === 0 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), a2.state.wrap === 1 ? a2.adler = d(a2.adler, o2, l2, h2) : a2.state.wrap === 2 && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && e2.strm.avail_in !== 0);
        }
        function Z(e2, t2) {
          for (var r2, n3; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (e2.lookahead === 0)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n3 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, --e2.match_length != 0; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n3 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n3 && (N(e2, false), e2.strm.avail_out === 0))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n3, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (e2.lookahead === 0)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n3 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), --e2.prev_length != 0; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n3 && (N(e2, false), e2.strm.avail_out === 0))
                return A;
            } else if (e2.match_available) {
              if ((n3 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n3 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : e2.last_lit && (N(e2, false), e2.strm.avail_out === 0) ? A : I;
        }
        function M(e2, t2, r2, n3, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n3, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = t2.wrap === 2 ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n3, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n3 < 0 ? (a2 = 0, n3 = -n3) : 15 < n3 && (a2 = 2, n3 -= 16), i2 < 1 || y < i2 || r2 !== v || n3 < 8 || 15 < n3 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          n3 === 8 && (n3 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n3, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), e2.lookahead === 0 && t2 === l)
                return A;
              if (e2.lookahead === 0)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n3 = e2.block_start + r2;
            if ((e2.strstart === 0 || e2.strstart >= n3) && (e2.lookahead = e2.strstart - n3, e2.strstart = n3, N(e2, false), e2.strm.avail_out === 0))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), e2.strm.avail_out === 0))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), e2.strm.avail_out === 0 ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? e2.state.wrap !== 2 ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n3, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n3 = e2.state, !e2.output || !e2.input && e2.avail_in !== 0 || n3.status === 666 && t2 !== f)
            return R(e2, e2.avail_out === 0 ? -5 : _);
          if (n3.strm = e2, r2 = n3.last_flush, n3.last_flush = t2, n3.status === C)
            if (n3.wrap === 2)
              e2.adler = 0, U(n3, 31), U(n3, 139), U(n3, 8), n3.gzhead ? (U(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U(n3, 255 & n3.gzhead.time), U(n3, n3.gzhead.time >> 8 & 255), U(n3, n3.gzhead.time >> 16 & 255), U(n3, n3.gzhead.time >> 24 & 255), U(n3, n3.level === 9 ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U(n3, 255 & n3.gzhead.extra.length), U(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 0), U(n3, 0), U(n3, n3.level === 9 ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U(n3, 3), n3.status = E);
            else {
              var a2 = v + (n3.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : n3.level === 6 ? 2 : 3) << 6, n3.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, n3.status = E, P(n3, a2), n3.strstart !== 0 && (P(n3, e2.adler >>> 16), P(n3, 65535 & e2.adler)), e2.adler = 1;
            }
          if (n3.status === 69)
            if (n3.gzhead.extra) {
              for (i2 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), F(e2), i2 = n3.pending, n3.pending !== n3.pending_buf_size)); )
                U(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
              n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
            } else
              n3.status = 73;
          if (n3.status === 73)
            if (n3.gzhead.name) {
              i2 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), F(e2), i2 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U(n3, s2);
              } while (s2 !== 0);
              n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), s2 === 0 && (n3.gzindex = 0, n3.status = 91);
            } else
              n3.status = 91;
          if (n3.status === 91)
            if (n3.gzhead.comment) {
              i2 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), F(e2), i2 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U(n3, s2);
              } while (s2 !== 0);
              n3.gzhead.hcrc && n3.pending > i2 && (e2.adler = p(e2.adler, n3.pending_buf, n3.pending - i2, i2)), s2 === 0 && (n3.status = 103);
            } else
              n3.status = 103;
          if (n3.status === 103 && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F(e2), n3.pending + 2 <= n3.pending_buf_size && (U(n3, 255 & e2.adler), U(n3, e2.adler >> 8 & 255), e2.adler = 0, n3.status = E)) : n3.status = E), n3.pending !== 0) {
            if (F(e2), e2.avail_out === 0)
              return n3.last_flush = -1, m;
          } else if (e2.avail_in === 0 && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (n3.status === 666 && e2.avail_in !== 0)
            return R(e2, -5);
          if (e2.avail_in !== 0 || n3.lookahead !== 0 || t2 !== l && n3.status !== 666) {
            var o2 = n3.strategy === 2 ? function(e3, t3) {
              for (var r3; ; ) {
                if (e3.lookahead === 0 && (j(e3), e3.lookahead === 0)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), e3.strm.avail_out === 0))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
            }(n3, t2) : n3.strategy === 3 ? function(e3, t3) {
              for (var r3, n4, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (e3.lookahead === 0)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n4 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && n4 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), e3.strm.avail_out === 0))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), e3.strm.avail_out === 0 ? O : B) : e3.last_lit && (N(e3, false), e3.strm.avail_out === 0) ? A : I;
            }(n3, t2) : h[n3.level].func(n3, t2);
            if (o2 !== O && o2 !== B || (n3.status = 666), o2 === A || o2 === O)
              return e2.avail_out === 0 && (n3.last_flush = -1), m;
            if (o2 === I && (t2 === 1 ? u._tr_align(n3) : t2 !== 5 && (u._tr_stored_block(n3, 0, 0, false), t2 === 3 && (D(n3.head), n3.lookahead === 0 && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F(e2), e2.avail_out === 0))
              return n3.last_flush = -1, m;
          }
          return t2 !== f ? m : n3.wrap <= 0 ? 1 : (n3.wrap === 2 ? (U(n3, 255 & e2.adler), U(n3, e2.adler >> 8 & 255), U(n3, e2.adler >> 16 & 255), U(n3, e2.adler >> 24 & 255), U(n3, 255 & e2.total_in), U(n3, e2.total_in >> 8 & 255), U(n3, e2.total_in >> 16 & 255), U(n3, e2.total_in >> 24 & 255)) : (P(n3, e2.adler >>> 16), P(n3, 65535 & e2.adler)), F(e2), 0 < n3.wrap && (n3.wrap = -n3.wrap), n3.pending !== 0 ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && t2 !== 69 && t2 !== 73 && t2 !== 91 && t2 !== 103 && t2 !== E && t2 !== 666 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n3, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if ((s2 = (r2 = e2.state).wrap) === 2 || s2 === 1 && r2.status !== C || r2.lookahead)
            return _;
          for (s2 === 1 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (s2 === 0 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n3 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n3 + x - 1]) & r2.hash_mask, r2.prev[n3 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n3, n3++, --i2; )
              ;
            r2.strstart = n3, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n2, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n2 = e2.next_in, z = e2.input, i = n2 + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n2++] << p, p += 8, d += z[n2++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, (y = v >>> 16 & 255) === 0)
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if ((64 & y) == 0) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n2++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n2++] << p, p += 8, d += z[n2++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if ((64 & y) == 0) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n2++] << p, (p += 8) < y && (d += z[n2++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n2 < i && s < o);
          n2 -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n2, e2.next_out = s, e2.avail_in = n2 < i ? i - n2 + 5 : 5 - (n2 - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n2 = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n2), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n3;
          return e2 && e2.state ? (n3 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (n3.window !== null && n3.wbits !== t2 && (n3.window = null), n3.wrap = r2, n3.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n3;
          return e2 ? (n3 = new s(), (e2.state = n3).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n3) {
          var i2, s2 = e2.state;
          return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n3 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n3 < (i2 = s2.wsize - s2.wnext) && (i2 = n3), I.arraySet(s2.window, t2, r2 - n3, i2, s2.wnext), (n3 -= i2) ? (I.arraySet(s2.window, t2, r2 - n3, n3, 0), s2.wnext = n3, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n3, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && e2.avail_in !== 0)
            return U;
          (r2 = e2.state).mode === 12 && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n3 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (r2.wrap === 0) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && u2 === 35615) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if ((15 & u2) != 8) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, (255 & r2.flags) != 8) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n3, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n3, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (o2 === 0)
                      break e;
                    for (d = 0; k = n3[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n3, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (o2 === 0)
                      break e;
                    for (d = 0; k = n3[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n3, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (r2.havedict === 0)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (t2 === 5 || t2 === 6)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, t2 !== 6)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, t2 === 6)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), d === 0)
                      break e;
                    I.arraySet(i2, n3, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (b === 16) {
                        for (z = _ + 2; l2 < z; ) {
                          if (o2 === 0)
                            break e;
                          o2--, u2 += n3[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, r2.have === 0) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (b === 17) {
                        for (z = _ + 3; l2 < z; ) {
                          if (o2 === 0)
                            break e;
                          o2--, u2 += n3[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (o2 === 0)
                            break e;
                          o2--, u2 += n3[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (r2.mode === 30)
                    break;
                  if (r2.lens[256] === 0) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, t2 === 6)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n3 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if (g && (240 & g) == 0) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, g === 0) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (o2 === 0)
                      break e;
                    o2--, u2 += n3[s2++] << l2, l2 += 8;
                  }
                  if ((240 & g) == 0) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (h2 === 0)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  r2.length === 0 && (r2.mode = 21);
                  break;
                case 26:
                  if (h2 === 0)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 |= n3[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += n3[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t2 !== 4)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && c2 === 0 || t2 === 4) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? (2 & (r2 = e2.state).wrap) == 0 ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n3 = t2.length;
          return e2 && e2.state ? (r2 = e2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, t2, n3, 0) !== r2.check ? -3 : Z(e2, t2, n3, n3) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n2, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n2; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && O[w] === 0; w--)
            ;
          if (w < k && (k = w), w === 0)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && O[y] === 0; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (e2 === 0 || w !== 1))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n2; v++)
            t2[r2 + v] !== 0 && (a[B[t2[r2 + v]]++] = v);
          if (d = e2 === 0 ? (A = R = a, 19) : e2 === 1 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, u !== 0; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (h !== 0 ? (E &= h - 1, E += h) : E = 0, v++, --O[b] == 0) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (S === 0 && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, e2 === 1 && 852 < C || e2 === 2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return E !== 0 && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n2(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n2(z);
        var C = new Array(2 * f);
        n2(C);
        var E = new Array(512);
        n2(E);
        var A = new Array(256);
        n2(A);
        var I = new Array(a);
        n2(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n3, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n3, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n3, i2, s2 = new Array(g + 1), a2 = 0;
          for (n3 = 1; n3 <= g; n3++)
            s2[n3] = a2 = a2 + r2[n3 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            o2 !== 0 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n3) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n3[t2] <= n3[r2];
        }
        function G(e2, t2, r2) {
          for (var n3 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n3, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n3;
        }
        function K(e2, t2, r2) {
          var n3, i2, s2, a2, o2 = 0;
          if (e2.last_lit !== 0)
            for (; n3 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, n3 === 0 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), (a2 = w[s2]) !== 0 && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n3), r2), (a2 = k[s2]) !== 0 && P(e2, n3 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n3, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            s2[2 * r2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n3 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n3, s2[2 * i2] = s2[2 * r2] + s2[2 * n3], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n3] ? e2.depth[r2] : e2.depth[n3]) + 1, s2[2 * r2 + 1] = s2[2 * n3 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n4, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n4 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n4 + 1] = s3, u3 < n4 || (e3.bl_count[s3]++, a3 = 0, d2 <= n4 && (a3 = c2[n4 - d2]), o3 = h3[2 * n4], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n4 + 1] + a3)));
            if (m2 !== 0) {
              do {
                for (s3 = p2 - 1; e3.bl_count[s3] === 0; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; s3 !== 0; s3--)
                for (n4 = e3.bl_count[s3]; n4 !== 0; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n4--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n3, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (a2 === 0 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n3 = 0; n3 <= r2; n3++)
            i2 = a2, a2 = t2[2 * (n3 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : i2 !== 0 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n3, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (a2 === 0 && (h2 = 138, u2 = 3), n3 = 0; n3 <= r2; n3++)
            if (i2 = a2, a2 = t2[2 * (n3 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), --o2 != 0; )
                  ;
              else
                i2 !== 0 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n2(T);
        var q = false;
        function J(e2, t2, r2, n3) {
          P(e2, (s << 1) + (n3 ? 1 : 0), 3), function(e3, t3, r3, n4) {
            M(e3), n4 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n3, i2, s2 = new Array(g + 1);
            for (n3 = r2 = 0; n3 < a - 1; n3++)
              for (I[n3] = r2, e3 = 0; e3 < 1 << w[n3]; e3++)
                A[r2++] = n3;
            for (A[r2 - 1] = n3, n3 = i2 = 0; n3 < 16; n3++)
              for (T[n3] = i2, e3 = 0; e3 < 1 << k[n3]; e3++)
                E[i2++] = n3;
            for (i2 >>= 7; n3 < f; n3++)
              for (T[n3] = i2 << 7, e3 = 0; e3 < 1 << k[n3] - 7; e3++)
                E[256 + i2++] = n3;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n3) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && e3.dyn_ltree[2 * t3] !== 0)
                return o;
            if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (e3.dyn_ltree[2 * t3] !== 0)
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && e3.bl_tree[2 * S[t3] + 1] === 0; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && t2 !== -1 ? J(e2, t2, r2, n3) : e2.strategy === 4 || s2 === i2 ? (P(e2, 2 + (n3 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n3 ? 1 : 0), 3), function(e3, t3, r3, n4) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n4 - 4, 4), i3 = 0; i3 < n4; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n3 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, t2 === 0 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            e3.bi_valid === 16 ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n2) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = {}.toString.call(r2.process) === "[object process]" ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                typeof e4 != "function" && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n3 = { callback: e4, args: t3 };
                return h[o] = n3, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n2, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && typeof e4.data == "string" && e4.data.indexOf(a) === 0 && c(+e4.data.slice(a.length));
            }
          }(typeof self == "undefined" ? e2 === void 0 ? this : e2 : self);
        }).call(this, typeof global != "undefined" ? global : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/smol-toml/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/smol-toml/dist/index.cjs"(exports2, module2) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames3 = Object.getOwnPropertyNames;
    var __hasOwnProp3 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name in all)
        __defProp3(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps3 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames3(from))
          if (!__hasOwnProp3.call(to, key2) && key2 !== except)
            __defProp3(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc3(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS3 = (mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export3(index_exports, {
      TomlDate: () => TomlDate,
      TomlError: () => TomlError,
      default: () => index_default,
      parse: () => parse2,
      stringify: () => stringify
    });
    module2.exports = __toCommonJS3(index_exports);
    function getLineColFromPtr(string, ptr) {
      let lines = string.slice(0, ptr).split(/\r\n|\n|\r/g);
      return [lines.length, lines.pop().length + 1];
    }
    function makeCodeBlock(string, line, column) {
      let lines = string.split(/\r\n|\n|\r/g);
      let codeblock = "";
      let numberLen = (Math.log10(line + 1) | 0) + 1;
      for (let i = line - 1; i <= line + 1; i++) {
        let l = lines[i - 1];
        if (!l)
          continue;
        codeblock += i.toString().padEnd(numberLen, " ");
        codeblock += ":  ";
        codeblock += l;
        codeblock += "\n";
        if (i === line) {
          codeblock += " ".repeat(numberLen + column + 2);
          codeblock += "^\n";
        }
      }
      return codeblock;
    }
    var TomlError = class extends Error {
      constructor(message, options) {
        const [line, column] = getLineColFromPtr(options.toml, options.ptr);
        const codeblock = makeCodeBlock(options.toml, line, column);
        super(`Invalid TOML document: ${message}

${codeblock}`, options);
        __publicField(this, "line");
        __publicField(this, "column");
        __publicField(this, "codeblock");
        this.line = line;
        this.column = column;
        this.codeblock = codeblock;
      }
    };
    function indexOfNewline(str, start = 0, end = str.length) {
      let idx = str.indexOf("\n", start);
      if (str[idx - 1] === "\r")
        idx--;
      return idx <= end ? idx : -1;
    }
    function skipComment(str, ptr) {
      for (let i = ptr; i < str.length; i++) {
        let c = str[i];
        if (c === "\n")
          return i;
        if (c === "\r" && str[i + 1] === "\n")
          return i + 1;
        if (c < " " && c !== "	" || c === "\x7F") {
          throw new TomlError("control characters are not allowed in comments", {
            toml: str,
            ptr
          });
        }
      }
      return str.length;
    }
    function skipVoid(str, ptr, banNewLines, banComments) {
      let c;
      while ((c = str[ptr]) === " " || c === "	" || !banNewLines && (c === "\n" || c === "\r" && str[ptr + 1] === "\n"))
        ptr++;
      return banComments || c !== "#" ? ptr : skipVoid(str, skipComment(str, ptr), banNewLines);
    }
    function skipUntil(str, ptr, sep3, end, banNewLines = false) {
      if (!end) {
        ptr = indexOfNewline(str, ptr);
        return ptr < 0 ? str.length : ptr;
      }
      for (let i = ptr; i < str.length; i++) {
        let c = str[i];
        if (c === "#") {
          i = indexOfNewline(str, i);
        } else if (c === sep3) {
          return i + 1;
        } else if (c === end || banNewLines && (c === "\n" || c === "\r" && str[i + 1] === "\n")) {
          return i;
        }
      }
      throw new TomlError("cannot find end of structure", {
        toml: str,
        ptr
      });
    }
    function getStringEnd(str, seek) {
      let first = str[seek];
      let target = first === str[seek + 1] && str[seek + 1] === str[seek + 2] ? str.slice(seek, seek + 3) : first;
      seek += target.length - 1;
      do
        seek = str.indexOf(target, ++seek);
      while (seek > -1 && first !== "'" && str[seek - 1] === "\\" && (str[seek - 2] !== "\\" || str[seek - 3] === "\\"));
      if (seek > -1) {
        seek += target.length;
        if (target.length > 1) {
          if (str[seek] === first)
            seek++;
          if (str[seek] === first)
            seek++;
        }
      }
      return seek;
    }
    var DATE_TIME_RE = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
    var _hasDate, _hasTime, _offset, _a;
    var TomlDate = (_a = class extends Date {
      constructor(date) {
        let hasDate = true;
        let hasTime = true;
        let offset = "Z";
        if (typeof date === "string") {
          let match = date.match(DATE_TIME_RE);
          if (match) {
            if (!match[1]) {
              hasDate = false;
              date = `0000-01-01T${date}`;
            }
            hasTime = !!match[2];
            hasTime && date[10] === " " && (date = date.replace(" ", "T"));
            if (match[2] && +match[2] > 23) {
              date = "";
            } else {
              offset = match[3] || null;
              date = date.toUpperCase();
              if (!offset && hasTime)
                date += "Z";
            }
          } else {
            date = "";
          }
        }
        super(date);
        __privateAdd(this, _hasDate, false);
        __privateAdd(this, _hasTime, false);
        __privateAdd(this, _offset, null);
        if (!isNaN(this.getTime())) {
          __privateSet(this, _hasDate, hasDate);
          __privateSet(this, _hasTime, hasTime);
          __privateSet(this, _offset, offset);
        }
      }
      isDateTime() {
        return __privateGet(this, _hasDate) && __privateGet(this, _hasTime);
      }
      isLocal() {
        return !__privateGet(this, _hasDate) || !__privateGet(this, _hasTime) || !__privateGet(this, _offset);
      }
      isDate() {
        return __privateGet(this, _hasDate) && !__privateGet(this, _hasTime);
      }
      isTime() {
        return __privateGet(this, _hasTime) && !__privateGet(this, _hasDate);
      }
      isValid() {
        return __privateGet(this, _hasDate) || __privateGet(this, _hasTime);
      }
      toISOString() {
        let iso = super.toISOString();
        if (this.isDate())
          return iso.slice(0, 10);
        if (this.isTime())
          return iso.slice(11, 23);
        if (__privateGet(this, _offset) === null)
          return iso.slice(0, -1);
        if (__privateGet(this, _offset) === "Z")
          return iso;
        let offset = +__privateGet(this, _offset).slice(1, 3) * 60 + +__privateGet(this, _offset).slice(4, 6);
        offset = __privateGet(this, _offset)[0] === "-" ? offset : -offset;
        let offsetDate = new Date(this.getTime() - offset * 6e4);
        return offsetDate.toISOString().slice(0, -1) + __privateGet(this, _offset);
      }
      static wrapAsOffsetDateTime(jsDate, offset = "Z") {
        let date = new _a(jsDate);
        __privateSet(date, _offset, offset);
        return date;
      }
      static wrapAsLocalDateTime(jsDate) {
        let date = new _a(jsDate);
        __privateSet(date, _offset, null);
        return date;
      }
      static wrapAsLocalDate(jsDate) {
        let date = new _a(jsDate);
        __privateSet(date, _hasTime, false);
        __privateSet(date, _offset, null);
        return date;
      }
      static wrapAsLocalTime(jsDate) {
        let date = new _a(jsDate);
        __privateSet(date, _hasDate, false);
        __privateSet(date, _offset, null);
        return date;
      }
    }, _hasDate = new WeakMap(), _hasTime = new WeakMap(), _offset = new WeakMap(), _a);
    var INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
    var FLOAT_REGEX = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
    var LEADING_ZERO = /^[+-]?0[0-9_]/;
    var ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;
    var ESC_MAP = {
      b: "\b",
      t: "	",
      n: "\n",
      f: "\f",
      r: "\r",
      '"': '"',
      "\\": "\\"
    };
    function parseString(str, ptr = 0, endPtr = str.length) {
      let isLiteral = str[ptr] === "'";
      let isMultiline = str[ptr++] === str[ptr] && str[ptr] === str[ptr + 1];
      if (isMultiline) {
        endPtr -= 2;
        if (str[ptr += 2] === "\r")
          ptr++;
        if (str[ptr] === "\n")
          ptr++;
      }
      let tmp = 0;
      let isEscape;
      let parsed = "";
      let sliceStart = ptr;
      while (ptr < endPtr - 1) {
        let c = str[ptr++];
        if (c === "\n" || c === "\r" && str[ptr] === "\n") {
          if (!isMultiline) {
            throw new TomlError("newlines are not allowed in strings", {
              toml: str,
              ptr: ptr - 1
            });
          }
        } else if (c < " " && c !== "	" || c === "\x7F") {
          throw new TomlError("control characters are not allowed in strings", {
            toml: str,
            ptr: ptr - 1
          });
        }
        if (isEscape) {
          isEscape = false;
          if (c === "u" || c === "U") {
            let code = str.slice(ptr, ptr += c === "u" ? 4 : 8);
            if (!ESCAPE_REGEX.test(code)) {
              throw new TomlError("invalid unicode escape", {
                toml: str,
                ptr: tmp
              });
            }
            try {
              parsed += String.fromCodePoint(parseInt(code, 16));
            } catch {
              throw new TomlError("invalid unicode escape", {
                toml: str,
                ptr: tmp
              });
            }
          } else if (isMultiline && (c === "\n" || c === " " || c === "	" || c === "\r")) {
            ptr = skipVoid(str, ptr - 1, true);
            if (str[ptr] !== "\n" && str[ptr] !== "\r") {
              throw new TomlError("invalid escape: only line-ending whitespace may be escaped", {
                toml: str,
                ptr: tmp
              });
            }
            ptr = skipVoid(str, ptr);
          } else if (c in ESC_MAP) {
            parsed += ESC_MAP[c];
          } else {
            throw new TomlError("unrecognized escape sequence", {
              toml: str,
              ptr: tmp
            });
          }
          sliceStart = ptr;
        } else if (!isLiteral && c === "\\") {
          tmp = ptr - 1;
          isEscape = true;
          parsed += str.slice(sliceStart, tmp);
        }
      }
      return parsed + str.slice(sliceStart, endPtr - 1);
    }
    function parseValue(value2, toml, ptr, integersAsBigInt) {
      if (value2 === "true")
        return true;
      if (value2 === "false")
        return false;
      if (value2 === "-inf")
        return -Infinity;
      if (value2 === "inf" || value2 === "+inf")
        return Infinity;
      if (value2 === "nan" || value2 === "+nan" || value2 === "-nan")
        return NaN;
      if (value2 === "-0")
        return integersAsBigInt ? 0n : 0;
      let isInt2 = INT_REGEX.test(value2);
      if (isInt2 || FLOAT_REGEX.test(value2)) {
        if (LEADING_ZERO.test(value2)) {
          throw new TomlError("leading zeroes are not allowed", {
            toml,
            ptr
          });
        }
        value2 = value2.replace(/_/g, "");
        let numeric = +value2;
        if (isNaN(numeric)) {
          throw new TomlError("invalid number", {
            toml,
            ptr
          });
        }
        if (isInt2) {
          if ((isInt2 = !Number.isSafeInteger(numeric)) && !integersAsBigInt) {
            throw new TomlError("integer value cannot be represented losslessly", {
              toml,
              ptr
            });
          }
          if (isInt2 || integersAsBigInt === true)
            numeric = BigInt(value2);
        }
        return numeric;
      }
      const date = new TomlDate(value2);
      if (!date.isValid()) {
        throw new TomlError("invalid value", {
          toml,
          ptr
        });
      }
      return date;
    }
    function sliceAndTrimEndOf(str, startPtr, endPtr, allowNewLines) {
      let value2 = str.slice(startPtr, endPtr);
      let commentIdx = value2.indexOf("#");
      if (commentIdx > -1) {
        skipComment(str, commentIdx);
        value2 = value2.slice(0, commentIdx);
      }
      let trimmed = value2.trimEnd();
      if (!allowNewLines) {
        let newlineIdx = value2.indexOf("\n", trimmed.length);
        if (newlineIdx > -1) {
          throw new TomlError("newlines are not allowed in inline tables", {
            toml: str,
            ptr: startPtr + newlineIdx
          });
        }
      }
      return [trimmed, commentIdx];
    }
    function extractValue(str, ptr, end, depth, integersAsBigInt) {
      if (depth === 0) {
        throw new TomlError("document contains excessively nested structures. aborting.", {
          toml: str,
          ptr
        });
      }
      let c = str[ptr];
      if (c === "[" || c === "{") {
        let [value2, endPtr2] = c === "[" ? parseArray(str, ptr, depth, integersAsBigInt) : parseInlineTable(str, ptr, depth, integersAsBigInt);
        let newPtr = end ? skipUntil(str, endPtr2, ",", end) : endPtr2;
        if (endPtr2 - newPtr && end === "}") {
          let nextNewLine = indexOfNewline(str, endPtr2, newPtr);
          if (nextNewLine > -1) {
            throw new TomlError("newlines are not allowed in inline tables", {
              toml: str,
              ptr: nextNewLine
            });
          }
        }
        return [value2, newPtr];
      }
      let endPtr;
      if (c === '"' || c === "'") {
        endPtr = getStringEnd(str, ptr);
        let parsed = parseString(str, ptr, endPtr);
        if (end) {
          endPtr = skipVoid(str, endPtr, end !== "]");
          if (str[endPtr] && str[endPtr] !== "," && str[endPtr] !== end && str[endPtr] !== "\n" && str[endPtr] !== "\r") {
            throw new TomlError("unexpected character encountered", {
              toml: str,
              ptr: endPtr
            });
          }
          endPtr += +(str[endPtr] === ",");
        }
        return [parsed, endPtr];
      }
      endPtr = skipUntil(str, ptr, ",", end);
      let slice = sliceAndTrimEndOf(str, ptr, endPtr - +(str[endPtr - 1] === ","), end === "]");
      if (!slice[0]) {
        throw new TomlError("incomplete key-value declaration: no value specified", {
          toml: str,
          ptr
        });
      }
      if (end && slice[1] > -1) {
        endPtr = skipVoid(str, ptr + slice[1]);
        endPtr += +(str[endPtr] === ",");
      }
      return [
        parseValue(slice[0], str, ptr, integersAsBigInt),
        endPtr
      ];
    }
    var KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \t]*$/;
    function parseKey(str, ptr, end = "=") {
      let dot = ptr - 1;
      let parsed = [];
      let endPtr = str.indexOf(end, ptr);
      if (endPtr < 0) {
        throw new TomlError("incomplete key-value: cannot find end of key", {
          toml: str,
          ptr
        });
      }
      do {
        let c = str[ptr = ++dot];
        if (c !== " " && c !== "	") {
          if (c === '"' || c === "'") {
            if (c === str[ptr + 1] && c === str[ptr + 2]) {
              throw new TomlError("multiline strings are not allowed in keys", {
                toml: str,
                ptr
              });
            }
            let eos = getStringEnd(str, ptr);
            if (eos < 0) {
              throw new TomlError("unfinished string encountered", {
                toml: str,
                ptr
              });
            }
            dot = str.indexOf(".", eos);
            let strEnd = str.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot);
            let newLine = indexOfNewline(strEnd);
            if (newLine > -1) {
              throw new TomlError("newlines are not allowed in keys", {
                toml: str,
                ptr: ptr + dot + newLine
              });
            }
            if (strEnd.trimStart()) {
              throw new TomlError("found extra tokens after the string part", {
                toml: str,
                ptr: eos
              });
            }
            if (endPtr < eos) {
              endPtr = str.indexOf(end, eos);
              if (endPtr < 0) {
                throw new TomlError("incomplete key-value: cannot find end of key", {
                  toml: str,
                  ptr
                });
              }
            }
            parsed.push(parseString(str, ptr, eos));
          } else {
            dot = str.indexOf(".", ptr);
            let part = str.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);
            if (!KEY_PART_RE.test(part)) {
              throw new TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
                toml: str,
                ptr
              });
            }
            parsed.push(part.trimEnd());
          }
        }
      } while (dot + 1 && dot < endPtr);
      return [parsed, skipVoid(str, endPtr + 1, true, true)];
    }
    function parseInlineTable(str, ptr, depth, integersAsBigInt) {
      let res = {};
      let seen = /* @__PURE__ */ new Set();
      let c;
      let comma = 0;
      ptr++;
      while ((c = str[ptr++]) !== "}" && c) {
        let err = { toml: str, ptr: ptr - 1 };
        if (c === "\n") {
          throw new TomlError("newlines are not allowed in inline tables", err);
        } else if (c === "#") {
          throw new TomlError("inline tables cannot contain comments", err);
        } else if (c === ",") {
          throw new TomlError("expected key-value, found comma", err);
        } else if (c !== " " && c !== "	") {
          let k;
          let t = res;
          let hasOwn = false;
          let [key2, keyEndPtr] = parseKey(str, ptr - 1);
          for (let i = 0; i < key2.length; i++) {
            if (i)
              t = hasOwn ? t[k] : t[k] = {};
            k = key2[i];
            if ((hasOwn = Object.hasOwn(t, k)) && (typeof t[k] !== "object" || seen.has(t[k]))) {
              throw new TomlError("trying to redefine an already defined value", {
                toml: str,
                ptr
              });
            }
            if (!hasOwn && k === "__proto__") {
              Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
            }
          }
          if (hasOwn) {
            throw new TomlError("trying to redefine an already defined value", {
              toml: str,
              ptr
            });
          }
          let [value2, valueEndPtr] = extractValue(str, keyEndPtr, "}", depth - 1, integersAsBigInt);
          seen.add(value2);
          t[k] = value2;
          ptr = valueEndPtr;
          comma = str[ptr - 1] === "," ? ptr - 1 : 0;
        }
      }
      if (comma) {
        throw new TomlError("trailing commas are not allowed in inline tables", {
          toml: str,
          ptr: comma
        });
      }
      if (!c) {
        throw new TomlError("unfinished table encountered", {
          toml: str,
          ptr
        });
      }
      return [res, ptr];
    }
    function parseArray(str, ptr, depth, integersAsBigInt) {
      let res = [];
      let c;
      ptr++;
      while ((c = str[ptr++]) !== "]" && c) {
        if (c === ",") {
          throw new TomlError("expected value, found comma", {
            toml: str,
            ptr: ptr - 1
          });
        } else if (c === "#")
          ptr = skipComment(str, ptr);
        else if (c !== " " && c !== "	" && c !== "\n" && c !== "\r") {
          let e = extractValue(str, ptr - 1, "]", depth - 1, integersAsBigInt);
          res.push(e[0]);
          ptr = e[1];
        }
      }
      if (!c) {
        throw new TomlError("unfinished array encountered", {
          toml: str,
          ptr
        });
      }
      return [res, ptr];
    }
    function peekTable(key2, table, meta, type) {
      let t = table;
      let m = meta;
      let k;
      let hasOwn = false;
      let state;
      for (let i = 0; i < key2.length; i++) {
        if (i) {
          t = hasOwn ? t[k] : t[k] = {};
          m = (state = m[k]).c;
          if (type === 0 && (state.t === 1 || state.t === 2)) {
            return null;
          }
          if (state.t === 2) {
            let l = t.length - 1;
            t = t[l];
            m = m[l].c;
          }
        }
        k = key2[i];
        if ((hasOwn = Object.hasOwn(t, k)) && m[k]?.t === 0 && m[k]?.d) {
          return null;
        }
        if (!hasOwn) {
          if (k === "__proto__") {
            Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });
            Object.defineProperty(m, k, { enumerable: true, configurable: true, writable: true });
          }
          m[k] = {
            t: i < key2.length - 1 && type === 2 ? 3 : type,
            d: false,
            i: 0,
            c: {}
          };
        }
      }
      state = m[k];
      if (state.t !== type && !(type === 1 && state.t === 3)) {
        return null;
      }
      if (type === 2) {
        if (!state.d) {
          state.d = true;
          t[k] = [];
        }
        t[k].push(t = {});
        state.c[state.i++] = state = { t: 1, d: false, i: 0, c: {} };
      }
      if (state.d) {
        return null;
      }
      state.d = true;
      if (type === 1) {
        t = hasOwn ? t[k] : t[k] = {};
      } else if (type === 0 && hasOwn) {
        return null;
      }
      return [k, t, state.c];
    }
    function parse2(toml, { maxDepth = 1e3, integersAsBigInt } = {}) {
      let res = {};
      let meta = {};
      let tbl = res;
      let m = meta;
      for (let ptr = skipVoid(toml, 0); ptr < toml.length; ) {
        if (toml[ptr] === "[") {
          let isTableArray = toml[++ptr] === "[";
          let k = parseKey(toml, ptr += +isTableArray, "]");
          if (isTableArray) {
            if (toml[k[1] - 1] !== "]") {
              throw new TomlError("expected end of table declaration", {
                toml,
                ptr: k[1] - 1
              });
            }
            k[1]++;
          }
          let p = peekTable(k[0], res, meta, isTableArray ? 2 : 1);
          if (!p) {
            throw new TomlError("trying to redefine an already defined table or value", {
              toml,
              ptr
            });
          }
          m = p[2];
          tbl = p[1];
          ptr = k[1];
        } else {
          let k = parseKey(toml, ptr);
          let p = peekTable(k[0], tbl, m, 0);
          if (!p) {
            throw new TomlError("trying to redefine an already defined table or value", {
              toml,
              ptr
            });
          }
          let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);
          p[1][p[0]] = v[0];
          ptr = v[1];
        }
        ptr = skipVoid(toml, ptr, true);
        if (toml[ptr] && toml[ptr] !== "\n" && toml[ptr] !== "\r") {
          throw new TomlError("each key-value declaration must be followed by an end-of-line", {
            toml,
            ptr
          });
        }
        ptr = skipVoid(toml, ptr);
      }
      return res;
    }
    var BARE_KEY = /^[a-z0-9-_]+$/i;
    function extendedTypeOf(obj) {
      let type = typeof obj;
      if (type === "object") {
        if (Array.isArray(obj))
          return "array";
        if (obj instanceof Date)
          return "date";
      }
      return type;
    }
    function isArrayOfTables(obj) {
      for (let i = 0; i < obj.length; i++) {
        if (extendedTypeOf(obj[i]) !== "object")
          return false;
      }
      return obj.length != 0;
    }
    function formatString(s) {
      return JSON.stringify(s).replace(/\x7f/g, "\\u007f");
    }
    function stringifyValue(val, type, depth, numberAsFloat) {
      if (depth === 0) {
        throw new Error("Could not stringify the object: maximum object depth exceeded");
      }
      if (type === "number") {
        if (isNaN(val))
          return "nan";
        if (val === Infinity)
          return "inf";
        if (val === -Infinity)
          return "-inf";
        if (numberAsFloat && Number.isInteger(val))
          return val.toFixed(1);
        return val.toString();
      }
      if (type === "bigint" || type === "boolean") {
        return val.toString();
      }
      if (type === "string") {
        return formatString(val);
      }
      if (type === "date") {
        if (isNaN(val.getTime())) {
          throw new TypeError("cannot serialize invalid date");
        }
        return val.toISOString();
      }
      if (type === "object") {
        return stringifyInlineTable(val, depth, numberAsFloat);
      }
      if (type === "array") {
        return stringifyArray(val, depth, numberAsFloat);
      }
    }
    function stringifyInlineTable(obj, depth, numberAsFloat) {
      let keys = Object.keys(obj);
      if (keys.length === 0)
        return "{}";
      let res = "{ ";
      for (let i = 0; i < keys.length; i++) {
        let k = keys[i];
        if (i)
          res += ", ";
        res += BARE_KEY.test(k) ? k : formatString(k);
        res += " = ";
        res += stringifyValue(obj[k], extendedTypeOf(obj[k]), depth - 1, numberAsFloat);
      }
      return res + " }";
    }
    function stringifyArray(array, depth, numberAsFloat) {
      if (array.length === 0)
        return "[]";
      let res = "[ ";
      for (let i = 0; i < array.length; i++) {
        if (i)
          res += ", ";
        if (array[i] === null || array[i] === void 0) {
          throw new TypeError("arrays cannot contain null or undefined values");
        }
        res += stringifyValue(array[i], extendedTypeOf(array[i]), depth - 1, numberAsFloat);
      }
      return res + " ]";
    }
    function stringifyArrayTable(array, key2, depth, numberAsFloat) {
      if (depth === 0) {
        throw new Error("Could not stringify the object: maximum object depth exceeded");
      }
      let res = "";
      for (let i = 0; i < array.length; i++) {
        res += `[[${key2}]]
`;
        res += stringifyTable(array[i], key2, depth, numberAsFloat);
        res += "\n\n";
      }
      return res;
    }
    function stringifyTable(obj, prefix, depth, numberAsFloat) {
      if (depth === 0) {
        throw new Error("Could not stringify the object: maximum object depth exceeded");
      }
      let preamble = "";
      let tables = "";
      let keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        let k = keys[i];
        if (obj[k] !== null && obj[k] !== void 0) {
          let type = extendedTypeOf(obj[k]);
          if (type === "symbol" || type === "function") {
            throw new TypeError(`cannot serialize values of type '${type}'`);
          }
          let key2 = BARE_KEY.test(k) ? k : formatString(k);
          if (type === "array" && isArrayOfTables(obj[k])) {
            tables += stringifyArrayTable(obj[k], prefix ? `${prefix}.${key2}` : key2, depth - 1, numberAsFloat);
          } else if (type === "object") {
            let tblKey = prefix ? `${prefix}.${key2}` : key2;
            tables += `[${tblKey}]
`;
            tables += stringifyTable(obj[k], tblKey, depth - 1, numberAsFloat);
            tables += "\n\n";
          } else {
            preamble += key2;
            preamble += " = ";
            preamble += stringifyValue(obj[k], type, depth, numberAsFloat);
            preamble += "\n";
          }
        }
      }
      return `${preamble}
${tables}`.trim();
    }
    function stringify(obj, { maxDepth = 1e3, numbersAsFloat = false } = {}) {
      if (extendedTypeOf(obj) !== "object") {
        throw new TypeError("stringify can only be called with an object");
      }
      return stringifyTable(obj, "", maxDepth, numbersAsFloat);
    }
    var index_default = { parse: parse2, stringify, TomlDate, TomlError };
  }
});

// node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  "node_modules/js-yaml/lib/common.js"(exports2, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key2, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key2 = sourceKeys[index];
          target[key2] = source[key2];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "node_modules/js-yaml/lib/exception.js"(exports2, module2) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark)
        return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module2.exports = YAMLException;
  }
});

// node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "node_modules/js-yaml/lib/snippet.js"(exports2, module2) {
    "use strict";
    var common2 = require_common();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
      };
    }
    function padStart(string, max) {
      return common2.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer)
        return null;
      if (!options.maxLength)
        options.maxLength = 79;
      if (typeof options.indent !== "number")
        options.indent = 1;
      if (typeof options.linesBefore !== "number")
        options.linesBefore = 3;
      if (typeof options.linesAfter !== "number")
        options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0)
          break;
        line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
        result = common2.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common2.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common2.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length)
          break;
        line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
        result += common2.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet;
  }
});

// node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "node_modules/js-yaml/lib/type.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  "node_modules/js-yaml/lib/schema.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema;
  }
});

// node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "node_modules/js-yaml/lib/type/str.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "node_modules/js-yaml/lib/type/seq.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "node_modules/js-yaml/lib/type/map.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/js-yaml/lib/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "node_modules/js-yaml/lib/type/null.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "node_modules/js-yaml/lib/type/bool.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "node_modules/js-yaml/lib/type/int.js"(exports2, module2) {
    "use strict";
    var common2 = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value2 = data, sign = 1, ch;
      if (value2.indexOf("_") !== -1) {
        value2 = value2.replace(/_/g, "");
      }
      ch = value2[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value2 = value2.slice(1);
        ch = value2[0];
      }
      if (value2 === "0")
        return 0;
      if (ch === "0") {
        if (value2[1] === "b")
          return sign * parseInt(value2.slice(2), 2);
        if (value2[1] === "x")
          return sign * parseInt(value2.slice(2), 16);
        if (value2[1] === "o")
          return sign * parseInt(value2.slice(2), 8);
      }
      return sign * parseInt(value2, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common2.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  "node_modules/js-yaml/lib/type/float.js"(exports2, module2) {
    "use strict";
    var common2 = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value2, sign;
      value2 = data.replace(/_/g, "").toLowerCase();
      sign = value2[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value2[0]) >= 0) {
        value2 = value2.slice(1);
      }
      if (value2 === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value2 === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value2, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common2.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common2.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "node_modules/js-yaml/lib/schema/json.js"(exports2, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "node_modules/js-yaml/lib/schema/core.js"(exports2, module2) {
    "use strict";
    module2.exports = require_json();
  }
});

// node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/js-yaml/lib/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  "node_modules/js-yaml/lib/type/merge.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/js-yaml/lib/type/binary.js
var require_binary = __commonJS({
  "node_modules/js-yaml/lib/type/binary.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "node_modules/js-yaml/lib/type/omap.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/js-yaml/lib/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  "node_modules/js-yaml/lib/type/set.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key2, object = data;
      for (key2 in object) {
        if (_hasOwnProperty.call(object, key2)) {
          if (object[key2] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  "node_modules/js-yaml/lib/schema/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "node_modules/js-yaml/lib/loader.js"(exports2, module2) {
    "use strict";
    var common2 = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key2, index, quantity;
      if (!common2.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key2 = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key2)) {
          destination[key2] = source[key2];
          overridableKeys[key2] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common2.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common2.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common2.repeat("\n", emptyLines);
          }
        } else {
          state.result += common2.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
  }
});

// node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "node_modules/js-yaml/lib/dumper.js"(exports2, module2) {
    "use strict";
    var common2 = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common2.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common2.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common2.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common2.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos2) {
      var first = string.charCodeAt(pos2), second;
      if (first >= 55296 && first <= 56319 && pos2 + 1 < string.length) {
        second = string.charCodeAt(pos2 + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char2 = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char2 >= 65536 ? i += 2 : i++) {
          char2 = codePointAt(string, i);
          if (!isPrintable(char2)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char2, prevChar, inblock);
          prevChar = char2;
        }
      } else {
        for (i = 0; i < string.length; char2 >= 65536 ? i += 2 : i++) {
          char2 = codePointAt(string, i);
          if (char2 === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char2)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char2, prevChar, inblock);
          prevChar = char2;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char2 = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char2 >= 65536 ? i += 2 : i++) {
        char2 = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char2];
        if (!escapeSeq && isPrintable(char2)) {
          result += string[i];
          if (char2 >= 65536)
            result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex(char2);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value2;
      for (index = 0, length = object.length; index < length; index += 1) {
        value2 = object[index];
        if (state.replacer) {
          value2 = state.replacer.call(object, String(index), value2);
        }
        if (writeNode(state, level, value2, false, false) || typeof value2 === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value2;
      for (index = 0, length = object.length; index < length; index += 1) {
        value2 = object[index];
        if (state.replacer) {
          value2 = state.replacer.call(object, String(index), value2);
        }
        if (writeNode(state, level + 1, value2, true, true, false, true) || typeof value2 === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value2 = input;
      if (state.replacer) {
        value2 = state.replacer.call({ "": value2 }, "", value2);
      }
      if (writeNode(state, 0, value2, true, true))
        return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump;
  }
});

// node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SCHEMA = require_default();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed("safeLoad", "load");
    module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed("safeDump", "dump");
  }
});

// node_modules/@mdfriday/text-template/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@mdfriday/text-template/dist/index.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (t, e, r) => e in t ? __defProp(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
    var __spreadValues = (t, e) => {
      for (var r in e || (e = {}))
        __hasOwnProp.call(e, r) && __defNormalProp(t, r, e[r]);
      if (__getOwnPropSymbols)
        for (var r of __getOwnPropSymbols(e))
          __propIsEnum.call(e, r) && __defNormalProp(t, r, e[r]);
      return t;
    };
    var __export = (t, e) => {
      for (var r in e)
        __defProp(t, r, { get: e[r], enumerable: true });
    };
    var __copyProps = (t, e, r, i) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let n2 of __getOwnPropNames(e))
          __hasOwnProp.call(t, n2) || n2 === r || __defProp(t, n2, { get: () => e[n2], enumerable: !(i = __getOwnPropDesc(e, n2)) || i.enumerable });
      return t;
    };
    var __toESM = (t, e, r) => (r = t != null ? __create(__getProtoOf(t)) : {}, __copyProps(!e && t && t.t ? r : __defProp(r, "default", { value: t, enumerable: true }), t));
    var __toCommonJS = (t) => __copyProps(__defProp({}, "__esModule", { value: true }), t);
    var __async = (t, e, r) => new Promise((i, n2) => {
      var s = (t2) => {
        try {
          h(r.next(t2));
        } catch (t3) {
          n2(t3);
        }
      }, o = (t2) => {
        try {
          h(r.throw(t2));
        } catch (t3) {
          n2(t3);
        }
      }, h = (t2) => t2.done ? i(t2.value) : Promise.resolve(t2.value).then(s, o);
      h((r = r.apply(t, e)).next());
    });
    var src_exports = {};
    __export(src_exports, { ActionNode: () => ActionNode, BoolNode: () => BoolNode, CommandNode: () => CommandNode, DotNode: () => DotNode, ExecError: () => ExecError, FieldNode: () => FieldNode, IdentifierNode: () => IdentifierNode, IfNode: () => IfNode, IsEmptyTree: () => IsEmptyTree, JSEscapeString: () => JSEscapeString, ListNode: () => ListNode, Mode: () => Mode, Must: () => Must, New: () => New2, NilNode: () => NilNode, NodeType: () => NodeType, NumberNode: () => NumberNode, ParseContents: () => ParseContents, ParseFiles: () => ParseFiles, PipeNode: () => PipeNode, RangeNode: () => RangeNode, StringNode: () => StringNode, Template: () => Template, TemplateNode: () => TemplateNode, TextNode: () => TextNode, Tree: () => Tree2, VariableNode: () => VariableNode, WithNode: () => WithNode, getTextFormat: () => getTextFormat, lex: () => lex, parse: () => parse, setTextFormat: () => setTextFormat }), module.exports = __toCommonJS(src_exports);
    var textFormat = "%s";
    function setTextFormat(t) {
      const e = textFormat;
      return textFormat = t, e;
    }
    function getTextFormat() {
      return textFormat;
    }
    var NodeType = ((t) => (t[t.NodeText = 0] = "NodeText", t[t.NodeAction = 1] = "NodeAction", t[t.NodeBool = 2] = "NodeBool", t[t.NodeChain = 3] = "NodeChain", t[t.NodeCommand = 4] = "NodeCommand", t[t.NodeDot = 5] = "NodeDot", t[t.NodeElse = 6] = "NodeElse", t[t.NodeEnd = 7] = "NodeEnd", t[t.NodeField = 8] = "NodeField", t[t.NodeIdentifier = 9] = "NodeIdentifier", t[t.NodeIf = 10] = "NodeIf", t[t.NodeList = 11] = "NodeList", t[t.NodeNil = 12] = "NodeNil", t[t.NodeNumber = 13] = "NodeNumber", t[t.NodePipe = 14] = "NodePipe", t[t.NodeRange = 15] = "NodeRange", t[t.NodeString = 16] = "NodeString", t[t.NodeTemplate = 17] = "NodeTemplate", t[t.NodeVariable = 18] = "NodeVariable", t[t.NodeWith = 19] = "NodeWith", t[t.NodeComment = 20] = "NodeComment", t[t.NodeBreak = 21] = "NodeBreak", t[t.NodeContinue = 22] = "NodeContinue", t))(NodeType || {});
    var StringBuilderImpl = class {
      constructor() {
        this.parts = [];
      }
      WriteString(t) {
        this.parts.push(t);
      }
      String() {
        return this.parts.join("");
      }
    };
    var TextNode = class t {
      constructor(t2, e, r) {
        this.nodeType = 0, this.tr = t2, this.pos = e, this.Text = new TextEncoder().encode(r);
      }
      Type() {
        return this.nodeType;
      }
      String() {
        return sprintf(textFormat, new TextDecoder().decode(this.Text));
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      Copy() {
        return new t(this.tr, this.pos, new TextDecoder().decode(this.Text));
      }
      writeTo(t2) {
        const e = new TextDecoder().decode(this.Text);
        t2.WriteString(sprintf(textFormat, e));
      }
    };
    function sprintf(t, ...e) {
      let r = 0;
      return t.replace(/%[sqd%vT]/g, (t2) => {
        if (t2 === "%%")
          return "%";
        if (r >= e.length)
          return t2;
        const i = e[r++];
        switch (t2) {
          case "%s":
            return String(i);
          case "%q":
            return typeof i == "string" ? `"${i}"` : String(i);
          case "%d":
            return Number(i).toString();
          case "%v":
            return i instanceof Error ? i.message : String(i);
          case "%T":
            return typeof i;
          default:
            return t2;
        }
      });
    }
    var ListNode = class t {
      constructor(t2) {
        this.Nodes = [], this.pos = t2;
      }
      Type() {
        return 11;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      append(t2) {
        this.Nodes.push(t2);
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      CopyList() {
        const e = new t(this.pos);
        return e.tr = this.tr, e.Nodes = this.Nodes.map((t2) => t2.Copy()), e;
      }
      Copy() {
        return this.CopyList();
      }
      writeTo(t2) {
        this.Nodes.forEach((e) => e.writeTo(t2));
      }
    };
    var ActionNode = class t {
      constructor(t2, e, r) {
        this.pos = t2, this.line = e, this.Pipe = r;
      }
      Type() {
        return 1;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      setPos(t2) {
        return this.pos = t2, this;
      }
      String() {
        return `{{${this.Pipe.String()}}}`;
      }
      Copy() {
        return new t(this.pos, this.line, this.Pipe.Copy());
      }
      writeTo(t2) {
        t2.WriteString("{{"), this.Pipe.writeTo(t2), t2.WriteString("}}");
      }
    };
    var PipeNode = class t {
      constructor(t2, e) {
        this.IsAssign = false, this.Decl = [], this.Cmds = [], this.pos = t2, this.Line = e;
      }
      Type() {
        return 14;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      append(t2) {
        this.Cmds.push(t2);
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        const e = new t(this.pos, this.Line);
        return e.IsAssign = this.IsAssign, e.Decl = this.Decl.map((t2) => t2.Copy()), e.Cmds = this.Cmds.map((t2) => t2.Copy()), e;
      }
      writeTo(t2) {
        this.Decl.length > 0 && (this.Decl.forEach((e, r) => {
          r > 0 && t2.WriteString(", "), e.writeTo(t2);
        }), t2.WriteString(" := ")), this.Cmds.forEach((e, r) => {
          r > 0 && t2.WriteString(" | "), e.writeTo(t2);
        });
      }
    };
    var CommandNode = class t {
      constructor(t2) {
        this.Args = [], this.pos = t2;
      }
      Type() {
        return 4;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      append(t2) {
        this.Args.push(t2);
      }
      Copy() {
        const e = new t(this.pos);
        return e.Args = this.Args.map((t2) => t2.Copy()), e;
      }
      writeTo(t2) {
        this.Args.forEach((e, r) => {
          r > 0 && t2.WriteString(" "), e.Type() === 14 ? (t2.WriteString("("), e.writeTo(t2), t2.WriteString(")")) : e.writeTo(t2);
        });
      }
    };
    var CommentNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.Text = e;
      }
      Type() {
        return 20;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Text);
      }
      writeTo(t2) {
        this.tr && 1 & this.tr.Mode && (t2.WriteString("{{"), t2.WriteString(this.Text), t2.WriteString("}}"));
      }
    };
    var VariableNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.Ident = e;
      }
      Type() {
        return 18;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Ident.slice());
      }
      writeTo(t2) {
        for (let e = 0; e < this.Ident.length; e++)
          e > 0 && t2.WriteString("."), t2.WriteString(this.Ident[e]);
      }
    };
    var IdentifierNode = class t {
      constructor(t2) {
        this.Ident = t2;
      }
      Type() {
        return 9;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      setPos(t2) {
        return this.pos = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.Ident).setTree(this.tr).setPos(this.pos);
      }
      writeTo(t2) {
        t2.WriteString(this.Ident);
      }
    };
    var DotNode = class t {
      constructor(t2) {
        this.pos = t2;
      }
      Type() {
        return 5;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos);
      }
      writeTo(t2) {
        t2.WriteString(".");
      }
    };
    var NilNode = class t {
      constructor(t2) {
        this.pos = t2;
      }
      Type() {
        return 12;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      setPos(t2) {
        return this.pos = t2, this;
      }
      String() {
        return "nil";
      }
      Copy() {
        return new t(this.pos);
      }
      writeTo(t2) {
        t2.WriteString("nil");
      }
    };
    var FieldNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.Ident = e;
      }
      Type() {
        return 8;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      setPos(t2) {
        return this.pos = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Ident.slice());
      }
      writeTo(t2) {
        for (const e of this.Ident)
          t2.WriteString("."), t2.WriteString(e);
      }
    };
    var ChainNode = class t {
      constructor(t2, e) {
        this.Field = [], this.pos = t2, this.Node = e;
      }
      Type() {
        return 3;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      setPos(t2) {
        return this.pos = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      add(t2) {
        if (t2.length === 0 || t2[0] !== ".")
          throw console.error(`[ChainNode.add] Field does not start with a dot: "${t2}"`), new Error("no dot in field");
        const e = t2.substring(1);
        if (e === "")
          throw console.error("[ChainNode.add] Empty field after removing dot"), new Error("empty field");
        this.Field.push(e);
      }
      Copy() {
        const e = new t(this.pos, this.Node.Copy());
        return e.Field = this.Field.slice(), e;
      }
      writeTo(t2) {
        this.Node.Type() === 14 ? (t2.WriteString("("), this.Node.writeTo(t2), t2.WriteString(")")) : this.Node.writeTo(t2), this.Field.forEach((e) => {
          t2.WriteString("."), t2.WriteString(e);
        });
      }
    };
    var BoolNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.True = e;
      }
      Type() {
        return 2;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.True);
      }
      writeTo(t2) {
        t2.WriteString(this.True ? "true" : "false");
      }
    };
    var NumberNode = class t {
      constructor(t2, e, r) {
        this.IsInt = false, this.IsUint = false, this.IsFloat = false, this.IsComplex = false, this.Int64 = 0, this.Uint64 = 0, this.Float64 = 0, this.Complex128 = { re: 0, im: 0 }, this.tr = t2, this.pos = e, this.Text = r;
      }
      Type() {
        return 13;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      String() {
        return this.Text;
      }
      Copy() {
        const e = new t(this.tr, this.pos, this.Text);
        return e.IsInt = this.IsInt, e.IsUint = this.IsUint, e.IsFloat = this.IsFloat, e.IsComplex = this.IsComplex, e.Int64 = this.Int64, e.Uint64 = this.Uint64, e.Float64 = this.Float64, e.Complex128 = __spreadValues({}, this.Complex128), e;
      }
      writeTo(t2) {
        t2.WriteString(this.Text);
      }
      simplifyComplex() {
        this.Complex128.im === 0 && (this.IsFloat = true, this.Float64 = this.Complex128.re, Number.isInteger(this.Float64) && (this.IsInt = true, this.Int64 = this.Float64, this.Float64 >= 0 && (this.IsUint = true, this.Uint64 = this.Float64)));
      }
    };
    var StringNode = class t {
      constructor(t2, e, r) {
        this.pos = t2, this.Quoted = e, this.Text = r;
      }
      Type() {
        return 16;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Quoted, this.Text);
      }
      writeTo(t2) {
        t2.WriteString(this.Quoted);
      }
    };
    var EndNode = class t {
      constructor(t2) {
        this.pos = t2;
      }
      Type() {
        return 7;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos);
      }
      writeTo(t2) {
        t2.WriteString("{{end}}");
      }
    };
    var ElseNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.Line = e;
      }
      Type() {
        return 6;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Line);
      }
      writeTo(t2) {
        t2.WriteString("{{else}}");
      }
    };
    var BreakNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.Line = e;
      }
      Type() {
        return 21;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Line);
      }
      writeTo(t2) {
        t2.WriteString("{{break}}");
      }
    };
    var ContinueNode = class t {
      constructor(t2, e) {
        this.pos = t2, this.Line = e;
      }
      Type() {
        return 22;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        const t2 = new StringBuilderImpl();
        return this.writeTo(t2), t2.String();
      }
      Copy() {
        return new t(this.pos, this.Line);
      }
      writeTo(t2) {
        t2.WriteString("{{continue}}");
      }
    };
    var BranchNode = class {
      constructor(t, e, r, i, n2, s, o) {
        this.nodeType = t, this.tr = e, this.pos = r, this.Line = i, this.Pipe = n2, this.List = s, this.ElseList = o;
      }
      Type() {
        return this.nodeType;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      String() {
        const t = new StringBuilderImpl();
        return this.writeTo(t), t.String();
      }
      Copy() {
        throw new Error("Copy() must be implemented by derived classes");
      }
      writeTo(t) {
        const e = this.nodeType === 10 ? "if" : this.nodeType === 15 ? "range" : this.nodeType === 19 ? "with" : "unknown";
        t.WriteString("{{" + e + " "), this.Pipe.writeTo(t), t.WriteString("}}"), this.List.writeTo(t), this.ElseList && (t.WriteString("{{else}}"), this.ElseList.writeTo(t)), t.WriteString("{{end}}");
      }
    };
    var IfNode = class t extends BranchNode {
      constructor(t2, e, r, i, n2, s) {
        super(10, t2, e, r, i, n2, s);
      }
      Copy() {
        var e;
        return new t(this.tr, this.pos, this.Line, this.Pipe.Copy(), this.List.CopyList(), ((e = this.ElseList) == null ? void 0 : e.CopyList()) || null);
      }
    };
    var RangeNode = class t extends BranchNode {
      constructor(t2, e, r, i, n2, s) {
        super(15, t2, e, r, i, n2, s);
      }
      Copy() {
        var e;
        return new t(this.tr, this.pos, this.Line, this.Pipe.Copy(), this.List.CopyList(), ((e = this.ElseList) == null ? void 0 : e.CopyList()) || null);
      }
    };
    var WithNode = class t extends BranchNode {
      constructor(t2, e, r, i, n2, s) {
        super(19, t2, e, r, i, n2, s);
      }
      Copy() {
        var e;
        return new t(this.tr, this.pos, this.Line, this.Pipe.Copy(), this.List.CopyList(), ((e = this.ElseList) == null ? void 0 : e.CopyList()) || null);
      }
    };
    var TemplateNode = class t {
      constructor(t2, e, r, i) {
        this.pos = t2, this.Line = e, this.Name = r, this.Pipe = i;
      }
      Type() {
        return 17;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        return "{{template " + JSON.stringify(this.Name) + (this.Pipe ? " " + this.Pipe.String() : "") + "}}";
      }
      Copy() {
        return new t(this.pos, this.Line, this.Name, this.Pipe ? this.Pipe.Copy() : null).setTree(this.tr);
      }
      writeTo(t2) {
        t2.WriteString("{{template "), t2.WriteString(JSON.stringify(this.Name)), this.Pipe && (t2.WriteString(" "), this.Pipe.writeTo(t2)), t2.WriteString("}}");
      }
    };
    var DefineNode = class t {
      constructor(t2, e, r, i) {
        this.pos = t2, this.Line = e, this.Name = r, this.Pipe = i;
      }
      Type() {
        return 17;
      }
      Position() {
        return this.pos;
      }
      tree() {
        return this.tr;
      }
      setTree(t2) {
        return this.tr = t2, this;
      }
      String() {
        return "{{define " + this.Name + "}}";
      }
      Copy() {
        return new t(this.pos, this.Line, this.Name, this.Pipe.Copy()).setTree(this.tr);
      }
      writeTo(t2) {
        t2.WriteString("{{define " + this.Name + "}}"), this.Pipe && (t2.WriteString(" "), this.Pipe.writeTo(t2)), t2.WriteString("}}");
      }
    };
    var key = { ".": 26, block: 23, break: 24, continue: 25, define: 27, else: 28, end: 29, if: 30, range: 32, nil: 31, template: 33, with: 34 };
    var EOF = -1;
    var spaceChars = " 	\r\n";
    var trimMarker = "-";
    var trimMarkerLen = 2;
    var leftDelim = "{{";
    var rightDelim = "}}";
    var leftComment = "/*";
    var rightComment = "*/";
    var Lexer = class {
      constructor(t, e, r, i) {
        this.name = t, this.input = e, this.leftDelim = r || leftDelim, this.rightDelim = i || rightDelim, this.pos = 0, this.start = 0, this.atEOF = false, this.parenDepth = 0, this.line = 1, this.startLine = 1, this.insideAction = false, this.options = { emitComment: false, breakOK: false, continueOK: false }, this.item = { typ: 8, pos: 0, val: "", line: 1 };
      }
      next() {
        if (this.pos >= this.input.length)
          return this.atEOF = true, String.fromCharCode(EOF);
        const t = this.input[this.pos];
        return this.pos++, t === "\n" && this.line++, t;
      }
      peek() {
        const t = this.next();
        return this.backup(), t;
      }
      backup() {
        !this.atEOF && this.pos > 0 && (this.pos--, this.input[this.pos] === "\n" && this.line--);
      }
      emit(t) {
        return this.item = { typ: t, pos: this.start, val: this.input.slice(this.start, this.pos), line: this.startLine }, this.start = this.pos, this.startLine = this.line, null;
      }
      ignore() {
        this.line += (this.input.slice(this.start, this.pos).match(/\n/g) || []).length, this.start = this.pos, this.startLine = this.line;
      }
      accept(t) {
        return !!t.includes(this.next()) || (this.backup(), false);
      }
      acceptRun(t) {
        for (; t.includes(this.next()); )
          ;
        this.backup();
      }
      errorf(t, ...e) {
        return this.item = { typ: 0, pos: this.start, val: t.replace(/%[sdq%]/g, () => {
          const t2 = e.shift();
          return String(t2);
        }), line: this.startLine }, null;
      }
      nextItem() {
        this.item = { typ: 8, pos: this.pos, val: "EOF", line: this.startLine };
        let t = this.insideAction ? lexInsideAction : lexText;
        for (; t; )
          if (t = t(this), this.item.typ === 0)
            return this.item;
        return this.item;
      }
      atRightDelim() {
        const t = this.input.slice(this.pos);
        return t.length >= 2 && isSpace(t[0]) && t[1] === trimMarker && t.slice(trimMarkerLen).startsWith(this.rightDelim) ? [true, true] : t.startsWith(this.rightDelim) ? [true, false] : [false, false];
      }
      atTerminator() {
        const t = this.peek();
        if (isSpace(t))
          return true;
        switch (t) {
          case String.fromCharCode(EOF):
          case ".":
          case ",":
          case "|":
          case ":":
          case ")":
          case "(":
            return true;
        }
        return this.input.slice(this.pos).startsWith(this.rightDelim);
      }
      scanNumber() {
        this.accept("+-");
        let t = "0123456789_";
        return this.accept("0") && (this.accept("xX") ? t = "0123456789abcdefABCDEF_" : this.accept("oO") ? t = "01234567_" : this.accept("bB") && (t = "01_")), this.acceptRun(t), this.accept(".") && this.acceptRun(t), t === "0123456789_" && this.accept("eE") && (this.accept("+-"), this.acceptRun("0123456789_")), t === "0123456789abcdefABCDEF_" && this.accept("pP") && (this.accept("+-"), this.acceptRun("0123456789_")), this.accept("i"), !isAlphaNumeric(this.peek()) || (this.next(), false);
      }
      thisItem(t) {
        const e = { typ: t, pos: this.start, val: this.input.slice(this.start, this.pos), line: this.startLine };
        return this.start = this.pos, this.startLine = this.line, e;
      }
      emitItem(t) {
        return this.item = t, null;
      }
    };
    function isSpace(t) {
      return t === " " || t === "	" || t === "\r" || t === "\n";
    }
    function isAlphaNumeric(t) {
      return t === "_" || /[a-zA-Z0-9]/.test(t);
    }
    function leftTrimLength(t) {
      let e = 0;
      for (; e < t.length && spaceChars.includes(t[e]); )
        e++;
      return e;
    }
    function rightTrimLength(t) {
      let e = t.length - 1;
      for (; e >= 0 && spaceChars.includes(t[e]); )
        e--;
      return t.length - (e + 1);
    }
    function hasLeftTrimMarker(t) {
      return t.length >= 2 && t[0] === trimMarker && spaceChars.includes(t[1]);
    }
    function hasRightTrimMarker(t) {
      return t.length >= 2 && spaceChars.includes(t[0]) && t[1] === trimMarker;
    }
    function lexText(t) {
      const e = t.input.indexOf(t.leftDelim, t.pos);
      if (e >= 0) {
        if (e > t.pos) {
          t.pos += e - t.pos;
          let r = 0;
          const i = t.pos + t.leftDelim.length;
          hasLeftTrimMarker(t.input.slice(i)) && (r = rightTrimLength(t.input.slice(t.start, t.pos))), t.pos -= r, t.line += (t.input.slice(t.start, t.pos).match(/\n/g) || []).length;
          const n2 = t.thisItem(20);
          if (t.pos += r, t.ignore(), n2.val.length > 0)
            return t.emitItem(n2);
        }
        return lexLeftDelim;
      }
      return t.pos = t.input.length, t.pos > t.start ? (t.line += (t.input.slice(t.start, t.pos).match(/\n/g) || []).length, t.emit(20)) : t.emit(8);
    }
    function lexLeftDelim(t) {
      t.pos += t.leftDelim.length;
      let e = 0;
      if (hasLeftTrimMarker(t.input.slice(t.pos)) && (e = trimMarkerLen), t.input.slice(t.pos + e).startsWith(leftComment))
        return t.pos += e, t.ignore(), lexComment;
      const r = t.thisItem(11);
      return t.insideAction = true, t.pos += e, t.ignore(), t.parenDepth = 0, t.emitItem(r);
    }
    function lexComment(t) {
      t.pos += leftComment.length;
      const e = t.input.slice(t.pos).indexOf(rightComment);
      if (e < 0)
        return t.errorf("unclosed comment");
      t.pos += e + rightComment.length;
      const [r, i] = t.atRightDelim();
      if (!r)
        return t.errorf("comment ends before closing delimiter");
      const n2 = t.thisItem(4);
      return i && (t.pos += trimMarkerLen), t.pos += t.rightDelim.length, i && (t.pos += leftTrimLength(t.input.slice(t.pos))), t.ignore(), t.options.emitComment ? t.emitItem(n2) : lexText;
    }
    function lexRightDelim(t) {
      const [e, r] = t.atRightDelim();
      r && (t.pos += trimMarkerLen, t.ignore()), t.pos += t.rightDelim.length;
      const i = t.thisItem(16);
      return r && (t.pos += leftTrimLength(t.input.slice(t.pos)), t.ignore()), t.insideAction = false, t.emitItem(i);
    }
    function lexInsideAction(t) {
      const [e, r] = t.atRightDelim();
      if (e)
        return t.parenDepth === 0 ? lexRightDelim : t.errorf("unclosed left paren");
      const i = t.next();
      if (i === String.fromCharCode(EOF))
        return t.errorf("unclosed action");
      if (isSpace(i))
        return t.backup(), lexSpace;
      switch (i) {
        case "=":
          return t.emit(6);
        case ":":
          return t.next() !== "=" ? t.errorf("expected :=") : t.emit(7);
        case "|":
          return t.emit(14);
        case '"':
          return lexQuote;
        case "`":
          return lexRawQuote;
        case "$":
          return lexVariable;
        case "'":
          return lexChar;
        case ".":
          if (t.pos < t.input.length) {
            const e3 = t.input[t.pos];
            if (!/[0-9]/.test(e3))
              return lexField;
          }
          return t.backup(), lexNumber;
        case "+":
        case "-":
          return t.backup(), lexNumber;
        case "(":
          return t.parenDepth++, t.emit(12);
        case ")":
          return t.parenDepth--, t.parenDepth < 0 ? t.errorf("unexpected right paren") : t.emit(17);
        default:
          if (/[0-9]/.test(i))
            return t.backup(), lexNumber;
          if (isAlphaNumeric(i))
            return t.backup(), lexIdentifier;
          if (i.charCodeAt(0) <= 127 && /[\x20-\x7E]/.test(i))
            return t.emit(2);
          const e2 = i.codePointAt(0) || 0;
          return t.errorf(`unrecognized character in action: U+${e2.toString(16).padStart(4, "0").toUpperCase()}`);
      }
    }
    function lexSpace(t) {
      let e = 0;
      for (; isSpace(t.peek()); )
        t.next(), e++;
      return hasRightTrimMarker(t.input.slice(t.pos - 1)) && t.input.slice(t.pos - 1 + trimMarkerLen).startsWith(t.rightDelim) && (t.backup(), e === 1) ? lexRightDelim : t.emit(18);
    }
    function lexIdentifier(t) {
      for (; ; ) {
        const e = t.next();
        if (!isAlphaNumeric(e)) {
          t.backup();
          const r = t.input.slice(t.start, t.pos);
          if (!t.atTerminator())
            return t.errorf(`bad character ${e}`);
          if (key[r] > 22) {
            const e2 = key[r];
            return e2 === 24 && !t.options.breakOK || e2 === 25 && !t.options.continueOK ? t.emit(10) : t.emit(e2);
          }
          return r[0] === "." ? t.emit(9) : r === "true" || r === "false" ? t.emit(1) : t.emit(10);
        }
      }
    }
    function lexField(t) {
      return lexFieldOrVariable(t, 9);
    }
    function lexVariable(t) {
      return t.atTerminator() ? t.emit(21) : lexFieldOrVariable(t, 21);
    }
    function lexFieldOrVariable(t, e) {
      if (t.atTerminator())
        return e === 21 ? t.emit(21) : t.emit(26);
      for (; ; )
        if (!isAlphaNumeric(t.next())) {
          t.backup();
          break;
        }
      return t.atTerminator() ? t.emit(e) : t.errorf(`bad character ${t.peek()}`);
    }
    function lexChar(t) {
      const e = t.pos - 1;
      t:
        for (; ; )
          switch (t.next()) {
            case "\\": {
              const e2 = t.next();
              if (e2 === String.fromCharCode(EOF) || e2 === "\n")
                return t.errorf("unterminated character constant");
              continue t;
            }
            case String.fromCharCode(EOF):
            case "\n":
              return t.errorf("unterminated character constant");
            case "'":
              break t;
          }
      return t.item = { typ: 3, pos: t.start, val: t.input.slice(e, t.pos), line: t.startLine }, t.start = t.pos, null;
    }
    function lexNumber(t) {
      return t.scanNumber() ? t.peek() === "+" || t.peek() === "-" ? t.scanNumber() && t.input[t.pos - 1] === "i" ? t.emit(5) : t.errorf(`bad number syntax: "${t.input.slice(t.start, t.pos)}"`) : t.emit(13) : t.errorf(`bad number syntax: "${t.input.slice(t.start, t.pos)}"`);
    }
    function lexQuote(t) {
      const e = t.pos - 1;
      t:
        for (; ; )
          switch (t.next()) {
            case "\\": {
              const e2 = t.next();
              if (e2 === String.fromCharCode(EOF) || e2 === "\n")
                return t.errorf("unterminated quoted string");
              continue t;
            }
            case String.fromCharCode(EOF):
            case "\n":
              return t.errorf("unterminated quoted string");
            case '"':
              break t;
          }
      return t.item = { typ: 19, pos: t.start, val: t.input.slice(e, t.pos), line: t.startLine }, t.start = t.pos, null;
    }
    function lexRawQuote(t) {
      for (; ; ) {
        const e = t.next();
        if (e === String.fromCharCode(EOF))
          return t.errorf("unterminated raw quoted string");
        if (e === "`")
          break;
      }
      return t.emit(15);
    }
    function lex(t, e, r = "", i = "") {
      return new Lexer(t, e, r, i);
    }
    var Mode = ((t) => (t[t.ParseComments = 1] = "ParseComments", t[t.SkipFuncCheck = 2] = "SkipFuncCheck", t))(Mode || {});
    function New(t, e = []) {
      return new Tree2(t, e);
    }
    var Tree2 = class __Tree {
      constructor(t, e = []) {
        this.Name = t, this.ParseName = "", this.Root = null, this.Mode = 0, this.text = "", this.funcs = e, this.lex = null, this.tokenArray = new Array(3).fill(null), this.peekCount = 0, this.vars = [], this.treeSet = /* @__PURE__ */ new Map(), this.actionLine = 0, this.rangeDepth = 0;
      }
      copy() {
        var t;
        return this ? new __Tree(this.Name, []).setProperties({ ParseName: this.ParseName, Root: (t = this.Root) == null ? void 0 : t.CopyList(), text: this.text }) : null;
      }
      setProperties(t) {
        return Object.assign(this, t), this;
      }
      next() {
        if (this.peekCount > 0)
          this.peekCount--;
        else {
          if (!this.lex)
            throw new Error("Lexer not initialized");
          const t2 = this.lex.nextItem();
          if (!t2)
            throw new Error("No token available from lexer");
          this.tokenArray[0] = t2;
        }
        const t = this.tokenArray[this.peekCount];
        if (!t)
          throw new Error("No token available");
        return t;
      }
      backup() {
        this.peekCount++;
      }
      backup2(t) {
        this.tokenArray[1] = t, this.peekCount = 2;
      }
      backup3(t, e) {
        this.tokenArray[1] = e, this.tokenArray[2] = t, this.peekCount = 3;
      }
      peek() {
        if (this.peekCount > 0) {
          const t2 = this.tokenArray[this.peekCount - 1];
          if (!t2)
            throw new Error("No token available");
          return t2;
        }
        if (this.peekCount = 1, !this.lex)
          throw new Error("Lexer not initialized");
        const t = this.lex.nextItem();
        if (!t)
          throw new Error("No token available from lexer");
        return this.tokenArray[0] = t, t;
      }
      nextNonSpace() {
        let t;
        for (; t = this.next(), t.typ === 18; )
          ;
        return t;
      }
      peekNonSpace() {
        const t = this.nextNonSpace();
        return this.backup(), t;
      }
      errorContext(t) {
        const e = t.Position(), r = t.tree() || this, i = r.text.substring(0, e);
        let n2 = i.lastIndexOf("\n");
        n2 === -1 ? n2 = e : (n2++, n2 = e - n2);
        const s = 1 + (i.match(/\n/g) || []).length, o = t.toString();
        return [`${r.ParseName}:${s}:${n2}`, o];
      }
      errorf(t, ...e) {
        this.Root = null;
        const r = this.tokenArray[0];
        if (!r)
          throw new Error(`template: ${this.ParseName}: ${sprintf(t, ...e)}`);
        throw t = `template: ${this.ParseName}:${r.line}: ${t}`, new Error(sprintf(t, ...e));
      }
      error(t) {
        this.errorf("%s", t);
      }
      expect(t, e) {
        const r = this.nextNonSpace();
        return r.typ !== t && this.unexpected(r, e), r;
      }
      expectOneOf(t, e, r) {
        const i = this.nextNonSpace();
        return i.typ !== t && i.typ !== e && this.unexpected(i, r), i;
      }
      unexpected(t, e) {
        if (t.typ === 0) {
          let e2 = "";
          this.actionLine !== 0 && this.actionLine !== t.line && (e2 = ` in action started at ${this.ParseName}:${this.actionLine}`, t.val.endsWith(" action") && (e2 = e2.substring(10))), this.errorf("%s%s", t.val, e2);
        }
        this.errorf("unexpected %s in %s", t.val, e);
      }
      recover(t) {
        var e;
        const r = t.err;
        if (r) {
          if (r instanceof Error && ((e = r.stack) == null ? void 0 : e.includes("runtime error:")))
            throw r;
          this && this.stopParse(), t.err = r;
        }
      }
      newList(t) {
        return new ListNode(t).setTree(this);
      }
      newText(t, e) {
        return new TextNode(this, t, e);
      }
      newAction(t, e, r) {
        if (!(r instanceof PipeNode))
          throw new Error("Pipeline must be a PipeNode");
        return new ActionNode(t, e, r).setTree(this);
      }
      newComment(t, e) {
        return new CommentNode(t, e).setTree(this);
      }
      newIf(t, e, r, i, n2) {
        if (!(r instanceof PipeNode))
          throw new Error("Pipe must be a PipeNode");
        return new IfNode(this, t, e, r, i, n2);
      }
      newRange(t, e, r, i, n2) {
        if (!(r instanceof PipeNode))
          throw new Error("Pipe must be a PipeNode");
        return new RangeNode(this, t, e, r, i, n2);
      }
      newTemplate(t, e, r, i) {
        if (i !== null && !(i instanceof PipeNode))
          throw new Error("Pipe must be a PipeNode");
        return new TemplateNode(t, e, r, i).setTree(this);
      }
      newWith(t, e, r, i, n2) {
        if (!(r instanceof PipeNode))
          throw new Error("Pipe must be a PipeNode");
        return new WithNode(this, t, e, r, i, n2);
      }
      newPipeline(t, e, r = []) {
        const i = new PipeNode(t, e).setTree(this);
        return r && (i.Decl = r), i;
      }
      newCommand(t) {
        return new CommandNode(t).setTree(this);
      }
      newChain(t, e) {
        return new ChainNode(t, e).setTree(this);
      }
      textOrAction() {
        const t = this.nextNonSpace();
        switch (t.typ) {
          case 20:
            return this.newText(t.pos, t.val);
          case 11:
            this.actionLine = t.line;
            const e = this.action();
            return this.clearActionLine(), e;
          case 4:
            return this.newComment(t.pos, t.val);
          default:
            return this.unexpected(t, "input"), this.newText(t.pos, "");
        }
      }
      action() {
        const t = this.nextNonSpace();
        switch (this.actionLine = t.line, t.typ) {
          case 23:
            return this.blockControl();
          case 24:
            return this.breakControl(t.pos, t.line);
          case 25:
            return this.continueControl(t.pos, t.line);
          case 28:
            return this.elseControl();
          case 29:
            return this.endControl();
          case 30:
            return this.ifControl();
          case 32:
            return this.rangeControl();
          case 33:
            return this.templateControl();
          case 34:
            return this.withControl();
        }
        this.backup();
        const e = this.peek().pos, r = this.peek().line, i = this.pipeline("command", 16);
        return this.newAction(e, r, i);
      }
      parse(t, e, r, i, n2 = []) {
        this.ParseName = this.Name;
        const s = lex(this.Name, t, e, r);
        this.startParse(n2, s, i), this.text = t;
        let o = null;
        try {
          return this.doParse(), this.add(), [this, null];
        } catch (t2) {
          return o = t2 instanceof Error ? t2 : new Error(String(t2)), [this, o];
        } finally {
          this.stopParse();
        }
      }
      startParse(t, e, r) {
        this.Root = null, this.lex = e, this.funcs = t, this.treeSet = r, this.tokenArray = new Array(3).fill(null), this.peekCount = 0, this.vars = ["$"], this.actionLine = 0, this.lex && (this.lex.options = { emitComment: !!(1 & this.Mode), breakOK: !this.hasFunction("break"), continueOK: !this.hasFunction("continue") });
      }
      stopParse() {
        this.lex = null, this.funcs = [], this.treeSet = /* @__PURE__ */ new Map(), this.tokenArray = new Array(3).fill(null), this.peekCount = 0, this.vars = [], this.actionLine = 0;
      }
      doParse() {
        for (this.Root = this.newList(this.peek().pos); this.peek().typ !== 8; ) {
          if (this.peek().typ === 11) {
            const t2 = this.next();
            if (this.nextNonSpace().typ === 27) {
              const t3 = New("definition");
              t3.text = this.text, t3.Mode = this.Mode, t3.ParseName = this.ParseName, t3.startParse(this.funcs, this.lex, this.treeSet), t3.parseDefinition();
              continue;
            }
            this.backup2(t2);
          }
          const t = this.textOrAction();
          switch (t.Type()) {
            case 7:
            case 6:
              this.errorf("unexpected %s", t);
              break;
            default:
              this.Root.append(t);
          }
        }
      }
      parseDefinition() {
        const t = "define clause", e = this.expectOneOf(19, 15, t), r = this.unquote(e.val);
        let i;
        r instanceof Error && this.error(r), this.Name = r, this.expect(16, t), [this.Root, i] = this.itemList(), i.Type() !== 7 && this.errorf("unexpected %s in %s", i, t), this.add(), this.stopParse();
      }
      breakControl(t, e) {
        const r = this.tokenArray[0];
        if (!r)
          throw new Error("No token available");
        return this.nextNonSpace().typ !== 16 && this.unexpected(r, "{{break}}"), this.rangeDepth === 0 && this.errorf("{{break}} outside of range"), this.newBreak(t, e);
      }
      continueControl(t, e) {
        const r = this.tokenArray[0];
        if (!r)
          throw new Error("No token available");
        return this.nextNonSpace().typ !== 16 && this.unexpected(r, "{{continue}}"), this.rangeDepth === 0 && this.errorf("{{continue}} outside of range"), this.newContinue(t, e);
      }
      endControl() {
        return new EndNode(this.expect(16, "end").pos).setTree(this);
      }
      elseControl() {
        const t = this.peekNonSpace();
        if (t.typ === 30)
          return new ElseNode(t.pos, t.line).setTree(this);
        const e = this.expect(16, "else");
        return new ElseNode(e.pos, e.line).setTree(this);
      }
      ifControl() {
        const [t, e, r, i, n2] = this.parseControl(true, "if");
        return this.newIf(t, e, r, i, n2);
      }
      rangeControl() {
        const [t, e, r, i, n2] = this.parseControl(false, "range");
        return this.newRange(t, e, r, i, n2);
      }
      withControl() {
        const [t, e, r, i, n2] = this.parseControl(false, "with");
        return this.newWith(t, e, r, i, n2);
      }
      templateControl() {
        const t = "template clause", e = this.nextNonSpace(), r = this.parseTemplateName(e, t);
        let i = null;
        return this.nextNonSpace().typ !== 16 && (this.backup(), i = this.pipeline(t, 16)), this.newTemplate(e.pos, e.line, r, i);
      }
      blockControl() {
        const t = "block clause", e = this.nextNonSpace(), r = this.parseTemplateName(e, t), i = this.pipeline(t, 16), n2 = this.lex, s = [...this.tokenArray], o = this.peekCount;
        n2 || this.errorf("Failed to save lexer state");
        const h = new __Tree(r);
        let u;
        return h.Mode = this.Mode, h.Root = this.newList(e.pos), h.ParseName = this.ParseName, h.startParse(this.funcs, n2, this.treeSet), [h.Root, u] = h.itemList(), u.Type() !== 7 && this.errorf("unexpected %s in %s", u.toString(), t), h.add(), this.lex = n2, this.tokenArray = s, this.peekCount = o, this.newTemplate(e.pos, e.line, r, i);
      }
      itemList() {
        const t = this.newList(this.peekNonSpace().pos);
        for (; this.peekNonSpace().typ !== 8; ) {
          const e = this.textOrAction();
          switch (e.Type()) {
            case 7:
            case 6:
              return [t, e];
          }
          t.append(e);
        }
        return this.errorf("unexpected EOF"), [t, this.newEnd(0)];
      }
      parseTemplateName(t, e) {
        switch (t.typ) {
          case 19:
          case 15:
            const r = this.unquote(t.val);
            return r instanceof Error && this.error(r), r;
          default:
            this.unexpected(t, e);
        }
        return "";
      }
      popVars(t) {
        this.vars = this.vars.slice(0, t);
      }
      pipeline(t, e) {
        let r = this.peekNonSpace();
        const i = this.newPipeline(r.pos, r.line);
        let n2 = true;
        for (; n2 && this.peekNonSpace().typ === 21; ) {
          let e2 = this.next();
          const r2 = this.peek(), s = this.peekNonSpace();
          switch (true) {
            case (s.typ === 6 || s.typ === 7):
              i.IsAssign = s.typ === 6, this.nextNonSpace(), i.Decl.push(this.newVariable(e2.pos, e2.val)), this.vars.push(e2.val), n2 = false;
              break;
            case (s.typ === 2 && s.val === ","):
              if (this.nextNonSpace(), i.Decl.push(this.newVariable(e2.pos, e2.val)), this.vars.push(e2.val), t === "range" && i.Decl.length < 2)
                switch (this.peekNonSpace().typ) {
                  case 21:
                    break;
                  case 16:
                  case 17:
                    n2 = false;
                    break;
                  default:
                    this.errorf("range can only initialize variables");
                }
              else
                this.errorf("too many declarations in %s", t);
              break;
            case r2.typ === 18:
              this.backup3(e2, r2), n2 = false;
              break;
            default:
              this.backup2(e2), n2 = false;
          }
        }
        for (; ; ) {
          const r2 = this.nextNonSpace();
          switch (r2.typ) {
            case e:
              return this.checkPipeline(i, t), i;
            case 1:
            case 3:
            case 5:
            case 26:
            case 9:
            case 10:
            case 13:
            case 31:
            case 15:
            case 19:
            case 21:
            case 12:
              this.backup(), i.append(this.command());
              break;
            default:
              this.unexpected(r2, t);
          }
        }
      }
      command() {
        const t = this.newCommand(this.peekNonSpace().pos);
        for (; ; ) {
          this.peekNonSpace();
          const e = this.operand();
          e && t.Args.push(e);
          const r = this.next();
          switch (r.typ) {
            case 18:
              continue;
            case 16:
            case 17:
              this.backup();
              break;
            case 14:
              break;
            default:
              this.unexpected(r, "operand");
          }
          break;
        }
        return t.Args.length === 0 && this.errorf("empty command"), t;
      }
      operand() {
        const t = this.term();
        if (t) {
          if (this.peek().typ === 9) {
            const e = this.newChain(this.peek().pos, t);
            for (; this.peek().typ === 9; ) {
              const t2 = this.next().val;
              e.add(t2);
            }
            switch (t.Type()) {
              case 8:
                return this.newField(e.Position(), e.String());
              case 18:
                const r = e.String();
                return this.newVariable(e.Position(), r);
              case 2:
              case 16:
              case 13:
              case 12:
              case 5:
                this.errorf("unexpected . after term %q", t.String());
              default:
                return e;
            }
          }
          return t;
        }
      }
      term() {
        const t = this.nextNonSpace();
        if (t) {
          switch (t.typ) {
            case 10:
              return !(2 & this.Mode) && !this.hasFunction(t.val) && this.errorf("function %q not defined", t.val), new IdentifierNode(t.val).setTree(this).setPos(t.pos);
            case 26:
              return this.newDot(t.pos);
            case 31:
              return this.newNil(t.pos);
            case 21:
              return this.useVar(t.pos, t.val);
            case 9:
              return this.newField(t.pos, t.val);
            case 1:
              return this.newBool(t.pos, t.val === "true");
            case 3:
            case 5:
            case 13:
              const e = this.newNumber(t.pos, t.val, t.typ);
              return e instanceof Error && this.error(e), e;
            case 12:
              return this.pipeline("parenthesized pipeline", 17);
            case 19:
            case 15:
              const r = this.unquote(t.val);
              if (typeof r == "string")
                return this.newString(t.pos, t.val, r);
              this.error(r);
          }
          this.backup();
        }
      }
      checkPipeline(t, e) {
        t.Cmds.length === 0 && this.errorf("missing value for %s", e);
        for (let e2 = 0; e2 < t.Cmds.length - 1; e2++) {
          const r = t.Cmds[e2 + 1];
          if (r.Args.length)
            switch (r.Args[0].Type()) {
              case 2:
              case 5:
              case 12:
              case 13:
              case 16:
                this.errorf("non executable command in pipeline stage %d", e2 + 2);
            }
        }
      }
      useVar(t, e) {
        const r = this.newVariable(t, e);
        for (const t2 of this.vars)
          if (t2 === r.Ident[0])
            return r;
        throw this.errorf("undefined variable %q", r.Ident[0]), new Error("unreachable");
      }
      newVariable(t, e) {
        const r = e.split(".").filter((t2) => t2 !== "");
        return new VariableNode(t, r).setTree(this);
      }
      newField(t, e) {
        return new FieldNode(t, e.substring(1).split(".")).setTree(this);
      }
      newNumber(pos, text, typ) {
        const n = new NumberNode(this, pos, text);
        try {
          switch (typ) {
            case 3: {
              if (text.length < 2 || text[0] !== "'" || text[text.length - 1] !== "'")
                throw new Error(`malformed character constant: ${text}`);
              const char = text.slice(1, -1), rune = char.length === 1 ? char.charCodeAt(0) : char.startsWith("\\u") || char.startsWith("\\x") ? parseInt(char.slice(2), 16) : char.startsWith("\\") ? eval(`"${text}"`.slice(1, -1)).charCodeAt(0) : char.charCodeAt(0);
              return n.IsInt = true, n.Int64 = rune, n.IsUint = true, n.Uint64 = rune, n.IsFloat = true, n.Float64 = rune, n;
            }
            case 5: {
              const t = text.match(/^([-+]?\d*\.?\d*(?:[eE][-+]?\d+)?)([-+]\d*\.?\d*(?:[eE][-+]?\d+)?)?i$/);
              if (!t)
                throw new Error(`illegal complex number syntax: ${text}`);
              const e = t[1] ? parseFloat(t[1]) : 0, r = t[2] ? parseFloat(t[2] + "1") : 1;
              return n.IsComplex = true, n.Complex128 = { re: e, im: r }, this.simplifyComplex(n), n;
            }
          }
          if (text.endsWith("i")) {
            const t = parseFloat(text.slice(0, -1));
            if (!isNaN(t))
              return n.IsComplex = true, n.Complex128 = { re: 0, im: t }, this.simplifyComplex(n), n;
          }
          const cleanText = text.replace(/_/g, "");
          let value, isInt = false;
          if (cleanText.startsWith("0x") || cleanText.startsWith("0X"))
            value = parseInt(cleanText.slice(2), 16), isInt = true;
          else if (cleanText.startsWith("0o") || cleanText.startsWith("0O"))
            value = parseInt(cleanText.slice(2), 8), isInt = true;
          else if (cleanText.startsWith("0b") || cleanText.startsWith("0B"))
            value = parseInt(cleanText.slice(2), 2), isInt = true;
          else if (cleanText.startsWith("0") && cleanText.length > 1 && !/[.eE]/.test(cleanText))
            value = parseInt(cleanText, 8), isInt = true;
          else {
            const t = parseInt(cleanText, 10);
            isNaN(t) || t.toString() !== cleanText ? (value = parseFloat(cleanText), isInt = false) : (value = t, isInt = true);
          }
          if (!isNaN(value))
            return isInt && (n.IsInt = true, n.Int64 = value, value >= 0 && (n.IsUint = true, n.Uint64 = value)), n.IsFloat = true, n.Float64 = value, n;
          throw new Error(`illegal number syntax: ${text}`);
        } catch (t) {
          throw console.error(`[newNumber] Error creating number node: ${t}`), t instanceof Error ? t : new Error(String(t));
        }
      }
      simplifyComplex(t) {
        t.Complex128.im === 0 && (t.IsFloat = true, t.Float64 = t.Complex128.re, Number.isInteger(t.Float64) && (t.IsInt = true, t.Int64 = t.Float64, t.Float64 >= 0 && (t.IsUint = true, t.Uint64 = t.Float64)));
      }
      newBreak(t, e) {
        return new BreakNode(t, e).setTree(this);
      }
      newContinue(t, e) {
        return new ContinueNode(t, e).setTree(this);
      }
      newDot(t) {
        return new DotNode(t).setTree(this);
      }
      newNil(t) {
        return new NilNode(t).setTree(this);
      }
      newBool(t, e) {
        return new BoolNode(t, e).setTree(this);
      }
      newString(t, e, r) {
        return new StringNode(t, e, r).setTree(this);
      }
      newEnd(t) {
        return new EndNode(t).setTree(this);
      }
      newDefine(t, e, r, i) {
        return new DefineNode(t, e, r, i).setTree(this);
      }
      unquote(t) {
        if (t.length < 2)
          return new Error("invalid quoted string");
        const e = t[0];
        if (e !== t[t.length - 1])
          return new Error("invalid quoted string");
        if (t = t.slice(1, -1), e === "`")
          return t;
        let r = "";
        for (let e2 = 0; e2 < t.length; e2++)
          if (t[e2] === "\\") {
            if (e2 + 1 >= t.length)
              return new Error("unterminated escape sequence");
            switch (e2++, t[e2]) {
              case "a":
                r += "\x07";
                break;
              case "b":
                r += "\b";
                break;
              case "f":
                r += "\f";
                break;
              case "n":
                r += "\n";
                break;
              case "r":
                r += "\r";
                break;
              case "t":
                r += "	";
                break;
              case "v":
                r += "\v";
                break;
              case "\\":
                r += "\\";
                break;
              case '"':
                r += '"';
                break;
              case "'":
                r += "'";
                break;
              default:
                return new Error(`invalid escape sequence: \\${t[e2]}`);
            }
          } else
            r += t[e2];
        return r;
      }
      clearActionLine() {
        this.actionLine = 0;
      }
      add() {
        const t = this.treeSet.get(this.Name);
        t && !this.isEmptyTree(t.Root) ? this.isEmptyTree(this.Root) || this.errorf("template: multiple definition of template %q", this.Name) : this.treeSet.set(this.Name, this);
      }
      isEmptyTree(t) {
        return IsEmptyTree(t);
      }
      hasFunction(t) {
        for (const e of this.funcs)
          if (e && e.has(t))
            return true;
        return false;
      }
      parseControl(t, e) {
        const r = this.vars.length;
        try {
          const r2 = this.pipeline(e, 16);
          let i, n2;
          e === "range" && this.rangeDepth++, [i, n2] = this.itemList(), e === "range" && this.rangeDepth--;
          let s = null;
          switch (n2.Type()) {
            case 7:
              break;
            case 6:
              if (t && this.peek().typ === 30) {
                this.next(), s = this.newList(n2.Position()), s.append(this.ifControl());
                break;
              }
              [s, n2] = this.itemList(), n2.Type() !== 7 && this.errorf("expected end; found %s", n2);
          }
          return [r2.Position(), r2.Line, r2, i, s];
        } finally {
          this.popVars(r);
        }
      }
    };
    function parse(t, e, r = "", i = "", n2 = []) {
      const s = New(t, n2), o = /* @__PURE__ */ new Map(), [h, u] = s.parse(e, r, i, o, n2);
      return u ? (console.error(`[parse] Error parsing template: ${u.message}`), [/* @__PURE__ */ new Map(), u]) : (o.set(t, h), [o, null]);
    }
    function IsEmptyTree(t) {
      if (!t)
        return true;
      switch (t.Type()) {
        case 1:
        case 10:
        case 15:
        case 17:
        case 19:
          return false;
        case 20:
          return true;
        case 11:
          const e = t;
          for (const t2 of e.Nodes)
            if (!IsEmptyTree(t2))
              return false;
          return true;
        case 0:
          const r = t;
          return r.Text.length === 0 || new TextDecoder().decode(r.Text).trim() === "";
        default:
          throw new Error("unknown node: " + t.String());
      }
    }
    var StringBuffer = class {
      constructor(t = 64) {
        this.chunks = [], this.currentSize = 0, this.chunks = [], this.chunks.length = 0;
      }
      push(t) {
        t.length !== 0 && (this.chunks.push(t), this.currentSize += t.length);
      }
      join() {
        if (this.chunks.length === 0)
          return "";
        const t = this.chunks.join("");
        return this.reset(), t;
      }
      reset() {
        this.chunks.length = 0, this.currentSize = 0;
      }
      size() {
        return this.currentSize;
      }
      isEmpty() {
        return this.chunks.length === 0;
      }
    };
    var common = class {
      constructor() {
        this.tmpl = /* @__PURE__ */ new Map(), this.option = { missingKey: "invalid" }, this.parseFuncs = /* @__PURE__ */ new Map(), this.execFuncs = /* @__PURE__ */ new Map();
      }
    };
    var Template = class t {
      constructor(t2) {
        this.Tree = null, this.common = null, this.leftDelim = "", this.rightDelim = "", this.rootName = "", this.name = t2, this.init();
      }
      Name() {
        return this.name;
      }
      New(e) {
        this.init();
        const r = new t(e);
        return r.common = this.common, r.leftDelim = this.leftDelim, r.rightDelim = this.rightDelim, r;
      }
      init() {
        if (this.common === null) {
          this.common = new common();
          const t2 = builtins();
          for (const [e, r] of t2.entries())
            this.common.execFuncs.set(e, r);
        }
      }
      Clone() {
        const t2 = this.copy(null);
        if (t2.init(), this.common === null)
          return [t2, null];
        for (const [e, r] of this.common.tmpl.entries()) {
          if (e === this.name) {
            t2.common.tmpl.set(this.name, t2);
            continue;
          }
          const i = r.copy(t2.common);
          t2.common.tmpl.set(e, i);
        }
        for (const [e, r] of this.common.parseFuncs.entries())
          t2.common.parseFuncs.set(e, r);
        for (const [e, r] of this.common.execFuncs.entries())
          t2.common.execFuncs.set(e, r);
        return [t2, null];
      }
      copy(e) {
        const r = new t(this.name);
        return r.Tree = this.Tree, r.common = e, r.leftDelim = this.leftDelim, r.rightDelim = this.rightDelim, r;
      }
      AddParseTree(t2, e) {
        this.init();
        let r = this;
        return t2 !== this.name && (r = this.New(t2)), (this.associate(r, e) || r.Tree === null) && (r.Tree = e), [r, null];
      }
      Templates() {
        if (this.common === null)
          return [];
        const t2 = [];
        for (const e of this.common.tmpl.values())
          t2.push(e);
        return t2;
      }
      Delims(t2, e) {
        return this.init(), this.leftDelim = t2, this.rightDelim = e, this;
      }
      Funcs(t2) {
        this.init();
        for (const [e, r] of t2.entries()) {
          if (!this.goodName(e))
            throw new Error(`function name "${e}" is not a valid identifier`);
          if (typeof r != "function")
            throw new Error(`value for ${e} not a function`);
          this.common.parseFuncs.set(e, r), this.common.execFuncs.set(e, r);
        }
        return this;
      }
      goodName(t2) {
        if (t2 === "")
          return false;
        for (let e = 0; e < t2.length; e++) {
          const r = t2.charCodeAt(e);
          if (t2.charAt(e) !== "_") {
            if (e === 0 && !this.isLetter(r))
              return false;
            if (!this.isLetter(r) && !this.isDigit(r))
              return false;
          }
        }
        return true;
      }
      isLetter(t2) {
        return t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122 || t2 > 127;
      }
      isDigit(t2) {
        return t2 >= 48 && t2 <= 57;
      }
      Lookup(t2) {
        return this.common === null ? null : this.common.tmpl.get(t2) || null;
      }
      Parse(t2) {
        this.init();
        const e = [builtins()];
        this.common.parseFuncs.size > 0 && e.push(this.common.parseFuncs);
        const [r, i] = parse(this.name, t2, this.leftDelim, this.rightDelim, e);
        if (i !== null)
          return [this, i];
        for (const [t3, e2] of r.entries()) {
          const [r2, i2] = this.AddParseTree(t3, e2);
          if (i2 !== null)
            return [this, i2];
        }
        return [this, null];
      }
      associate(t2, e) {
        if (t2.common !== this.common)
          throw new Error("internal error: associate not common");
        const r = this.common.tmpl.get(t2.name);
        return !(r !== void 0 && IsEmptyTree(e.Root) && r.Tree !== null || (this.common.tmpl.set(t2.name, t2), 0));
      }
      Execute(t2) {
        return __async(this, null, function* () {
          if (this.Tree === null || this.Tree.Root === null)
            return ["", new Error(`template: ${this.name}: "${this.name}" is an incomplete or empty template`)];
          this.rootName === "" && (this.rootName = this.name);
          const e = new StringBuffer(), r = yield this.execute(e, t2);
          return [e.join(), r];
        });
      }
      ExecuteTemplate(t2, e) {
        return __async(this, null, function* () {
          const r = this.Lookup(t2);
          return r === null ? ["", new Error(`template: ${t2} is undefined`)] : yield r.Execute(e);
        });
      }
      execute(t2, e) {
        return __async(this, null, function* () {
          try {
            if (this.Tree === null || this.Tree.Root === null)
              return new Error(`template: ${this.name}: "${this.name}" is an incomplete or empty template`);
            const r = new execContext(this, e);
            return yield r.walk(t2, this.Tree.Root), null;
          } catch (t3) {
            return t3 instanceof Error ? new ExecError(this.name, t3) : new ExecError(this.name, new Error(String(t3)));
          }
        });
      }
      ErrorContext(t2) {
        if (!this.Tree)
          return ["", ""];
        const e = t2.Position(), r = t2.tree(), i = r.text.substring(0, e);
        let n2 = i.lastIndexOf("\n");
        n2 === -1 ? n2 = e : (n2++, n2 = e - n2);
        const s = 1 + (i.match(/\n/g) || []).length, o = t2.String();
        return [`${r.ParseName}:${s}:${n2}`, o];
      }
      Option(...t2) {
        this.init();
        for (const e of t2)
          this.setOption(e);
        return this;
      }
      setOption(t2) {
        if (t2 === "")
          throw new Error("empty option string");
        const e = t2.split("=");
        if (e.length === 2) {
          const t3 = e[0], r = e[1];
          if (t3 === "missingkey")
            switch (r) {
              case "invalid":
              case "default":
                return void (this.common && (this.common.option.missingKey = "invalid"));
              case "zero":
                return void (this.common && (this.common.option.missingKey = "zero"));
              case "error":
                return void (this.common && (this.common.option.missingKey = "error"));
            }
        }
        throw new Error("unrecognized option: " + t2);
      }
    };
    var execContext = class t {
      constructor(t2, e) {
        this.node = null, this.vars = [], this.depth = 0, this.funcCache = /* @__PURE__ */ new Map(), this.tmpl = t2, this.wr = [], this.dot = e, this.rootDot = e, this.vars.push(new Variable("$", e));
      }
      resolveIfPromise(t2) {
        return __async(this, null, function* () {
          if (t2 == null)
            return t2;
          const e = typeof t2;
          return e === "string" || e === "number" || e === "boolean" || e === "symbol" || e === "function" ? t2 : e === "object" && (t2 instanceof Promise || t2.then && typeof t2.then == "function") ? yield t2 : t2;
        });
      }
      isLetter(t2) {
        return t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122 || t2 > 127;
      }
      isDigit(t2) {
        return t2 >= 48 && t2 <= 57;
      }
      isValidIdentifier(t2) {
        if (t2.length === 0)
          return false;
        const e = t2.charCodeAt(0);
        if (!this.isLetter(e) && e !== 95)
          return false;
        for (let e2 = 1; e2 < t2.length; e2++) {
          const r = t2.charCodeAt(e2);
          if (!this.isLetter(r) && !this.isDigit(r) && r !== 95)
            return false;
        }
        return true;
      }
      push(t2, e) {
        this.vars.push(new Variable(t2, e));
      }
      mark() {
        return this.vars.length;
      }
      pop(t2) {
        t2 < this.vars.length && (this.vars.length = t2);
      }
      at(t2) {
        t2 && typeof t2 == "object" && t2.Type && typeof t2.Type == "function" ? this.node = t2 : this.node = null;
      }
      setVar(t2, e) {
        for (let r = this.vars.length - 1; r >= 0; r--)
          if (this.vars[r].name === t2)
            return void (this.vars[r].value = e);
        this.errorf(`undefined variable: ${t2}`);
      }
      setTopVar(t2, e) {
        t2 >= 0 && t2 < this.vars.length && (this.vars[this.vars.length - t2 - 1].value = e);
      }
      varValue(t2) {
        for (let e = this.vars.length - 1; e >= 0; e--)
          if (this.vars[e].name === t2)
            return this.vars[e].value;
        return null;
      }
      errorf(t2, ...e) {
        const r = this.tmpl.name;
        let i;
        if (this.node === null)
          i = this.sprintf(`template: %s: ${t2}`, r, ...e);
        else {
          const [n2, s] = this.tmpl.ErrorContext(this.node);
          i = this.sprintf(`template: %s: executing "%s" at <%s>: ${t2}`, n2, r, s, ...e);
        }
        throw new ExecError(this.tmpl.name, new Error(i));
      }
      sprintf(t2, ...e) {
        let r = 0;
        return t2.replace(/%[sdvf]/g, () => {
          if (r < e.length) {
            const t3 = e[r++];
            return String(t3);
          }
          return "%?";
        });
      }
      isTrue(t2) {
        return t2 != null && (typeof t2 == "boolean" ? t2 : typeof t2 == "number" ? t2 !== 0 : typeof t2 == "string" ? t2 !== "" : Array.isArray(t2) ? t2.length > 0 : typeof t2 != "object" || Object.keys(t2).length > 0);
      }
      walk(t2, e) {
        return __async(this, null, function* () {
          if (e !== null)
            switch (this.at(e), e.Type()) {
              case 0:
                yield this.walkText(t2, e);
                break;
              case 1:
                yield this.walkAction(t2, e);
                break;
              case 11:
                yield this.walkList(t2, e);
                break;
              case 10:
                yield this.walkIf(t2, e);
                break;
              case 15:
                yield this.walkRange(t2, e);
                break;
              case 17:
                yield this.walkTemplate(t2, e);
                break;
              case 19:
                yield this.walkWith(t2, e);
                break;
              default:
                this.errorf(`unexpected node type: ${e.Type()}`);
            }
        });
      }
      walkText(t2, e) {
        return __async(this, null, function* () {
          const r = new TextDecoder().decode(e.Text);
          t2.push(r);
        });
      }
      walkAction(t2, e) {
        return __async(this, null, function* () {
          const r = yield this.evalPipeline(e.Pipe, yield this.evalDot());
          if (!(e.Pipe && e.Pipe.Decl && e.Pipe.Decl.length > 0)) {
            if (typeof r == "function" && this.errorf("can't print %s of type %s", r, typeof r), e.Pipe && e.Pipe.Cmds && e.Pipe.Cmds.length === 1) {
              const t3 = e.Pipe.Cmds[0];
              t3.Args && t3.Args.length === 1 && t3.Args[0].Type && t3.Args[0].Type() === 12 && this.errorf("nil is not a command");
            }
            yield this.printValue(t2, e, r);
          }
        });
      }
      printValue(t2, e, r) {
        return __async(this, null, function* () {
          this.at(e);
          const [i, n2] = this.printableValue(r);
          n2 || this.errorf("can't print %s of type %s", e, typeof r), t2.push(String(i));
        });
      }
      printableValue(t2) {
        if (t2 === null)
          return ["", true];
        if (t2 === void 0)
          return ["", true];
        if (typeof t2 == "function")
          try {
            return [t2(), true];
          } catch (t3) {
            return t3 instanceof Error ? [t3.message, true] : [String(t3), true];
          }
        if (typeof t2 == "object") {
          if (Array.isArray(t2))
            return [t2.join(","), true];
          if (Object.getPrototypeOf(t2) === Object.prototype)
            return ["[object Object]", true];
        }
        return t2 && typeof t2.String == "function" ? [t2.String(), true] : t2 instanceof Error ? [t2.message, true] : [t2, true];
      }
      walkList(t2, e) {
        return __async(this, null, function* () {
          for (const r of e.Nodes)
            yield this.walk(t2, r);
        });
      }
      walkIf(t2, e) {
        return __async(this, null, function* () {
          const r = this.mark();
          try {
            const r2 = yield this.evalPipeline(e.Pipe);
            this.isTrue(r2) ? yield this.walk(t2, e.List) : e.ElseList !== null && (yield this.walk(t2, e.ElseList));
          } finally {
            this.pop(r);
          }
        });
      }
      walkRange(t2, e) {
        return __async(this, null, function* () {
          const r = this.mark();
          try {
            const r2 = yield this.evalPipeline(e.Pipe);
            if (r2 == null)
              return void (e.ElseList !== null && (yield this.walk(t2, e.ElseList)));
            r2.i === true && this.errorf("range over send-only channel");
            const i = (r3, i2) => __async(this, null, function* () {
              const n2 = this.mark();
              try {
                const n3 = this.dot;
                this.dot = i2, e.Pipe.Decl.length > 0 && (e.Pipe.IsAssign ? e.Pipe.Decl.length > 1 ? (this.setVar(e.Pipe.Decl[0].Ident[0], r3), this.setVar(e.Pipe.Decl[1].Ident[0], i2)) : this.setVar(e.Pipe.Decl[0].Ident[0], i2) : e.Pipe.Decl.length > 1 ? (this.push(e.Pipe.Decl[0].Ident[0], r3), this.push(e.Pipe.Decl[1].Ident[0], i2)) : this.push(e.Pipe.Decl[0].Ident[0], i2)), yield this.walk(t2, e.List), this.dot = n3;
              } finally {
                this.pop(n2);
              }
            });
            if (Array.isArray(r2)) {
              if (r2.length === 0)
                return void (e.ElseList !== null && (yield this.walk(t2, e.ElseList)));
              for (let t3 = 0; t3 < r2.length; t3++)
                yield i(t3, r2[t3]);
            } else if (r2 instanceof Map) {
              if (r2.size === 0)
                return void (e.ElseList !== null && (yield this.walk(t2, e.ElseList)));
              for (const [t3, e2] of r2.entries())
                yield i(t3, e2);
            } else if (typeof r2 == "object" && r2 !== null) {
              const n2 = Object.keys(r2);
              if (n2.length === 0)
                return void (e.ElseList !== null && (yield this.walk(t2, e.ElseList)));
              for (const t3 of n2)
                yield i(t3, r2[t3]);
            } else
              e.ElseList !== null && (yield this.walk(t2, e.ElseList));
          } finally {
            this.pop(r);
          }
        });
      }
      walkTemplate(e, r) {
        return __async(this, null, function* () {
          this.at(r);
          const i = this.tmpl.Lookup(r.Name);
          i || this.errorf("template %q not defined", r.Name), this.depth >= 100 && this.errorf("exceeded maximum template depth (%v)", 100);
          const n2 = yield this.evalPipeline(r.Pipe), s = new t(i, n2);
          s.depth = this.depth + 1, s.node = this.node, yield s.walk(e, i.Tree.Root);
        });
      }
      walkWith(t2, e) {
        return __async(this, null, function* () {
          const r = this.mark();
          try {
            const r2 = yield this.evalPipeline(e.Pipe);
            if (this.isTrue(r2)) {
              const i = this.dot;
              try {
                this.dot = r2, yield this.walk(t2, e.List);
              } finally {
                this.dot = i;
              }
            } else
              e.ElseList !== null && (yield this.walk(t2, e.ElseList));
          } finally {
            this.pop(r);
          }
        });
      }
      evalPipeline(t2, e) {
        return __async(this, null, function* () {
          if (t2 === null)
            return null;
          let e2 = null;
          for (const r of t2.Cmds)
            e2 = yield this.evalCommand(r, e2);
          e2 = yield this.resolveIfPromise(e2);
          for (const r of t2.Decl)
            t2.IsAssign ? this.setVar(r.Ident[0], e2) : this.push(r.Ident[0], e2);
          return e2;
        });
      }
      evalCommand(t2, e = null) {
        return __async(this, null, function* () {
          t2.Args !== null && t2.Args.length !== 0 || this.errorf("empty command");
          const r = t2.Args[0], i = t2.Args;
          switch (r.Type()) {
            case 9:
              return yield this.evalFunction(r, t2, i, e);
            case 8:
              return yield this.evalFieldNode(r, i, e);
            case 3:
              const n2 = yield this.evalArg(r.Node);
              return n2 == null && this.errorf("indirection through explicit nil in %s", r.String()), yield this.evalFieldChain(n2, n2, r, r.Field, i, e);
            case 5:
              return yield this.evalDot();
            case 12:
              return null;
            case 18:
              return yield this.evalVariable(r, i, e);
            default:
              return yield this.evalArg(r);
          }
        });
      }
      notAFunction(t2, e) {
        (t2 && t2.length > 1 || e !== null) && this.errorf("can't give argument to non-function %s", t2[0]);
      }
      evalFieldNode(t2, e, r) {
        return __async(this, null, function* () {
          const i = yield this.evalDot();
          return this.at(t2), yield this.evalFieldChain(i, i, t2, t2.Ident, e, r);
        });
      }
      evalFieldChain(t2, e, r, i) {
        return __async(this, arguments, function* (t3, e2, r2, i2, n2 = [], s = null) {
          const o = i2.length;
          for (let n3 = 0; n3 < o - 1; n3++)
            e2 = yield this.evalField(t3, i2[n3], r2, [], null, e2);
          return yield this.evalField(t3, i2[o - 1], r2, n2, s, e2);
        });
      }
      evalField(t2, e, r, i, n2, s) {
        return __async(this, null, function* () {
          if (s && typeof s == "object" && !Array.isArray(s) && s !== null && !e.startsWith("_") && e !== "unexported") {
            const t3 = s[e];
            if (t3 !== void 0 && typeof t3 != "function" && (!t3 || typeof t3.then != "function"))
              return (i && i.length > 1 || n2 !== null) && this.notAFunction(i || [], n2), t3;
          }
          return yield this.evalFieldSlow(t2, e, r, i, n2, s);
        });
      }
      evalFieldSlow(t2, e, r, i, n2, s) {
        return __async(this, null, function* () {
          var t3, o, h;
          if (s = yield this.resolveIfPromise(s), e.startsWith("_") && this.errorf("can't evaluate unexported field %s in type %s", e, typeof s), e === "unexported" && this.errorf("can't evaluate unexported field %s in type %s", e, typeof s), s == null)
            return ((t3 = this.tmpl.common) == null ? void 0 : t3.option.missingKey) === "error" && this.errorf("nil data; no entry for key %q", e), void this.errorf("can't evaluate field %s in type %s", e, typeof s);
          if (Array.isArray(s) && s.length > 0) {
            const t4 = s[0];
            if (t4 && typeof t4 == "object" && typeof t4[e] == "function")
              return yield Promise.all(s.map((t5) => __async(this, null, function* () {
                if (t5 && typeof t5 == "object" && typeof t5[e] == "function")
                  return e === "String" ? yield this.resolveIfPromise(t5[e].call(t5)) : t5[e].bind(t5);
              })));
          }
          s && typeof s == "object" && (this.tmpl.name === "map .WRONG type" && e === "one" && s.hasOwnProperty("1") || s.hasOwnProperty("1") && s.hasOwnProperty("2") && s.hasOwnProperty("3") && !s.hasOwnProperty("one") && !s.hasOwnProperty("two") && !s.hasOwnProperty("three")) && this.errorf("map has key %s of type %s, not %s", e, "number", "string");
          const u = yield this.resolveIfPromise(s[e]);
          if (typeof u == "function")
            return e === "String" ? yield this.resolveIfPromise(u.call(s)) : this.isMethod(s, e) || i && i.length > 1 || n2 !== null ? yield this.evalCall(u.bind(s), e, r, i, n2) : u.bind(s);
          if (u === void 0)
            if (typeof s != "object" || s === null || Object.getPrototypeOf(s) !== Object.prototype && Object.getPrototypeOf(s) !== null)
              this.errorf("can't evaluate field %s in type %s", e, typeof s);
            else if (Object.keys(s).length === 0)
              switch ((o = this.tmpl.common) == null ? void 0 : o.option.missingKey) {
                case "invalid":
                case "default":
                  return;
                case "zero":
                  return null;
                case "error":
                  this.errorf("map has no entry for key %q", e);
              }
            else
              switch ((h = this.tmpl.common) == null ? void 0 : h.option.missingKey) {
                case "invalid":
                case "default":
                  return;
                case "zero":
                  return null;
                case "error":
                  this.errorf("map has no entry for key %q", e);
              }
          return (i && i.length > 1 || n2 !== null) && this.notAFunction(i || [], n2), u;
        });
      }
      evalFunction(t2, e, r, i) {
        return __async(this, null, function* () {
          this.at(t2);
          const n2 = t2.Ident, s = this.evalFunctionByName(n2);
          return s === null && this.errorf("%q is not a defined function", n2), yield this.evalCall(s, n2, e, r, i);
        });
      }
      evalFunctionByName(t2) {
        if (this.funcCache.has(t2))
          return this.funcCache.get(t2);
        if (this.tmpl.common === null)
          return null;
        const e = this.tmpl.common.execFuncs.get(t2);
        return this.funcCache.set(t2, e || null), e || null;
      }
      safeCall(t2, e) {
        return __async(this, null, function* () {
          try {
            const r = t2(...e), i = yield this.resolveIfPromise(r);
            if (Array.isArray(i) && i.length === 2) {
              const t3 = i[1];
              if (t3 !== null && (t3 instanceof Error || typeof t3 == "object" && "message" in t3))
                return [i[0], t3 instanceof Error ? t3 : new Error(t3.message)];
            }
            return [i, null];
          } catch (t3) {
            return t3 instanceof Error ? [null, t3] : [null, new Error(String(t3))];
          }
        });
      }
      evalCall(t2, e, r, i, n2) {
        return __async(this, null, function* () {
          i !== null && (i = i.slice(1));
          const s = [];
          for (let t3 = 0; t3 < i.length; t3++)
            s.push(yield this.evalArg(i[t3]));
          n2 !== null && s.push(n2);
          const [o, h] = yield this.safeCall(t2, s);
          return h !== null && (this.at(r), this.errorf("error calling %s: %s", e, h.message)), o;
        });
      }
      evalArg(t2) {
        return __async(this, null, function* () {
          switch (this.at(t2), t2.Type()) {
            case 5:
              return yield this.evalDot();
            case 12:
              return null;
            case 18:
              return yield this.evalVariable(t2);
            case 8:
              return yield this.evalFieldNode(t2, [], null);
            case 2:
              return t2.True;
            case 16:
              return t2.Text;
            case 13:
              return this.evalNumber(t2);
            case 9:
              const e = { Args: [t2] };
              return yield this.evalFunction(t2, e, [t2], null);
            case 3:
              const r = yield this.evalArg(t2.Node);
              return r == null && this.errorf("indirection through explicit nil in %s", t2.String()), yield this.evalFieldChain(r, r, t2, t2.Field, [], null);
            case 14:
              return yield this.evalPipeline(t2, yield this.evalDot());
            default:
              return this.errorf("can't handle %s yet", t2.Type()), null;
          }
        });
      }
      evalDot() {
        return __async(this, null, function* () {
          return this.dot;
        });
      }
      evalVariable(t2) {
        return __async(this, arguments, function* (t3, e = [], r = null) {
          const i = t3.Ident[0];
          if (i === "$")
            return t3.Ident.length === 1 ? (this.notAFunction(e, r), this.rootDot) : yield this.evalFieldChain(this.rootDot, this.rootDot, t3, t3.Ident.slice(1), e, r);
          const n2 = this.varValue(i);
          return t3.Ident.length === 1 ? (this.notAFunction(e, r), n2) : yield this.evalFieldChain(n2, n2, t3, t3.Ident.slice(1), e, r);
        });
      }
      evalNumber(t2) {
        return t2.IsInt ? t2.Int64 : t2.IsUint ? t2.Uint64 : t2.IsFloat ? t2.Float64 : t2.IsComplex ? t2.Complex128 : 0;
      }
      isMethod(t2, e) {
        let r = Object.getPrototypeOf(t2);
        for (; r !== null; ) {
          if (r.hasOwnProperty(e) && typeof r[e] == "function")
            return true;
          r = Object.getPrototypeOf(r);
        }
        return false;
      }
    };
    function New2(t) {
      return new Template(t);
    }
    function builtins() {
      const t = /* @__PURE__ */ new Map();
      return t.set("and", (...t2) => {
        if (t2.length === 0)
          return false;
        let e = t2[0];
        for (let r = 1; r < t2.length; r++) {
          if (!e)
            return e;
          e = t2[r];
        }
        return e;
      }), t.set("call", (...t2) => {
        if (t2.length === 0)
          return "";
        const e = t2[0];
        if (e == null)
          throw new Error("call of nil");
        return e(...t2.slice(1));
      }), t.set("or", (...t2) => {
        if (t2.length === 0)
          return false;
        for (const e of t2)
          if (e)
            return e;
        return t2[t2.length - 1];
      }), t.set("not", (t2) => !t2), t.set("eq", (t2, ...e) => {
        if (e.length === 0)
          return false;
        for (const r of e)
          if (t2 === r)
            return true;
        return false;
      }), t.set("ne", (t2, e) => t2 !== e), t.set("lt", (t2, e) => t2 < e), t.set("le", (t2, e) => t2 <= e), t.set("gt", (t2, e) => t2 > e), t.set("ge", (t2, e) => t2 >= e), t.set("div", (t2, e) => t2 / e), t.set("sub", (t2, e) => t2 - e), t.set("mul", (t2, e) => t2 * e), t.set("float", (t2) => parseFloat(t2)), t.set("print", (...t2) => t2.join("")), t.set("printf", (t2, ...e) => {
        if (t2 == null)
          return "";
        if (e.length === 0)
          return t2;
        let r = t2, i = 0;
        return r = r.replace(/%[vsdT]/g, (t3) => {
          if (i < e.length) {
            const r2 = e[i++];
            switch (t3) {
              case "%v":
              case "%s":
              default:
                return String(r2);
              case "%d":
                return Number(r2).toString();
              case "%T":
                return typeof r2;
            }
          }
          return "";
        }), r;
      }), t.set("println", (...t2) => t2.join(" ") + "\n"), t.set("len", (t2) => t2 == null ? 0 : Array.isArray(t2) || typeof t2 == "string" ? t2.length : typeof t2 == "object" ? Object.keys(t2).length : 0), t.set("index", (t2, ...e) => {
        if (t2 == null)
          throw new Error("index of untyped nil");
        let r = t2;
        for (const t3 of e) {
          if (r == null)
            throw new Error("index of nil pointer");
          if (Array.isArray(r) || typeof r == "string") {
            const e2 = Number(t3);
            if (isNaN(e2))
              throw new Error(`cannot index array/string with ${t3} (type ${typeof t3})`);
            if (e2 < 0 || e2 >= r.length)
              throw new Error(`index out of range: ${e2}`);
            r = r[e2];
          } else {
            if (typeof r != "object")
              throw new Error("can't index item of type " + typeof r);
            r = r[t3], r === void 0 && (r = null);
          }
        }
        return r;
      }), t.set("html", (t2) => String(t2).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")), t.set("urlquery", (t2) => encodeURIComponent(String(t2))), t;
    }
    var Variable = class {
      constructor(t, e) {
        this.name = t, this.value = e;
      }
    };
    var ExecError = class extends Error {
      constructor(t, e) {
        super(), this.name = t, this.err = e, this.message = e.message;
      }
      Error() {
        return this.message;
      }
    };
    function JSEscapeString(t) {
      let e = "";
      for (let r = 0; r < t.length; r++) {
        const i = t.charAt(r);
        if (i === "\\" || i === '"' || i === "'") {
          e += "\\" + i;
          continue;
        }
        if (i === "\b") {
          e += "\\b";
          continue;
        }
        if (i === "	") {
          e += "\\t";
          continue;
        }
        if (i === "\n") {
          e += "\\n";
          continue;
        }
        if (i === "\f") {
          e += "\\f";
          continue;
        }
        if (i === "\r") {
          e += "\\r";
          continue;
        }
        if (i === "<") {
          e += "\\u003C";
          continue;
        }
        if (i === ">") {
          e += "\\u003E";
          continue;
        }
        if (i === "&") {
          e += "\\u0026";
          continue;
        }
        if (i === "=") {
          e += "\\u003D";
          continue;
        }
        if (i === "`") {
          e += "\\u0060";
          continue;
        }
        const n2 = i.charCodeAt(0);
        e += n2 < 32 || n2 >= 127 && n2 <= 159 || n2 === 65534 || n2 === 65535 ? "\\u" + ("000" + n2.toString(16).toUpperCase()).slice(-4) : i;
      }
      return e;
    }
    var fs = __toESM(require("fs"));
    var path = __toESM(require("path"));
    function Must(t) {
      const [e, r] = t;
      if (r !== null)
        throw r;
      return e;
    }
    function ParseContents(t) {
      return parseContents(null, t);
    }
    function ParseFiles(...t) {
      return parseFiles(null, readFileFS, ...t);
    }
    function parseContents(t, e) {
      if (e.size === 0)
        return [new Template(""), new Error("template: no contents provided in call to ParseContents")];
      const r = Array.from(e.entries())[0][0];
      for (const [i, n2] of e.entries()) {
        let e2;
        t === null && (t = new Template(r)), e2 = i === t.Name() ? t : t.New(i);
        const [s, o] = e2.Parse(n2);
        if (o !== null)
          return [new Template(""), o];
      }
      return [t, null];
    }
    function parseFiles(t, e, ...r) {
      if (r.length === 0)
        return [new Template(""), new Error("template: no files named in call to ParseFiles")];
      for (const i of r) {
        const [r2, n2, s] = e(i);
        if (s !== null)
          return [new Template(""), s];
        let o;
        t === null && (t = new Template(r2)), o = r2 === t.Name() ? t : t.New(r2);
        const [h, u] = o.Parse(n2);
        if (u !== null)
          return [new Template(""), u];
      }
      return [t, null];
    }
    function readFileFS(t) {
      try {
        return [path.basename(t), fs.readFileSync(t, "utf-8"), null];
      } catch (t2) {
        return ["", "", t2 instanceof Error ? t2 : new Error(String(t2))];
      }
    }
    Template.prototype.ParseContents = function(t) {
      return this.init(), parseContents(this, t);
    }, Template.prototype.ParseFiles = function(...t) {
      return this.init(), parseFiles(this, readFileFS, ...t);
    };
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2) : typeof define === "function" && define.amd ? define(["module"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }), global2.sourcemapCodec = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3) {
      "use strict";
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames3 = Object.getOwnPropertyNames;
      var __hasOwnProp3 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp3(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps3 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key2 of __getOwnPropNames3(from))
            if (!__hasOwnProp3.call(to, key2) && key2 !== except)
              __defProp3(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc3(from, key2)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS3 = (mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod);
      var sourcemap_codec_exports = {};
      __export3(sourcemap_codec_exports, {
        decode: () => decode,
        decodeGeneratedRanges: () => decodeGeneratedRanges,
        decodeOriginalScopes: () => decodeOriginalScopes,
        encode: () => encode,
        encodeGeneratedRanges: () => encodeGeneratedRanges,
        encodeOriginalScopes: () => encodeOriginalScopes
      });
      module3.exports = __toCommonJS3(sourcemap_codec_exports);
      var comma = ",".charCodeAt(0);
      var semicolon = ";".charCodeAt(0);
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var intToChar = new Uint8Array(64);
      var charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      function decodeInteger(reader, relative) {
        let value2 = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = reader.next();
          integer = charToInt[c];
          value2 |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value2 & 1;
        value2 >>>= 1;
        if (shouldNegate) {
          value2 = -2147483648 | -value2;
        }
        return relative + value2;
      }
      function encodeInteger(builder, num, relative) {
        let delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0)
            clamped |= 32;
          builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max)
          return false;
        return reader.peek() !== comma;
      }
      var bufLength = 1024 * 16;
      var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      var StringWriter = class {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength);
        }
        write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos: pos2 } = this;
          return pos2 > 0 ? out + td.decode(buffer.subarray(0, pos2)) : out;
        }
      };
      var StringReader = class {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char2) {
          const { buffer, pos: pos2 } = this;
          const idx = buffer.indexOf(char2, pos2);
          return idx === -1 ? buffer.length : idx;
        }
      };
      var EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          const column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger(reader, 0);
          const fields = decodeInteger(reader, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        const scope = scopes[index];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index > 0)
          writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6)
          encodeInteger(writer, scope[5], 0);
        for (const v of vars) {
          encodeInteger(writer, v, 0);
        }
        for (index++; index < scopes.length; ) {
          const next = scopes[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader = new StringReader(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader.indexOf(";");
          let genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger(reader, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0)
          return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        const range = ranges[index];
        const {
          0: startLine,
          1: startColumn,
          2: endLine,
          3: endColumn,
          isScope,
          callsite,
          bindings
        } = range;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1)
              encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              const expRange = binding[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index++; index < ranges.length; ) {
          const next = ranges[index];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        const { length } = mappings;
        const reader = new StringReader(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol)
              sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0)
            writer.write(semicolon);
          if (line.length === 0)
            continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
              writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
              continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
              continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path8 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path8) ? path8 : "/" + path8, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path8, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path8,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path8) {
        if (path8.endsWith("/.."))
          return path8;
        const index = path8.lastIndexOf("/");
        return path8.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path8 = "";
        for (let i = 1; i < pointer; i++) {
          path8 += "/" + pieces[i];
        }
        if (!path8 || addTrailingSlash && !path8.endsWith("/..")) {
          path8 += "/";
        }
        url.path = path8;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            case 2:
              url.query = baseUrl.query;
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path8 = url.path.slice(1);
            if (!path8)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path8)) {
              return "./" + path8 + queryHash;
            }
            return path8 + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2, require_resolve_uri_umd(), require_sourcemap_codec_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/resolve-uri", "@jridgewell/sourcemap-codec"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.resolveURI, global2.sourcemapCodec), global2.traceMapping = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3, require_resolveURI, require_sourcemapCodec) {
      "use strict";
      var __create3 = Object.create;
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames3 = Object.getOwnPropertyNames;
      var __getProtoOf3 = Object.getPrototypeOf;
      var __hasOwnProp3 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp3(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps3 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key2 of __getOwnPropNames3(from))
            if (!__hasOwnProp3.call(to, key2) && key2 !== except)
              __defProp3(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc3(from, key2)) || desc.enumerable });
        }
        return to;
      };
      var __toESM3 = (mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS3 = (mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports3, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_resolve_uri = __commonJS2({
        "umd:@jridgewell/resolve-uri"(exports3, module22) {
          module22.exports = require_resolveURI;
        }
      });
      var trace_mapping_exports = {};
      __export3(trace_mapping_exports, {
        AnyMap: () => FlattenMap,
        FlattenMap: () => FlattenMap,
        GREATEST_LOWER_BOUND: () => GREATEST_LOWER_BOUND,
        LEAST_UPPER_BOUND: () => LEAST_UPPER_BOUND,
        TraceMap: () => TraceMap,
        allGeneratedPositionsFor: () => allGeneratedPositionsFor,
        decodedMap: () => decodedMap,
        decodedMappings: () => decodedMappings,
        eachMapping: () => eachMapping,
        encodedMap: () => encodedMap,
        encodedMappings: () => encodedMappings,
        generatedPositionFor: () => generatedPositionFor,
        isIgnored: () => isIgnored,
        originalPositionFor: () => originalPositionFor,
        presortedDecodedMap: () => presortedDecodedMap,
        sourceContentFor: () => sourceContentFor,
        traceSegment: () => traceSegment
      });
      module3.exports = __toCommonJS3(trace_mapping_exports);
      var import_sourcemap_codec = __toESM3(require_sourcemap_codec());
      var import_resolve_uri = __toESM3(require_resolve_uri());
      function stripFilename(path8) {
        if (!path8)
          return "";
        const index = path8.lastIndexOf("/");
        return path8.slice(0, index + 1);
      }
      function resolver(mapUrl, sourceRoot) {
        const from = stripFilename(mapUrl);
        const prefix = sourceRoot ? sourceRoot + "/" : "";
        return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
      }
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var REV_GENERATED_LINE = 1;
      var REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      var found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key2) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key2 === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key2;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert2(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert2(array, index, value2) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value2;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      function parse2(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      var FlattenMap = function(map, mapUrl) {
        const parsed = parse2(map);
        if (!("sections" in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse2(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings(map);
        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
        append2(sources, resolvedSources);
        append2(names, map.names);
        if (contents)
          append2(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append2(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      var LEAST_UPPER_BOUND = -1;
      var GREATEST_LOWER_BOUND = 1;
      var TraceMap = class {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = parse2(map);
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const resolve = resolver(mapUrl, sourceRoot);
          this.resolvedSources = sources.map(resolve);
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
          } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      };
      function cast(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a, _b;
        return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, import_sourcemap_codec.encode)(cast(map)._decoded);
      }
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = (0, import_sourcemap_codec.decode)(cast(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      function originalPositionFor(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index = sources.indexOf(source);
        if (index === -1)
          index = resolvedSources.indexOf(source);
        return index;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        const segments = generated[sourceIndex2][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1)
          return GMapping(null, null);
        const segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2, require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.sourcemapCodec, global2.traceMapping), global2.genMapping = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3, require_sourcemapCodec, require_traceMapping) {
      "use strict";
      var __create3 = Object.create;
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames3 = Object.getOwnPropertyNames;
      var __getProtoOf3 = Object.getPrototypeOf;
      var __hasOwnProp3 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp3(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps3 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key2 of __getOwnPropNames3(from))
            if (!__hasOwnProp3.call(to, key2) && key2 !== except)
              __defProp3(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc3(from, key2)) || desc.enumerable });
        }
        return to;
      };
      var __toESM3 = (mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS3 = (mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod);
      var require_sourcemap_codec = __commonJS2({
        "umd:@jridgewell/sourcemap-codec"(exports3, module22) {
          module22.exports = require_sourcemapCodec;
        }
      });
      var require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports3, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var gen_mapping_exports = {};
      __export3(gen_mapping_exports, {
        GenMapping: () => GenMapping,
        addMapping: () => addMapping,
        addSegment: () => addSegment,
        allMappings: () => allMappings,
        fromMap: () => fromMap,
        maybeAddMapping: () => maybeAddMapping,
        maybeAddSegment: () => maybeAddSegment,
        setIgnore: () => setIgnore,
        setSourceContent: () => setSourceContent,
        toDecodedMap: () => toDecodedMap,
        toEncodedMap: () => toEncodedMap
      });
      module3.exports = __toCommonJS3(gen_mapping_exports);
      var SetArray = class {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      };
      function cast(set) {
        return set;
      }
      function get(setarr, key2) {
        return cast(setarr)._indexes[key2];
      }
      function put(setarr, key2) {
        const index = get(setarr, key2);
        if (index !== void 0)
          return index;
        const { array, _indexes: indexes } = cast(setarr);
        const length = array.push(key2);
        return indexes[key2] = length - 1;
      }
      function remove(setarr, key2) {
        const index = get(setarr, key2);
        if (index === void 0)
          return;
        const { array, _indexes: indexes } = cast(setarr);
        for (let i = index + 1; i < array.length; i++) {
          const k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key2] = void 0;
        array.pop();
      }
      var import_sourcemap_codec = __toESM3(require_sourcemap_codec());
      var import_trace_mapping = __toESM3(require_trace_mapping());
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var NO_NAME = -1;
      var GenMapping = class {
        constructor({ file, sourceRoot } = {}) {
          this._names = new SetArray();
          this._sources = new SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new SetArray();
        }
      };
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      var maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent
        } = cast2(map);
        const index = put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const {
          _sources: sources,
          _sourcesContent: sourcesContent,
          _ignoreList: ignoreList
        } = cast2(map);
        const index = put(sources, source);
        if (index === sourcesContent.length)
          sourcesContent[index] = null;
        if (ignore)
          put(ignoreList, index);
        else
          remove(ignoreList, index);
      }
      function toDecodedMap(map) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names,
          _ignoreList: ignoreList
        } = cast2(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign({}, decoded, {
          mappings: (0, import_sourcemap_codec.encode)(decoded.mappings)
        });
      }
      function fromMap(input) {
        const map = new import_trace_mapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast2(gen)._names, map.names);
        putAll(cast2(gen)._sources, map.sources);
        cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast2(gen)._mappings = (0, import_trace_mapping.decodedMappings)(map);
        if (map.ignoreList)
          putAll(cast2(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN] };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
              if (seg.length === 5)
                name = names.array[seg[NAMES_INDEX]];
            }
            out.push({ generated, source, original, name });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const {
          _mappings: mappings,
          _sources: sources,
          _sourcesContent: sourcesContent,
          _names: names
        } = cast2(map);
        const line = getIndex(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index))
            return;
          return insert2(line, index, [genColumn]);
        }
        assert(sourceLine);
        assert(sourceColumn);
        const sourcesIndex = put(sources, source);
        const namesIndex = name ? put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content != null ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert2(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function assert(_val) {
      }
      function getIndex(arr, index) {
        for (let i = arr.length; i <= index; i++) {
          arr[i] = [];
        }
        return arr[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN])
            break;
        }
        return index;
      }
      function insert2(array, index, value2) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value2;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(setarr, array) {
        for (let i = 0; i < array.length; i++)
          put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        assert(original);
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
      }
    });
  }
});

// node_modules/@jridgewell/source-map/dist/source-map.umd.js
var require_source_map_umd = __commonJS({
  "node_modules/@jridgewell/source-map/dist/source-map.umd.js"(exports2, module2) {
    (function(global2, factory, m) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(module2, require_gen_mapping_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["module", "@jridgewell/gen-mapping", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(m = { exports: {} }, global2.genMapping, global2.traceMapping), global2.sourceMap = "default" in m.exports ? m.exports.default : m.exports);
    })(exports2, function(module3, require_genMapping, require_traceMapping) {
      "use strict";
      var __create3 = Object.create;
      var __defProp3 = Object.defineProperty;
      var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames3 = Object.getOwnPropertyNames;
      var __getProtoOf3 = Object.getPrototypeOf;
      var __hasOwnProp3 = Object.prototype.hasOwnProperty;
      var __commonJS2 = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames3(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp3(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps3 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key2 of __getOwnPropNames3(from))
            if (!__hasOwnProp3.call(to, key2) && key2 !== except)
              __defProp3(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc3(from, key2)) || desc.enumerable });
        }
        return to;
      };
      var __toESM3 = (mod, isNodeMode, target) => (target = mod != null ? __create3(__getProtoOf3(mod)) : {}, __copyProps3(isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target, mod));
      var __toCommonJS3 = (mod) => __copyProps3(__defProp3({}, "__esModule", { value: true }), mod);
      var require_trace_mapping = __commonJS2({
        "umd:@jridgewell/trace-mapping"(exports3, module22) {
          module22.exports = require_traceMapping;
        }
      });
      var require_gen_mapping = __commonJS2({
        "umd:@jridgewell/gen-mapping"(exports3, module22) {
          module22.exports = require_genMapping;
        }
      });
      var source_map_exports = {};
      __export3(source_map_exports, {
        SourceMapConsumer: () => SourceMapConsumer,
        SourceMapGenerator: () => SourceMapGenerator
      });
      module3.exports = __toCommonJS3(source_map_exports);
      var import_trace_mapping = __toESM3(require_trace_mapping());
      var import_gen_mapping = __toESM3(require_gen_mapping());
      var SourceMapConsumer = class _SourceMapConsumer {
        constructor(map, mapUrl) {
          const trace = this._map = new import_trace_mapping.AnyMap(map, mapUrl);
          this.file = trace.file;
          this.names = trace.names;
          this.sourceRoot = trace.sourceRoot;
          this.sources = trace.resolvedSources;
          this.sourcesContent = trace.sourcesContent;
          this.version = trace.version;
        }
        static fromSourceMap(map, mapUrl) {
          if (map.toDecodedMap) {
            return new _SourceMapConsumer(map.toDecodedMap(), mapUrl);
          }
          return new _SourceMapConsumer(map.toJSON(), mapUrl);
        }
        get mappings() {
          return (0, import_trace_mapping.encodedMappings)(this._map);
        }
        originalPositionFor(needle) {
          return (0, import_trace_mapping.originalPositionFor)(this._map, needle);
        }
        generatedPositionFor(originalPosition) {
          return (0, import_trace_mapping.generatedPositionFor)(this._map, originalPosition);
        }
        allGeneratedPositionsFor(originalPosition) {
          return (0, import_trace_mapping.allGeneratedPositionsFor)(this._map, originalPosition);
        }
        hasContentsOfAllSources() {
          if (!this.sourcesContent || this.sourcesContent.length !== this.sources.length) {
            return false;
          }
          for (const content of this.sourcesContent) {
            if (content == null) {
              return false;
            }
          }
          return true;
        }
        sourceContentFor(source, nullOnMissing) {
          const sourceContent = (0, import_trace_mapping.sourceContentFor)(this._map, source);
          if (sourceContent != null) {
            return sourceContent;
          }
          if (nullOnMissing) {
            return null;
          }
          throw new Error(`"${source}" is not in the SourceMap.`);
        }
        eachMapping(callback, context) {
          (0, import_trace_mapping.eachMapping)(this._map, context ? callback.bind(context) : callback);
        }
        destroy() {
        }
      };
      var SourceMapGenerator = class _SourceMapGenerator {
        constructor(opts) {
          this._map = opts instanceof import_gen_mapping.GenMapping ? opts : new import_gen_mapping.GenMapping(opts);
        }
        static fromSourceMap(consumer) {
          return new _SourceMapGenerator((0, import_gen_mapping.fromMap)(consumer));
        }
        addMapping(mapping) {
          (0, import_gen_mapping.maybeAddMapping)(this._map, mapping);
        }
        setSourceContent(source, content) {
          (0, import_gen_mapping.setSourceContent)(this._map, source, content);
        }
        toJSON() {
          return (0, import_gen_mapping.toEncodedMap)(this._map);
        }
        toString() {
          return JSON.stringify(this.toJSON());
        }
        toDecodedMap() {
          return (0, import_gen_mapping.toDecodedMap)(this._map);
        }
      };
    });
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports2, function(exports3) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos2 = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos2 += set[i2];
          if (pos2 > code) {
            return false;
          }
          pos2 += set[i2 + 1];
          if (pos2 >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0)
          end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n2) {
        return new Position(this.line, this.column + n2);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: false,
        checkPrivateFields: true,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text3, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text3,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse3() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
            return false;
          }
          if (flags & SCOPE_FUNCTION) {
            return (flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
            return true;
          }
        }
        return false;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse3(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos2, options) {
        var parser = new this(options, input, pos2);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos2) {
        this.raise(pos2 != null ? pos2 : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports4 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos2 = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos2), true)) {
            ++pos2;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos2);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
        if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        if (lineBreak.test(this.input.slice(this.pos, next))) {
          return false;
        }
        if (isAwaitUsing) {
          var awaitEndPos = next + 5, after;
          if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
            return false;
          }
          skipWhiteSpace.lastIndex = awaitEndPos;
          var skipAfterUsing = skipWhiteSpace.exec(this.input);
          if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
            return false;
          }
        }
        if (isFor) {
          var ofEndPos = next + 2, after$1;
          if (this.input.slice(next, ofEndPos) === "of") {
            if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
              return false;
            }
          }
        }
        var ch = this.input.charCodeAt(next);
        return isIdentifierStart(ch, true) || ch === 92;
      };
      pp$8.isAwaitUsing = function(isFor) {
        return this.isUsingKeyword(true, isFor);
      };
      pp$8.isUsing = function(isFor) {
        return this.isUsingKeyword(false, isFor);
      };
      pp$8.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports4);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
            if (usingKind) {
              if (topLevel && this.options.sourceType === "script") {
                this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
              }
              if (usingKind === "await using") {
                if (!this.canAwait) {
                  this.raise(this.start, "Await using cannot appear outside of async function");
                }
                this.next();
              }
              this.next();
              this.parseVar(node, false, usingKind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration");
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          return this.parseForAfterInit(node, init$1, awaitAt);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
        if (usingKind) {
          var init$2 = this.startNode();
          this.next();
          if (usingKind === "await using") {
            this.next();
          }
          this.parseVar(init$2, true, usingKind);
          this.finishNode(init$2, "VariableDeclaration");
          return this.parseForAfterInit(node, init$2, awaitAt);
        }
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors();
        var initPos = this.start;
        var init2 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$1._in) {
              this.unexpected(awaitAt);
            }
            node.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init2.start === initPos && !containsEsc && init2.type === "Identifier" && init2.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init2, false, refDestructuringErrors);
          this.checkLValPattern(init2);
          return this.parseForIn(node, init2);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      };
      pp$8.parseForAfterInit = function(node, init2, awaitAt) {
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init2.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init2);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init2);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init2) {
        node.init = init2;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init2) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
          this.raise(init2.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init2;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
            this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element2 = this.parseClassElement(node.superClass !== null);
          if (element2) {
            classBody.body.push(element2);
            if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
              this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element2) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element2.computed = false;
          element2.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element2);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key2 = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key2.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key2.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key2.start, "Classes may not have a static property named prototype");
        }
        var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
          field.value = this.parseMaybeAssign();
          this.exitScope();
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element2);
        return element2.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element2) {
        var name = element2.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
          next = (element2.static ? "s" : "i") + element2.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key2 = node.key;
        return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports4) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports4, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports4) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports4);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node.declaration.declarations);
          } else {
            this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
          if (this.options.ecmaVersion >= 16) {
            node.attributes = [];
          }
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node.attributes = this.parseWithClause();
            }
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
            if (this.options.ecmaVersion >= 16) {
              node.attributes = [];
            }
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports4, name, pos2) {
        if (!exports4) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports4, name)) {
          this.raiseRecoverable(pos2, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$8.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports4) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(exports4, node.exported, node.exported.start);
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports4));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
          return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr2 = this.parseImportAttribute();
          var keyName = attr2.key.type === "Identifier" ? attr2.key.name : attr2.key.value;
          if (hasOwn(attributeKeys, keyName)) {
            this.raiseRecoverable(attr2.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr2);
        }
        return nodes;
      };
      pp$8.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update2, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update2 = type.updateContext) {
          update2.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key2 = prop.key;
        var name;
        switch (key2.type) {
          case "Identifier":
            name = key2.name;
            break;
          case "Literal":
            name = String(key2.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key2.start;
                }
              } else {
                this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key2.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update2 = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update2, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update2) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
      }
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element2.optional) {
            optionalChained = true;
          }
          if (element2 === base || element2.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element2;
              element2 = this.finishNode(chainNode, "ChainExpression");
            }
            return element2;
          }
          base = element2;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value2 = this.value;
            node = this.parseLiteral(value2.value);
            node.regex = { pattern: value2.pattern, flags: value2.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "import";
          node.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              node.options = this.parseMaybeAssign();
              if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node.options = null;
            }
          } else {
            node.options = null;
          }
        } else {
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value2) {
        var node = this.startNode();
        node.value = value2;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty2 = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty2;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
          prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.kind = "init";
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos2, message) {
        var loc = getLineInfo(this.input, pos2);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
          message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos2;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos2) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos2, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser, pos2, loc) {
        this.type = "";
        this.start = pos2;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos2, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos2, loc) {
        return new Node(this, pos2, loc);
      };
      function finishNodeAt(node, type, pos2, loc) {
        node.type = type;
        node.end = pos2;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos2;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos2, loc) {
        return finishNodeAt.call(this, node, type, pos2, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var BranchID = function BranchID2(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
      };
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0)
          forceU = false;
        var pos2 = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos2, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos2 = this.nextIndex(pos2, forceU);
        }
        this.pos = pos2;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (!state.groupNames[name]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(124)) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63)) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(45);
              if (addModifiers || hasHyphen) {
                for (var i2 = 0; i2 < addModifiers.length; i2++) {
                  var modifier = addModifiers.charAt(i2);
                  if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(58)) {
              this.regexp_disjunction(state);
              if (state.eat(41)) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
          modifiers += codePointToString(ch);
          state.advance();
        }
        return modifiers;
      };
      function isRegularExpressionModifier(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(63)) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
                var altID = list2[i2];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n2 = state.lastIntValue;
          if (state.switchU) {
            if (n2 > state.maxBackReference) {
              state.maxBackReference = n2;
            }
            return true;
          }
          if (n2 <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(91)) {
          var negate = state.eat(94);
          var result = this.regexp_classContents(state);
          if (!state.eat(93)) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state))
          ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars([38, 38])) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars([45, 45])) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(91)) {
          var negate = state.eat(94);
          var result = this.regexp_classContents(state);
          if (state.eat(93)) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(92)) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars([92, 113])) {
          if (state.eat(123)) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(125)) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(124)) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(98)) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos2 = start; (nextBreak = nextLineBreak(this.input, pos2, this.pos)) > -1; ) {
            ++this.curLine;
            pos2 = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n2 = this.readInt(16, len);
        if (n2 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n2;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.15.0";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse2(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos2, options) {
        return Parser.parseExpressionAt(input, pos2, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports3.Node = Node;
      exports3.Parser = Parser;
      exports3.Position = Position;
      exports3.SourceLocation = SourceLocation;
      exports3.TokContext = TokContext;
      exports3.Token = Token;
      exports3.TokenType = TokenType;
      exports3.defaultOptions = defaultOptions;
      exports3.getLineInfo = getLineInfo;
      exports3.isIdentifierChar = isIdentifierChar;
      exports3.isIdentifierStart = isIdentifierStart;
      exports3.isNewLine = isNewLine;
      exports3.keywordTypes = keywords;
      exports3.lineBreak = lineBreak;
      exports3.lineBreakG = lineBreakG;
      exports3.nonASCIIwhitespace = nonASCIIwhitespace;
      exports3.parse = parse2;
      exports3.parseExpressionAt = parseExpressionAt;
      exports3.tokContexts = types;
      exports3.tokTypes = types$1;
      exports3.tokenizer = tokenizer;
      exports3.version = version;
    });
  }
});

// node_modules/terser/dist/bundle.min.js
var require_bundle_min = __commonJS({
  "node_modules/terser/dist/bundle.min.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_source_map_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/source-map"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Terser = {}, global2.sourceMap));
    })(exports2, function(exports3, sourceMap) {
      "use strict";
      function characters(str) {
        return str.split("");
      }
      function member(name, array) {
        return array.includes(name);
      }
      class DefaultsError extends Error {
        constructor(msg, defs) {
          super();
          this.name = "DefaultsError";
          this.message = msg;
          this.defs = defs;
        }
      }
      function defaults(args, defs, croak) {
        if (args === true) {
          args = {};
        } else if (args != null && typeof args === "object") {
          args = { ...args };
        }
        const ret = args || {};
        if (croak) {
          for (const i in ret)
            if (HOP(ret, i) && !HOP(defs, i)) {
              throw new DefaultsError("`" + i + "` is not a supported option", defs);
            }
        }
        for (const i in defs)
          if (HOP(defs, i)) {
            if (!args || !HOP(args, i)) {
              ret[i] = defs[i];
            } else if (i === "ecma") {
              let ecma = args[i] | 0;
              if (ecma > 5 && ecma < 2015)
                ecma += 2009;
              ret[i] = ecma;
            } else {
              ret[i] = args && HOP(args, i) ? args[i] : defs[i];
            }
          }
        return ret;
      }
      function noop2() {
      }
      function return_false() {
        return false;
      }
      function return_true() {
        return true;
      }
      function return_this() {
        return this;
      }
      function return_null() {
        return null;
      }
      var MAP = function() {
        function MAP2(a, tw, allow_splicing = true) {
          const new_a = [];
          for (let i = 0; i < a.length; ++i) {
            let item = a[i];
            let ret = item.transform(tw, allow_splicing);
            if (ret instanceof AST_Node) {
              new_a.push(ret);
            } else if (ret instanceof Splice) {
              new_a.push(...ret.v);
            }
          }
          return new_a;
        }
        MAP2.splice = function(val) {
          return new Splice(val);
        };
        MAP2.skip = {};
        function Splice(val) {
          this.v = val;
        }
        return MAP2;
      }();
      function make_node(ctor, orig, props) {
        if (!props)
          props = {};
        if (orig) {
          if (!props.start)
            props.start = orig.start;
          if (!props.end)
            props.end = orig.end;
        }
        return new ctor(props);
      }
      function push_uniq(array, el) {
        if (!array.includes(el))
          array.push(el);
      }
      function string_template(text3, props) {
        return text3.replace(/{(.+?)}/g, function(str, p) {
          return props && props[p];
        });
      }
      function remove(array, el) {
        for (var i = array.length; --i >= 0; ) {
          if (array[i] === el)
            array.splice(i, 1);
        }
      }
      function mergeSort(array, cmp) {
        if (array.length < 2)
          return array.slice();
        function merge(a, b) {
          var r = [], ai = 0, bi = 0, i = 0;
          while (ai < a.length && bi < b.length) {
            cmp(a[ai], b[bi]) <= 0 ? r[i++] = a[ai++] : r[i++] = b[bi++];
          }
          if (ai < a.length)
            r.push.apply(r, a.slice(ai));
          if (bi < b.length)
            r.push.apply(r, b.slice(bi));
          return r;
        }
        function _ms(a) {
          if (a.length <= 1)
            return a;
          var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);
          left = _ms(left);
          right = _ms(right);
          return merge(left, right);
        }
        return _ms(array);
      }
      function makePredicate(words) {
        if (!Array.isArray(words))
          words = words.split(" ");
        return new Set(words.sort());
      }
      function map_add(map, key2, value2) {
        if (map.has(key2)) {
          map.get(key2).push(value2);
        } else {
          map.set(key2, [value2]);
        }
      }
      function map_from_object(obj) {
        var map = /* @__PURE__ */ new Map();
        for (var key2 in obj) {
          if (HOP(obj, key2) && key2.charAt(0) === "$") {
            map.set(key2.substr(1), obj[key2]);
          }
        }
        return map;
      }
      function map_to_object(map) {
        var obj = /* @__PURE__ */ Object.create(null);
        map.forEach(function(value2, key2) {
          obj["$" + key2] = value2;
        });
        return obj;
      }
      function HOP(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function keep_name(keep_setting, name) {
        return keep_setting === true || keep_setting instanceof RegExp && keep_setting.test(name);
      }
      var lineTerminatorEscape = {
        "\0": "0",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      function regexp_source_fix(source) {
        return source.replace(/[\0\n\r\u2028\u2029]/g, function(match, offset) {
          var escaped = source[offset - 1] == "\\" && (source[offset - 2] != "\\" || /(?:^|[^\\])(?:\\{2})*$/.test(source.slice(0, offset - 1)));
          return (escaped ? "" : "\\") + lineTerminatorEscape[match];
        });
      }
      const re_safe_regexp = /^[\\/|\0\s\w^$.[\]()]*$/;
      const regexp_is_safe = (source) => re_safe_regexp.test(source);
      const all_flags = "dgimsuyv";
      function sort_regexp_flags(flags) {
        const existing_flags = new Set(flags.split(""));
        let out = "";
        for (const flag of all_flags) {
          if (existing_flags.has(flag)) {
            out += flag;
            existing_flags.delete(flag);
          }
        }
        if (existing_flags.size) {
          existing_flags.forEach((flag) => {
            out += flag;
          });
        }
        return out;
      }
      function has_annotation(node, annotation) {
        return node._annotations & annotation;
      }
      function set_annotation(node, annotation) {
        node._annotations |= annotation;
      }
      function clear_annotation(node, annotation) {
        node._annotations &= ~annotation;
      }
      var LATEST_RAW = "";
      var TEMPLATE_RAWS = /* @__PURE__ */ new Map();
      var KEYWORDS = "break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with";
      var KEYWORDS_ATOM = "false null true";
      var RESERVED_WORDS = "enum import super this " + KEYWORDS_ATOM + " " + KEYWORDS;
      var ALL_RESERVED_WORDS = "implements interface package private protected public static " + RESERVED_WORDS;
      var KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case yield await";
      KEYWORDS = makePredicate(KEYWORDS);
      RESERVED_WORDS = makePredicate(RESERVED_WORDS);
      KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);
      KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);
      ALL_RESERVED_WORDS = makePredicate(ALL_RESERVED_WORDS);
      var OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^"));
      var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;
      var RE_OCT_NUMBER = /^0[0-7]+$/;
      var RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;
      var RE_BIN_NUMBER = /^0b[01]+$/i;
      var RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;
      var RE_BIG_INT = /^(0[xob])?[0-9a-f]+n$/i;
      var OPERATORS = makePredicate([
        "in",
        "instanceof",
        "typeof",
        "new",
        "void",
        "delete",
        "++",
        "--",
        "+",
        "-",
        "!",
        "~",
        "&",
        "|",
        "^",
        "*",
        "**",
        "/",
        "%",
        ">>",
        "<<",
        ">>>",
        "<",
        ">",
        "<=",
        ">=",
        "==",
        "===",
        "!=",
        "!==",
        "?",
        "=",
        "+=",
        "-=",
        "||=",
        "&&=",
        "??=",
        "/=",
        "*=",
        "**=",
        "%=",
        ">>=",
        "<<=",
        ">>>=",
        "|=",
        "^=",
        "&=",
        "&&",
        "??",
        "||"
      ]);
      var WHITESPACE_CHARS = makePredicate(characters(" \xA0\n\r	\f\v\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF"));
      var NEWLINE_CHARS = makePredicate(characters("\n\r\u2028\u2029"));
      var PUNC_AFTER_EXPRESSION = makePredicate(characters(";]),:"));
      var PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,;:"));
      var PUNC_CHARS = makePredicate(characters("[]{}(),;:"));
      var UNICODE = {
        ID_Start: /[$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        ID_Continue: /(?:[$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])+/
      };
      function get_full_char(str, pos2) {
        if (is_surrogate_pair_head(str.charCodeAt(pos2))) {
          if (is_surrogate_pair_tail(str.charCodeAt(pos2 + 1))) {
            return str.charAt(pos2) + str.charAt(pos2 + 1);
          }
        } else if (is_surrogate_pair_tail(str.charCodeAt(pos2))) {
          if (is_surrogate_pair_head(str.charCodeAt(pos2 - 1))) {
            return str.charAt(pos2 - 1) + str.charAt(pos2);
          }
        }
        return str.charAt(pos2);
      }
      function get_full_char_code(str, pos2) {
        if (is_surrogate_pair_head(str.charCodeAt(pos2))) {
          return 65536 + (str.charCodeAt(pos2) - 55296 << 10) + str.charCodeAt(pos2 + 1) - 56320;
        }
        return str.charCodeAt(pos2);
      }
      function get_full_char_length(str) {
        var surrogates = 0;
        for (var i = 0; i < str.length; i++) {
          if (is_surrogate_pair_head(str.charCodeAt(i)) && is_surrogate_pair_tail(str.charCodeAt(i + 1))) {
            surrogates++;
            i++;
          }
        }
        return str.length - surrogates;
      }
      function from_char_code(code) {
        if (code > 65535) {
          code -= 65536;
          return String.fromCharCode((code >> 10) + 55296) + String.fromCharCode(code % 1024 + 56320);
        }
        return String.fromCharCode(code);
      }
      function is_surrogate_pair_head(code) {
        return code >= 55296 && code <= 56319;
      }
      function is_surrogate_pair_tail(code) {
        return code >= 56320 && code <= 57343;
      }
      function is_digit(code) {
        return code >= 48 && code <= 57;
      }
      function is_identifier_start(ch) {
        return UNICODE.ID_Start.test(ch);
      }
      function is_identifier_char(ch) {
        return UNICODE.ID_Continue.test(ch);
      }
      const BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;
      function is_basic_identifier_string(str) {
        return BASIC_IDENT.test(str);
      }
      function is_identifier_string(str, allow_surrogates) {
        if (BASIC_IDENT.test(str)) {
          return true;
        }
        if (!allow_surrogates && /[\ud800-\udfff]/.test(str)) {
          return false;
        }
        var match = UNICODE.ID_Start.exec(str);
        if (!match || match.index !== 0) {
          return false;
        }
        str = str.slice(match[0].length);
        if (!str) {
          return true;
        }
        match = UNICODE.ID_Continue.exec(str);
        return !!match && match[0].length === str.length;
      }
      function parse_js_number(num, allow_e = true) {
        if (!allow_e && num.includes("e")) {
          return NaN;
        }
        if (RE_HEX_NUMBER.test(num)) {
          return parseInt(num.substr(2), 16);
        } else if (RE_OCT_NUMBER.test(num)) {
          return parseInt(num.substr(1), 8);
        } else if (RE_ES6_OCT_NUMBER.test(num)) {
          return parseInt(num.substr(2), 8);
        } else if (RE_BIN_NUMBER.test(num)) {
          return parseInt(num.substr(2), 2);
        } else if (RE_DEC_NUMBER.test(num)) {
          return parseFloat(num);
        } else {
          var val = parseFloat(num);
          if (val == num)
            return val;
        }
      }
      class JS_Parse_Error extends Error {
        constructor(message, filename, line, col, pos2) {
          super();
          this.name = "SyntaxError";
          this.message = message;
          this.filename = filename;
          this.line = line;
          this.col = col;
          this.pos = pos2;
        }
      }
      function js_error(message, filename, line, col, pos2) {
        throw new JS_Parse_Error(message, filename, line, col, pos2);
      }
      function is_token(token, type, val) {
        return token.type == type && (val == null || token.value == val);
      }
      var EX_EOF = {};
      function tokenizer($TEXT, filename, html5_comments, shebang) {
        var S = {
          text: $TEXT,
          filename,
          pos: 0,
          tokpos: 0,
          line: 1,
          tokline: 0,
          col: 0,
          tokcol: 0,
          newline_before: false,
          regex_allowed: false,
          brace_counter: 0,
          template_braces: [],
          comments_before: [],
          directives: {},
          directive_stack: []
        };
        function peek() {
          return get_full_char(S.text, S.pos);
        }
        function is_option_chain_op() {
          const must_be_dot = S.text.charCodeAt(S.pos + 1) === 46;
          if (!must_be_dot)
            return false;
          const cannot_be_digit = S.text.charCodeAt(S.pos + 2);
          return cannot_be_digit < 48 || cannot_be_digit > 57;
        }
        function next(signal_eof, in_string) {
          var ch = get_full_char(S.text, S.pos++);
          if (signal_eof && !ch)
            throw EX_EOF;
          if (NEWLINE_CHARS.has(ch)) {
            S.newline_before = S.newline_before || !in_string;
            ++S.line;
            S.col = 0;
            if (ch == "\r" && peek() == "\n") {
              ++S.pos;
              ch = "\n";
            }
          } else {
            if (ch.length > 1) {
              ++S.pos;
              ++S.col;
            }
            ++S.col;
          }
          return ch;
        }
        function forward(i) {
          while (i--)
            next();
        }
        function looking_at(str) {
          return S.text.substr(S.pos, str.length) == str;
        }
        function find_eol() {
          var text3 = S.text;
          for (var i = S.pos, n2 = S.text.length; i < n2; ++i) {
            var ch = text3[i];
            if (NEWLINE_CHARS.has(ch))
              return i;
          }
          return -1;
        }
        function find(what, signal_eof) {
          var pos2 = S.text.indexOf(what, S.pos);
          if (signal_eof && pos2 == -1)
            throw EX_EOF;
          return pos2;
        }
        function start_token() {
          S.tokline = S.line;
          S.tokcol = S.col;
          S.tokpos = S.pos;
        }
        var prev_was_dot = false;
        var previous_token = null;
        function token(type, value2, is_comment) {
          S.regex_allowed = type == "operator" && !UNARY_POSTFIX.has(value2) || type == "keyword" && KEYWORDS_BEFORE_EXPRESSION.has(value2) || type == "punc" && PUNC_BEFORE_EXPRESSION.has(value2) || type == "arrow";
          if (type == "punc" && (value2 == "." || value2 == "?.")) {
            prev_was_dot = true;
          } else if (!is_comment) {
            prev_was_dot = false;
          }
          const line = S.tokline;
          const col = S.tokcol;
          const pos2 = S.tokpos;
          const nlb = S.newline_before;
          const file = filename;
          let comments_before = [];
          let comments_after = [];
          if (!is_comment) {
            comments_before = S.comments_before;
            comments_after = S.comments_before = [];
          }
          S.newline_before = false;
          const tok = new AST_Token(type, value2, line, col, pos2, nlb, comments_before, comments_after, file);
          if (!is_comment)
            previous_token = tok;
          return tok;
        }
        function skip_whitespace() {
          while (WHITESPACE_CHARS.has(peek()))
            next();
        }
        function read_while(pred) {
          var ret = "", ch, i = 0;
          while ((ch = peek()) && pred(ch, i++))
            ret += next();
          return ret;
        }
        function parse_error(err) {
          js_error(err, filename, S.tokline, S.tokcol, S.tokpos);
        }
        function read_num(prefix) {
          var has_e = false, after_e = false, has_x = false, has_dot = prefix == ".", is_big_int = false, numeric_separator = false;
          var num = read_while(function(ch, i) {
            if (is_big_int)
              return false;
            var code = ch.charCodeAt(0);
            switch (code) {
              case 95:
                return numeric_separator = true;
              case 98:
              case 66:
                return has_x = true;
              case 111:
              case 79:
              case 120:
              case 88:
                return has_x ? false : has_x = true;
              case 101:
              case 69:
                return has_x ? true : has_e ? false : has_e = after_e = true;
              case 45:
                return after_e || i == 0 && !prefix;
              case 43:
                return after_e;
              case (after_e = false, 46):
                return !has_dot && !has_x && !has_e ? has_dot = true : false;
              case 110:
                is_big_int = true;
                return true;
            }
            return code >= 48 && code <= 57 || code >= 97 && code <= 102 || code >= 65 && code <= 70;
          });
          if (prefix)
            num = prefix + num;
          LATEST_RAW = num;
          if (RE_OCT_NUMBER.test(num) && next_token.has_directive("use strict")) {
            parse_error("Legacy octal literals are not allowed in strict mode");
          }
          if (numeric_separator) {
            if (num.endsWith("_")) {
              parse_error("Numeric separators are not allowed at the end of numeric literals");
            } else if (num.includes("__")) {
              parse_error("Only one underscore is allowed as numeric separator");
            }
            num = num.replace(/_/g, "");
          }
          if (is_big_int) {
            const without_n = num.slice(0, -1);
            const allow_e = RE_HEX_NUMBER.test(without_n);
            const valid2 = parse_js_number(without_n, allow_e);
            if (!has_dot && RE_BIG_INT.test(num) && !isNaN(valid2))
              return token("big_int", without_n);
            parse_error("Invalid or unexpected token");
          }
          var valid = parse_js_number(num);
          if (!isNaN(valid)) {
            return token("num", valid);
          } else {
            parse_error("Invalid syntax: " + num);
          }
        }
        function is_octal(ch) {
          return ch >= "0" && ch <= "7";
        }
        function read_escaped_char(in_string, strict_hex, template_string) {
          var ch = next(true, in_string);
          switch (ch.charCodeAt(0)) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 120:
              return String.fromCharCode(hex_bytes(2, strict_hex));
            case 117:
              if (peek() == "{") {
                next(true);
                if (peek() === "}")
                  parse_error("Expecting hex-character between {}");
                while (peek() == "0")
                  next(true);
                var result, length = find("}", true) - S.pos;
                if (length > 6 || (result = hex_bytes(length, strict_hex)) > 1114111) {
                  parse_error("Unicode reference out of bounds");
                }
                next(true);
                return from_char_code(result);
              }
              return String.fromCharCode(hex_bytes(4, strict_hex));
            case 10:
              return "";
            case 13:
              if (peek() == "\n") {
                next(true, in_string);
                return "";
              }
          }
          if (is_octal(ch)) {
            if (template_string && strict_hex) {
              const represents_null_character = ch === "0" && !is_octal(peek());
              if (!represents_null_character) {
                parse_error("Octal escape sequences are not allowed in template strings");
              }
            }
            return read_octal_escape_sequence(ch, strict_hex);
          }
          return ch;
        }
        function read_octal_escape_sequence(ch, strict_octal) {
          var p = peek();
          if (p >= "0" && p <= "7") {
            ch += next(true);
            if (ch[0] <= "3" && (p = peek()) >= "0" && p <= "7")
              ch += next(true);
          }
          if (ch === "0")
            return "\0";
          if (ch.length > 0 && next_token.has_directive("use strict") && strict_octal)
            parse_error("Legacy octal escape sequences are not allowed in strict mode");
          return String.fromCharCode(parseInt(ch, 8));
        }
        function hex_bytes(n2, strict_hex) {
          var num = 0;
          for (; n2 > 0; --n2) {
            if (!strict_hex && isNaN(parseInt(peek(), 16))) {
              return parseInt(num, 16) || "";
            }
            var digit = next(true);
            if (isNaN(parseInt(digit, 16)))
              parse_error("Invalid hex-character pattern in string");
            num += digit;
          }
          return parseInt(num, 16);
        }
        var read_string = with_eof_error("Unterminated string constant", function() {
          const start_pos = S.pos;
          var quote = next(), ret = [];
          for (; ; ) {
            var ch = next(true, true);
            if (ch == "\\")
              ch = read_escaped_char(true, true);
            else if (ch == "\r" || ch == "\n")
              parse_error("Unterminated string constant");
            else if (ch == quote)
              break;
            ret.push(ch);
          }
          var tok = token("string", ret.join(""));
          LATEST_RAW = S.text.slice(start_pos, S.pos);
          tok.quote = quote;
          return tok;
        });
        var read_template_characters = with_eof_error("Unterminated template", function(begin) {
          if (begin) {
            S.template_braces.push(S.brace_counter);
          }
          var content = "", raw = "", ch, tok;
          next(true, true);
          while ((ch = next(true, true)) != "`") {
            if (ch == "\r") {
              if (peek() == "\n")
                ++S.pos;
              ch = "\n";
            } else if (ch == "$" && peek() == "{") {
              next(true, true);
              S.brace_counter++;
              tok = token(begin ? "template_head" : "template_cont", content);
              TEMPLATE_RAWS.set(tok, raw);
              tok.template_end = false;
              return tok;
            }
            raw += ch;
            if (ch == "\\") {
              var tmp = S.pos;
              var prev_is_tag = previous_token && (previous_token.type === "name" || previous_token.type === "punc" && (previous_token.value === ")" || previous_token.value === "]"));
              ch = read_escaped_char(true, !prev_is_tag, true);
              raw += S.text.substr(tmp, S.pos - tmp);
            }
            content += ch;
          }
          S.template_braces.pop();
          tok = token(begin ? "template_head" : "template_cont", content);
          TEMPLATE_RAWS.set(tok, raw);
          tok.template_end = true;
          return tok;
        });
        function skip_line_comment(type) {
          var regex_allowed = S.regex_allowed;
          var i = find_eol(), ret;
          if (i == -1) {
            ret = S.text.substr(S.pos);
            S.pos = S.text.length;
          } else {
            ret = S.text.substring(S.pos, i);
            S.pos = i;
          }
          S.col = S.tokcol + (S.pos - S.tokpos);
          S.comments_before.push(token(type, ret, true));
          S.regex_allowed = regex_allowed;
          return next_token;
        }
        var skip_multiline_comment = with_eof_error("Unterminated multiline comment", function() {
          var regex_allowed = S.regex_allowed;
          var i = find("*/", true);
          var text3 = S.text.substring(S.pos, i).replace(/\r\n|\r|\u2028|\u2029/g, "\n");
          forward(get_full_char_length(text3) + 2);
          S.comments_before.push(token("comment2", text3, true));
          S.newline_before = S.newline_before || text3.includes("\n");
          S.regex_allowed = regex_allowed;
          return next_token;
        });
        var read_name = function() {
          let start = S.pos, end = start - 1, ch = "c";
          while ((ch = S.text.charAt(++end)) && (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z"))
            ;
          if (end > start + 1 && ch && ch !== "\\" && !is_identifier_char(ch)) {
            S.pos += end - start;
            S.col += end - start;
            return S.text.slice(start, S.pos);
          }
          return read_name_hard();
        };
        var read_name_hard = with_eof_error("Unterminated identifier name", function() {
          var name = [], ch, escaped = false;
          var read_escaped_identifier_char = function() {
            escaped = true;
            next();
            if (peek() !== "u") {
              parse_error("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}");
            }
            return read_escaped_char(false, true);
          };
          if ((ch = peek()) === "\\") {
            ch = read_escaped_identifier_char();
            if (!is_identifier_start(ch)) {
              parse_error("First identifier char is an invalid identifier char");
            }
          } else if (is_identifier_start(ch)) {
            next();
          } else {
            return "";
          }
          name.push(ch);
          while ((ch = peek()) != null) {
            if ((ch = peek()) === "\\") {
              ch = read_escaped_identifier_char();
              if (!is_identifier_char(ch)) {
                parse_error("Invalid escaped identifier char");
              }
            } else {
              if (!is_identifier_char(ch)) {
                break;
              }
              next();
            }
            name.push(ch);
          }
          const name_str = name.join("");
          if (RESERVED_WORDS.has(name_str) && escaped) {
            parse_error("Escaped characters are not allowed in keywords");
          }
          return name_str;
        });
        var read_regexp = with_eof_error("Unterminated regular expression", function(source) {
          var prev_backslash = false, ch, in_class = false;
          while (ch = next(true))
            if (NEWLINE_CHARS.has(ch)) {
              parse_error("Unexpected line terminator");
            } else if (prev_backslash) {
              if (/^[\u0000-\u007F]$/.test(ch)) {
                source += "\\" + ch;
              } else {
                source += ch;
              }
              prev_backslash = false;
            } else if (ch == "[") {
              in_class = true;
              source += ch;
            } else if (ch == "]" && in_class) {
              in_class = false;
              source += ch;
            } else if (ch == "/" && !in_class) {
              break;
            } else if (ch == "\\") {
              prev_backslash = true;
            } else {
              source += ch;
            }
          const flags = read_name();
          return token("regexp", "/" + source + "/" + flags);
        });
        function read_operator(prefix) {
          function grow(op) {
            if (!peek())
              return op;
            var bigger = op + peek();
            if (OPERATORS.has(bigger)) {
              next();
              return grow(bigger);
            } else {
              return op;
            }
          }
          return token("operator", grow(prefix || next()));
        }
        function handle_slash() {
          next();
          switch (peek()) {
            case "/":
              next();
              return skip_line_comment("comment1");
            case "*":
              next();
              return skip_multiline_comment();
          }
          return S.regex_allowed ? read_regexp("") : read_operator("/");
        }
        function handle_eq_sign() {
          next();
          if (peek() === ">") {
            next();
            return token("arrow", "=>");
          } else {
            return read_operator("=");
          }
        }
        function handle_dot() {
          next();
          if (is_digit(peek().charCodeAt(0))) {
            return read_num(".");
          }
          if (peek() === ".") {
            next();
            next();
            return token("expand", "...");
          }
          return token("punc", ".");
        }
        function read_word() {
          var word = read_name();
          if (prev_was_dot)
            return token("name", word);
          return KEYWORDS_ATOM.has(word) ? token("atom", word) : !KEYWORDS.has(word) ? token("name", word) : OPERATORS.has(word) ? token("operator", word) : token("keyword", word);
        }
        function read_private_word() {
          next();
          return token("privatename", read_name());
        }
        function with_eof_error(eof_error, cont) {
          return function(x) {
            try {
              return cont(x);
            } catch (ex) {
              if (ex === EX_EOF)
                parse_error(eof_error);
              else
                throw ex;
            }
          };
        }
        function next_token(force_regexp) {
          if (force_regexp != null)
            return read_regexp(force_regexp);
          if (shebang && S.pos == 0 && looking_at("#!")) {
            start_token();
            forward(2);
            skip_line_comment("comment5");
          }
          for (; ; ) {
            skip_whitespace();
            start_token();
            if (html5_comments) {
              if (looking_at("<!--")) {
                forward(4);
                skip_line_comment("comment3");
                continue;
              }
              if (looking_at("-->") && S.newline_before) {
                forward(3);
                skip_line_comment("comment4");
                continue;
              }
            }
            var ch = peek();
            if (!ch)
              return token("eof");
            var code = ch.charCodeAt(0);
            switch (code) {
              case 34:
              case 39:
                return read_string();
              case 46:
                return handle_dot();
              case 47: {
                var tok = handle_slash();
                if (tok === next_token)
                  continue;
                return tok;
              }
              case 61:
                return handle_eq_sign();
              case 63: {
                if (!is_option_chain_op())
                  break;
                next();
                next();
                return token("punc", "?.");
              }
              case 96:
                return read_template_characters(true);
              case 123:
                S.brace_counter++;
                break;
              case 125:
                S.brace_counter--;
                if (S.template_braces.length > 0 && S.template_braces[S.template_braces.length - 1] === S.brace_counter)
                  return read_template_characters(false);
                break;
            }
            if (is_digit(code))
              return read_num();
            if (PUNC_CHARS.has(ch))
              return token("punc", next());
            if (OPERATOR_CHARS.has(ch))
              return read_operator();
            if (code == 92 || is_identifier_start(ch))
              return read_word();
            if (code == 35)
              return read_private_word();
            break;
          }
          parse_error("Unexpected character '" + ch + "'");
        }
        next_token.next = next;
        next_token.peek = peek;
        next_token.context = function(nc) {
          if (nc)
            S = nc;
          return S;
        };
        next_token.add_directive = function(directive) {
          S.directive_stack[S.directive_stack.length - 1].push(directive);
          if (S.directives[directive] === void 0) {
            S.directives[directive] = 1;
          } else {
            S.directives[directive]++;
          }
        };
        next_token.push_directives_stack = function() {
          S.directive_stack.push([]);
        };
        next_token.pop_directives_stack = function() {
          var directives2 = S.directive_stack[S.directive_stack.length - 1];
          for (var i = 0; i < directives2.length; i++) {
            S.directives[directives2[i]]--;
          }
          S.directive_stack.pop();
        };
        next_token.has_directive = function(directive) {
          return S.directives[directive] > 0;
        };
        return next_token;
      }
      var UNARY_PREFIX = makePredicate([
        "typeof",
        "void",
        "delete",
        "--",
        "++",
        "!",
        "~",
        "-",
        "+"
      ]);
      var UNARY_POSTFIX = makePredicate(["--", "++"]);
      var ASSIGNMENT = makePredicate(["=", "+=", "-=", "??=", "&&=", "||=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]);
      var LOGICAL_ASSIGNMENT = makePredicate(["??=", "&&=", "||="]);
      var PRECEDENCE = function(a, ret) {
        for (var i = 0; i < a.length; ++i) {
          for (const op of a[i]) {
            ret[op] = i + 1;
          }
        }
        return ret;
      }([
        ["||"],
        ["??"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"],
        ["**"]
      ], {});
      var ATOMIC_START_TOKEN = makePredicate(["atom", "num", "big_int", "string", "regexp", "name"]);
      function parse2($TEXT, options) {
        const outer_comments_before_counts = /* @__PURE__ */ new WeakMap();
        options = defaults(options, {
          bare_returns: false,
          ecma: null,
          expression: false,
          filename: null,
          html5_comments: true,
          module: false,
          shebang: true,
          strict: false,
          toplevel: null
        }, true);
        var S = {
          input: typeof $TEXT == "string" ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang) : $TEXT,
          token: null,
          prev: null,
          peeked: null,
          in_function: 0,
          in_async: -1,
          in_generator: -1,
          in_directives: true,
          in_loop: 0,
          labels: []
        };
        S.token = next();
        function is(type, value2) {
          return is_token(S.token, type, value2);
        }
        function peek() {
          return S.peeked || (S.peeked = S.input());
        }
        function next() {
          S.prev = S.token;
          if (!S.peeked)
            peek();
          S.token = S.peeked;
          S.peeked = null;
          S.in_directives = S.in_directives && (S.token.type == "string" || is("punc", ";"));
          return S.token;
        }
        function prev() {
          return S.prev;
        }
        function croak(msg, line, col, pos2) {
          var ctx = S.input.context();
          js_error(msg, ctx.filename, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos2 != null ? pos2 : ctx.tokpos);
        }
        function token_error(token, msg) {
          croak(msg, token.line, token.col);
        }
        function unexpected(token) {
          if (token == null)
            token = S.token;
          token_error(token, "Unexpected token: " + token.type + " (" + token.value + ")");
        }
        function expect_token(type, val) {
          if (is(type, val)) {
            return next();
          }
          token_error(S.token, "Unexpected token " + S.token.type + " \xAB" + S.token.value + "\xBB, expected " + type + " \xAB" + val + "\xBB");
        }
        function expect(punc) {
          return expect_token("punc", punc);
        }
        function has_newline_before(token) {
          return token.nlb || !token.comments_before.every((comment) => !comment.nlb);
        }
        function can_insert_semicolon() {
          return !options.strict && (is("eof") || is("punc", "}") || has_newline_before(S.token));
        }
        function is_in_generator() {
          return S.in_generator === S.in_function;
        }
        function is_in_async() {
          return S.in_async === S.in_function;
        }
        function can_await() {
          return S.in_async === S.in_function || S.in_function === 0 && S.input.has_directive("use strict");
        }
        function semicolon(optional) {
          if (is("punc", ";"))
            next();
          else if (!optional && !can_insert_semicolon())
            unexpected();
        }
        function parenthesised() {
          expect("(");
          var exp = expression(true);
          expect(")");
          return exp;
        }
        function embed_tokens(parser) {
          return function _embed_tokens_wrapper(...args) {
            const start = S.token;
            const expr = parser(...args);
            expr.start = start;
            expr.end = prev();
            return expr;
          };
        }
        function handle_regexp() {
          if (is("operator", "/") || is("operator", "/=")) {
            S.peeked = null;
            S.token = S.input(S.token.value.substr(1));
          }
        }
        var statement = embed_tokens(function statement2(is_export_default, is_for_body, is_if_body) {
          handle_regexp();
          switch (S.token.type) {
            case "string":
              if (S.in_directives) {
                var token = peek();
                if (!LATEST_RAW.includes("\\") && (is_token(token, "punc", ";") || is_token(token, "punc", "}") || has_newline_before(token) || is_token(token, "eof"))) {
                  S.input.add_directive(S.token.value);
                } else {
                  S.in_directives = false;
                }
              }
              var dir = S.in_directives, stat = simple_statement();
              return dir && stat.body instanceof AST_String ? new AST_Directive(stat.body) : stat;
            case "template_head":
            case "num":
            case "big_int":
            case "regexp":
            case "operator":
            case "atom":
              return simple_statement();
            case "name":
            case "privatename":
              if (is("privatename") && !S.in_class)
                croak("Private field must be used in an enclosing class");
              if (S.token.value == "async" && is_token(peek(), "keyword", "function")) {
                next();
                next();
                if (is_for_body) {
                  croak("functions are not allowed as the body of a loop");
                }
                return function_(AST_Defun, false, true, is_export_default);
              }
              if (S.token.value == "import" && !is_token(peek(), "punc", "(") && !is_token(peek(), "punc", ".")) {
                next();
                var node = import_statement();
                semicolon();
                return node;
              }
              return is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement();
            case "punc":
              switch (S.token.value) {
                case "{":
                  return new AST_BlockStatement({
                    start: S.token,
                    body: block_(),
                    end: prev()
                  });
                case "[":
                case "(":
                  return simple_statement();
                case ";":
                  S.in_directives = false;
                  next();
                  return new AST_EmptyStatement();
                default:
                  unexpected();
              }
            case "keyword":
              switch (S.token.value) {
                case "break":
                  next();
                  return break_cont(AST_Break);
                case "continue":
                  next();
                  return break_cont(AST_Continue);
                case "debugger":
                  next();
                  semicolon();
                  return new AST_Debugger();
                case "do":
                  next();
                  var body = in_loop(statement2);
                  expect_token("keyword", "while");
                  var condition = parenthesised();
                  semicolon(true);
                  return new AST_Do({
                    body,
                    condition
                  });
                case "while":
                  next();
                  return new AST_While({
                    condition: parenthesised(),
                    body: in_loop(function() {
                      return statement2(false, true);
                    })
                  });
                case "for":
                  next();
                  return for_();
                case "class":
                  next();
                  if (is_for_body) {
                    croak("classes are not allowed as the body of a loop");
                  }
                  if (is_if_body) {
                    croak("classes are not allowed as the body of an if");
                  }
                  return class_(AST_DefClass, is_export_default);
                case "function":
                  next();
                  if (is_for_body) {
                    croak("functions are not allowed as the body of a loop");
                  }
                  return function_(AST_Defun, false, false, is_export_default);
                case "if":
                  next();
                  return if_();
                case "return":
                  if (S.in_function == 0 && !options.bare_returns)
                    croak("'return' outside of function");
                  next();
                  var value2 = null;
                  if (is("punc", ";")) {
                    next();
                  } else if (!can_insert_semicolon()) {
                    value2 = expression(true);
                    semicolon();
                  }
                  return new AST_Return({
                    value: value2
                  });
                case "switch":
                  next();
                  return new AST_Switch({
                    expression: parenthesised(),
                    body: in_loop(switch_body_)
                  });
                case "throw":
                  next();
                  if (has_newline_before(S.token))
                    croak("Illegal newline after 'throw'");
                  var value2 = expression(true);
                  semicolon();
                  return new AST_Throw({
                    value: value2
                  });
                case "try":
                  next();
                  return try_();
                case "var":
                  next();
                  var node = var_();
                  semicolon();
                  return node;
                case "let":
                  next();
                  var node = let_();
                  semicolon();
                  return node;
                case "const":
                  next();
                  var node = const_();
                  semicolon();
                  return node;
                case "with":
                  if (S.input.has_directive("use strict")) {
                    croak("Strict mode may not include a with statement");
                  }
                  next();
                  return new AST_With({
                    expression: parenthesised(),
                    body: statement2()
                  });
                case "export":
                  if (!is_token(peek(), "punc", "(")) {
                    next();
                    var node = export_statement();
                    if (is("punc", ";"))
                      semicolon();
                    return node;
                  }
              }
          }
          unexpected();
        });
        function labeled_statement() {
          var label = as_symbol(AST_Label);
          if (label.name === "await" && is_in_async()) {
            token_error(S.prev, "await cannot be used as label inside async function");
          }
          if (S.labels.some((l) => l.name === label.name)) {
            croak("Label " + label.name + " defined twice");
          }
          expect(":");
          S.labels.push(label);
          var stat = statement();
          S.labels.pop();
          if (!(stat instanceof AST_IterationStatement)) {
            label.references.forEach(function(ref) {
              if (ref instanceof AST_Continue) {
                ref = ref.label.start;
                croak("Continue label `" + label.name + "` refers to non-IterationStatement.", ref.line, ref.col, ref.pos);
              }
            });
          }
          return new AST_LabeledStatement({ body: stat, label });
        }
        function simple_statement(tmp) {
          return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });
        }
        function break_cont(type) {
          var label = null, ldef;
          if (!can_insert_semicolon()) {
            label = as_symbol(AST_LabelRef, true);
          }
          if (label != null) {
            ldef = S.labels.find((l) => l.name === label.name);
            if (!ldef)
              croak("Undefined label " + label.name);
            label.thedef = ldef;
          } else if (S.in_loop == 0)
            croak(type.TYPE + " not inside a loop or switch");
          semicolon();
          var stat = new type({ label });
          if (ldef)
            ldef.references.push(stat);
          return stat;
        }
        function for_() {
          var for_await_error = "`for await` invalid in this context";
          var await_tok = S.token;
          if (await_tok.type == "name" && await_tok.value == "await") {
            if (!can_await()) {
              token_error(await_tok, for_await_error);
            }
            next();
          } else {
            await_tok = false;
          }
          expect("(");
          var init2 = null;
          if (!is("punc", ";")) {
            init2 = is("keyword", "var") ? (next(), var_(true)) : is("keyword", "let") ? (next(), let_(true)) : is("keyword", "const") ? (next(), const_(true)) : expression(true, true);
            var is_in = is("operator", "in");
            var is_of = is("name", "of");
            if (await_tok && !is_of) {
              token_error(await_tok, for_await_error);
            }
            if (is_in || is_of) {
              if (init2 instanceof AST_Definitions) {
                if (init2.definitions.length > 1)
                  token_error(init2.start, "Only one variable declaration allowed in for..in loop");
              } else if (!(is_assignable(init2) || (init2 = to_destructuring(init2)) instanceof AST_Destructuring)) {
                token_error(init2.start, "Invalid left-hand side in for..in loop");
              }
              next();
              if (is_in) {
                return for_in(init2);
              } else {
                return for_of(init2, !!await_tok);
              }
            }
          } else if (await_tok) {
            token_error(await_tok, for_await_error);
          }
          return regular_for(init2);
        }
        function regular_for(init2) {
          expect(";");
          var test = is("punc", ";") ? null : expression(true);
          expect(";");
          var step = is("punc", ")") ? null : expression(true);
          expect(")");
          return new AST_For({
            init: init2,
            condition: test,
            step,
            body: in_loop(function() {
              return statement(false, true);
            })
          });
        }
        function for_of(init2, is_await) {
          var lhs = init2 instanceof AST_Definitions ? init2.definitions[0].name : null;
          var obj = expression(true);
          expect(")");
          return new AST_ForOf({
            await: is_await,
            init: init2,
            name: lhs,
            object: obj,
            body: in_loop(function() {
              return statement(false, true);
            })
          });
        }
        function for_in(init2) {
          var obj = expression(true);
          expect(")");
          return new AST_ForIn({
            init: init2,
            object: obj,
            body: in_loop(function() {
              return statement(false, true);
            })
          });
        }
        var arrow_function = function(start, argnames, is_async) {
          if (has_newline_before(S.token)) {
            croak("Unexpected newline before arrow (=>)");
          }
          expect_token("arrow", "=>");
          var body = _function_body(is("punc", "{"), false, is_async);
          return new AST_Arrow({
            start,
            end: body.end,
            async: is_async,
            argnames,
            body
          });
        };
        var function_ = function(ctor, is_generator, is_async, is_export_default) {
          var in_statement = ctor === AST_Defun;
          if (is("operator", "*")) {
            is_generator = true;
            next();
          }
          var name = is("name") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;
          if (in_statement && !name) {
            if (is_export_default) {
              ctor = AST_Function;
            } else {
              unexpected();
            }
          }
          if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))
            unexpected(prev());
          var args = [];
          var body = _function_body(true, is_generator, is_async, name, args);
          return new ctor({
            start: args.start,
            end: body.end,
            is_generator,
            async: is_async,
            name,
            argnames: args,
            body
          });
        };
        class UsedParametersTracker {
          constructor(is_parameter, strict, duplicates_ok = false) {
            this.is_parameter = is_parameter;
            this.duplicates_ok = duplicates_ok;
            this.parameters = /* @__PURE__ */ new Set();
            this.duplicate = null;
            this.default_assignment = false;
            this.spread = false;
            this.strict_mode = !!strict;
          }
          add_parameter(token) {
            if (this.parameters.has(token.value)) {
              if (this.duplicate === null) {
                this.duplicate = token;
              }
              this.check_strict();
            } else {
              this.parameters.add(token.value);
              if (this.is_parameter) {
                switch (token.value) {
                  case "arguments":
                  case "eval":
                  case "yield":
                    if (this.strict_mode) {
                      token_error(token, "Unexpected " + token.value + " identifier as parameter inside strict mode");
                    }
                    break;
                  default:
                    if (RESERVED_WORDS.has(token.value)) {
                      unexpected();
                    }
                }
              }
            }
          }
          mark_default_assignment(token) {
            if (this.default_assignment === false) {
              this.default_assignment = token;
            }
          }
          mark_spread(token) {
            if (this.spread === false) {
              this.spread = token;
            }
          }
          mark_strict_mode() {
            this.strict_mode = true;
          }
          is_strict() {
            return this.default_assignment !== false || this.spread !== false || this.strict_mode;
          }
          check_strict() {
            if (this.is_strict() && this.duplicate !== null && !this.duplicates_ok) {
              token_error(this.duplicate, "Parameter " + this.duplicate.value + " was used already");
            }
          }
        }
        function parameters(params) {
          var used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
          expect("(");
          while (!is("punc", ")")) {
            var param = parameter(used_parameters);
            params.push(param);
            if (!is("punc", ")")) {
              expect(",");
            }
            if (param instanceof AST_Expansion) {
              break;
            }
          }
          next();
        }
        function parameter(used_parameters, symbol_type) {
          var param;
          var expand = false;
          if (used_parameters === void 0) {
            used_parameters = new UsedParametersTracker(true, S.input.has_directive("use strict"));
          }
          if (is("expand", "...")) {
            expand = S.token;
            used_parameters.mark_spread(S.token);
            next();
          }
          param = binding_element(used_parameters, symbol_type);
          if (is("operator", "=") && expand === false) {
            used_parameters.mark_default_assignment(S.token);
            next();
            param = new AST_DefaultAssign({
              start: param.start,
              left: param,
              operator: "=",
              right: expression(false),
              end: S.token
            });
          }
          if (expand !== false) {
            if (!is("punc", ")")) {
              unexpected();
            }
            param = new AST_Expansion({
              start: expand,
              expression: param,
              end: expand
            });
          }
          used_parameters.check_strict();
          return param;
        }
        function binding_element(used_parameters, symbol_type) {
          var elements = [];
          var first = true;
          var is_expand = false;
          var expand_token;
          var first_token = S.token;
          if (used_parameters === void 0) {
            const strict = S.input.has_directive("use strict");
            const duplicates_ok = symbol_type === AST_SymbolVar;
            used_parameters = new UsedParametersTracker(false, strict, duplicates_ok);
          }
          symbol_type = symbol_type === void 0 ? AST_SymbolFunarg : symbol_type;
          if (is("punc", "[")) {
            next();
            while (!is("punc", "]")) {
              if (first) {
                first = false;
              } else {
                expect(",");
              }
              if (is("expand", "...")) {
                is_expand = true;
                expand_token = S.token;
                used_parameters.mark_spread(S.token);
                next();
              }
              if (is("punc")) {
                switch (S.token.value) {
                  case ",":
                    elements.push(new AST_Hole({
                      start: S.token,
                      end: S.token
                    }));
                    continue;
                  case "]":
                    break;
                  case "[":
                  case "{":
                    elements.push(binding_element(used_parameters, symbol_type));
                    break;
                  default:
                    unexpected();
                }
              } else if (is("name")) {
                used_parameters.add_parameter(S.token);
                elements.push(as_symbol(symbol_type));
              } else {
                croak("Invalid function parameter");
              }
              if (is("operator", "=") && is_expand === false) {
                used_parameters.mark_default_assignment(S.token);
                next();
                elements[elements.length - 1] = new AST_DefaultAssign({
                  start: elements[elements.length - 1].start,
                  left: elements[elements.length - 1],
                  operator: "=",
                  right: expression(false),
                  end: S.token
                });
              }
              if (is_expand) {
                if (!is("punc", "]")) {
                  croak("Rest element must be last element");
                }
                elements[elements.length - 1] = new AST_Expansion({
                  start: expand_token,
                  expression: elements[elements.length - 1],
                  end: expand_token
                });
              }
            }
            expect("]");
            used_parameters.check_strict();
            return new AST_Destructuring({
              start: first_token,
              names: elements,
              is_array: true,
              end: prev()
            });
          } else if (is("punc", "{")) {
            next();
            while (!is("punc", "}")) {
              if (first) {
                first = false;
              } else {
                expect(",");
              }
              if (is("expand", "...")) {
                is_expand = true;
                expand_token = S.token;
                used_parameters.mark_spread(S.token);
                next();
              }
              if (is("name") && (is_token(peek(), "punc") || is_token(peek(), "operator")) && [",", "}", "="].includes(peek().value)) {
                used_parameters.add_parameter(S.token);
                var start = prev();
                var value2 = as_symbol(symbol_type);
                if (is_expand) {
                  elements.push(new AST_Expansion({
                    start: expand_token,
                    expression: value2,
                    end: value2.end
                  }));
                } else {
                  elements.push(new AST_ObjectKeyVal({
                    start,
                    key: value2.name,
                    value: value2,
                    end: value2.end
                  }));
                }
              } else if (is("punc", "}")) {
                continue;
              } else {
                var property_token = S.token;
                var property = as_property_name();
                if (property === null) {
                  unexpected(prev());
                } else if (prev().type === "name" && !is("punc", ":")) {
                  elements.push(new AST_ObjectKeyVal({
                    start: prev(),
                    key: property,
                    value: new symbol_type({
                      start: prev(),
                      name: property,
                      end: prev()
                    }),
                    end: prev()
                  }));
                } else {
                  expect(":");
                  elements.push(new AST_ObjectKeyVal({
                    start: property_token,
                    quote: property_token.quote,
                    key: property,
                    value: binding_element(used_parameters, symbol_type),
                    end: prev()
                  }));
                }
              }
              if (is_expand) {
                if (!is("punc", "}")) {
                  croak("Rest element must be last element");
                }
              } else if (is("operator", "=")) {
                used_parameters.mark_default_assignment(S.token);
                next();
                elements[elements.length - 1].value = new AST_DefaultAssign({
                  start: elements[elements.length - 1].value.start,
                  left: elements[elements.length - 1].value,
                  operator: "=",
                  right: expression(false),
                  end: S.token
                });
              }
            }
            expect("}");
            used_parameters.check_strict();
            return new AST_Destructuring({
              start: first_token,
              names: elements,
              is_array: false,
              end: prev()
            });
          } else if (is("name")) {
            used_parameters.add_parameter(S.token);
            return as_symbol(symbol_type);
          } else {
            croak("Invalid function parameter");
          }
        }
        function params_or_seq_(allow_arrows, maybe_sequence) {
          var spread_token;
          var invalid_sequence;
          var trailing_comma;
          var a = [];
          expect("(");
          while (!is("punc", ")")) {
            if (spread_token)
              unexpected(spread_token);
            if (is("expand", "...")) {
              spread_token = S.token;
              if (maybe_sequence)
                invalid_sequence = S.token;
              next();
              a.push(new AST_Expansion({
                start: prev(),
                expression: expression(),
                end: S.token
              }));
            } else {
              a.push(expression());
            }
            if (!is("punc", ")")) {
              expect(",");
              if (is("punc", ")")) {
                trailing_comma = prev();
                if (maybe_sequence)
                  invalid_sequence = trailing_comma;
              }
            }
          }
          expect(")");
          if (allow_arrows && is("arrow", "=>")) {
            if (spread_token && trailing_comma)
              unexpected(trailing_comma);
          } else if (invalid_sequence) {
            unexpected(invalid_sequence);
          }
          return a;
        }
        function _function_body(block, generator, is_async, name, args) {
          var loop = S.in_loop;
          var labels = S.labels;
          var current_generator = S.in_generator;
          var current_async = S.in_async;
          ++S.in_function;
          if (generator)
            S.in_generator = S.in_function;
          if (is_async)
            S.in_async = S.in_function;
          if (args)
            parameters(args);
          if (block)
            S.in_directives = true;
          S.in_loop = 0;
          S.labels = [];
          if (block) {
            S.input.push_directives_stack();
            var a = block_();
            if (name)
              _verify_symbol(name);
            if (args)
              args.forEach(_verify_symbol);
            S.input.pop_directives_stack();
          } else {
            var a = [new AST_Return({
              start: S.token,
              value: expression(false),
              end: S.token
            })];
          }
          --S.in_function;
          S.in_loop = loop;
          S.labels = labels;
          S.in_generator = current_generator;
          S.in_async = current_async;
          return a;
        }
        function _await_expression() {
          if (!can_await()) {
            croak("Unexpected await expression outside async function", S.prev.line, S.prev.col, S.prev.pos);
          }
          return new AST_Await({
            start: prev(),
            end: S.token,
            expression: maybe_unary(true)
          });
        }
        function _yield_expression() {
          var start = S.token;
          var star = false;
          var has_expression = true;
          if (can_insert_semicolon() || is("punc") && PUNC_AFTER_EXPRESSION.has(S.token.value) || is("template_cont")) {
            has_expression = false;
          } else if (is("operator", "*")) {
            star = true;
            next();
          }
          return new AST_Yield({
            start,
            is_star: star,
            expression: has_expression ? expression() : null,
            end: prev()
          });
        }
        function if_() {
          var cond = parenthesised(), body = statement(false, false, true), belse = null;
          if (is("keyword", "else")) {
            next();
            belse = statement(false, false, true);
          }
          return new AST_If({
            condition: cond,
            body,
            alternative: belse
          });
        }
        function block_() {
          expect("{");
          var a = [];
          while (!is("punc", "}")) {
            if (is("eof"))
              unexpected();
            a.push(statement());
          }
          next();
          return a;
        }
        function switch_body_() {
          expect("{");
          var a = [], cur = null, branch = null, tmp;
          while (!is("punc", "}")) {
            if (is("eof"))
              unexpected();
            if (is("keyword", "case")) {
              if (branch)
                branch.end = prev();
              cur = [];
              branch = new AST_Case({
                start: (tmp = S.token, next(), tmp),
                expression: expression(true),
                body: cur
              });
              a.push(branch);
              expect(":");
            } else if (is("keyword", "default")) {
              if (branch)
                branch.end = prev();
              cur = [];
              branch = new AST_Default({
                start: (tmp = S.token, next(), expect(":"), tmp),
                body: cur
              });
              a.push(branch);
            } else {
              if (!cur)
                unexpected();
              cur.push(statement());
            }
          }
          if (branch)
            branch.end = prev();
          next();
          return a;
        }
        function try_() {
          var body, bcatch = null, bfinally = null;
          body = new AST_TryBlock({
            start: S.token,
            body: block_(),
            end: prev()
          });
          if (is("keyword", "catch")) {
            var start = S.token;
            next();
            if (is("punc", "{")) {
              var name = null;
            } else {
              expect("(");
              var name = parameter(void 0, AST_SymbolCatch);
              expect(")");
            }
            bcatch = new AST_Catch({
              start,
              argname: name,
              body: block_(),
              end: prev()
            });
          }
          if (is("keyword", "finally")) {
            var start = S.token;
            next();
            bfinally = new AST_Finally({
              start,
              body: block_(),
              end: prev()
            });
          }
          if (!bcatch && !bfinally)
            croak("Missing catch/finally blocks");
          return new AST_Try({
            body,
            bcatch,
            bfinally
          });
        }
        function vardefs(no_in, kind) {
          var var_defs = [];
          var def;
          for (; ; ) {
            var sym_type = kind === "var" ? AST_SymbolVar : kind === "const" ? AST_SymbolConst : kind === "let" ? AST_SymbolLet : null;
            if (is("punc", "{") || is("punc", "[")) {
              def = new AST_VarDef({
                start: S.token,
                name: binding_element(void 0, sym_type),
                value: is("operator", "=") ? (expect_token("operator", "="), expression(false, no_in)) : null,
                end: prev()
              });
            } else {
              def = new AST_VarDef({
                start: S.token,
                name: as_symbol(sym_type),
                value: is("operator", "=") ? (next(), expression(false, no_in)) : !no_in && kind === "const" ? croak("Missing initializer in const declaration") : null,
                end: prev()
              });
              if (def.name.name == "import")
                croak("Unexpected token: import");
            }
            var_defs.push(def);
            if (!is("punc", ","))
              break;
            next();
          }
          return var_defs;
        }
        var var_ = function(no_in) {
          return new AST_Var({
            start: prev(),
            definitions: vardefs(no_in, "var"),
            end: prev()
          });
        };
        var let_ = function(no_in) {
          return new AST_Let({
            start: prev(),
            definitions: vardefs(no_in, "let"),
            end: prev()
          });
        };
        var const_ = function(no_in) {
          return new AST_Const({
            start: prev(),
            definitions: vardefs(no_in, "const"),
            end: prev()
          });
        };
        var new_ = function(allow_calls) {
          var start = S.token;
          expect_token("operator", "new");
          if (is("punc", ".")) {
            next();
            expect_token("name", "target");
            return subscripts(new AST_NewTarget({
              start,
              end: prev()
            }), allow_calls);
          }
          var newexp = expr_atom(false), args;
          if (is("punc", "(")) {
            next();
            args = expr_list(")", true);
          } else {
            args = [];
          }
          var call = new AST_New({
            start,
            expression: newexp,
            args,
            end: prev()
          });
          annotate(call);
          return subscripts(call, allow_calls);
        };
        function as_atom_node() {
          var tok = S.token, ret;
          switch (tok.type) {
            case "name":
              ret = _make_symbol(AST_SymbolRef);
              break;
            case "num":
              ret = new AST_Number({
                start: tok,
                end: tok,
                value: tok.value,
                raw: LATEST_RAW
              });
              break;
            case "big_int":
              ret = new AST_BigInt({
                start: tok,
                end: tok,
                value: tok.value,
                raw: LATEST_RAW
              });
              break;
            case "string":
              ret = new AST_String({
                start: tok,
                end: tok,
                value: tok.value,
                quote: tok.quote
              });
              annotate(ret);
              break;
            case "regexp":
              const [_, source, flags] = tok.value.match(/^\/(.*)\/(\w*)$/);
              ret = new AST_RegExp({ start: tok, end: tok, value: { source, flags } });
              break;
            case "atom":
              switch (tok.value) {
                case "false":
                  ret = new AST_False({ start: tok, end: tok });
                  break;
                case "true":
                  ret = new AST_True({ start: tok, end: tok });
                  break;
                case "null":
                  ret = new AST_Null({ start: tok, end: tok });
                  break;
              }
              break;
          }
          next();
          return ret;
        }
        function to_fun_args(ex, default_seen_above) {
          var insert_default = function(ex2, default_value) {
            if (default_value) {
              return new AST_DefaultAssign({
                start: ex2.start,
                left: ex2,
                operator: "=",
                right: default_value,
                end: default_value.end
              });
            }
            return ex2;
          };
          if (ex instanceof AST_Object) {
            return insert_default(new AST_Destructuring({
              start: ex.start,
              end: ex.end,
              is_array: false,
              names: ex.properties.map((prop) => to_fun_args(prop))
            }), default_seen_above);
          } else if (ex instanceof AST_ObjectKeyVal) {
            ex.value = to_fun_args(ex.value);
            return insert_default(ex, default_seen_above);
          } else if (ex instanceof AST_Hole) {
            return ex;
          } else if (ex instanceof AST_Destructuring) {
            ex.names = ex.names.map((name) => to_fun_args(name));
            return insert_default(ex, default_seen_above);
          } else if (ex instanceof AST_SymbolRef) {
            return insert_default(new AST_SymbolFunarg({
              name: ex.name,
              start: ex.start,
              end: ex.end
            }), default_seen_above);
          } else if (ex instanceof AST_Expansion) {
            ex.expression = to_fun_args(ex.expression);
            return insert_default(ex, default_seen_above);
          } else if (ex instanceof AST_Array) {
            return insert_default(new AST_Destructuring({
              start: ex.start,
              end: ex.end,
              is_array: true,
              names: ex.elements.map((elm) => to_fun_args(elm))
            }), default_seen_above);
          } else if (ex instanceof AST_Assign) {
            return insert_default(to_fun_args(ex.left, ex.right), default_seen_above);
          } else if (ex instanceof AST_DefaultAssign) {
            ex.left = to_fun_args(ex.left);
            return ex;
          } else {
            croak("Invalid function parameter", ex.start.line, ex.start.col);
          }
        }
        var expr_atom = function(allow_calls, allow_arrows) {
          if (is("operator", "new")) {
            return new_(allow_calls);
          }
          if (is("name", "import") && is_token(peek(), "punc", ".")) {
            return import_meta(allow_calls);
          }
          var start = S.token;
          var peeked;
          var async = is("name", "async") && (peeked = peek()).value != "[" && peeked.type != "arrow" && as_atom_node();
          if (is("punc")) {
            switch (S.token.value) {
              case "(":
                if (async && !allow_calls)
                  break;
                var exprs = params_or_seq_(allow_arrows, !async);
                if (allow_arrows && is("arrow", "=>")) {
                  return arrow_function(start, exprs.map((e) => to_fun_args(e)), !!async);
                }
                var ex = async ? new AST_Call({
                  expression: async,
                  args: exprs
                }) : to_expr_or_sequence(start, exprs);
                if (ex.start) {
                  const outer_comments_before = start.comments_before.length;
                  outer_comments_before_counts.set(start, outer_comments_before);
                  ex.start.comments_before.unshift(...start.comments_before);
                  start.comments_before = ex.start.comments_before;
                  if (outer_comments_before == 0 && start.comments_before.length > 0) {
                    var comment = start.comments_before[0];
                    if (!comment.nlb) {
                      comment.nlb = start.nlb;
                      start.nlb = false;
                    }
                  }
                  start.comments_after = ex.start.comments_after;
                }
                ex.start = start;
                var end = prev();
                if (ex.end) {
                  end.comments_before = ex.end.comments_before;
                  ex.end.comments_after.push(...end.comments_after);
                  end.comments_after = ex.end.comments_after;
                }
                ex.end = end;
                if (ex instanceof AST_Call)
                  annotate(ex);
                return subscripts(ex, allow_calls);
              case "[":
                return subscripts(array_(), allow_calls);
              case "{":
                return subscripts(object_or_destructuring_(), allow_calls);
            }
            if (!async)
              unexpected();
          }
          if (allow_arrows && is("name") && is_token(peek(), "arrow")) {
            var param = new AST_SymbolFunarg({
              name: S.token.value,
              start,
              end: start
            });
            next();
            return arrow_function(start, [param], !!async);
          }
          if (is("keyword", "function")) {
            next();
            var func = function_(AST_Function, false, !!async);
            func.start = start;
            func.end = prev();
            return subscripts(func, allow_calls);
          }
          if (async)
            return subscripts(async, allow_calls);
          if (is("keyword", "class")) {
            next();
            var cls = class_(AST_ClassExpression);
            cls.start = start;
            cls.end = prev();
            return subscripts(cls, allow_calls);
          }
          if (is("template_head")) {
            return subscripts(template_string(), allow_calls);
          }
          if (ATOMIC_START_TOKEN.has(S.token.type)) {
            return subscripts(as_atom_node(), allow_calls);
          }
          unexpected();
        };
        function template_string() {
          var segments = [], start = S.token;
          segments.push(new AST_TemplateSegment({
            start: S.token,
            raw: TEMPLATE_RAWS.get(S.token),
            value: S.token.value,
            end: S.token
          }));
          while (!S.token.template_end) {
            next();
            handle_regexp();
            segments.push(expression(true));
            segments.push(new AST_TemplateSegment({
              start: S.token,
              raw: TEMPLATE_RAWS.get(S.token),
              value: S.token.value,
              end: S.token
            }));
          }
          next();
          return new AST_TemplateString({
            start,
            segments,
            end: S.token
          });
        }
        function expr_list(closing, allow_trailing_comma, allow_empty) {
          var first = true, a = [];
          while (!is("punc", closing)) {
            if (first)
              first = false;
            else
              expect(",");
            if (allow_trailing_comma && is("punc", closing))
              break;
            if (is("punc", ",") && allow_empty) {
              a.push(new AST_Hole({ start: S.token, end: S.token }));
            } else if (is("expand", "...")) {
              next();
              a.push(new AST_Expansion({ start: prev(), expression: expression(), end: S.token }));
            } else {
              a.push(expression(false));
            }
          }
          next();
          return a;
        }
        var array_ = embed_tokens(function() {
          expect("[");
          return new AST_Array({
            elements: expr_list("]", !options.strict, true)
          });
        });
        var create_accessor = embed_tokens((is_generator, is_async) => {
          return function_(AST_Accessor, is_generator, is_async);
        });
        var object_or_destructuring_ = embed_tokens(function object_or_destructuring_2() {
          var start = S.token, first = true, a = [];
          expect("{");
          while (!is("punc", "}")) {
            if (first)
              first = false;
            else
              expect(",");
            if (!options.strict && is("punc", "}"))
              break;
            start = S.token;
            if (start.type == "expand") {
              next();
              a.push(new AST_Expansion({
                start,
                expression: expression(false),
                end: prev()
              }));
              continue;
            }
            if (is("privatename")) {
              croak("private fields are not allowed in an object");
            }
            var name = as_property_name();
            var value2;
            if (!is("punc", ":")) {
              var concise = object_or_class_property(name, start);
              if (concise) {
                a.push(concise);
                continue;
              }
              value2 = new AST_SymbolRef({
                start: prev(),
                name,
                end: prev()
              });
            } else if (name === null) {
              unexpected(prev());
            } else {
              next();
              value2 = expression(false);
            }
            if (is("operator", "=")) {
              next();
              value2 = new AST_Assign({
                start,
                left: value2,
                operator: "=",
                right: expression(false),
                logical: false,
                end: prev()
              });
            }
            const kv = new AST_ObjectKeyVal({
              start,
              quote: start.quote,
              key: name,
              value: value2,
              end: prev()
            });
            a.push(annotate(kv));
          }
          next();
          return new AST_Object({ properties: a });
        });
        function class_(KindOfClass, is_export_default) {
          var start, method, class_name, extends_, properties = [];
          S.input.push_directives_stack();
          S.input.add_directive("use strict");
          if (S.token.type == "name" && S.token.value != "extends") {
            class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);
          }
          if (KindOfClass === AST_DefClass && !class_name) {
            if (is_export_default) {
              KindOfClass = AST_ClassExpression;
            } else {
              unexpected();
            }
          }
          if (S.token.value == "extends") {
            next();
            extends_ = expression(true);
          }
          expect("{");
          const save_in_class = S.in_class;
          S.in_class = true;
          while (is("punc", ";")) {
            next();
          }
          while (!is("punc", "}")) {
            start = S.token;
            method = object_or_class_property(as_property_name(), start, true);
            if (!method) {
              unexpected();
            }
            properties.push(method);
            while (is("punc", ";")) {
              next();
            }
          }
          S.in_class = save_in_class;
          S.input.pop_directives_stack();
          next();
          return new KindOfClass({
            start,
            name: class_name,
            extends: extends_,
            properties,
            end: prev()
          });
        }
        function object_or_class_property(name, start, is_class) {
          const get_symbol_ast = (name2, SymbolClass) => {
            if (typeof name2 === "string") {
              return new SymbolClass({ start, name: name2, end: prev() });
            } else if (name2 === null) {
              unexpected();
            }
            return name2;
          };
          const is_not_method_start = () => !is("punc", "(") && !is("punc", ",") && !is("punc", "}") && !is("punc", ";") && !is("operator", "=");
          var is_async = false;
          var is_static = false;
          var is_generator = false;
          var is_private = false;
          var accessor_type = null;
          if (is_class && name === "static" && is_not_method_start()) {
            const static_block = class_static_block();
            if (static_block != null) {
              return static_block;
            }
            is_static = true;
            name = as_property_name();
          }
          if (name === "async" && is_not_method_start()) {
            is_async = true;
            name = as_property_name();
          }
          if (prev().type === "operator" && prev().value === "*") {
            is_generator = true;
            name = as_property_name();
          }
          if ((name === "get" || name === "set") && is_not_method_start()) {
            accessor_type = name;
            name = as_property_name();
          }
          if (prev().type === "privatename") {
            is_private = true;
          }
          const property_token = prev();
          if (accessor_type != null) {
            if (!is_private) {
              const AccessorClass = accessor_type === "get" ? AST_ObjectGetter : AST_ObjectSetter;
              name = get_symbol_ast(name, AST_SymbolMethod);
              return annotate(new AccessorClass({
                start,
                static: is_static,
                key: name,
                quote: name instanceof AST_SymbolMethod ? property_token.quote : void 0,
                value: create_accessor(),
                end: prev()
              }));
            } else {
              const AccessorClass = accessor_type === "get" ? AST_PrivateGetter : AST_PrivateSetter;
              return annotate(new AccessorClass({
                start,
                static: is_static,
                key: get_symbol_ast(name, AST_SymbolMethod),
                value: create_accessor(),
                end: prev()
              }));
            }
          }
          if (is("punc", "(")) {
            name = get_symbol_ast(name, AST_SymbolMethod);
            const AST_MethodVariant = is_private ? AST_PrivateMethod : AST_ConciseMethod;
            var node = new AST_MethodVariant({
              start,
              static: is_static,
              key: name,
              quote: name instanceof AST_SymbolMethod ? property_token.quote : void 0,
              value: create_accessor(is_generator, is_async),
              end: prev()
            });
            return annotate(node);
          }
          if (is_class) {
            const AST_SymbolVariant = is_private ? AST_SymbolPrivateProperty : AST_SymbolClassProperty;
            const AST_ClassPropertyVariant = is_private ? AST_ClassPrivateProperty : AST_ClassProperty;
            const key2 = get_symbol_ast(name, AST_SymbolVariant);
            const quote = key2 instanceof AST_SymbolClassProperty ? property_token.quote : void 0;
            if (is("operator", "=")) {
              next();
              return annotate(new AST_ClassPropertyVariant({
                start,
                static: is_static,
                quote,
                key: key2,
                value: expression(false),
                end: prev()
              }));
            } else if (is("name") || is("privatename") || is("punc", "[") || is("operator", "*") || is("punc", ";") || is("punc", "}") || is("string") || is("num") || is("big_int")) {
              return annotate(new AST_ClassPropertyVariant({
                start,
                static: is_static,
                quote,
                key: key2,
                end: prev()
              }));
            }
          }
        }
        function class_static_block() {
          if (!is("punc", "{")) {
            return null;
          }
          const start = S.token;
          const body = [];
          next();
          while (!is("punc", "}")) {
            body.push(statement());
          }
          next();
          return new AST_ClassStaticBlock({ start, body, end: prev() });
        }
        function maybe_import_attributes() {
          if ((is("keyword", "with") || is("name", "assert")) && !has_newline_before(S.token)) {
            next();
            return object_or_destructuring_();
          }
          return null;
        }
        function import_statement() {
          var start = prev();
          var imported_name;
          var imported_names;
          if (is("name")) {
            imported_name = as_symbol(AST_SymbolImport);
          }
          if (is("punc", ",")) {
            next();
          }
          imported_names = map_names(true);
          if (imported_names || imported_name) {
            expect_token("name", "from");
          }
          var mod_str = S.token;
          if (mod_str.type !== "string") {
            unexpected();
          }
          next();
          const attributes = maybe_import_attributes();
          return new AST_Import({
            start,
            imported_name,
            imported_names,
            module_name: new AST_String({
              start: mod_str,
              value: mod_str.value,
              quote: mod_str.quote,
              end: mod_str
            }),
            attributes,
            end: S.token
          });
        }
        function import_meta(allow_calls) {
          var start = S.token;
          expect_token("name", "import");
          expect_token("punc", ".");
          expect_token("name", "meta");
          return subscripts(new AST_ImportMeta({
            start,
            end: prev()
          }), allow_calls);
        }
        function map_name(is_import) {
          function make_symbol(type2, quote) {
            return new type2({
              name: as_property_name(),
              quote: quote || void 0,
              start: prev(),
              end: prev()
            });
          }
          var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
          var type = is_import ? AST_SymbolImport : AST_SymbolExport;
          var start = S.token;
          var foreign_name;
          var name;
          if (is_import) {
            foreign_name = make_symbol(foreign_type, start.quote);
          } else {
            name = make_symbol(type, start.quote);
          }
          if (is("name", "as")) {
            next();
            if (is_import) {
              name = make_symbol(type);
            } else {
              foreign_name = make_symbol(foreign_type, S.token.quote);
            }
          } else {
            if (is_import) {
              name = new type(foreign_name);
            } else {
              foreign_name = new foreign_type(name);
            }
          }
          return new AST_NameMapping({
            start,
            foreign_name,
            name,
            end: prev()
          });
        }
        function map_nameAsterisk(is_import, import_or_export_foreign_name) {
          var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;
          var type = is_import ? AST_SymbolImport : AST_SymbolExport;
          var start = S.token;
          var name, foreign_name;
          var end = prev();
          if (is_import) {
            name = import_or_export_foreign_name;
          } else {
            foreign_name = import_or_export_foreign_name;
          }
          name = name || new type({
            start,
            name: "*",
            end
          });
          foreign_name = foreign_name || new foreign_type({
            start,
            name: "*",
            end
          });
          return new AST_NameMapping({
            start,
            foreign_name,
            name,
            end
          });
        }
        function map_names(is_import) {
          var names;
          if (is("punc", "{")) {
            next();
            names = [];
            while (!is("punc", "}")) {
              names.push(map_name(is_import));
              if (is("punc", ",")) {
                next();
              }
            }
            next();
          } else if (is("operator", "*")) {
            var name;
            next();
            if (is("name", "as")) {
              next();
              name = is_import ? as_symbol(AST_SymbolImport) : as_symbol_or_string(AST_SymbolExportForeign);
            }
            names = [map_nameAsterisk(is_import, name)];
          }
          return names;
        }
        function export_statement() {
          var start = S.token;
          var is_default;
          var exported_names;
          if (is("keyword", "default")) {
            is_default = true;
            next();
          } else if (exported_names = map_names(false)) {
            if (is("name", "from")) {
              next();
              var mod_str = S.token;
              if (mod_str.type !== "string") {
                unexpected();
              }
              next();
              const attributes = maybe_import_attributes();
              return new AST_Export({
                start,
                is_default,
                exported_names,
                module_name: new AST_String({
                  start: mod_str,
                  value: mod_str.value,
                  quote: mod_str.quote,
                  end: mod_str
                }),
                end: prev(),
                attributes
              });
            } else {
              return new AST_Export({
                start,
                is_default,
                exported_names,
                end: prev()
              });
            }
          }
          var node;
          var exported_value;
          var exported_definition;
          if (is("punc", "{") || is_default && (is("keyword", "class") || is("keyword", "function")) && is_token(peek(), "punc")) {
            exported_value = expression(false);
            semicolon();
          } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {
            unexpected(node.start);
          } else if (node instanceof AST_Definitions || node instanceof AST_Defun || node instanceof AST_DefClass) {
            exported_definition = node;
          } else if (node instanceof AST_ClassExpression || node instanceof AST_Function) {
            exported_value = node;
          } else if (node instanceof AST_SimpleStatement) {
            exported_value = node.body;
          } else {
            unexpected(node.start);
          }
          return new AST_Export({
            start,
            is_default,
            exported_value,
            exported_definition,
            end: prev(),
            attributes: null
          });
        }
        function as_property_name() {
          var tmp = S.token;
          switch (tmp.type) {
            case "punc":
              if (tmp.value === "[") {
                next();
                var ex = expression(false);
                expect("]");
                return ex;
              } else
                unexpected(tmp);
            case "operator":
              if (tmp.value === "*") {
                next();
                return null;
              }
              if (!["delete", "in", "instanceof", "new", "typeof", "void"].includes(tmp.value)) {
                unexpected(tmp);
              }
            case "name":
            case "privatename":
            case "string":
            case "keyword":
            case "atom":
              next();
              return tmp.value;
            case "num":
            case "big_int":
              next();
              return "" + tmp.value;
            default:
              unexpected(tmp);
          }
        }
        function as_name() {
          var tmp = S.token;
          if (tmp.type != "name" && tmp.type != "privatename")
            unexpected();
          next();
          return tmp.value;
        }
        function _make_symbol(type) {
          var name = S.token.value;
          return new (name == "this" ? AST_This : name == "super" ? AST_Super : type)({
            name: String(name),
            start: S.token,
            end: S.token
          });
        }
        function _verify_symbol(sym) {
          var name = sym.name;
          if (is_in_generator() && name == "yield") {
            token_error(sym.start, "Yield cannot be used as identifier inside generators");
          }
          if (S.input.has_directive("use strict")) {
            if (name == "yield") {
              token_error(sym.start, "Unexpected yield identifier inside strict mode");
            }
            if (sym instanceof AST_SymbolDeclaration && (name == "arguments" || name == "eval")) {
              token_error(sym.start, "Unexpected " + name + " in strict mode");
            }
          }
        }
        function as_symbol(type, noerror) {
          if (!is("name")) {
            if (!noerror)
              croak("Name expected");
            return null;
          }
          var sym = _make_symbol(type);
          _verify_symbol(sym);
          next();
          return sym;
        }
        function as_symbol_or_string(type) {
          if (!is("name")) {
            if (!is("string")) {
              croak("Name or string expected");
            }
            var tok = S.token;
            var ret = new type({
              start: tok,
              end: tok,
              name: tok.value,
              quote: tok.quote
            });
            next();
            return ret;
          }
          var sym = _make_symbol(type);
          _verify_symbol(sym);
          next();
          return sym;
        }
        function annotate(node, before_token = node.start) {
          var comments = before_token.comments_before;
          const comments_outside_parens = outer_comments_before_counts.get(before_token);
          var i = comments_outside_parens != null ? comments_outside_parens : comments.length;
          while (--i >= 0) {
            var comment = comments[i];
            if (/[@#]__/.test(comment.value)) {
              if (/[@#]__PURE__/.test(comment.value)) {
                set_annotation(node, _PURE);
                break;
              }
              if (/[@#]__INLINE__/.test(comment.value)) {
                set_annotation(node, _INLINE);
                break;
              }
              if (/[@#]__NOINLINE__/.test(comment.value)) {
                set_annotation(node, _NOINLINE);
                break;
              }
              if (/[@#]__KEY__/.test(comment.value)) {
                set_annotation(node, _KEY);
                break;
              }
              if (/[@#]__MANGLE_PROP__/.test(comment.value)) {
                set_annotation(node, _MANGLEPROP);
                break;
              }
            }
          }
          return node;
        }
        var subscripts = function(expr, allow_calls, is_chain) {
          var start = expr.start;
          if (is("punc", ".")) {
            next();
            if (is("privatename") && !S.in_class)
              croak("Private field must be used in an enclosing class");
            const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
            return annotate(subscripts(new AST_DotVariant({
              start,
              expression: expr,
              optional: false,
              property: as_name(),
              end: prev()
            }), allow_calls, is_chain));
          }
          if (is("punc", "[")) {
            next();
            var prop = expression(true);
            expect("]");
            return annotate(subscripts(new AST_Sub({
              start,
              expression: expr,
              optional: false,
              property: prop,
              end: prev()
            }), allow_calls, is_chain));
          }
          if (allow_calls && is("punc", "(")) {
            next();
            var call = new AST_Call({
              start,
              expression: expr,
              optional: false,
              args: call_args(),
              end: prev()
            });
            annotate(call);
            return subscripts(call, true, is_chain);
          }
          if (is("punc", "?.")) {
            next();
            let chain_contents;
            if (allow_calls && is("punc", "(")) {
              next();
              const call2 = new AST_Call({
                start,
                optional: true,
                expression: expr,
                args: call_args(),
                end: prev()
              });
              annotate(call2);
              chain_contents = subscripts(call2, true, true);
            } else if (is("name") || is("privatename")) {
              if (is("privatename") && !S.in_class)
                croak("Private field must be used in an enclosing class");
              const AST_DotVariant = is("privatename") ? AST_DotHash : AST_Dot;
              chain_contents = annotate(subscripts(new AST_DotVariant({
                start,
                expression: expr,
                optional: true,
                property: as_name(),
                end: prev()
              }), allow_calls, true));
            } else if (is("punc", "[")) {
              next();
              const property = expression(true);
              expect("]");
              chain_contents = annotate(subscripts(new AST_Sub({
                start,
                expression: expr,
                optional: true,
                property,
                end: prev()
              }), allow_calls, true));
            }
            if (!chain_contents)
              unexpected();
            if (chain_contents instanceof AST_Chain)
              return chain_contents;
            return new AST_Chain({
              start,
              expression: chain_contents,
              end: prev()
            });
          }
          if (is("template_head")) {
            if (is_chain) {
              unexpected();
            }
            return subscripts(new AST_PrefixedTemplateString({
              start,
              prefix: expr,
              template_string: template_string(),
              end: prev()
            }), allow_calls);
          }
          return expr;
        };
        function call_args() {
          var args = [];
          while (!is("punc", ")")) {
            if (is("expand", "...")) {
              next();
              args.push(new AST_Expansion({
                start: prev(),
                expression: expression(false),
                end: prev()
              }));
            } else {
              args.push(expression(false));
            }
            if (!is("punc", ")")) {
              expect(",");
            }
          }
          next();
          return args;
        }
        var maybe_unary = function(allow_calls, allow_arrows) {
          var start = S.token;
          if (start.type == "name" && start.value == "await" && can_await()) {
            next();
            return _await_expression();
          }
          if (is("operator") && UNARY_PREFIX.has(start.value)) {
            next();
            handle_regexp();
            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));
            ex.start = start;
            ex.end = prev();
            return ex;
          }
          var val = expr_atom(allow_calls, allow_arrows);
          while (is("operator") && UNARY_POSTFIX.has(S.token.value) && !has_newline_before(S.token)) {
            if (val instanceof AST_Arrow)
              unexpected();
            val = make_unary(AST_UnaryPostfix, S.token, val);
            val.start = start;
            val.end = S.token;
            next();
          }
          return val;
        };
        function make_unary(ctor, token, expr) {
          var op = token.value;
          switch (op) {
            case "++":
            case "--":
              if (!is_assignable(expr))
                croak("Invalid use of " + op + " operator", token.line, token.col, token.pos);
              break;
            case "delete":
              if (expr instanceof AST_SymbolRef && S.input.has_directive("use strict"))
                croak("Calling delete on expression not allowed in strict mode", expr.start.line, expr.start.col, expr.start.pos);
              break;
          }
          return new ctor({ operator: op, expression: expr });
        }
        var expr_op = function(left, min_prec, no_in) {
          var op = is("operator") ? S.token.value : null;
          if (op == "in" && no_in)
            op = null;
          if (op == "**" && left instanceof AST_UnaryPrefix && !is_token(left.start, "punc", "(") && left.operator !== "--" && left.operator !== "++")
            unexpected(left.start);
          var prec = op != null ? PRECEDENCE[op] : null;
          if (prec != null && (prec > min_prec || op === "**" && min_prec === prec)) {
            next();
            var right = expr_ops(no_in, prec, true);
            return expr_op(new AST_Binary({
              start: left.start,
              left,
              operator: op,
              right,
              end: right.end
            }), min_prec, no_in);
          }
          return left;
        };
        function expr_ops(no_in, min_prec, allow_calls, allow_arrows) {
          if (!no_in && min_prec < PRECEDENCE["in"] && is("privatename")) {
            if (!S.in_class) {
              croak("Private field must be used in an enclosing class");
            }
            const start = S.token;
            const key2 = new AST_SymbolPrivateProperty({
              start,
              name: start.value,
              end: start
            });
            next();
            expect_token("operator", "in");
            const private_in = new AST_PrivateIn({
              start,
              key: key2,
              value: expr_ops(no_in, PRECEDENCE["in"], true),
              end: prev()
            });
            return expr_op(private_in, 0, no_in);
          } else {
            return expr_op(maybe_unary(allow_calls, allow_arrows), min_prec, no_in);
          }
        }
        var maybe_conditional = function(no_in) {
          var start = S.token;
          var expr = expr_ops(no_in, 0, true, true);
          if (is("operator", "?")) {
            next();
            var yes = expression(false);
            expect(":");
            return new AST_Conditional({
              start,
              condition: expr,
              consequent: yes,
              alternative: expression(false, no_in),
              end: prev()
            });
          }
          return expr;
        };
        function is_assignable(expr) {
          return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;
        }
        function to_destructuring(node) {
          if (node instanceof AST_Object) {
            node = new AST_Destructuring({
              start: node.start,
              names: node.properties.map(to_destructuring),
              is_array: false,
              end: node.end
            });
          } else if (node instanceof AST_Array) {
            var names = [];
            for (var i = 0; i < node.elements.length; i++) {
              if (node.elements[i] instanceof AST_Expansion) {
                if (i + 1 !== node.elements.length) {
                  token_error(node.elements[i].start, "Spread must the be last element in destructuring array");
                }
                node.elements[i].expression = to_destructuring(node.elements[i].expression);
              }
              names.push(to_destructuring(node.elements[i]));
            }
            node = new AST_Destructuring({
              start: node.start,
              names,
              is_array: true,
              end: node.end
            });
          } else if (node instanceof AST_ObjectProperty) {
            node.value = to_destructuring(node.value);
          } else if (node instanceof AST_Assign) {
            node = new AST_DefaultAssign({
              start: node.start,
              left: node.left,
              operator: "=",
              right: node.right,
              end: node.end
            });
          }
          return node;
        }
        var maybe_assign = function(no_in) {
          handle_regexp();
          var start = S.token;
          if (start.type == "name" && start.value == "yield") {
            if (is_in_generator()) {
              next();
              return _yield_expression();
            } else if (S.input.has_directive("use strict")) {
              token_error(S.token, "Unexpected yield identifier inside strict mode");
            }
          }
          var left = maybe_conditional(no_in);
          var val = S.token.value;
          if (is("operator") && ASSIGNMENT.has(val)) {
            if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {
              next();
              return new AST_Assign({
                start,
                left,
                operator: val,
                right: maybe_assign(no_in),
                logical: LOGICAL_ASSIGNMENT.has(val),
                end: prev()
              });
            }
            croak("Invalid assignment");
          }
          return left;
        };
        var to_expr_or_sequence = function(start, exprs) {
          if (exprs.length === 1) {
            return exprs[0];
          } else if (exprs.length > 1) {
            return new AST_Sequence({ start, expressions: exprs, end: peek() });
          } else {
            croak("Invalid parenthesized expression");
          }
        };
        var expression = function(commas, no_in) {
          var start = S.token;
          var exprs = [];
          while (true) {
            exprs.push(maybe_assign(no_in));
            if (!commas || !is("punc", ","))
              break;
            next();
            commas = true;
          }
          return to_expr_or_sequence(start, exprs);
        };
        function in_loop(cont) {
          ++S.in_loop;
          var ret = cont();
          --S.in_loop;
          return ret;
        }
        if (options.expression) {
          return expression(true);
        }
        return function parse_toplevel() {
          var start = S.token;
          var body = [];
          S.input.push_directives_stack();
          if (options.module)
            S.input.add_directive("use strict");
          while (!is("eof")) {
            body.push(statement());
          }
          S.input.pop_directives_stack();
          var end = prev();
          var toplevel = options.toplevel;
          if (toplevel) {
            toplevel.body = toplevel.body.concat(body);
            toplevel.end = end;
          } else {
            toplevel = new AST_Toplevel({ start, body, end });
          }
          TEMPLATE_RAWS = /* @__PURE__ */ new Map();
          return toplevel;
        }();
      }
      function DEFNODE(type, props, ctor, methods, base = AST_Node) {
        if (!props)
          props = [];
        else
          props = props.split(/\s+/);
        var self_props = props;
        if (base && base.PROPS)
          props = props.concat(base.PROPS);
        const proto = base && Object.create(base.prototype);
        if (proto) {
          ctor.prototype = proto;
          ctor.BASE = base;
        }
        if (base)
          base.SUBCLASSES.push(ctor);
        ctor.prototype.CTOR = ctor;
        ctor.prototype.constructor = ctor;
        ctor.PROPS = props || null;
        ctor.SELF_PROPS = self_props;
        ctor.SUBCLASSES = [];
        if (type) {
          ctor.prototype.TYPE = ctor.TYPE = type;
        }
        if (methods) {
          for (let i in methods)
            if (HOP(methods, i)) {
              if (i[0] === "$") {
                ctor[i.substr(1)] = methods[i];
              } else {
                ctor.prototype[i] = methods[i];
              }
            }
        }
        ctor.DEFMETHOD = function(name, method) {
          this.prototype[name] = method;
        };
        return ctor;
      }
      const has_tok_flag = (tok, flag) => Boolean(tok.flags & flag);
      const set_tok_flag = (tok, flag, truth) => {
        if (truth) {
          tok.flags |= flag;
        } else {
          tok.flags &= ~flag;
        }
      };
      const TOK_FLAG_NLB = 1;
      const TOK_FLAG_QUOTE_SINGLE = 2;
      const TOK_FLAG_QUOTE_EXISTS = 4;
      const TOK_FLAG_TEMPLATE_END = 8;
      class AST_Token {
        constructor(type, value2, line, col, pos2, nlb, comments_before, comments_after, file) {
          this.flags = nlb ? 1 : 0;
          this.type = type;
          this.value = value2;
          this.line = line;
          this.col = col;
          this.pos = pos2;
          this.comments_before = comments_before;
          this.comments_after = comments_after;
          this.file = file;
          Object.seal(this);
        }
        [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
          const special = (str) => options.stylize(str, "special");
          const quote = typeof this.value === "string" && this.value.includes("`") ? "'" : "`";
          const value2 = `${quote}${this.value}${quote}`;
          return `${special("[AST_Token")} ${value2} at ${this.line}:${this.col}${special("]")}`;
        }
        get nlb() {
          return has_tok_flag(this, TOK_FLAG_NLB);
        }
        set nlb(new_nlb) {
          set_tok_flag(this, TOK_FLAG_NLB, new_nlb);
        }
        get quote() {
          return !has_tok_flag(this, TOK_FLAG_QUOTE_EXISTS) ? "" : has_tok_flag(this, TOK_FLAG_QUOTE_SINGLE) ? "'" : '"';
        }
        set quote(quote_type) {
          set_tok_flag(this, TOK_FLAG_QUOTE_SINGLE, quote_type === "'");
          set_tok_flag(this, TOK_FLAG_QUOTE_EXISTS, !!quote_type);
        }
        get template_end() {
          return has_tok_flag(this, TOK_FLAG_TEMPLATE_END);
        }
        set template_end(new_template_end) {
          set_tok_flag(this, TOK_FLAG_TEMPLATE_END, new_template_end);
        }
      }
      var AST_Node = DEFNODE("Node", "start end", function AST_Node2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        _clone: function(deep) {
          if (deep) {
            var self2 = this.clone();
            return self2.transform(new TreeTransformer(function(node) {
              if (node !== self2) {
                return node.clone(true);
              }
            }));
          }
          return new this.CTOR(this);
        },
        clone: function(deep) {
          return this._clone(deep);
        },
        $documentation: "Base class of all AST nodes",
        $propdoc: {
          start: "[AST_Token] The first token of this node",
          end: "[AST_Token] The last token of this node"
        },
        _walk: function(visitor) {
          return visitor._visit(this);
        },
        walk: function(visitor) {
          return this._walk(visitor);
        },
        _children_backwards: () => {
        }
      }, null);
      var AST_Statement = DEFNODE("Statement", null, function AST_Statement2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class of all statements"
      });
      var AST_Debugger = DEFNODE("Debugger", null, function AST_Debugger2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Represents a debugger statement"
      }, AST_Statement);
      var AST_Directive = DEFNODE("Directive", "value quote", function AST_Directive2(props) {
        if (props) {
          this.value = props.value;
          this.quote = props.quote;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: 'Represents a directive, like "use strict";',
        $propdoc: {
          value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
          quote: "[string] the original quote character"
        }
      }, AST_Statement);
      var AST_SimpleStatement = DEFNODE("SimpleStatement", "body", function AST_SimpleStatement2(props) {
        if (props) {
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
        $propdoc: {
          body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
        }
      }, AST_Statement);
      function walk_body(node, visitor) {
        const body = node.body;
        for (var i = 0, len = body.length; i < len; i++) {
          body[i]._walk(visitor);
        }
      }
      function clone_block_scope(deep) {
        var clone = this._clone(deep);
        if (this.block_scope) {
          clone.block_scope = this.block_scope.clone();
        }
        return clone;
      }
      var AST_Block = DEFNODE("Block", "body block_scope", function AST_Block2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A body of statements (usually braced)",
        $propdoc: {
          body: "[AST_Statement*] an array of statements",
          block_scope: "[AST_Scope] the block scope"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
        },
        clone: clone_block_scope
      }, AST_Statement);
      var AST_BlockStatement = DEFNODE("BlockStatement", null, function AST_BlockStatement2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A block statement"
      }, AST_Block);
      var AST_EmptyStatement = DEFNODE("EmptyStatement", null, function AST_EmptyStatement2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The empty statement (empty block or simply a semicolon)"
      }, AST_Statement);
      var AST_StatementWithBody = DEFNODE("StatementWithBody", "body", function AST_StatementWithBody2(props) {
        if (props) {
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
        $propdoc: {
          body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
        }
      }, AST_Statement);
      var AST_LabeledStatement = DEFNODE("LabeledStatement", "label", function AST_LabeledStatement2(props) {
        if (props) {
          this.label = props.label;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Statement with a label",
        $propdoc: {
          label: "[AST_Label] a label definition"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.label._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          push2(this.label);
        },
        clone: function(deep) {
          var node = this._clone(deep);
          if (deep) {
            var label = node.label;
            var def = this.label;
            node.walk(new TreeWalker(function(node2) {
              if (node2 instanceof AST_LoopControl && node2.label && node2.label.thedef === def) {
                node2.label.thedef = label;
                label.references.push(node2);
              }
            }));
          }
          return node;
        }
      }, AST_StatementWithBody);
      var AST_IterationStatement = DEFNODE("IterationStatement", "block_scope", function AST_IterationStatement2(props) {
        if (props) {
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Internal class.  All loops inherit from it.",
        $propdoc: {
          block_scope: "[AST_Scope] the block scope for this iteration statement."
        },
        clone: clone_block_scope
      }, AST_StatementWithBody);
      var AST_DWLoop = DEFNODE("DWLoop", "condition", function AST_DWLoop2(props) {
        if (props) {
          this.condition = props.condition;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for do/while statements",
        $propdoc: {
          condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
        }
      }, AST_IterationStatement);
      var AST_Do = DEFNODE("Do", null, function AST_Do2(props) {
        if (props) {
          this.condition = props.condition;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `do` statement",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.body._walk(visitor);
            this.condition._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.condition);
          push2(this.body);
        }
      }, AST_DWLoop);
      var AST_While = DEFNODE("While", null, function AST_While2(props) {
        if (props) {
          this.condition = props.condition;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `while` statement",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.condition._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          push2(this.condition);
        }
      }, AST_DWLoop);
      var AST_For = DEFNODE("For", "init condition step", function AST_For2(props) {
        if (props) {
          this.init = props.init;
          this.condition = props.condition;
          this.step = props.step;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `for` statement",
        $propdoc: {
          init: "[AST_Node?] the `for` initialization code, or null if empty",
          condition: "[AST_Node?] the `for` termination clause, or null if empty",
          step: "[AST_Node?] the `for` update clause, or null if empty"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.init)
              this.init._walk(visitor);
            if (this.condition)
              this.condition._walk(visitor);
            if (this.step)
              this.step._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          if (this.step)
            push2(this.step);
          if (this.condition)
            push2(this.condition);
          if (this.init)
            push2(this.init);
        }
      }, AST_IterationStatement);
      var AST_ForIn = DEFNODE("ForIn", "init object", function AST_ForIn2(props) {
        if (props) {
          this.init = props.init;
          this.object = props.object;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `for ... in` statement",
        $propdoc: {
          init: "[AST_Node] the `for/in` initialization code",
          object: "[AST_Node] the object that we're looping through"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.init._walk(visitor);
            this.object._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          if (this.object)
            push2(this.object);
          if (this.init)
            push2(this.init);
        }
      }, AST_IterationStatement);
      var AST_ForOf = DEFNODE("ForOf", "await", function AST_ForOf2(props) {
        if (props) {
          this.await = props.await;
          this.init = props.init;
          this.object = props.object;
          this.block_scope = props.block_scope;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `for ... of` statement"
      }, AST_ForIn);
      var AST_With = DEFNODE("With", "expression", function AST_With2(props) {
        if (props) {
          this.expression = props.expression;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `with` statement",
        $propdoc: {
          expression: "[AST_Node] the `with` expression"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            this.body._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.body);
          push2(this.expression);
        }
      }, AST_StatementWithBody);
      var AST_Scope = DEFNODE("Scope", "variables uses_with uses_eval parent_scope enclosed cname", function AST_Scope2(props) {
        if (props) {
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for all statements introducing a lexical scope",
        $propdoc: {
          variables: "[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
          uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
          uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
          parent_scope: "[AST_Scope?/S] link to the parent scope",
          enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
          cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
        },
        get_defun_scope: function() {
          var self2 = this;
          while (self2.is_block_scope()) {
            self2 = self2.parent_scope;
          }
          return self2;
        },
        clone: function(deep, toplevel) {
          var node = this._clone(deep);
          if (deep && this.variables && toplevel && !this._block_scope) {
            node.figure_out_scope({}, {
              toplevel,
              parent_scope: this.parent_scope
            });
          } else {
            if (this.variables)
              node.variables = new Map(this.variables);
            if (this.enclosed)
              node.enclosed = this.enclosed.slice();
            if (this._block_scope)
              node._block_scope = this._block_scope;
          }
          return node;
        },
        pinned: function() {
          return this.uses_eval || this.uses_with;
        }
      }, AST_Block);
      var AST_Toplevel = DEFNODE("Toplevel", "globals", function AST_Toplevel2(props) {
        if (props) {
          this.globals = props.globals;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The toplevel scope",
        $propdoc: {
          globals: "[Map/S] a map of name -> SymbolDef for all undeclared names"
        },
        wrap_commonjs: function(name) {
          var body = this.body;
          var wrapped_tl = "(function(exports){'$ORIG';})(typeof " + name + "=='undefined'?(" + name + "={}):" + name + ");";
          wrapped_tl = parse2(wrapped_tl);
          wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {
            if (node instanceof AST_Directive && node.value == "$ORIG") {
              return MAP.splice(body);
            }
          }));
          return wrapped_tl;
        },
        wrap_enclose: function(args_values) {
          if (typeof args_values != "string")
            args_values = "";
          var index = args_values.indexOf(":");
          if (index < 0)
            index = args_values.length;
          var body = this.body;
          return parse2([
            "(function(",
            args_values.slice(0, index),
            '){"$ORIG"})(',
            args_values.slice(index + 1),
            ")"
          ].join("")).transform(new TreeTransformer(function(node) {
            if (node instanceof AST_Directive && node.value == "$ORIG") {
              return MAP.splice(body);
            }
          }));
        }
      }, AST_Scope);
      var AST_Expansion = DEFNODE("Expansion", "expression", function AST_Expansion2(props) {
        if (props) {
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",
        $propdoc: {
          expression: "[AST_Node] the thing to be expanded"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression.walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments is_generator async", function AST_Lambda2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for functions",
        $propdoc: {
          name: "[AST_SymbolDeclaration?] the name of this function",
          argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",
          uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
          is_generator: "[boolean] is this a generator method",
          async: "[boolean] is this method async"
        },
        args_as_names: function() {
          var out = [];
          for (var i = 0; i < this.argnames.length; i++) {
            if (this.argnames[i] instanceof AST_Destructuring) {
              out.push(...this.argnames[i].all_symbols());
            } else {
              out.push(this.argnames[i]);
            }
          }
          return out;
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.name)
              this.name._walk(visitor);
            var argnames = this.argnames;
            for (var i = 0, len = argnames.length; i < len; i++) {
              argnames[i]._walk(visitor);
            }
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          i = this.argnames.length;
          while (i--)
            push2(this.argnames[i]);
          if (this.name)
            push2(this.name);
        },
        is_braceless() {
          return this.body[0] instanceof AST_Return && this.body[0].value;
        },
        length_property() {
          let length = 0;
          for (const arg of this.argnames) {
            if (arg instanceof AST_SymbolFunarg || arg instanceof AST_Destructuring) {
              length++;
            }
          }
          return length;
        }
      }, AST_Scope);
      var AST_Accessor = DEFNODE("Accessor", null, function AST_Accessor2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A setter/getter function.  The `name` property is always null."
      }, AST_Lambda);
      var AST_Function = DEFNODE("Function", null, function AST_Function2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A function expression"
      }, AST_Lambda);
      var AST_Arrow = DEFNODE("Arrow", null, function AST_Arrow2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An ES6 Arrow function ((a) => b)"
      }, AST_Lambda);
      var AST_Defun = DEFNODE("Defun", null, function AST_Defun2(props) {
        if (props) {
          this.name = props.name;
          this.argnames = props.argnames;
          this.uses_arguments = props.uses_arguments;
          this.is_generator = props.is_generator;
          this.async = props.async;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A function definition"
      }, AST_Lambda);
      var AST_Destructuring = DEFNODE("Destructuring", "names is_array", function AST_Destructuring2(props) {
        if (props) {
          this.names = props.names;
          this.is_array = props.is_array;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
        $propdoc: {
          "names": "[AST_Node*] Array of properties or elements",
          "is_array": "[Boolean] Whether the destructuring represents an object or array"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.names.forEach(function(name) {
              name._walk(visitor);
            });
          });
        },
        _children_backwards(push2) {
          let i = this.names.length;
          while (i--)
            push2(this.names[i]);
        },
        all_symbols: function() {
          var out = [];
          walk(this, (node) => {
            if (node instanceof AST_SymbolDeclaration) {
              out.push(node);
            }
            if (node instanceof AST_Lambda) {
              return true;
            }
          });
          return out;
        }
      });
      var AST_PrefixedTemplateString = DEFNODE("PrefixedTemplateString", "template_string prefix", function AST_PrefixedTemplateString2(props) {
        if (props) {
          this.template_string = props.template_string;
          this.prefix = props.prefix;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
        $propdoc: {
          template_string: "[AST_TemplateString] The template string",
          prefix: "[AST_Node] The prefix, which will get called."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.prefix._walk(visitor);
            this.template_string._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.template_string);
          push2(this.prefix);
        }
      });
      var AST_TemplateString = DEFNODE("TemplateString", "segments", function AST_TemplateString2(props) {
        if (props) {
          this.segments = props.segments;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A template string literal",
        $propdoc: {
          segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.segments.forEach(function(seg) {
              seg._walk(visitor);
            });
          });
        },
        _children_backwards(push2) {
          let i = this.segments.length;
          while (i--)
            push2(this.segments[i]);
        }
      });
      var AST_TemplateSegment = DEFNODE("TemplateSegment", "value raw", function AST_TemplateSegment2(props) {
        if (props) {
          this.value = props.value;
          this.raw = props.raw;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A segment of a template string literal",
        $propdoc: {
          value: "Content of the segment",
          raw: "Raw source of the segment"
        }
      });
      var AST_Jump = DEFNODE("Jump", null, function AST_Jump2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)"
      }, AST_Statement);
      var AST_Exit = DEFNODE("Exit", "value", function AST_Exit2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for \u201Cexits\u201D (`return` and `throw`)",
        $propdoc: {
          value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
        },
        _walk: function(visitor) {
          return visitor._visit(this, this.value && function() {
            this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value)
            push2(this.value);
        }
      }, AST_Jump);
      var AST_Return = DEFNODE("Return", null, function AST_Return2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `return` statement"
      }, AST_Exit);
      var AST_Throw = DEFNODE("Throw", null, function AST_Throw2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `throw` statement"
      }, AST_Exit);
      var AST_LoopControl = DEFNODE("LoopControl", "label", function AST_LoopControl2(props) {
        if (props) {
          this.label = props.label;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for loop control statements (`break` and `continue`)",
        $propdoc: {
          label: "[AST_LabelRef?] the label, or null if none"
        },
        _walk: function(visitor) {
          return visitor._visit(this, this.label && function() {
            this.label._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.label)
            push2(this.label);
        }
      }, AST_Jump);
      var AST_Break = DEFNODE("Break", null, function AST_Break2(props) {
        if (props) {
          this.label = props.label;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `break` statement"
      }, AST_LoopControl);
      var AST_Continue = DEFNODE("Continue", null, function AST_Continue2(props) {
        if (props) {
          this.label = props.label;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `continue` statement"
      }, AST_LoopControl);
      var AST_Await = DEFNODE("Await", "expression", function AST_Await2(props) {
        if (props) {
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `await` statement",
        $propdoc: {
          expression: "[AST_Node] the mandatory expression being awaited"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_Yield = DEFNODE("Yield", "expression is_star", function AST_Yield2(props) {
        if (props) {
          this.expression = props.expression;
          this.is_star = props.is_star;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `yield` statement",
        $propdoc: {
          expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",
          is_star: "[Boolean] Whether this is a yield or yield* statement"
        },
        _walk: function(visitor) {
          return visitor._visit(this, this.expression && function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.expression)
            push2(this.expression);
        }
      });
      var AST_If = DEFNODE("If", "condition alternative", function AST_If2(props) {
        if (props) {
          this.condition = props.condition;
          this.alternative = props.alternative;
          this.body = props.body;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `if` statement",
        $propdoc: {
          condition: "[AST_Node] the `if` condition",
          alternative: "[AST_Statement?] the `else` part, or null if not present"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.condition._walk(visitor);
            this.body._walk(visitor);
            if (this.alternative)
              this.alternative._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.alternative) {
            push2(this.alternative);
          }
          push2(this.body);
          push2(this.condition);
        }
      }, AST_StatementWithBody);
      var AST_Switch = DEFNODE("Switch", "expression", function AST_Switch2(props) {
        if (props) {
          this.expression = props.expression;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `switch` statement",
        $propdoc: {
          expression: "[AST_Node] the `switch` \u201Cdiscriminant\u201D"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          push2(this.expression);
        }
      }, AST_Block);
      var AST_SwitchBranch = DEFNODE("SwitchBranch", null, function AST_SwitchBranch2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for `switch` branches"
      }, AST_Block);
      var AST_Default = DEFNODE("Default", null, function AST_Default2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `default` switch branch"
      }, AST_SwitchBranch);
      var AST_Case = DEFNODE("Case", "expression", function AST_Case2(props) {
        if (props) {
          this.expression = props.expression;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `case` switch branch",
        $propdoc: {
          expression: "[AST_Node] the `case` expression"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          push2(this.expression);
        }
      }, AST_SwitchBranch);
      var AST_Try = DEFNODE("Try", "body bcatch bfinally", function AST_Try2(props) {
        if (props) {
          this.body = props.body;
          this.bcatch = props.bcatch;
          this.bfinally = props.bfinally;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `try` statement",
        $propdoc: {
          body: "[AST_TryBlock] the try block",
          bcatch: "[AST_Catch?] the catch block, or null if not present",
          bfinally: "[AST_Finally?] the finally block, or null if not present"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.body._walk(visitor);
            if (this.bcatch)
              this.bcatch._walk(visitor);
            if (this.bfinally)
              this.bfinally._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.bfinally)
            push2(this.bfinally);
          if (this.bcatch)
            push2(this.bcatch);
          push2(this.body);
        }
      }, AST_Statement);
      var AST_TryBlock = DEFNODE("TryBlock", null, function AST_TryBlock2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `try` block of a try statement"
      }, AST_Block);
      var AST_Catch = DEFNODE("Catch", "argname", function AST_Catch2(props) {
        if (props) {
          this.argname = props.argname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `catch` node; only makes sense as part of a `try` statement",
        $propdoc: {
          argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.argname)
              this.argname._walk(visitor);
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
          if (this.argname)
            push2(this.argname);
        }
      }, AST_Block);
      var AST_Finally = DEFNODE("Finally", null, function AST_Finally2(props) {
        if (props) {
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `finally` node; only makes sense as part of a `try` statement"
      }, AST_Block);
      var AST_Definitions = DEFNODE("Definitions", "definitions", function AST_Definitions2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
        $propdoc: {
          definitions: "[AST_VarDef*] array of variable definitions"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            var definitions = this.definitions;
            for (var i = 0, len = definitions.length; i < len; i++) {
              definitions[i]._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          let i = this.definitions.length;
          while (i--)
            push2(this.definitions[i]);
        }
      }, AST_Statement);
      var AST_Var = DEFNODE("Var", null, function AST_Var2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `var` statement"
      }, AST_Definitions);
      var AST_Let = DEFNODE("Let", null, function AST_Let2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `let` statement"
      }, AST_Definitions);
      var AST_Const = DEFNODE("Const", null, function AST_Const2(props) {
        if (props) {
          this.definitions = props.definitions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A `const` statement"
      }, AST_Definitions);
      var AST_VarDef = DEFNODE("VarDef", "name value", function AST_VarDef2(props) {
        if (props) {
          this.name = props.name;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A variable declaration; only appears in a AST_Definitions node",
        $propdoc: {
          name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
          value: "[AST_Node?] initializer, or null of there's no initializer"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.name._walk(visitor);
            if (this.value)
              this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value)
            push2(this.value);
          push2(this.name);
        },
        declarations_as_names() {
          if (this.name instanceof AST_SymbolDeclaration) {
            return [this];
          } else {
            return this.name.all_symbols();
          }
        }
      });
      var AST_NameMapping = DEFNODE("NameMapping", "foreign_name name", function AST_NameMapping2(props) {
        if (props) {
          this.foreign_name = props.foreign_name;
          this.name = props.name;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The part of the export/import statement that declare names from a module.",
        $propdoc: {
          foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
          name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.foreign_name._walk(visitor);
            this.name._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.name);
          push2(this.foreign_name);
        }
      });
      var AST_Import = DEFNODE("Import", "imported_name imported_names module_name attributes", function AST_Import2(props) {
        if (props) {
          this.imported_name = props.imported_name;
          this.imported_names = props.imported_names;
          this.module_name = props.module_name;
          this.attributes = props.attributes;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `import` statement",
        $propdoc: {
          imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
          imported_names: "[AST_NameMapping*] The names of non-default imported variables",
          module_name: "[AST_String] String literal describing where this module came from",
          attributes: "[AST_Object?] The import attributes (with {...})"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.imported_name) {
              this.imported_name._walk(visitor);
            }
            if (this.imported_names) {
              this.imported_names.forEach(function(name_import) {
                name_import._walk(visitor);
              });
            }
            this.module_name._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.module_name);
          if (this.imported_names) {
            let i = this.imported_names.length;
            while (i--)
              push2(this.imported_names[i]);
          }
          if (this.imported_name)
            push2(this.imported_name);
        }
      });
      var AST_ImportMeta = DEFNODE("ImportMeta", null, function AST_ImportMeta2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A reference to import.meta"
      });
      var AST_Export = DEFNODE("Export", "exported_definition exported_value is_default exported_names module_name attributes", function AST_Export2(props) {
        if (props) {
          this.exported_definition = props.exported_definition;
          this.exported_value = props.exported_value;
          this.is_default = props.is_default;
          this.exported_names = props.exported_names;
          this.module_name = props.module_name;
          this.attributes = props.attributes;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `export` statement",
        $propdoc: {
          exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
          exported_value: "[AST_Node?] An exported value",
          exported_names: "[AST_NameMapping*?] List of exported names",
          module_name: "[AST_String?] Name of the file to load exports from",
          is_default: "[Boolean] Whether this is the default exported value of this module",
          attributes: "[AST_Object?] The import attributes"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.exported_definition) {
              this.exported_definition._walk(visitor);
            }
            if (this.exported_value) {
              this.exported_value._walk(visitor);
            }
            if (this.exported_names) {
              this.exported_names.forEach(function(name_export) {
                name_export._walk(visitor);
              });
            }
            if (this.module_name) {
              this.module_name._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          if (this.module_name)
            push2(this.module_name);
          if (this.exported_names) {
            let i = this.exported_names.length;
            while (i--)
              push2(this.exported_names[i]);
          }
          if (this.exported_value)
            push2(this.exported_value);
          if (this.exported_definition)
            push2(this.exported_definition);
        }
      }, AST_Statement);
      var AST_Call = DEFNODE("Call", "expression args optional _annotations", function AST_Call2(props) {
        if (props) {
          this.expression = props.expression;
          this.args = props.args;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
          this.initialize();
        }
        this.flags = 0;
      }, {
        $documentation: "A function call expression",
        $propdoc: {
          expression: "[AST_Node] expression to invoke as function",
          args: "[AST_Node*] array of arguments",
          optional: "[boolean] whether this is an optional call (IE ?.() )",
          _annotations: "[number] bitfield containing information about the call"
        },
        initialize() {
          if (this._annotations == null)
            this._annotations = 0;
        },
        _walk(visitor) {
          return visitor._visit(this, function() {
            var args = this.args;
            for (var i = 0, len = args.length; i < len; i++) {
              args[i]._walk(visitor);
            }
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.args.length;
          while (i--)
            push2(this.args[i]);
          push2(this.expression);
        }
      });
      var AST_New = DEFNODE("New", null, function AST_New2(props) {
        if (props) {
          this.expression = props.expression;
          this.args = props.args;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
          this.initialize();
        }
        this.flags = 0;
      }, {
        $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
      }, AST_Call);
      var AST_Sequence = DEFNODE("Sequence", "expressions", function AST_Sequence2(props) {
        if (props) {
          this.expressions = props.expressions;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A sequence expression (comma-separated expressions)",
        $propdoc: {
          expressions: "[AST_Node*] array of expressions (at least two)"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expressions.forEach(function(node) {
              node._walk(visitor);
            });
          });
        },
        _children_backwards(push2) {
          let i = this.expressions.length;
          while (i--)
            push2(this.expressions[i]);
        }
      });
      var AST_PropAccess = DEFNODE("PropAccess", "expression property optional", function AST_PropAccess2(props) {
        if (props) {
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
        $propdoc: {
          expression: "[AST_Node] the \u201Ccontainer\u201D expression",
          property: "[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",
          optional: "[boolean] whether this is an optional property access (IE ?.)"
        }
      });
      var AST_Dot = DEFNODE("Dot", "quote", function AST_Dot2(props) {
        if (props) {
          this.quote = props.quote;
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A dotted property access expression",
        $propdoc: {
          quote: "[string] the original quote character when transformed from AST_Sub"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      }, AST_PropAccess);
      var AST_DotHash = DEFNODE("DotHash", "", function AST_DotHash2(props) {
        if (props) {
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A dotted property access to a private property",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      }, AST_PropAccess);
      var AST_Sub = DEFNODE("Sub", null, function AST_Sub2(props) {
        if (props) {
          this.expression = props.expression;
          this.property = props.property;
          this.optional = props.optional;
          this._annotations = props._annotations;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: 'Index-style property access, i.e. `a["foo"]`',
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
            this.property._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.property);
          push2(this.expression);
        }
      }, AST_PropAccess);
      var AST_Chain = DEFNODE("Chain", "expression", function AST_Chain2(props) {
        if (props) {
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A chain expression like a?.b?.(c)?.[d]",
        $propdoc: {
          expression: "[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_Unary = DEFNODE("Unary", "operator expression", function AST_Unary2(props) {
        if (props) {
          this.operator = props.operator;
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for unary expressions",
        $propdoc: {
          operator: "[string] the operator",
          expression: "[AST_Node] expression that this unary operator applies to"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.expression._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.expression);
        }
      });
      var AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, function AST_UnaryPrefix2(props) {
        if (props) {
          this.operator = props.operator;
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
      }, AST_Unary);
      var AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, function AST_UnaryPostfix2(props) {
        if (props) {
          this.operator = props.operator;
          this.expression = props.expression;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Unary postfix expression, i.e. `i++`"
      }, AST_Unary);
      var AST_Binary = DEFNODE("Binary", "operator left right", function AST_Binary2(props) {
        if (props) {
          this.operator = props.operator;
          this.left = props.left;
          this.right = props.right;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Binary expression, i.e. `a + b`",
        $propdoc: {
          left: "[AST_Node] left-hand side expression",
          operator: "[string] the operator",
          right: "[AST_Node] right-hand side expression"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.left._walk(visitor);
            this.right._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.right);
          push2(this.left);
        }
      });
      var AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", function AST_Conditional2(props) {
        if (props) {
          this.condition = props.condition;
          this.consequent = props.consequent;
          this.alternative = props.alternative;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
        $propdoc: {
          condition: "[AST_Node]",
          consequent: "[AST_Node]",
          alternative: "[AST_Node]"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.condition._walk(visitor);
            this.consequent._walk(visitor);
            this.alternative._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.alternative);
          push2(this.consequent);
          push2(this.condition);
        }
      });
      var AST_Assign = DEFNODE("Assign", "logical", function AST_Assign2(props) {
        if (props) {
          this.logical = props.logical;
          this.operator = props.operator;
          this.left = props.left;
          this.right = props.right;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An assignment expression \u2014 `a = b + 5`",
        $propdoc: {
          logical: "Whether it's a logical assignment"
        }
      }, AST_Binary);
      var AST_DefaultAssign = DEFNODE("DefaultAssign", null, function AST_DefaultAssign2(props) {
        if (props) {
          this.operator = props.operator;
          this.left = props.left;
          this.right = props.right;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A default assignment expression like in `(a = 3) => a`"
      }, AST_Binary);
      var AST_Array = DEFNODE("Array", "elements", function AST_Array2(props) {
        if (props) {
          this.elements = props.elements;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An array literal",
        $propdoc: {
          elements: "[AST_Node*] array of elements"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            var elements = this.elements;
            for (var i = 0, len = elements.length; i < len; i++) {
              elements[i]._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          let i = this.elements.length;
          while (i--)
            push2(this.elements[i]);
        }
      });
      var AST_Object = DEFNODE("Object", "properties", function AST_Object2(props) {
        if (props) {
          this.properties = props.properties;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An object literal",
        $propdoc: {
          properties: "[AST_ObjectProperty*] array of properties"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            var properties = this.properties;
            for (var i = 0, len = properties.length; i < len; i++) {
              properties[i]._walk(visitor);
            }
          });
        },
        _children_backwards(push2) {
          let i = this.properties.length;
          while (i--)
            push2(this.properties[i]);
        }
      });
      var AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", function AST_ObjectProperty2(props) {
        if (props) {
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for literal object properties",
        $propdoc: {
          key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",
          value: "[AST_Node] property value.  For getters, setters and methods this is an AST_Accessor."
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.key instanceof AST_Node)
              this.key._walk(visitor);
            this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.value);
          if (this.key instanceof AST_Node)
            push2(this.key);
        }
      });
      var AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", "quote", function AST_ObjectKeyVal2(props) {
        if (props) {
          this.quote = props.quote;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "A key: value object property",
        $propdoc: {
          quote: "[string] the original quote character"
        },
        computed_key() {
          return this.key instanceof AST_Node;
        }
      }, AST_ObjectProperty);
      var AST_PrivateSetter = DEFNODE("PrivateSetter", "static", function AST_PrivateSetter2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          static: "[boolean] whether this is a static private setter"
        },
        $documentation: "A private setter property",
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_PrivateGetter = DEFNODE("PrivateGetter", "static", function AST_PrivateGetter2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          static: "[boolean] whether this is a static private getter"
        },
        $documentation: "A private getter property",
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_ObjectSetter = DEFNODE("ObjectSetter", "quote static", function AST_ObjectSetter2(props) {
        if (props) {
          this.quote = props.quote;
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] whether this is a static setter (classes only)"
        },
        $documentation: "An object setter property",
        computed_key() {
          return !(this.key instanceof AST_SymbolMethod);
        }
      }, AST_ObjectProperty);
      var AST_ObjectGetter = DEFNODE("ObjectGetter", "quote static", function AST_ObjectGetter2(props) {
        if (props) {
          this.quote = props.quote;
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] whether this is a static getter (classes only)"
        },
        $documentation: "An object getter property",
        computed_key() {
          return !(this.key instanceof AST_SymbolMethod);
        }
      }, AST_ObjectProperty);
      var AST_ConciseMethod = DEFNODE("ConciseMethod", "quote static", function AST_ConciseMethod2(props) {
        if (props) {
          this.quote = props.quote;
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          quote: "[string|undefined] the original quote character, if any",
          static: "[boolean] is this method static (classes only)"
        },
        $documentation: "An ES6 concise method inside an object or class",
        computed_key() {
          return !(this.key instanceof AST_SymbolMethod);
        }
      }, AST_ObjectProperty);
      var AST_PrivateMethod = DEFNODE("PrivateMethod", "static", function AST_PrivateMethod2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A private class method inside a class",
        $propdoc: {
          static: "[boolean] is this a static private method"
        },
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_Class = DEFNODE("Class", "name extends properties", function AST_Class2(props) {
        if (props) {
          this.name = props.name;
          this.extends = props.extends;
          this.properties = props.properties;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
          extends: "[AST_Node]? optional parent class",
          properties: "[AST_ObjectProperty|AST_ClassStaticBlock]* array of properties or static blocks"
        },
        $documentation: "An ES6 class",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.name) {
              this.name._walk(visitor);
            }
            if (this.extends) {
              this.extends._walk(visitor);
            }
            this.properties.forEach((prop) => prop._walk(visitor));
          });
        },
        _children_backwards(push2) {
          let i = this.properties.length;
          while (i--)
            push2(this.properties[i]);
          if (this.extends)
            push2(this.extends);
          if (this.name)
            push2(this.name);
        },
        visit_nondeferred_class_parts(visitor) {
          if (this.extends) {
            this.extends._walk(visitor);
          }
          this.properties.forEach((prop) => {
            if (prop instanceof AST_ClassStaticBlock) {
              prop._walk(visitor);
              return;
            }
            if (prop.computed_key()) {
              visitor.push(prop);
              prop.key._walk(visitor);
              visitor.pop();
            }
            if (prop instanceof AST_ClassPrivateProperty && prop.static && prop.value || prop instanceof AST_ClassProperty && prop.static && prop.value) {
              visitor.push(prop);
              prop.value._walk(visitor);
              visitor.pop();
            }
          });
        },
        visit_deferred_class_parts(visitor) {
          this.properties.forEach((prop) => {
            if (prop instanceof AST_ConciseMethod || prop instanceof AST_PrivateMethod) {
              prop.walk(visitor);
            } else if (prop instanceof AST_ClassProperty && !prop.static && prop.value || prop instanceof AST_ClassPrivateProperty && !prop.static && prop.value) {
              visitor.push(prop);
              prop.value._walk(visitor);
              visitor.pop();
            }
          });
        },
        is_self_referential: function() {
          const this_id = this.name && this.name.definition().id;
          let found = false;
          let class_this = true;
          this.visit_nondeferred_class_parts(new TreeWalker((node, descend) => {
            if (found)
              return true;
            if (node instanceof AST_This)
              return found = class_this;
            if (node instanceof AST_SymbolRef)
              return found = node.definition().id === this_id;
            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
              const class_this_save = class_this;
              class_this = false;
              descend();
              class_this = class_this_save;
              return true;
            }
          }));
          return found;
        }
      }, AST_Scope);
      var AST_ClassProperty = DEFNODE("ClassProperty", "static quote", function AST_ClassProperty2(props) {
        if (props) {
          this.static = props.static;
          this.quote = props.quote;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "A class property",
        $propdoc: {
          static: "[boolean] whether this is a static key",
          quote: "[string] which quote is being used"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.key instanceof AST_Node)
              this.key._walk(visitor);
            if (this.value instanceof AST_Node)
              this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value instanceof AST_Node)
            push2(this.value);
          if (this.key instanceof AST_Node)
            push2(this.key);
        },
        computed_key() {
          return !(this.key instanceof AST_SymbolClassProperty);
        }
      }, AST_ObjectProperty);
      var AST_ClassPrivateProperty = DEFNODE("ClassPrivateProperty", "", function AST_ClassPrivateProperty2(props) {
        if (props) {
          this.static = props.static;
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A class property for a private property",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            if (this.value instanceof AST_Node)
              this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          if (this.value instanceof AST_Node)
            push2(this.value);
        },
        computed_key() {
          return false;
        }
      }, AST_ObjectProperty);
      var AST_PrivateIn = DEFNODE("PrivateIn", "key value", function AST_PrivateIn2(props) {
        if (props) {
          this.key = props.key;
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "An `in` binop when the key is private, eg #x in this",
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            this.key._walk(visitor);
            this.value._walk(visitor);
          });
        },
        _children_backwards(push2) {
          push2(this.value);
          push2(this.key);
        }
      });
      var AST_DefClass = DEFNODE("DefClass", null, function AST_DefClass2(props) {
        if (props) {
          this.name = props.name;
          this.extends = props.extends;
          this.properties = props.properties;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A class definition"
      }, AST_Class);
      var AST_ClassStaticBlock = DEFNODE("ClassStaticBlock", "body block_scope", function AST_ClassStaticBlock2(props) {
        this.body = props.body;
        this.block_scope = props.block_scope;
        this.start = props.start;
        this.end = props.end;
      }, {
        $documentation: "A block containing statements to be executed in the context of the class",
        $propdoc: {
          body: "[AST_Statement*] an array of statements"
        },
        _walk: function(visitor) {
          return visitor._visit(this, function() {
            walk_body(this, visitor);
          });
        },
        _children_backwards(push2) {
          let i = this.body.length;
          while (i--)
            push2(this.body[i]);
        },
        clone: clone_block_scope,
        computed_key() {
          return false;
        }
      }, AST_Scope);
      var AST_ClassExpression = DEFNODE("ClassExpression", null, function AST_ClassExpression2(props) {
        if (props) {
          this.name = props.name;
          this.extends = props.extends;
          this.properties = props.properties;
          this.variables = props.variables;
          this.uses_with = props.uses_with;
          this.uses_eval = props.uses_eval;
          this.parent_scope = props.parent_scope;
          this.enclosed = props.enclosed;
          this.cname = props.cname;
          this.body = props.body;
          this.block_scope = props.block_scope;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A class expression."
      }, AST_Class);
      var AST_Symbol = DEFNODE("Symbol", "scope name thedef", function AST_Symbol2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $propdoc: {
          name: "[string] name of this symbol",
          scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
          thedef: "[SymbolDef/S] the definition of this symbol"
        },
        $documentation: "Base class for all symbols"
      });
      var AST_NewTarget = DEFNODE("NewTarget", null, function AST_NewTarget2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A reference to new.target"
      });
      var AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", function AST_SymbolDeclaration2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"
      }, AST_Symbol);
      var AST_SymbolVar = DEFNODE("SymbolVar", null, function AST_SymbolVar2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol defining a variable"
      }, AST_SymbolDeclaration);
      var AST_SymbolBlockDeclaration = DEFNODE("SymbolBlockDeclaration", null, function AST_SymbolBlockDeclaration2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for block-scoped declaration symbols"
      }, AST_SymbolDeclaration);
      var AST_SymbolConst = DEFNODE("SymbolConst", null, function AST_SymbolConst2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A constant declaration"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolLet = DEFNODE("SymbolLet", null, function AST_SymbolLet2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A block-scoped `let` declaration"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, function AST_SymbolFunarg2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a function argument"
      }, AST_SymbolVar);
      var AST_SymbolDefun = DEFNODE("SymbolDefun", null, function AST_SymbolDefun2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol defining a function"
      }, AST_SymbolDeclaration);
      var AST_SymbolMethod = DEFNODE("SymbolMethod", null, function AST_SymbolMethod2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol in an object defining a method"
      }, AST_Symbol);
      var AST_SymbolClassProperty = DEFNODE("SymbolClassProperty", null, function AST_SymbolClassProperty2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol for a class property"
      }, AST_Symbol);
      var AST_SymbolLambda = DEFNODE("SymbolLambda", null, function AST_SymbolLambda2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a function expression"
      }, AST_SymbolDeclaration);
      var AST_SymbolDefClass = DEFNODE("SymbolDefClass", null, function AST_SymbolDefClass2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolClass = DEFNODE("SymbolClass", null, function AST_SymbolClass2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a class's name. Lexically scoped to the class."
      }, AST_SymbolDeclaration);
      var AST_SymbolCatch = DEFNODE("SymbolCatch", null, function AST_SymbolCatch2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming the exception in catch"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolImport = DEFNODE("SymbolImport", null, function AST_SymbolImport2(props) {
        if (props) {
          this.init = props.init;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol referring to an imported name"
      }, AST_SymbolBlockDeclaration);
      var AST_SymbolImportForeign = DEFNODE("SymbolImportForeign", "quote", function AST_SymbolImportForeign2(props) {
        if (props) {
          this.quote = props.quote;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"
      }, AST_Symbol);
      var AST_Label = DEFNODE("Label", "references", function AST_Label2(props) {
        if (props) {
          this.references = props.references;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
          this.initialize();
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol naming a label (declaration)",
        $propdoc: {
          references: "[AST_LoopControl*] a list of nodes referring to this label"
        },
        initialize: function() {
          this.references = [];
          this.thedef = this;
        }
      }, AST_Symbol);
      var AST_SymbolRef = DEFNODE("SymbolRef", null, function AST_SymbolRef2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Reference to some symbol (not definition/declaration)"
      }, AST_Symbol);
      var AST_SymbolExport = DEFNODE("SymbolExport", "quote", function AST_SymbolExport2(props) {
        if (props) {
          this.quote = props.quote;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Symbol referring to a name to export"
      }, AST_SymbolRef);
      var AST_SymbolExportForeign = DEFNODE("SymbolExportForeign", "quote", function AST_SymbolExportForeign2(props) {
        if (props) {
          this.quote = props.quote;
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"
      }, AST_Symbol);
      var AST_LabelRef = DEFNODE("LabelRef", null, function AST_LabelRef2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Reference to a label symbol"
      }, AST_Symbol);
      var AST_SymbolPrivateProperty = DEFNODE("SymbolPrivateProperty", null, function AST_SymbolPrivateProperty2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A symbol that refers to a private property"
      }, AST_Symbol);
      var AST_This = DEFNODE("This", null, function AST_This2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `this` symbol"
      }, AST_Symbol);
      var AST_Super = DEFNODE("Super", null, function AST_Super2(props) {
        if (props) {
          this.scope = props.scope;
          this.name = props.name;
          this.thedef = props.thedef;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `super` symbol"
      }, AST_This);
      var AST_Constant = DEFNODE("Constant", null, function AST_Constant2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for all constants",
        getValue: function() {
          return this.value;
        }
      });
      var AST_String = DEFNODE("String", "value quote", function AST_String2(props) {
        if (props) {
          this.value = props.value;
          this.quote = props.quote;
          this.start = props.start;
          this.end = props.end;
          this._annotations = props._annotations;
        }
        this.flags = 0;
      }, {
        $documentation: "A string literal",
        $propdoc: {
          value: "[string] the contents of this string",
          quote: "[string] the original quote character"
        }
      }, AST_Constant);
      var AST_Number = DEFNODE("Number", "value raw", function AST_Number2(props) {
        if (props) {
          this.value = props.value;
          this.raw = props.raw;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A number literal",
        $propdoc: {
          value: "[number] the numeric value",
          raw: "[string] numeric value as string"
        }
      }, AST_Constant);
      var AST_BigInt = DEFNODE("BigInt", "value raw", function AST_BigInt2(props) {
        if (props) {
          this.value = props.value;
          this.raw = props.raw;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A big int literal",
        $propdoc: {
          value: "[string] big int value, represented as a string",
          raw: "[string] the original format preserved"
        }
      }, AST_Constant);
      var AST_RegExp = DEFNODE("RegExp", "value", function AST_RegExp2(props) {
        if (props) {
          this.value = props.value;
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A regexp literal",
        $propdoc: {
          value: "[RegExp] the actual regexp"
        }
      }, AST_Constant);
      var AST_Atom = DEFNODE("Atom", null, function AST_Atom2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for atoms"
      }, AST_Constant);
      var AST_Null = DEFNODE("Null", null, function AST_Null2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `null` atom",
        value: null
      }, AST_Atom);
      var AST_NaN = DEFNODE("NaN", null, function AST_NaN2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The impossible value",
        value: 0 / 0
      }, AST_Atom);
      var AST_Undefined = DEFNODE("Undefined", null, function AST_Undefined2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `undefined` value",
        value: function() {
        }()
      }, AST_Atom);
      var AST_Hole = DEFNODE("Hole", null, function AST_Hole2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "A hole in an array",
        value: function() {
        }()
      }, AST_Atom);
      var AST_Infinity = DEFNODE("Infinity", null, function AST_Infinity2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `Infinity` value",
        value: 1 / 0
      }, AST_Atom);
      var AST_Boolean = DEFNODE("Boolean", null, function AST_Boolean2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "Base class for booleans"
      }, AST_Atom);
      var AST_False = DEFNODE("False", null, function AST_False2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `false` atom",
        value: false
      }, AST_Boolean);
      var AST_True = DEFNODE("True", null, function AST_True2(props) {
        if (props) {
          this.start = props.start;
          this.end = props.end;
        }
        this.flags = 0;
      }, {
        $documentation: "The `true` atom",
        value: true
      }, AST_Boolean);
      function walk(node, cb, to_visit = [node]) {
        const push2 = to_visit.push.bind(to_visit);
        while (to_visit.length) {
          const node2 = to_visit.pop();
          const ret = cb(node2, to_visit);
          if (ret) {
            if (ret === walk_abort)
              return true;
            continue;
          }
          node2._children_backwards(push2);
        }
        return false;
      }
      function walk_parent(node, cb, initial_stack) {
        const to_visit = [node];
        const push2 = to_visit.push.bind(to_visit);
        const stack = initial_stack ? initial_stack.slice() : [];
        const parent_pop_indices = [];
        let current;
        const info = {
          parent: (n2 = 0) => {
            if (n2 === -1) {
              return current;
            }
            if (initial_stack && n2 >= stack.length) {
              n2 -= stack.length;
              return initial_stack[initial_stack.length - (n2 + 1)];
            }
            return stack[stack.length - (1 + n2)];
          }
        };
        while (to_visit.length) {
          current = to_visit.pop();
          while (parent_pop_indices.length && to_visit.length == parent_pop_indices[parent_pop_indices.length - 1]) {
            stack.pop();
            parent_pop_indices.pop();
          }
          const ret = cb(current, info);
          if (ret) {
            if (ret === walk_abort)
              return true;
            continue;
          }
          const visit_length = to_visit.length;
          current._children_backwards(push2);
          if (to_visit.length > visit_length) {
            stack.push(current);
            parent_pop_indices.push(visit_length - 1);
          }
        }
        return false;
      }
      const walk_abort = Symbol("abort walk");
      class TreeWalker {
        constructor(callback) {
          this.visit = callback;
          this.stack = [];
          this.directives = /* @__PURE__ */ Object.create(null);
        }
        _visit(node, descend) {
          this.push(node);
          var ret = this.visit(node, descend ? function() {
            descend.call(node);
          } : noop2);
          if (!ret && descend) {
            descend.call(node);
          }
          this.pop();
          return ret;
        }
        parent(n2) {
          return this.stack[this.stack.length - 2 - (n2 || 0)];
        }
        push(node) {
          if (node instanceof AST_Lambda) {
            this.directives = Object.create(this.directives);
          } else if (node instanceof AST_Directive && !this.directives[node.value]) {
            this.directives[node.value] = node;
          } else if (node instanceof AST_Class) {
            this.directives = Object.create(this.directives);
            if (!this.directives["use strict"]) {
              this.directives["use strict"] = node;
            }
          }
          this.stack.push(node);
        }
        pop() {
          var node = this.stack.pop();
          if (node instanceof AST_Lambda || node instanceof AST_Class) {
            this.directives = Object.getPrototypeOf(this.directives);
          }
        }
        self() {
          return this.stack[this.stack.length - 1];
        }
        find_parent(type) {
          var stack = this.stack;
          for (var i = stack.length; --i >= 0; ) {
            var x = stack[i];
            if (x instanceof type)
              return x;
          }
        }
        is_within_loop() {
          let i = this.stack.length - 1;
          let child = this.stack[i];
          while (i--) {
            const node = this.stack[i];
            if (node instanceof AST_Lambda)
              return false;
            if (node instanceof AST_IterationStatement && !(node instanceof AST_For && child === node.init) && !((node instanceof AST_ForIn || node instanceof AST_ForOf) && child === node.object)) {
              return true;
            }
            child = node;
          }
          return false;
        }
        find_scope() {
          var stack = this.stack;
          for (var i = stack.length; --i >= 0; ) {
            const p = stack[i];
            if (p instanceof AST_Toplevel)
              return p;
            if (p instanceof AST_Lambda)
              return p;
            if (p.block_scope)
              return p.block_scope;
          }
        }
        has_directive(type) {
          var dir = this.directives[type];
          if (dir)
            return dir;
          var node = this.stack[this.stack.length - 1];
          if (node instanceof AST_Scope && node.body) {
            for (var i = 0; i < node.body.length; ++i) {
              var st = node.body[i];
              if (!(st instanceof AST_Directive))
                break;
              if (st.value == type)
                return st;
            }
          }
        }
        loopcontrol_target(node) {
          var stack = this.stack;
          if (node.label)
            for (var i = stack.length; --i >= 0; ) {
              var x = stack[i];
              if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)
                return x.body;
            }
          else
            for (var i = stack.length; --i >= 0; ) {
              var x = stack[i];
              if (x instanceof AST_IterationStatement || node instanceof AST_Break && x instanceof AST_Switch)
                return x;
            }
        }
      }
      class TreeTransformer extends TreeWalker {
        constructor(before, after) {
          super();
          this.before = before;
          this.after = after;
        }
      }
      const _PURE = 1;
      const _INLINE = 2;
      const _NOINLINE = 4;
      const _KEY = 8;
      const _MANGLEPROP = 16;
      function def_transform(node, descend) {
        node.DEFMETHOD("transform", function(tw, in_list) {
          let transformed = void 0;
          tw.push(this);
          if (tw.before)
            transformed = tw.before(this, descend, in_list);
          if (transformed === void 0) {
            transformed = this;
            descend(transformed, tw);
            if (tw.after) {
              const after_ret = tw.after(transformed, in_list);
              if (after_ret !== void 0)
                transformed = after_ret;
            }
          }
          tw.pop();
          return transformed;
        });
      }
      def_transform(AST_Node, noop2);
      def_transform(AST_LabeledStatement, function(self2, tw) {
        self2.label = self2.label.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_SimpleStatement, function(self2, tw) {
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_Block, function(self2, tw) {
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Do, function(self2, tw) {
        self2.body = self2.body.transform(tw);
        self2.condition = self2.condition.transform(tw);
      });
      def_transform(AST_While, function(self2, tw) {
        self2.condition = self2.condition.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_For, function(self2, tw) {
        if (self2.init)
          self2.init = self2.init.transform(tw);
        if (self2.condition)
          self2.condition = self2.condition.transform(tw);
        if (self2.step)
          self2.step = self2.step.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_ForIn, function(self2, tw) {
        self2.init = self2.init.transform(tw);
        self2.object = self2.object.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_With, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.body = self2.body.transform(tw);
      });
      def_transform(AST_Exit, function(self2, tw) {
        if (self2.value)
          self2.value = self2.value.transform(tw);
      });
      def_transform(AST_LoopControl, function(self2, tw) {
        if (self2.label)
          self2.label = self2.label.transform(tw);
      });
      def_transform(AST_If, function(self2, tw) {
        self2.condition = self2.condition.transform(tw);
        self2.body = self2.body.transform(tw);
        if (self2.alternative)
          self2.alternative = self2.alternative.transform(tw);
      });
      def_transform(AST_Switch, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Case, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Try, function(self2, tw) {
        self2.body = self2.body.transform(tw);
        if (self2.bcatch)
          self2.bcatch = self2.bcatch.transform(tw);
        if (self2.bfinally)
          self2.bfinally = self2.bfinally.transform(tw);
      });
      def_transform(AST_Catch, function(self2, tw) {
        if (self2.argname)
          self2.argname = self2.argname.transform(tw);
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Definitions, function(self2, tw) {
        self2.definitions = MAP(self2.definitions, tw);
      });
      def_transform(AST_VarDef, function(self2, tw) {
        self2.name = self2.name.transform(tw);
        if (self2.value)
          self2.value = self2.value.transform(tw);
      });
      def_transform(AST_Destructuring, function(self2, tw) {
        self2.names = MAP(self2.names, tw);
      });
      def_transform(AST_Lambda, function(self2, tw) {
        if (self2.name)
          self2.name = self2.name.transform(tw);
        self2.argnames = MAP(self2.argnames, tw, false);
        if (self2.body instanceof AST_Node) {
          self2.body = self2.body.transform(tw);
        } else {
          self2.body = MAP(self2.body, tw);
        }
      });
      def_transform(AST_Call, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.args = MAP(self2.args, tw, false);
      });
      def_transform(AST_Sequence, function(self2, tw) {
        const result = MAP(self2.expressions, tw);
        self2.expressions = result.length ? result : [new AST_Number({ value: 0 })];
      });
      def_transform(AST_PropAccess, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Sub, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
        self2.property = self2.property.transform(tw);
      });
      def_transform(AST_Chain, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Yield, function(self2, tw) {
        if (self2.expression)
          self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Await, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Unary, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_Binary, function(self2, tw) {
        self2.left = self2.left.transform(tw);
        self2.right = self2.right.transform(tw);
      });
      def_transform(AST_PrivateIn, function(self2, tw) {
        self2.key = self2.key.transform(tw);
        self2.value = self2.value.transform(tw);
      });
      def_transform(AST_Conditional, function(self2, tw) {
        self2.condition = self2.condition.transform(tw);
        self2.consequent = self2.consequent.transform(tw);
        self2.alternative = self2.alternative.transform(tw);
      });
      def_transform(AST_Array, function(self2, tw) {
        self2.elements = MAP(self2.elements, tw);
      });
      def_transform(AST_Object, function(self2, tw) {
        self2.properties = MAP(self2.properties, tw);
      });
      def_transform(AST_ObjectProperty, function(self2, tw) {
        if (self2.key instanceof AST_Node) {
          self2.key = self2.key.transform(tw);
        }
        if (self2.value)
          self2.value = self2.value.transform(tw);
      });
      def_transform(AST_Class, function(self2, tw) {
        if (self2.name)
          self2.name = self2.name.transform(tw);
        if (self2.extends)
          self2.extends = self2.extends.transform(tw);
        self2.properties = MAP(self2.properties, tw);
      });
      def_transform(AST_ClassStaticBlock, function(self2, tw) {
        self2.body = MAP(self2.body, tw);
      });
      def_transform(AST_Expansion, function(self2, tw) {
        self2.expression = self2.expression.transform(tw);
      });
      def_transform(AST_NameMapping, function(self2, tw) {
        self2.foreign_name = self2.foreign_name.transform(tw);
        self2.name = self2.name.transform(tw);
      });
      def_transform(AST_Import, function(self2, tw) {
        if (self2.imported_name)
          self2.imported_name = self2.imported_name.transform(tw);
        if (self2.imported_names)
          MAP(self2.imported_names, tw);
        self2.module_name = self2.module_name.transform(tw);
      });
      def_transform(AST_Export, function(self2, tw) {
        if (self2.exported_definition)
          self2.exported_definition = self2.exported_definition.transform(tw);
        if (self2.exported_value)
          self2.exported_value = self2.exported_value.transform(tw);
        if (self2.exported_names)
          MAP(self2.exported_names, tw);
        if (self2.module_name)
          self2.module_name = self2.module_name.transform(tw);
      });
      def_transform(AST_TemplateString, function(self2, tw) {
        self2.segments = MAP(self2.segments, tw);
      });
      def_transform(AST_PrefixedTemplateString, function(self2, tw) {
        self2.prefix = self2.prefix.transform(tw);
        self2.template_string = self2.template_string.transform(tw);
      });
      (function() {
        var normalize_directives = function(body) {
          for (var i = 0; i < body.length; i++) {
            if (body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {
              body[i] = new AST_Directive({
                start: body[i].start,
                end: body[i].end,
                quote: '"',
                value: body[i].body.value
              });
            } else {
              return body;
            }
          }
          return body;
        };
        function import_attributes_from_moz(attributes) {
          if (attributes && attributes.length > 0) {
            return new AST_Object({
              start: my_start_token(attributes),
              end: my_end_token(attributes),
              properties: attributes.map((attr2) => new AST_ObjectKeyVal({
                start: my_start_token(attr2),
                end: my_end_token(attr2),
                key: attr2.key.name || attr2.key.value,
                value: from_moz(attr2.value)
              }))
            });
          }
          return null;
        }
        var MOZ_TO_ME = {
          Program: function(M) {
            return new AST_Toplevel({
              start: my_start_token(M),
              end: my_end_token(M),
              body: normalize_directives(M.body.map(from_moz))
            });
          },
          ArrayPattern: function(M) {
            return new AST_Destructuring({
              start: my_start_token(M),
              end: my_end_token(M),
              names: M.elements.map(function(elm) {
                if (elm === null) {
                  return new AST_Hole();
                }
                return from_moz(elm);
              }),
              is_array: true
            });
          },
          ObjectPattern: function(M) {
            return new AST_Destructuring({
              start: my_start_token(M),
              end: my_end_token(M),
              names: M.properties.map(from_moz),
              is_array: false
            });
          },
          AssignmentPattern: function(M) {
            return new AST_DefaultAssign({
              start: my_start_token(M),
              end: my_end_token(M),
              left: from_moz(M.left),
              operator: "=",
              right: from_moz(M.right)
            });
          },
          SpreadElement: function(M) {
            return new AST_Expansion({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument)
            });
          },
          RestElement: function(M) {
            return new AST_Expansion({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument)
            });
          },
          TemplateElement: function(M) {
            return new AST_TemplateSegment({
              start: my_start_token(M),
              end: my_end_token(M),
              value: M.value.cooked,
              raw: M.value.raw
            });
          },
          TemplateLiteral: function(M) {
            var segments = [];
            for (var i = 0; i < M.quasis.length; i++) {
              segments.push(from_moz(M.quasis[i]));
              if (M.expressions[i]) {
                segments.push(from_moz(M.expressions[i]));
              }
            }
            return new AST_TemplateString({
              start: my_start_token(M),
              end: my_end_token(M),
              segments
            });
          },
          TaggedTemplateExpression: function(M) {
            return new AST_PrefixedTemplateString({
              start: my_start_token(M),
              end: my_end_token(M),
              template_string: from_moz(M.quasi),
              prefix: from_moz(M.tag)
            });
          },
          FunctionDeclaration: function(M) {
            return new AST_Defun({
              start: my_start_token(M),
              end: my_end_token(M),
              name: M.id && from_moz_symbol(AST_SymbolDefun, M.id),
              argnames: M.params.map((M2) => from_moz_pattern(M2, AST_SymbolFunarg)),
              is_generator: M.generator,
              async: M.async,
              body: normalize_directives(from_moz(M.body).body)
            });
          },
          FunctionExpression: function(M) {
            return from_moz_lambda(M, false);
          },
          ArrowFunctionExpression: function(M) {
            const body = M.body.type === "BlockStatement" ? from_moz(M.body).body : [make_node(AST_Return, {}, { value: from_moz(M.body) })];
            return new AST_Arrow({
              start: my_start_token(M),
              end: my_end_token(M),
              argnames: M.params.map((p) => from_moz_pattern(p, AST_SymbolFunarg)),
              body,
              async: M.async
            });
          },
          ExpressionStatement: function(M) {
            return new AST_SimpleStatement({
              start: my_start_token(M),
              end: my_end_token(M),
              body: from_moz(M.expression)
            });
          },
          TryStatement: function(M) {
            var handlers = M.handlers || [M.handler];
            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {
              throw new Error("Multiple catch clauses are not supported.");
            }
            return new AST_Try({
              start: my_start_token(M),
              end: my_end_token(M),
              body: new AST_TryBlock(from_moz(M.block)),
              bcatch: from_moz(handlers[0]),
              bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null
            });
          },
          Property: function(M) {
            if (M.kind == "init" && !M.method) {
              var args = {
                start: my_start_token(M.key || M.value),
                end: my_end_token(M.value),
                key: M.computed ? from_moz(M.key) : M.key.name || String(M.key.value),
                quote: from_moz_quote(M.key, M.computed),
                static: false,
                value: from_moz(M.value)
              };
              return new AST_ObjectKeyVal(args);
            } else {
              var value2 = from_moz_lambda(M.value, true);
              var args = {
                start: my_start_token(M.key || M.value),
                end: my_end_token(M.value),
                key: M.computed ? from_moz(M.key) : from_moz_symbol(AST_SymbolMethod, M.key),
                quote: from_moz_quote(M.key, M.computed),
                static: false,
                value: value2
              };
              if (M.kind == "get")
                return new AST_ObjectGetter(args);
              if (M.kind == "set")
                return new AST_ObjectSetter(args);
              if (M.method)
                return new AST_ConciseMethod(args);
            }
          },
          MethodDefinition: function(M) {
            const is_private = M.key.type === "PrivateIdentifier";
            const key2 = M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || String(M.key.value) });
            var args = {
              start: my_start_token(M),
              end: my_end_token(M),
              key: key2,
              quote: from_moz_quote(M.key, M.computed),
              value: from_moz_lambda(M.value, true),
              static: M.static
            };
            if (M.kind == "get") {
              return new (is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);
            }
            if (M.kind == "set") {
              return new (is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);
            }
            return new (is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);
          },
          FieldDefinition: function(M) {
            let key2;
            if (M.computed) {
              key2 = from_moz(M.key);
            } else {
              if (M.key.type !== "Identifier")
                throw new Error("Non-Identifier key in FieldDefinition");
              key2 = from_moz(M.key);
            }
            return new AST_ClassProperty({
              start: my_start_token(M),
              end: my_end_token(M),
              quote: from_moz_quote(M.key, M.computed),
              key: key2,
              value: from_moz(M.value),
              static: M.static
            });
          },
          PropertyDefinition: function(M) {
            let key2;
            if (M.computed) {
              key2 = from_moz(M.key);
            } else if (M.key.type === "PrivateIdentifier") {
              return new AST_ClassPrivateProperty({
                start: my_start_token(M),
                end: my_end_token(M),
                key: from_moz(M.key),
                value: from_moz(M.value),
                static: M.static
              });
            } else {
              key2 = from_moz_symbol(AST_SymbolClassProperty, M.key);
            }
            return new AST_ClassProperty({
              start: my_start_token(M),
              end: my_end_token(M),
              quote: from_moz_quote(M.key, M.computed),
              key: key2,
              value: from_moz(M.value),
              static: M.static
            });
          },
          PrivateIdentifier: function(M) {
            return new AST_SymbolPrivateProperty({
              start: my_start_token(M),
              end: my_end_token(M),
              name: M.name
            });
          },
          StaticBlock: function(M) {
            return new AST_ClassStaticBlock({
              start: my_start_token(M),
              end: my_end_token(M),
              body: M.body.map(from_moz)
            });
          },
          ArrayExpression: function(M) {
            return new AST_Array({
              start: my_start_token(M),
              end: my_end_token(M),
              elements: M.elements.map(function(elem) {
                return elem === null ? new AST_Hole() : from_moz(elem);
              })
            });
          },
          ObjectExpression: function(M) {
            return new AST_Object({
              start: my_start_token(M),
              end: my_end_token(M),
              properties: M.properties.map(function(prop) {
                if (prop.type === "SpreadElement") {
                  return from_moz(prop);
                }
                prop.type = "Property";
                return from_moz(prop);
              })
            });
          },
          SequenceExpression: function(M) {
            return new AST_Sequence({
              start: my_start_token(M),
              end: my_end_token(M),
              expressions: M.expressions.map(from_moz)
            });
          },
          MemberExpression: function(M) {
            if (M.property.type === "PrivateIdentifier") {
              return new AST_DotHash({
                start: my_start_token(M),
                end: my_end_token(M),
                property: M.property.name,
                expression: from_moz(M.object),
                optional: M.optional || false
              });
            }
            return new (M.computed ? AST_Sub : AST_Dot)({
              start: my_start_token(M),
              end: my_end_token(M),
              property: M.computed ? from_moz(M.property) : M.property.name,
              expression: from_moz(M.object),
              optional: M.optional || false
            });
          },
          ChainExpression: function(M) {
            return new AST_Chain({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.expression)
            });
          },
          SwitchCase: function(M) {
            return new (M.test ? AST_Case : AST_Default)({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.test),
              body: M.consequent.map(from_moz)
            });
          },
          VariableDeclaration: function(M) {
            let decl_type;
            let sym_type;
            if (M.kind === "const") {
              decl_type = AST_Const;
              sym_type = AST_SymbolConst;
            } else if (M.kind === "let") {
              decl_type = AST_Let;
              sym_type = AST_SymbolLet;
            } else {
              decl_type = AST_Var;
              sym_type = AST_SymbolVar;
            }
            const definitions = M.declarations.map((M2) => {
              return new AST_VarDef({
                start: my_start_token(M2),
                end: my_end_token(M2),
                name: from_moz_pattern(M2.id, sym_type),
                value: from_moz(M2.init)
              });
            });
            return new decl_type({
              start: my_start_token(M),
              end: my_end_token(M),
              definitions
            });
          },
          ImportDeclaration: function(M) {
            var imported_name = null;
            var imported_names = null;
            M.specifiers.forEach(function(specifier) {
              if (specifier.type === "ImportSpecifier" || specifier.type === "ImportNamespaceSpecifier") {
                if (!imported_names) {
                  imported_names = [];
                }
                imported_names.push(from_moz(specifier));
              } else if (specifier.type === "ImportDefaultSpecifier") {
                imported_name = from_moz(specifier);
              }
            });
            return new AST_Import({
              start: my_start_token(M),
              end: my_end_token(M),
              imported_name,
              imported_names,
              module_name: from_moz(M.source),
              attributes: import_attributes_from_moz(M.attributes || M.assertions)
            });
          },
          ImportSpecifier: function(M) {
            return new AST_NameMapping({
              start: my_start_token(M),
              end: my_end_token(M),
              foreign_name: from_moz_symbol(AST_SymbolImportForeign, M.imported, M.imported.type === "Literal"),
              name: from_moz_symbol(AST_SymbolImport, M.local)
            });
          },
          ImportDefaultSpecifier: function(M) {
            return from_moz_symbol(AST_SymbolImport, M.local);
          },
          ImportNamespaceSpecifier: function(M) {
            return new AST_NameMapping({
              start: my_start_token(M),
              end: my_end_token(M),
              foreign_name: new AST_SymbolImportForeign({ name: "*" }),
              name: from_moz_symbol(AST_SymbolImport, M.local)
            });
          },
          ImportExpression: function(M) {
            const args = [from_moz(M.source)];
            if (M.options) {
              args.push(from_moz(M.options));
            }
            return new AST_Call({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz({
                type: "Identifier",
                name: "import"
              }),
              optional: false,
              args
            });
          },
          ExportAllDeclaration: function(M) {
            var foreign_name = M.exported == null ? new AST_SymbolExportForeign({ name: "*" }) : from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === "Literal");
            return new AST_Export({
              start: my_start_token(M),
              end: my_end_token(M),
              exported_names: [
                new AST_NameMapping({
                  start: my_start_token(M),
                  end: my_end_token(M),
                  name: new AST_SymbolExport({ name: "*" }),
                  foreign_name
                })
              ],
              module_name: from_moz(M.source),
              attributes: import_attributes_from_moz(M.attributes || M.assertions)
            });
          },
          ExportNamedDeclaration: function(M) {
            if (M.declaration) {
              return new AST_Export({
                start: my_start_token(M),
                end: my_end_token(M),
                exported_definition: from_moz(M.declaration),
                exported_names: null,
                module_name: null,
                attributes: null
              });
            } else {
              return new AST_Export({
                start: my_start_token(M),
                end: my_end_token(M),
                exported_definition: null,
                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(from_moz) : [],
                module_name: from_moz(M.source),
                attributes: import_attributes_from_moz(M.attributes || M.assertions)
              });
            }
          },
          ExportDefaultDeclaration: function(M) {
            return new AST_Export({
              start: my_start_token(M),
              end: my_end_token(M),
              exported_value: from_moz(M.declaration),
              is_default: true
            });
          },
          ExportSpecifier: function(M) {
            return new AST_NameMapping({
              start: my_start_token(M),
              end: my_end_token(M),
              foreign_name: from_moz_symbol(AST_SymbolExportForeign, M.exported, M.exported.type === "Literal"),
              name: from_moz_symbol(AST_SymbolExport, M.local, M.local.type === "Literal")
            });
          },
          Literal: function(M) {
            var val = M.value, args = {
              start: my_start_token(M),
              end: my_end_token(M)
            };
            var rx = M.regex;
            if (rx && rx.pattern) {
              args.value = {
                source: rx.pattern,
                flags: rx.flags
              };
              return new AST_RegExp(args);
            } else if (rx) {
              const rx_source = M.raw || val;
              const match = rx_source.match(/^\/(.*)\/(\w*)$/);
              if (!match)
                throw new Error("Invalid regex source " + rx_source);
              const [_, source, flags] = match;
              args.value = { source, flags };
              return new AST_RegExp(args);
            }
            const bi = typeof M.value === "bigint" ? M.value.toString() : M.bigint;
            if (typeof bi === "string") {
              args.value = bi;
              args.raw = M.raw;
              return new AST_BigInt(args);
            }
            if (val === null)
              return new AST_Null(args);
            switch (typeof val) {
              case "string":
                args.quote = '"';
                args.value = val;
                return new AST_String(args);
              case "number":
                args.value = val;
                args.raw = M.raw || val.toString();
                return new AST_Number(args);
              case "boolean":
                return new (val ? AST_True : AST_False)(args);
            }
          },
          MetaProperty: function(M) {
            if (M.meta.name === "new" && M.property.name === "target") {
              return new AST_NewTarget({
                start: my_start_token(M),
                end: my_end_token(M)
              });
            } else if (M.meta.name === "import" && M.property.name === "meta") {
              return new AST_ImportMeta({
                start: my_start_token(M),
                end: my_end_token(M)
              });
            }
          },
          Identifier: function(M) {
            return new AST_SymbolRef({
              start: my_start_token(M),
              end: my_end_token(M),
              name: M.name
            });
          },
          EmptyStatement: function(M) {
            return new AST_EmptyStatement({
              start: my_start_token(M),
              end: my_end_token(M)
            });
          },
          BlockStatement: function(M) {
            return new AST_BlockStatement({
              start: my_start_token(M),
              end: my_end_token(M),
              body: M.body.map(from_moz)
            });
          },
          IfStatement: function(M) {
            return new AST_If({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              body: from_moz(M.consequent),
              alternative: from_moz(M.alternate)
            });
          },
          LabeledStatement: function(M) {
            try {
              const label = from_moz_symbol(AST_Label, M.label);
              FROM_MOZ_LABELS.push(label);
              const stat = new AST_LabeledStatement({
                start: my_start_token(M),
                end: my_end_token(M),
                label,
                body: from_moz(M.body)
              });
              return stat;
            } finally {
              FROM_MOZ_LABELS.pop();
            }
          },
          BreakStatement: function(M) {
            return new AST_Break({
              start: my_start_token(M),
              end: my_end_token(M),
              label: from_moz_label_ref(M.label)
            });
          },
          ContinueStatement: function(M) {
            return new AST_Continue({
              start: my_start_token(M),
              end: my_end_token(M),
              label: from_moz_label_ref(M.label)
            });
          },
          WithStatement: function(M) {
            return new AST_With({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.object),
              body: from_moz(M.body)
            });
          },
          SwitchStatement: function(M) {
            return new AST_Switch({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.discriminant),
              body: M.cases.map(from_moz)
            });
          },
          ReturnStatement: function(M) {
            return new AST_Return({
              start: my_start_token(M),
              end: my_end_token(M),
              value: from_moz(M.argument)
            });
          },
          ThrowStatement: function(M) {
            return new AST_Throw({
              start: my_start_token(M),
              end: my_end_token(M),
              value: from_moz(M.argument)
            });
          },
          WhileStatement: function(M) {
            return new AST_While({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              body: from_moz(M.body)
            });
          },
          DoWhileStatement: function(M) {
            return new AST_Do({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              body: from_moz(M.body)
            });
          },
          ForStatement: function(M) {
            return new AST_For({
              start: my_start_token(M),
              end: my_end_token(M),
              init: from_moz(M.init),
              condition: from_moz(M.test),
              step: from_moz(M.update),
              body: from_moz(M.body)
            });
          },
          ForInStatement: function(M) {
            return new AST_ForIn({
              start: my_start_token(M),
              end: my_end_token(M),
              init: from_moz(M.left),
              object: from_moz(M.right),
              body: from_moz(M.body)
            });
          },
          ForOfStatement: function(M) {
            return new AST_ForOf({
              start: my_start_token(M),
              end: my_end_token(M),
              init: from_moz(M.left),
              object: from_moz(M.right),
              body: from_moz(M.body),
              await: M.await
            });
          },
          AwaitExpression: function(M) {
            return new AST_Await({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument)
            });
          },
          YieldExpression: function(M) {
            return new AST_Yield({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.argument),
              is_star: M.delegate
            });
          },
          DebuggerStatement: function(M) {
            return new AST_Debugger({
              start: my_start_token(M),
              end: my_end_token(M)
            });
          },
          CatchClause: function(M) {
            return new AST_Catch({
              start: my_start_token(M),
              end: my_end_token(M),
              argname: M.param ? from_moz_pattern(M.param, AST_SymbolCatch) : null,
              body: from_moz(M.body).body
            });
          },
          ThisExpression: function(M) {
            return new AST_This({
              start: my_start_token(M),
              name: "this",
              end: my_end_token(M)
            });
          },
          Super: function(M) {
            return new AST_Super({
              start: my_start_token(M),
              end: my_end_token(M),
              name: "super"
            });
          },
          BinaryExpression: function(M) {
            if (M.left.type === "PrivateIdentifier") {
              return new AST_PrivateIn({
                start: my_start_token(M),
                end: my_end_token(M),
                key: new AST_SymbolPrivateProperty({
                  start: my_start_token(M.left),
                  end: my_end_token(M.left),
                  name: M.left.name
                }),
                value: from_moz(M.right)
              });
            }
            return new AST_Binary({
              start: my_start_token(M),
              end: my_end_token(M),
              operator: M.operator,
              left: from_moz(M.left),
              right: from_moz(M.right)
            });
          },
          LogicalExpression: function(M) {
            return new AST_Binary({
              start: my_start_token(M),
              end: my_end_token(M),
              operator: M.operator,
              left: from_moz(M.left),
              right: from_moz(M.right)
            });
          },
          AssignmentExpression: function(M) {
            return new AST_Assign({
              start: my_start_token(M),
              end: my_end_token(M),
              operator: M.operator,
              logical: M.operator === "??=" || M.operator === "&&=" || M.operator === "||=",
              left: from_moz(M.left),
              right: from_moz(M.right)
            });
          },
          ConditionalExpression: function(M) {
            return new AST_Conditional({
              start: my_start_token(M),
              end: my_end_token(M),
              condition: from_moz(M.test),
              consequent: from_moz(M.consequent),
              alternative: from_moz(M.alternate)
            });
          },
          NewExpression: function(M) {
            return new AST_New({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.callee),
              args: M.arguments.map(from_moz)
            });
          },
          CallExpression: function(M) {
            return new AST_Call({
              start: my_start_token(M),
              end: my_end_token(M),
              expression: from_moz(M.callee),
              optional: M.optional,
              args: M.arguments.map(from_moz)
            });
          }
        };
        MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {
          var prefix = "prefix" in M ? M.prefix : M.type == "UnaryExpression" ? true : false;
          return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({
            start: my_start_token(M),
            end: my_end_token(M),
            operator: M.operator,
            expression: from_moz(M.argument)
          });
        };
        MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {
          return new (M.type === "ClassDeclaration" ? AST_DefClass : AST_ClassExpression)({
            start: my_start_token(M),
            end: my_end_token(M),
            name: M.id && from_moz_symbol(M.type === "ClassDeclaration" ? AST_SymbolDefClass : AST_SymbolClass, M.id),
            extends: from_moz(M.superClass),
            properties: M.body.body.map(from_moz)
          });
        };
        def_to_moz(AST_EmptyStatement, function To_Moz_EmptyStatement() {
          return {
            type: "EmptyStatement"
          };
        });
        def_to_moz(AST_BlockStatement, function To_Moz_BlockStatement(M) {
          return {
            type: "BlockStatement",
            body: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_If, function To_Moz_IfStatement(M) {
          return {
            type: "IfStatement",
            test: to_moz(M.condition),
            consequent: to_moz(M.body),
            alternate: to_moz(M.alternative)
          };
        });
        def_to_moz(AST_LabeledStatement, function To_Moz_LabeledStatement(M) {
          return {
            type: "LabeledStatement",
            label: to_moz(M.label),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_Break, function To_Moz_BreakStatement(M) {
          return {
            type: "BreakStatement",
            label: to_moz(M.label)
          };
        });
        def_to_moz(AST_Continue, function To_Moz_ContinueStatement(M) {
          return {
            type: "ContinueStatement",
            label: to_moz(M.label)
          };
        });
        def_to_moz(AST_With, function To_Moz_WithStatement(M) {
          return {
            type: "WithStatement",
            object: to_moz(M.expression),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_Switch, function To_Moz_SwitchStatement(M) {
          return {
            type: "SwitchStatement",
            discriminant: to_moz(M.expression),
            cases: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_Return, function To_Moz_ReturnStatement(M) {
          return {
            type: "ReturnStatement",
            argument: to_moz(M.value)
          };
        });
        def_to_moz(AST_Throw, function To_Moz_ThrowStatement(M) {
          return {
            type: "ThrowStatement",
            argument: to_moz(M.value)
          };
        });
        def_to_moz(AST_While, function To_Moz_WhileStatement(M) {
          return {
            type: "WhileStatement",
            test: to_moz(M.condition),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_Do, function To_Moz_DoWhileStatement(M) {
          return {
            type: "DoWhileStatement",
            test: to_moz(M.condition),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_For, function To_Moz_ForStatement(M) {
          return {
            type: "ForStatement",
            init: to_moz(M.init),
            test: to_moz(M.condition),
            update: to_moz(M.step),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_ForIn, function To_Moz_ForInStatement(M) {
          return {
            type: "ForInStatement",
            left: to_moz(M.init),
            right: to_moz(M.object),
            body: to_moz(M.body)
          };
        });
        def_to_moz(AST_ForOf, function To_Moz_ForOfStatement(M) {
          return {
            type: "ForOfStatement",
            left: to_moz(M.init),
            right: to_moz(M.object),
            body: to_moz(M.body),
            await: M.await
          };
        });
        def_to_moz(AST_Await, function To_Moz_AwaitExpression(M) {
          return {
            type: "AwaitExpression",
            argument: to_moz(M.expression)
          };
        });
        def_to_moz(AST_Yield, function To_Moz_YieldExpression(M) {
          return {
            type: "YieldExpression",
            argument: to_moz(M.expression),
            delegate: M.is_star
          };
        });
        def_to_moz(AST_Debugger, function To_Moz_DebuggerStatement() {
          return {
            type: "DebuggerStatement"
          };
        });
        def_to_moz(AST_VarDef, function To_Moz_VariableDeclarator(M) {
          return {
            type: "VariableDeclarator",
            id: to_moz(M.name),
            init: to_moz(M.value)
          };
        });
        def_to_moz(AST_This, function To_Moz_ThisExpression() {
          return {
            type: "ThisExpression"
          };
        });
        def_to_moz(AST_Super, function To_Moz_Super() {
          return {
            type: "Super"
          };
        });
        def_to_moz(AST_Conditional, function To_Moz_ConditionalExpression(M) {
          return {
            type: "ConditionalExpression",
            test: to_moz(M.condition),
            consequent: to_moz(M.consequent),
            alternate: to_moz(M.alternative)
          };
        });
        def_to_moz(AST_New, function To_Moz_NewExpression(M) {
          return {
            type: "NewExpression",
            callee: to_moz(M.expression),
            arguments: M.args.map(to_moz)
          };
        });
        def_to_moz(AST_Call, function To_Moz_CallExpression(M) {
          if (M.expression instanceof AST_SymbolRef && M.expression.name === "import") {
            const [source, options] = M.args.map(to_moz);
            return {
              type: "ImportExpression",
              source,
              options: options || null
            };
          }
          return {
            type: "CallExpression",
            callee: to_moz(M.expression),
            optional: M.optional,
            arguments: M.args.map(to_moz)
          };
        });
        def_to_moz(AST_Toplevel, function To_Moz_Program(M) {
          return to_moz_scope("Program", M);
        });
        def_to_moz(AST_Expansion, function To_Moz_Spread(M) {
          return {
            type: to_moz_in_destructuring() ? "RestElement" : "SpreadElement",
            argument: to_moz(M.expression)
          };
        });
        def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {
          return {
            type: "TaggedTemplateExpression",
            tag: to_moz(M.prefix),
            quasi: to_moz(M.template_string)
          };
        });
        def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {
          var quasis = [];
          var expressions = [];
          for (var i = 0; i < M.segments.length; i++) {
            if (i % 2 !== 0) {
              expressions.push(to_moz(M.segments[i]));
            } else {
              quasis.push({
                type: "TemplateElement",
                value: {
                  raw: M.segments[i].raw,
                  cooked: M.segments[i].value
                },
                tail: i === M.segments.length - 1
              });
            }
          }
          return {
            type: "TemplateLiteral",
            quasis,
            expressions
          };
        });
        def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {
          return {
            type: "FunctionDeclaration",
            id: to_moz(M.name),
            params: M.argnames.map(to_moz_pattern),
            generator: M.is_generator,
            async: M.async,
            body: to_moz_scope("BlockStatement", M)
          };
        });
        def_to_moz(AST_Function, function To_Moz_FunctionExpression(M) {
          return {
            type: "FunctionExpression",
            id: to_moz(M.name),
            params: M.argnames.map(to_moz_pattern),
            generator: M.is_generator || false,
            async: M.async || false,
            body: to_moz_scope("BlockStatement", M)
          };
        });
        def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {
          var body = M.body.length === 1 && M.body[0] instanceof AST_Return && M.body[0].value ? to_moz(M.body[0].value) : {
            type: "BlockStatement",
            body: M.body.map(to_moz)
          };
          return {
            type: "ArrowFunctionExpression",
            params: M.argnames.map(to_moz_pattern),
            async: M.async,
            body
          };
        });
        def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {
          if (M.is_array) {
            return {
              type: "ArrayPattern",
              elements: M.names.map((M2) => M2 instanceof AST_Hole ? null : to_moz_pattern(M2))
            };
          }
          return {
            type: "ObjectPattern",
            properties: M.names.map((M2) => {
              if (M2 instanceof AST_ObjectKeyVal) {
                var computed = M2.computed_key();
                const [shorthand, key2] = to_moz_property_key(M2.key, computed, M2.quote, M2.value);
                return {
                  type: "Property",
                  computed,
                  kind: "init",
                  key: key2,
                  method: false,
                  shorthand,
                  value: to_moz_pattern(M2.value)
                };
              } else {
                return to_moz_pattern(M2);
              }
            })
          };
        });
        def_to_moz(AST_DefaultAssign, function To_Moz_AssignmentExpression(M) {
          return {
            type: "AssignmentPattern",
            left: to_moz_pattern(M.left),
            right: to_moz(M.right)
          };
        });
        def_to_moz(AST_Directive, function To_Moz_Directive(M) {
          return {
            type: "ExpressionStatement",
            expression: {
              type: "Literal",
              value: M.value,
              raw: M.print_to_string()
            },
            directive: M.value
          };
        });
        def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {
          return {
            type: "ExpressionStatement",
            expression: to_moz(M.body)
          };
        });
        def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {
          return {
            type: "SwitchCase",
            test: to_moz(M.expression),
            consequent: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_Try, function To_Moz_TryStatement(M) {
          return {
            type: "TryStatement",
            block: to_moz_block(M.body),
            handler: to_moz(M.bcatch),
            guardedHandlers: [],
            finalizer: to_moz(M.bfinally)
          };
        });
        def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {
          return {
            type: "CatchClause",
            param: M.argname != null ? to_moz_pattern(M.argname) : null,
            body: to_moz_block(M)
          };
        });
        def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {
          return {
            type: "VariableDeclaration",
            kind: M instanceof AST_Const ? "const" : M instanceof AST_Let ? "let" : "var",
            declarations: M.definitions.map(to_moz)
          };
        });
        function import_attributes_to_moz(attribute) {
          const import_attributes = [];
          if (attribute) {
            for (const { key: key2, value: value2 } of attribute.properties) {
              const key_moz = is_basic_identifier_string(key2) ? { type: "Identifier", name: key2 } : { type: "Literal", value: key2, raw: JSON.stringify(key2) };
              import_attributes.push({
                type: "ImportAttribute",
                key: key_moz,
                value: to_moz(value2)
              });
            }
          }
          return import_attributes;
        }
        def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {
          if (M.exported_names) {
            var first_exported = M.exported_names[0];
            if (first_exported && first_exported.name.name === "*" && !first_exported.name.quote) {
              var foreign_name = first_exported.foreign_name;
              var exported = foreign_name.name === "*" && !foreign_name.quote ? null : to_moz(foreign_name);
              return {
                type: "ExportAllDeclaration",
                source: to_moz(M.module_name),
                exported,
                attributes: import_attributes_to_moz(M.attributes)
              };
            }
            return {
              type: "ExportNamedDeclaration",
              specifiers: M.exported_names.map(function(name_mapping) {
                return {
                  type: "ExportSpecifier",
                  exported: to_moz(name_mapping.foreign_name),
                  local: to_moz(name_mapping.name)
                };
              }),
              declaration: to_moz(M.exported_definition),
              source: to_moz(M.module_name),
              attributes: import_attributes_to_moz(M.attributes)
            };
          }
          if (M.is_default) {
            return {
              type: "ExportDefaultDeclaration",
              declaration: to_moz(M.exported_value || M.exported_definition)
            };
          } else {
            return {
              type: "ExportNamedDeclaration",
              declaration: to_moz(M.exported_value || M.exported_definition),
              specifiers: [],
              source: null
            };
          }
        });
        def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {
          var specifiers = [];
          if (M.imported_name) {
            specifiers.push({
              type: "ImportDefaultSpecifier",
              local: to_moz(M.imported_name)
            });
          }
          if (M.imported_names) {
            var first_imported_foreign_name = M.imported_names[0].foreign_name;
            if (first_imported_foreign_name.name === "*" && !first_imported_foreign_name.quote) {
              specifiers.push({
                type: "ImportNamespaceSpecifier",
                local: to_moz(M.imported_names[0].name)
              });
            } else {
              M.imported_names.forEach(function(name_mapping) {
                specifiers.push({
                  type: "ImportSpecifier",
                  local: to_moz(name_mapping.name),
                  imported: to_moz(name_mapping.foreign_name)
                });
              });
            }
          }
          return {
            type: "ImportDeclaration",
            specifiers,
            source: to_moz(M.module_name),
            attributes: import_attributes_to_moz(M.attributes)
          };
        });
        def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {
          return {
            type: "MetaProperty",
            meta: {
              type: "Identifier",
              name: "import"
            },
            property: {
              type: "Identifier",
              name: "meta"
            }
          };
        });
        def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {
          return {
            type: "SequenceExpression",
            expressions: M.expressions.map(to_moz)
          };
        });
        def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {
          return {
            type: "MemberExpression",
            object: to_moz(M.expression),
            computed: false,
            property: {
              type: "PrivateIdentifier",
              name: M.property
            },
            optional: M.optional
          };
        });
        def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {
          var isComputed = M instanceof AST_Sub;
          return {
            type: "MemberExpression",
            object: to_moz(M.expression),
            computed: isComputed,
            property: isComputed ? to_moz(M.property) : { type: "Identifier", name: M.property },
            optional: M.optional
          };
        });
        def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {
          return {
            type: "ChainExpression",
            expression: to_moz(M.expression)
          };
        });
        def_to_moz(AST_Unary, function To_Moz_Unary(M) {
          return {
            type: M.operator == "++" || M.operator == "--" ? "UpdateExpression" : "UnaryExpression",
            operator: M.operator,
            prefix: M instanceof AST_UnaryPrefix,
            argument: to_moz(M.expression)
          };
        });
        def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {
          if (M.operator == "=" && to_moz_in_destructuring()) {
            return {
              type: "AssignmentPattern",
              left: to_moz(M.left),
              right: to_moz(M.right)
            };
          }
          const type = M.operator == "&&" || M.operator == "||" || M.operator === "??" ? "LogicalExpression" : "BinaryExpression";
          return {
            type,
            left: to_moz(M.left),
            operator: M.operator,
            right: to_moz(M.right)
          };
        });
        def_to_moz(AST_Assign, function To_Moz_AssignmentExpression(M) {
          return {
            type: "AssignmentExpression",
            operator: M.operator,
            left: to_moz(M.left),
            right: to_moz(M.right)
          };
        });
        def_to_moz(AST_PrivateIn, function To_Moz_BinaryExpression_PrivateIn(M) {
          return {
            type: "BinaryExpression",
            left: { type: "PrivateIdentifier", name: M.key.name },
            operator: "in",
            right: to_moz(M.value)
          };
        });
        def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {
          return {
            type: "ArrayExpression",
            elements: M.elements.map(to_moz)
          };
        });
        def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {
          return {
            type: "ObjectExpression",
            properties: M.properties.map(to_moz)
          };
        });
        def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {
          var computed = M.computed_key();
          const [shorthand, key2] = to_moz_property_key(M.key, computed, M.quote, M.value);
          var kind;
          if (M instanceof AST_ObjectGetter) {
            kind = "get";
          } else if (M instanceof AST_ObjectSetter) {
            kind = "set";
          }
          if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {
            const kind2 = M instanceof AST_PrivateGetter ? "get" : "set";
            return {
              type: "MethodDefinition",
              computed: false,
              kind: kind2,
              static: M.static,
              key: {
                type: "PrivateIdentifier",
                name: M.key.name
              },
              value: to_moz(M.value)
            };
          }
          if (M instanceof AST_ClassPrivateProperty) {
            return {
              type: "PropertyDefinition",
              key: {
                type: "PrivateIdentifier",
                name: M.key.name
              },
              value: to_moz(M.value),
              computed: false,
              static: M.static
            };
          }
          if (M instanceof AST_ClassProperty) {
            return {
              type: "PropertyDefinition",
              key: key2,
              value: to_moz(M.value),
              computed,
              static: M.static
            };
          }
          if (parent instanceof AST_Class) {
            return {
              type: "MethodDefinition",
              computed,
              kind,
              static: M.static,
              key: to_moz(M.key),
              value: to_moz(M.value)
            };
          }
          return {
            type: "Property",
            computed,
            method: false,
            shorthand,
            kind,
            key: key2,
            value: to_moz(M.value)
          };
        });
        def_to_moz(AST_ObjectKeyVal, function To_Moz_Property(M) {
          var computed = M.computed_key();
          const [shorthand, key2] = to_moz_property_key(M.key, computed, M.quote, M.value);
          return {
            type: "Property",
            computed,
            shorthand,
            method: false,
            kind: "init",
            key: key2,
            value: to_moz(M.value)
          };
        });
        def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {
          const computed = M.computed_key();
          const [_always_false, key2] = to_moz_property_key(M.key, computed, M.quote, M.value);
          if (parent instanceof AST_Object) {
            return {
              type: "Property",
              kind: "init",
              computed,
              method: true,
              shorthand: false,
              key: key2,
              value: to_moz(M.value)
            };
          }
          return {
            type: "MethodDefinition",
            kind: !computed && M.key.name === "constructor" ? "constructor" : "method",
            computed,
            key: key2,
            value: to_moz(M.value),
            static: M.static
          };
        });
        def_to_moz(AST_PrivateMethod, function To_Moz_MethodDefinition(M) {
          return {
            type: "MethodDefinition",
            kind: "method",
            key: { type: "PrivateIdentifier", name: M.key.name },
            value: to_moz(M.value),
            computed: false,
            static: M.static
          };
        });
        def_to_moz(AST_Class, function To_Moz_Class(M) {
          var type = M instanceof AST_ClassExpression ? "ClassExpression" : "ClassDeclaration";
          return {
            type,
            superClass: to_moz(M.extends),
            id: M.name ? to_moz(M.name) : null,
            body: {
              type: "ClassBody",
              body: M.properties.map(to_moz)
            }
          };
        });
        def_to_moz(AST_ClassStaticBlock, function To_Moz_StaticBlock(M) {
          return {
            type: "StaticBlock",
            body: M.body.map(to_moz)
          };
        });
        def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {
          return {
            type: "MetaProperty",
            meta: {
              type: "Identifier",
              name: "new"
            },
            property: {
              type: "Identifier",
              name: "target"
            }
          };
        });
        def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {
          if (M instanceof AST_SymbolMethod && parent.quote || (M instanceof AST_SymbolImportForeign || M instanceof AST_SymbolExportForeign || M instanceof AST_SymbolExport) && M.quote) {
            return {
              type: "Literal",
              value: M.name
            };
          }
          var def = M.definition();
          return {
            type: "Identifier",
            name: def ? def.mangled_name || def.name : M.name
          };
        });
        def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {
          const pattern = M.value.source;
          const flags = M.value.flags;
          return {
            type: "Literal",
            value: null,
            raw: M.print_to_string(),
            regex: { pattern, flags }
          };
        });
        def_to_moz(AST_Constant, function To_Moz_Literal(M) {
          var value2 = M.value;
          return {
            type: "Literal",
            value: value2,
            raw: M.raw || M.print_to_string()
          };
        });
        def_to_moz(AST_Atom, function To_Moz_Atom(M) {
          return {
            type: "Identifier",
            name: String(M.value)
          };
        });
        def_to_moz(AST_BigInt, (M) => ({
          type: "Literal",
          value: null,
          bigint: typeof BigInt === "function" ? BigInt(M.value).toString() : M.value,
          raw: M.raw
        }));
        AST_Boolean.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
        AST_Null.DEFMETHOD("to_mozilla_ast", AST_Constant.prototype.to_mozilla_ast);
        AST_Hole.DEFMETHOD("to_mozilla_ast", function To_Moz_ArrayHole() {
          return null;
        });
        AST_Block.DEFMETHOD("to_mozilla_ast", AST_BlockStatement.prototype.to_mozilla_ast);
        AST_Lambda.DEFMETHOD("to_mozilla_ast", AST_Function.prototype.to_mozilla_ast);
        function my_start_token(moznode) {
          var loc = moznode.loc, start = loc && loc.start;
          var range = moznode.range;
          return new AST_Token("", "", start && start.line || 0, start && start.column || 0, range ? range[0] : moznode.start, false, [], [], loc && loc.source);
        }
        function my_end_token(moznode) {
          var loc = moznode.loc, end = loc && loc.end;
          var range = moznode.range;
          return new AST_Token("", "", end && end.line || 0, end && end.column || 0, range ? range[0] : moznode.end, false, [], [], loc && loc.source);
        }
        var FROM_MOZ_LABELS = null;
        function from_moz(node) {
          if (node == null)
            return null;
          return MOZ_TO_ME[node.type](node);
        }
        function from_moz_quote(moz_key, computed) {
          if (!computed && moz_key.type === "Literal" && typeof moz_key.value === "string") {
            return '"';
          } else {
            return "";
          }
        }
        function from_moz_symbol(symbol_type, M, has_quote) {
          return new symbol_type({
            start: my_start_token(M),
            quote: has_quote ? '"' : void 0,
            name: M.type === "Identifier" ? M.name : String(M.value),
            end: my_end_token(M)
          });
        }
        function from_moz_lambda(M, is_method) {
          return new (is_method ? AST_Accessor : AST_Function)({
            start: my_start_token(M),
            end: my_end_token(M),
            name: M.id && from_moz_symbol(is_method ? AST_SymbolMethod : AST_SymbolLambda, M.id),
            argnames: M.params.map((M2) => from_moz_pattern(M2, AST_SymbolFunarg)),
            is_generator: M.generator,
            async: M.async,
            body: normalize_directives(from_moz(M.body).body)
          });
        }
        function from_moz_pattern(M, sym_type) {
          switch (M.type) {
            case "ObjectPattern":
              return new AST_Destructuring({
                start: my_start_token(M),
                end: my_end_token(M),
                names: M.properties.map((p) => from_moz_pattern(p, sym_type)),
                is_array: false
              });
            case "Property":
              var key2 = M.key;
              var args = {
                start: my_start_token(key2 || M.value),
                end: my_end_token(M.value),
                key: key2.type == "Identifier" ? key2.name : String(key2.value),
                quote: !M.computed && key2.type === "Literal" && typeof key2.value === "string" ? '"' : "",
                value: from_moz_pattern(M.value, sym_type)
              };
              if (M.computed) {
                args.key = from_moz(M.key);
              }
              return new AST_ObjectKeyVal(args);
            case "ArrayPattern":
              return new AST_Destructuring({
                start: my_start_token(M),
                end: my_end_token(M),
                names: M.elements.map(function(elm) {
                  if (elm === null) {
                    return new AST_Hole();
                  }
                  return from_moz_pattern(elm, sym_type);
                }),
                is_array: true
              });
            case "SpreadElement":
            case "RestElement":
              return new AST_Expansion({
                start: my_start_token(M),
                end: my_end_token(M),
                expression: from_moz_pattern(M.argument, sym_type)
              });
            case "AssignmentPattern":
              return new AST_DefaultAssign({
                start: my_start_token(M),
                end: my_end_token(M),
                left: from_moz_pattern(M.left, sym_type),
                operator: "=",
                right: from_moz(M.right)
              });
            case "Identifier":
              return new sym_type({
                start: my_start_token(M),
                end: my_end_token(M),
                name: M.name
              });
            default:
              throw new Error("Invalid node type for destructuring: " + M.type);
          }
        }
        function from_moz_label_ref(m_label) {
          if (!m_label)
            return null;
          const label = from_moz_symbol(AST_LabelRef, m_label);
          let i = FROM_MOZ_LABELS.length;
          while (i--) {
            const label_origin = FROM_MOZ_LABELS[i];
            if (label.name === label_origin.name) {
              label.thedef = label_origin;
              break;
            }
          }
          return label;
        }
        AST_Node.from_mozilla_ast = function(node) {
          var save_labels = FROM_MOZ_LABELS;
          FROM_MOZ_LABELS = [];
          var ast = from_moz(node);
          FROM_MOZ_LABELS = save_labels;
          return ast;
        };
        function set_moz_loc(mynode, moznode) {
          var start = mynode.start;
          var end = mynode.end;
          if (!(start && end)) {
            return moznode;
          }
          if (start.pos != null && end.endpos != null) {
            moznode.range = [start.pos, end.endpos];
          }
          if (start.line) {
            moznode.loc = {
              start: { line: start.line, column: start.col },
              end: end.endline ? { line: end.endline, column: end.endcol } : null
            };
            if (start.file) {
              moznode.loc.source = start.file;
            }
          }
          return moznode;
        }
        function def_to_moz(mytype, handler) {
          mytype.DEFMETHOD("to_mozilla_ast", function(parent) {
            return set_moz_loc(this, handler(this, parent));
          });
        }
        var TO_MOZ_STACK = null;
        function to_moz(node) {
          if (TO_MOZ_STACK === null) {
            TO_MOZ_STACK = [];
          }
          TO_MOZ_STACK.push(node);
          var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;
          TO_MOZ_STACK.pop();
          if (TO_MOZ_STACK.length === 0) {
            TO_MOZ_STACK = null;
          }
          return ast;
        }
        function to_moz_property_key(key2, computed = false, quote = false, value2 = null) {
          if (computed) {
            return [false, to_moz(key2)];
          }
          const key_name = typeof key2 === "string" ? key2 : key2.name;
          let moz_key;
          if (quote) {
            moz_key = { type: "Literal", value: key_name, raw: JSON.stringify(key_name) };
          } else if ("" + +key_name === key_name && +key_name >= 0) {
            moz_key = { type: "Literal", value: +key_name, raw: JSON.stringify(+key_name) };
          } else {
            moz_key = { type: "Identifier", name: key_name };
          }
          const shorthand = moz_key.type === "Identifier" && moz_key.name === key_name && (value2 instanceof AST_Symbol && value2.name === key_name || value2 instanceof AST_DefaultAssign && value2.left.name === key_name);
          return [shorthand, moz_key];
        }
        function to_moz_pattern(node) {
          if (node instanceof AST_Expansion) {
            return {
              type: "RestElement",
              argument: to_moz_pattern(node.expression)
            };
          }
          if (node instanceof AST_Symbol || node instanceof AST_Destructuring || node instanceof AST_DefaultAssign || node instanceof AST_PropAccess) {
            return to_moz(node);
          }
          throw new Error(node.TYPE);
        }
        function to_moz_in_destructuring() {
          var i = TO_MOZ_STACK.length;
          while (i--) {
            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {
              return true;
            }
          }
          return false;
        }
        function to_moz_block(node) {
          return {
            type: "BlockStatement",
            body: node.body.map(to_moz)
          };
        }
        function to_moz_scope(type, node) {
          var body = node.body.map(to_moz);
          if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {
            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));
          }
          return {
            type,
            body
          };
        }
      })();
      function first_in_statement(stack) {
        let node = stack.parent(-1);
        for (let i = 0, p; p = stack.parent(i); i++) {
          if (p instanceof AST_Statement && p.body === node)
            return true;
          if (p instanceof AST_Sequence && p.expressions[0] === node || p.TYPE === "Call" && p.expression === node || p instanceof AST_PrefixedTemplateString && p.prefix === node || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Chain && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {
            node = p;
          } else {
            return false;
          }
        }
      }
      function left_is_object(node) {
        if (node instanceof AST_Object)
          return true;
        if (node instanceof AST_Sequence)
          return left_is_object(node.expressions[0]);
        if (node.TYPE === "Call")
          return left_is_object(node.expression);
        if (node instanceof AST_PrefixedTemplateString)
          return left_is_object(node.prefix);
        if (node instanceof AST_Dot || node instanceof AST_Sub)
          return left_is_object(node.expression);
        if (node instanceof AST_Chain)
          return left_is_object(node.expression);
        if (node instanceof AST_Conditional)
          return left_is_object(node.condition);
        if (node instanceof AST_Binary)
          return left_is_object(node.left);
        if (node instanceof AST_UnaryPostfix)
          return left_is_object(node.expression);
        return false;
      }
      const CODE_LINE_BREAK = 10;
      const CODE_SPACE = 32;
      const r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/;
      function is_some_comments(comment) {
        return (comment.type === "comment2" || comment.type === "comment1") && /@preserve|@copyright|@lic|@cc_on|^\**!/i.test(comment.value);
      }
      const ROPE_COMMIT_WHEN = 8 * 1e3;
      class Rope {
        constructor() {
          this.committed = "";
          this.current = "";
        }
        append(str) {
          if (this.current.length > ROPE_COMMIT_WHEN) {
            this.committed += this.current + str;
            this.current = "";
          } else {
            this.current += str;
          }
        }
        insertAt(char2, index) {
          const { committed, current } = this;
          if (index < committed.length) {
            this.committed = committed.slice(0, index) + char2 + committed.slice(index);
          } else if (index === committed.length) {
            this.committed += char2;
          } else {
            index -= committed.length;
            this.committed += current.slice(0, index) + char2;
            this.current = current.slice(index);
          }
        }
        charAt(index) {
          const { committed } = this;
          if (index < committed.length)
            return committed[index];
          return this.current[index - committed.length];
        }
        charCodeAt(index) {
          const { committed } = this;
          if (index < committed.length)
            return committed.charCodeAt(index);
          return this.current.charCodeAt(index - committed.length);
        }
        length() {
          return this.committed.length + this.current.length;
        }
        expectDirective() {
          let ch, n2 = this.length();
          if (n2 <= 0)
            return true;
          while ((ch = this.charCodeAt(--n2)) && (ch == CODE_SPACE || ch == CODE_LINE_BREAK))
            ;
          return !ch || ch === 59 || ch === 123;
        }
        hasNLB() {
          let n2 = this.length() - 1;
          while (n2 >= 0) {
            const code = this.charCodeAt(n2--);
            if (code === CODE_LINE_BREAK)
              return true;
            if (code !== CODE_SPACE)
              return false;
          }
          return true;
        }
        toString() {
          return this.committed + this.current;
        }
      }
      function OutputStream(options) {
        var readonly = !options;
        options = defaults(options, {
          ascii_only: false,
          beautify: false,
          braces: false,
          comments: "some",
          ecma: 5,
          ie8: false,
          indent_level: 4,
          indent_start: 0,
          inline_script: true,
          keep_numbers: false,
          keep_quoted_props: false,
          max_line_len: false,
          preamble: null,
          preserve_annotations: false,
          quote_keys: false,
          quote_style: 0,
          safari10: false,
          semicolons: true,
          shebang: true,
          shorthand: void 0,
          source_map: null,
          webkit: false,
          width: 80,
          wrap_iife: false,
          wrap_func_args: false,
          _destroy_ast: false
        }, true);
        if (options.shorthand === void 0)
          options.shorthand = options.ecma > 5;
        var comment_filter = return_false;
        if (options.comments) {
          let comments = options.comments;
          if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
            var regex_pos = options.comments.lastIndexOf("/");
            comments = new RegExp(options.comments.substr(1, regex_pos - 1), options.comments.substr(regex_pos + 1));
          }
          if (comments instanceof RegExp) {
            comment_filter = function(comment) {
              return comment.type != "comment5" && comments.test(comment.value);
            };
          } else if (typeof comments === "function") {
            comment_filter = function(comment) {
              return comment.type != "comment5" && comments(this, comment);
            };
          } else if (comments === "some") {
            comment_filter = is_some_comments;
          } else {
            comment_filter = return_true;
          }
        }
        if (options.preserve_annotations) {
          let prev_comment_filter = comment_filter;
          comment_filter = function(comment) {
            return r_annotation.test(comment.value) || prev_comment_filter.apply(this, arguments);
          };
        }
        var indentation = 0;
        var current_col = 0;
        var current_line = 1;
        var current_pos = 0;
        var OUTPUT = new Rope();
        let printed_comments = /* @__PURE__ */ new Set();
        var to_utf8 = options.ascii_only ? function(str, identifier = false, regexp = false) {
          if (options.ecma >= 2015 && !options.safari10 && !regexp) {
            str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
              var code = get_full_char_code(ch, 0).toString(16);
              return "\\u{" + code + "}";
            });
          }
          return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
              while (code.length < 2)
                code = "0" + code;
              return "\\x" + code;
            } else {
              while (code.length < 4)
                code = "0" + code;
              return "\\u" + code;
            }
          });
        } : function(str) {
          return str.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, function(match, lone) {
            if (lone) {
              return "\\u" + lone.charCodeAt(0).toString(16);
            }
            return match;
          });
        };
        function make_string(str, quote) {
          var dq = 0, sq = 0;
          str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g, function(s, i) {
            switch (s) {
              case '"':
                ++dq;
                return '"';
              case "'":
                ++sq;
                return "'";
              case "\\":
                return "\\\\";
              case "\n":
                return "\\n";
              case "\r":
                return "\\r";
              case "	":
                return "\\t";
              case "\b":
                return "\\b";
              case "\f":
                return "\\f";
              case "\v":
                return options.ie8 ? "\\x0B" : "\\v";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              case "\uFEFF":
                return "\\ufeff";
              case "\0":
                return /[0-9]/.test(get_full_char(str, i + 1)) ? "\\x00" : "\\0";
            }
            return s;
          });
          function quote_single() {
            return "'" + str.replace(/\x27/g, "\\'") + "'";
          }
          function quote_double() {
            return '"' + str.replace(/\x22/g, '\\"') + '"';
          }
          function quote_template() {
            return "`" + str.replace(/`/g, "\\`") + "`";
          }
          str = to_utf8(str);
          if (quote === "`")
            return quote_template();
          switch (options.quote_style) {
            case 1:
              return quote_single();
            case 2:
              return quote_double();
            case 3:
              return quote == "'" ? quote_single() : quote_double();
            default:
              return dq > sq ? quote_single() : quote_double();
          }
        }
        function encode_string(str, quote) {
          var ret = make_string(str, quote);
          if (options.inline_script) {
            ret = ret.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
            ret = ret.replace(/\x3c!--/g, "\\x3c!--");
            ret = ret.replace(/--\x3e/g, "--\\x3e");
          }
          return ret;
        }
        function make_name(name) {
          name = name.toString();
          name = to_utf8(name, true);
          return name;
        }
        function make_indent(back) {
          return " ".repeat(options.indent_start + indentation - back * options.indent_level);
        }
        var has_parens = false;
        var might_need_space = false;
        var might_need_semicolon = false;
        var might_add_newline = 0;
        var need_newline_indented = false;
        var need_space = false;
        var newline_insert = -1;
        var last = "";
        var mapping_token, mapping_name, mappings = options.source_map && [];
        var do_add_mapping = mappings ? function() {
          mappings.forEach(function(mapping) {
            try {
              let { name, token } = mapping;
              if (name !== false) {
                if (token.type == "name" || token.type === "privatename") {
                  name = token.value;
                } else if (name instanceof AST_Symbol) {
                  name = token.type === "string" ? token.value : name.name;
                }
              }
              options.source_map.add(mapping.token.file, mapping.line, mapping.col, mapping.token.line, mapping.token.col, is_basic_identifier_string(name) ? name : void 0);
            } catch (ex) {
            }
          });
          mappings = [];
        } : noop2;
        var ensure_line_len = options.max_line_len ? function() {
          if (current_col > options.max_line_len) {
            if (might_add_newline) {
              OUTPUT.insertAt("\n", might_add_newline);
              const len_after_newline = OUTPUT.length() - might_add_newline - 1;
              if (mappings) {
                var delta = len_after_newline - current_col;
                mappings.forEach(function(mapping) {
                  mapping.line++;
                  mapping.col += delta;
                });
              }
              current_line++;
              current_pos++;
              current_col = len_after_newline;
            }
          }
          if (might_add_newline) {
            might_add_newline = 0;
            do_add_mapping();
          }
        } : noop2;
        var requireSemicolonChars = makePredicate("( [ + * / - , . `");
        function print(str) {
          str = String(str);
          var ch = get_full_char(str, 0);
          if (need_newline_indented && ch) {
            need_newline_indented = false;
            if (ch !== "\n") {
              print("\n");
              indent();
            }
          }
          if (need_space && ch) {
            need_space = false;
            if (!/[\s;})]/.test(ch)) {
              space2();
            }
          }
          newline_insert = -1;
          var prev = last.charAt(last.length - 1);
          if (might_need_semicolon) {
            might_need_semicolon = false;
            if (prev === ":" && ch === "}" || (!ch || !";}".includes(ch)) && prev !== ";") {
              if (options.semicolons || requireSemicolonChars.has(ch)) {
                OUTPUT.append(";");
                current_col++;
                current_pos++;
              } else {
                ensure_line_len();
                if (current_col > 0) {
                  OUTPUT.append("\n");
                  current_pos++;
                  current_line++;
                  current_col = 0;
                }
                if (/^\s+$/.test(str)) {
                  might_need_semicolon = true;
                }
              }
              if (!options.beautify)
                might_need_space = false;
            }
          }
          if (might_need_space) {
            if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == "\\") || ch == "/" && ch == prev || (ch == "+" || ch == "-") && ch == last) {
              OUTPUT.append(" ");
              current_col++;
              current_pos++;
            }
            might_need_space = false;
          }
          if (mapping_token) {
            mappings.push({
              token: mapping_token,
              name: mapping_name,
              line: current_line,
              col: current_col
            });
            mapping_token = false;
            if (!might_add_newline)
              do_add_mapping();
          }
          OUTPUT.append(str);
          has_parens = str[str.length - 1] == "(";
          current_pos += str.length;
          var a = str.split(/\r?\n/), n2 = a.length - 1;
          current_line += n2;
          current_col += a[0].length;
          if (n2 > 0) {
            ensure_line_len();
            current_col = a[n2].length;
          }
          last = str;
        }
        var star = function() {
          print("*");
        };
        var space2 = options.beautify ? function() {
          print(" ");
        } : function() {
          might_need_space = true;
        };
        var indent = options.beautify ? function(half) {
          if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
          }
        } : noop2;
        var with_indent = options.beautify ? function(col, cont) {
          if (col === true)
            col = next_indent();
          var save_indentation = indentation;
          indentation = col;
          var ret = cont();
          indentation = save_indentation;
          return ret;
        } : function(col, cont) {
          return cont();
        };
        var newline = options.beautify ? function() {
          if (newline_insert < 0)
            return print("\n");
          if (OUTPUT.charAt(newline_insert) != "\n") {
            OUTPUT.insertAt("\n", newline_insert);
            current_pos++;
            current_line++;
          }
          newline_insert++;
        } : options.max_line_len ? function() {
          ensure_line_len();
          might_add_newline = OUTPUT.length();
        } : noop2;
        var semicolon = options.beautify ? function() {
          print(";");
        } : function() {
          might_need_semicolon = true;
        };
        function force_semicolon() {
          might_need_semicolon = false;
          print(";");
        }
        function next_indent() {
          return indentation + options.indent_level;
        }
        function with_block(cont) {
          var ret;
          print("{");
          newline();
          with_indent(next_indent(), function() {
            ret = cont();
          });
          indent();
          print("}");
          return ret;
        }
        function with_parens(cont) {
          print("(");
          var ret = cont();
          print(")");
          return ret;
        }
        function with_square(cont) {
          print("[");
          var ret = cont();
          print("]");
          return ret;
        }
        function comma() {
          print(",");
          space2();
        }
        function colon() {
          print(":");
          space2();
        }
        var add_mapping = mappings ? function(token, name) {
          mapping_token = token;
          mapping_name = name;
        } : noop2;
        function get() {
          if (might_add_newline) {
            ensure_line_len();
          }
          return OUTPUT.toString();
        }
        function filter_comment(comment) {
          if (!options.preserve_annotations) {
            comment = comment.replace(r_annotation, " ");
          }
          if (/^\s*$/.test(comment)) {
            return "";
          }
          return comment.replace(/(<\s*\/\s*)(script)/i, "<\\/$2");
        }
        function prepend_comments(node) {
          var self2 = this;
          var start = node.start;
          if (!start)
            return;
          var printed_comments2 = self2.printed_comments;
          const keyword_with_value = node instanceof AST_Exit && node.value || (node instanceof AST_Await || node instanceof AST_Yield) && node.expression;
          if (start.comments_before && printed_comments2.has(start.comments_before)) {
            if (keyword_with_value) {
              start.comments_before = [];
            } else {
              return;
            }
          }
          var comments = start.comments_before;
          if (!comments) {
            comments = start.comments_before = [];
          }
          printed_comments2.add(comments);
          if (keyword_with_value) {
            var tw = new TreeWalker(function(node2) {
              var parent = tw.parent();
              if (parent instanceof AST_Exit || parent instanceof AST_Await || parent instanceof AST_Yield || parent instanceof AST_Binary && parent.left === node2 || parent.TYPE == "Call" && parent.expression === node2 || parent instanceof AST_Conditional && parent.condition === node2 || parent instanceof AST_Dot && parent.expression === node2 || parent instanceof AST_Sequence && parent.expressions[0] === node2 || parent instanceof AST_Sub && parent.expression === node2 || parent instanceof AST_UnaryPostfix) {
                if (!node2.start)
                  return;
                var text3 = node2.start.comments_before;
                if (text3 && !printed_comments2.has(text3)) {
                  printed_comments2.add(text3);
                  comments = comments.concat(text3);
                }
              } else {
                return true;
              }
            });
            tw.push(node);
            keyword_with_value.walk(tw);
          }
          if (current_pos == 0) {
            if (comments.length > 0 && options.shebang && comments[0].type === "comment5" && !printed_comments2.has(comments[0])) {
              print("#!" + comments.shift().value + "\n");
              indent();
            }
            var preamble = options.preamble;
            if (preamble) {
              print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
            }
          }
          comments = comments.filter(comment_filter, node).filter((c) => !printed_comments2.has(c));
          if (comments.length == 0)
            return;
          var last_nlb = OUTPUT.hasNLB();
          comments.forEach(function(c, i) {
            printed_comments2.add(c);
            if (!last_nlb) {
              if (c.nlb) {
                print("\n");
                indent();
                last_nlb = true;
              } else if (i > 0) {
                space2();
              }
            }
            if (/comment[134]/.test(c.type)) {
              var value2 = filter_comment(c.value);
              if (value2) {
                print("//" + value2 + "\n");
                indent();
              }
              last_nlb = true;
            } else if (c.type == "comment2") {
              var value2 = filter_comment(c.value);
              if (value2) {
                print("/*" + value2 + "*/");
              }
              last_nlb = false;
            }
          });
          if (!last_nlb) {
            if (start.nlb) {
              print("\n");
              indent();
            } else {
              space2();
            }
          }
        }
        function append_comments(node, tail) {
          var self2 = this;
          var token = node.end;
          if (!token)
            return;
          var printed_comments2 = self2.printed_comments;
          var comments = token[tail ? "comments_before" : "comments_after"];
          if (!comments || printed_comments2.has(comments))
            return;
          if (!(node instanceof AST_Statement || comments.every((c) => !/comment[134]/.test(c.type))))
            return;
          printed_comments2.add(comments);
          var insert2 = OUTPUT.length();
          comments.filter(comment_filter, node).forEach(function(c, i) {
            if (printed_comments2.has(c))
              return;
            printed_comments2.add(c);
            need_space = false;
            if (need_newline_indented) {
              print("\n");
              indent();
              need_newline_indented = false;
            } else if (c.nlb && (i > 0 || !OUTPUT.hasNLB())) {
              print("\n");
              indent();
            } else if (i > 0 || !tail) {
              space2();
            }
            if (/comment[134]/.test(c.type)) {
              const value2 = filter_comment(c.value);
              if (value2) {
                print("//" + value2);
              }
              need_newline_indented = true;
            } else if (c.type == "comment2") {
              const value2 = filter_comment(c.value);
              if (value2) {
                print("/*" + value2 + "*/");
              }
              need_space = true;
            }
          });
          if (OUTPUT.length() > insert2)
            newline_insert = insert2;
        }
        const gc_scope = options["_destroy_ast"] ? function gc_scope2(scope) {
          scope.body.length = 0;
          scope.argnames.length = 0;
        } : noop2;
        var stack = [];
        return {
          get,
          toString: get,
          indent,
          in_directive: false,
          use_asm: null,
          active_scope: null,
          indentation: function() {
            return indentation;
          },
          current_width: function() {
            return current_col - indentation;
          },
          should_break: function() {
            return options.width && this.current_width() >= options.width;
          },
          has_parens: function() {
            return has_parens;
          },
          newline,
          print,
          star,
          space: space2,
          comma,
          colon,
          last: function() {
            return last;
          },
          semicolon,
          force_semicolon,
          to_utf8,
          print_name: function(name) {
            print(make_name(name));
          },
          print_string: function(str, quote, escape_directive) {
            var encoded = encode_string(str, quote);
            if (escape_directive === true && !encoded.includes("\\")) {
              if (!OUTPUT.expectDirective()) {
                force_semicolon();
              }
              force_semicolon();
            }
            print(encoded);
          },
          print_template_string_chars: function(str) {
            var encoded = encode_string(str, "`").replace(/\${/g, "\\${");
            return print(encoded.substr(1, encoded.length - 2));
          },
          encode_string,
          next_indent,
          with_indent,
          with_block,
          with_parens,
          with_square,
          add_mapping,
          option: function(opt) {
            return options[opt];
          },
          gc_scope,
          printed_comments,
          prepend_comments: readonly ? noop2 : prepend_comments,
          append_comments: readonly || comment_filter === return_false ? noop2 : append_comments,
          line: function() {
            return current_line;
          },
          col: function() {
            return current_col;
          },
          pos: function() {
            return current_pos;
          },
          push_node: function(node) {
            stack.push(node);
          },
          pop_node: function() {
            return stack.pop();
          },
          parent: function(n2) {
            return stack[stack.length - 2 - (n2 || 0)];
          }
        };
      }
      (function() {
        function DEFPRINT(nodetype, generator) {
          nodetype.DEFMETHOD("_codegen", generator);
        }
        AST_Node.DEFMETHOD("print", function(output, force_parens) {
          var self2 = this, generator = self2._codegen;
          if (self2 instanceof AST_Scope) {
            output.active_scope = self2;
          } else if (!output.use_asm && self2 instanceof AST_Directive && self2.value == "use asm") {
            output.use_asm = output.active_scope;
          }
          function doit() {
            output.prepend_comments(self2);
            self2.add_source_map(output);
            generator(self2, output);
            output.append_comments(self2);
          }
          output.push_node(self2);
          if (force_parens || self2.needs_parens(output)) {
            output.with_parens(doit);
          } else {
            doit();
          }
          output.pop_node();
          if (self2 === output.use_asm) {
            output.use_asm = null;
          }
        });
        AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);
        AST_Node.DEFMETHOD("print_to_string", function(options) {
          var output = OutputStream(options);
          this.print(output);
          return output.get();
        });
        function PARENS(nodetype, func) {
          if (Array.isArray(nodetype)) {
            nodetype.forEach(function(nodetype2) {
              PARENS(nodetype2, func);
            });
          } else {
            nodetype.DEFMETHOD("needs_parens", func);
          }
        }
        PARENS(AST_Node, return_false);
        PARENS(AST_Function, function(output) {
          if (!output.has_parens() && first_in_statement(output)) {
            return true;
          }
          if (output.option("webkit")) {
            var p = output.parent();
            if (p instanceof AST_PropAccess && p.expression === this) {
              return true;
            }
          }
          if (output.option("wrap_iife")) {
            var p = output.parent();
            if (p instanceof AST_Call && p.expression === this) {
              return true;
            }
          }
          if (output.option("wrap_func_args")) {
            var p = output.parent();
            if (p instanceof AST_Call && p.args.includes(this)) {
              return true;
            }
          }
          return false;
        });
        PARENS(AST_Arrow, function(output) {
          var p = output.parent();
          if (output.option("wrap_func_args") && p instanceof AST_Call && p.args.includes(this)) {
            return true;
          }
          return p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Conditional && p.condition === this;
        });
        PARENS(AST_Object, function(output) {
          return !output.has_parens() && first_in_statement(output);
        });
        PARENS(AST_ClassExpression, first_in_statement);
        PARENS(AST_Unary, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Call && p.expression === this || p instanceof AST_Binary && p.operator === "**" && this instanceof AST_UnaryPrefix && p.left === this && this.operator !== "++" && this.operator !== "--";
        });
        PARENS(AST_Await, function(output) {
          var p = output.parent();
          return p instanceof AST_PropAccess && p.expression === this || p instanceof AST_Call && p.expression === this || p instanceof AST_Binary && p.operator === "**" && p.left === this || output.option("safari10") && p instanceof AST_UnaryPrefix;
        });
        PARENS(AST_Sequence, function(output) {
          var p = output.parent();
          return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_PropAccess || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional || p instanceof AST_Arrow || p instanceof AST_DefaultAssign || p instanceof AST_Expansion || p instanceof AST_ForOf && this === p.object || p instanceof AST_Yield || p instanceof AST_Export;
        });
        PARENS(AST_Binary, function(output) {
          var p = output.parent();
          if (p instanceof AST_Call && p.expression === this)
            return true;
          if (p instanceof AST_Unary)
            return true;
          if (p instanceof AST_PropAccess && p.expression === this)
            return true;
          if (p instanceof AST_Binary) {
            const parent_op = p.operator;
            const op = this.operator;
            if (op === "??" && (parent_op === "||" || parent_op === "&&")) {
              return true;
            }
            if (parent_op === "??" && (op === "||" || op === "&&")) {
              return true;
            }
            const pp = PRECEDENCE[parent_op];
            const sp = PRECEDENCE[op];
            if (pp > sp || pp == sp && (this === p.right || parent_op == "**")) {
              return true;
            }
          }
          if (p instanceof AST_PrivateIn) {
            const op = this.operator;
            const pp = PRECEDENCE["in"];
            const sp = PRECEDENCE[op];
            if (pp > sp || pp == sp && this === p.value) {
              return true;
            }
          }
        });
        PARENS(AST_PrivateIn, function(output) {
          var p = output.parent();
          if (p instanceof AST_Call && p.expression === this) {
            return true;
          }
          if (p instanceof AST_Unary) {
            return true;
          }
          if (p instanceof AST_PropAccess && p.expression === this) {
            return true;
          }
          if (p instanceof AST_Binary) {
            const parent_op = p.operator;
            const pp = PRECEDENCE[parent_op];
            const sp = PRECEDENCE["in"];
            if (pp > sp || pp == sp && (this === p.right || parent_op == "**")) {
              return true;
            }
          }
          if (p instanceof AST_PrivateIn && this === p.value) {
            return true;
          }
        });
        PARENS(AST_Yield, function(output) {
          var p = output.parent();
          if (p instanceof AST_Binary && p.operator !== "=")
            return true;
          if (p instanceof AST_Call && p.expression === this)
            return true;
          if (p instanceof AST_Conditional && p.condition === this)
            return true;
          if (p instanceof AST_Unary)
            return true;
          if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        });
        PARENS(AST_Chain, function(output) {
          var p = output.parent();
          if (!(p instanceof AST_Call || p instanceof AST_PropAccess))
            return false;
          return p.expression === this;
        });
        PARENS(AST_PropAccess, function(output) {
          var p = output.parent();
          if (p instanceof AST_New && p.expression === this) {
            return walk(this, (node) => {
              if (node instanceof AST_Scope)
                return true;
              if (node instanceof AST_Call) {
                return walk_abort;
              }
            });
          }
        });
        PARENS(AST_Call, function(output) {
          var p = output.parent(), p1;
          if (p instanceof AST_New && p.expression === this || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)
            return true;
          return this.expression instanceof AST_Function && p instanceof AST_PropAccess && p.expression === this && (p1 = output.parent(1)) instanceof AST_Assign && p1.left === p;
        });
        PARENS(AST_New, function(output) {
          var p = output.parent();
          if (this.args.length === 0 && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this || p instanceof AST_PrefixedTemplateString && p.prefix === this))
            return true;
        });
        PARENS(AST_Number, function(output) {
          var p = output.parent();
          if (p instanceof AST_PropAccess && p.expression === this) {
            var value2 = this.getValue();
            if (value2 < 0 || /^0/.test(make_num(value2))) {
              return true;
            }
          }
        });
        PARENS(AST_BigInt, function(output) {
          var p = output.parent();
          if (p instanceof AST_PropAccess && p.expression === this) {
            var value2 = this.getValue();
            if (value2.startsWith("-")) {
              return true;
            }
          }
        });
        PARENS([AST_Assign, AST_Conditional], function(output) {
          var p = output.parent();
          if (p instanceof AST_Unary)
            return true;
          if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
          if (p instanceof AST_Call && p.expression === this)
            return true;
          if (p instanceof AST_Conditional && p.condition === this)
            return true;
          if (p instanceof AST_PropAccess && p.expression === this)
            return true;
          if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)
            return true;
        });
        DEFPRINT(AST_Directive, function(self2, output) {
          output.print_string(self2.value, self2.quote);
          output.semicolon();
        });
        DEFPRINT(AST_Expansion, function(self2, output) {
          output.print("...");
          self2.expression.print(output);
        });
        DEFPRINT(AST_Destructuring, function(self2, output) {
          output.print(self2.is_array ? "[" : "{");
          var len = self2.names.length;
          self2.names.forEach(function(name, i) {
            if (i > 0)
              output.comma();
            name.print(output);
            if (i == len - 1 && name instanceof AST_Hole)
              output.comma();
          });
          output.print(self2.is_array ? "]" : "}");
        });
        DEFPRINT(AST_Debugger, function(self2, output) {
          output.print("debugger");
          output.semicolon();
        });
        function display_body(body, is_toplevel, output, allow_directives) {
          var last = body.length - 1;
          output.in_directive = allow_directives;
          body.forEach(function(stmt, i) {
            if (output.in_directive === true && !(stmt instanceof AST_Directive || stmt instanceof AST_EmptyStatement || stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)) {
              output.in_directive = false;
            }
            if (!(stmt instanceof AST_EmptyStatement)) {
              output.indent();
              stmt.print(output);
              if (!(i == last && is_toplevel)) {
                output.newline();
                if (is_toplevel)
                  output.newline();
              }
            }
            if (output.in_directive === true && stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {
              output.in_directive = false;
            }
          });
          output.in_directive = false;
        }
        AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
          print_maybe_braced_body(this.body, output);
        });
        DEFPRINT(AST_Statement, function(self2, output) {
          self2.body.print(output);
          output.semicolon();
        });
        DEFPRINT(AST_Toplevel, function(self2, output) {
          display_body(self2.body, true, output, true);
          output.print("");
        });
        DEFPRINT(AST_LabeledStatement, function(self2, output) {
          self2.label.print(output);
          output.colon();
          self2.body.print(output);
        });
        DEFPRINT(AST_SimpleStatement, function(self2, output) {
          self2.body.print(output);
          output.semicolon();
        });
        function print_braced_empty(self2, output) {
          output.print("{");
          output.with_indent(output.next_indent(), function() {
            output.append_comments(self2, true);
          });
          output.add_mapping(self2.end);
          output.print("}");
        }
        function print_braced(self2, output, allow_directives) {
          if (self2.body.length > 0) {
            output.with_block(function() {
              display_body(self2.body, false, output, allow_directives);
              output.add_mapping(self2.end);
            });
          } else
            print_braced_empty(self2, output);
        }
        DEFPRINT(AST_BlockStatement, function(self2, output) {
          print_braced(self2, output);
        });
        DEFPRINT(AST_EmptyStatement, function(self2, output) {
          output.semicolon();
        });
        DEFPRINT(AST_Do, function(self2, output) {
          output.print("do");
          output.space();
          make_block(self2.body, output);
          output.space();
          output.print("while");
          output.space();
          output.with_parens(function() {
            self2.condition.print(output);
          });
          output.semicolon();
        });
        DEFPRINT(AST_While, function(self2, output) {
          output.print("while");
          output.space();
          output.with_parens(function() {
            self2.condition.print(output);
          });
          output.space();
          self2._do_print_body(output);
        });
        DEFPRINT(AST_For, function(self2, output) {
          output.print("for");
          output.space();
          output.with_parens(function() {
            if (self2.init) {
              if (self2.init instanceof AST_Definitions) {
                self2.init.print(output);
              } else {
                parenthesize_for_noin(self2.init, output, true);
              }
              output.print(";");
              output.space();
            } else {
              output.print(";");
            }
            if (self2.condition) {
              self2.condition.print(output);
              output.print(";");
              output.space();
            } else {
              output.print(";");
            }
            if (self2.step) {
              self2.step.print(output);
            }
          });
          output.space();
          self2._do_print_body(output);
        });
        DEFPRINT(AST_ForIn, function(self2, output) {
          output.print("for");
          if (self2.await) {
            output.space();
            output.print("await");
          }
          output.space();
          output.with_parens(function() {
            self2.init.print(output);
            output.space();
            output.print(self2 instanceof AST_ForOf ? "of" : "in");
            output.space();
            self2.object.print(output);
          });
          output.space();
          self2._do_print_body(output);
        });
        DEFPRINT(AST_With, function(self2, output) {
          output.print("with");
          output.space();
          output.with_parens(function() {
            self2.expression.print(output);
          });
          output.space();
          self2._do_print_body(output);
        });
        AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
          var self2 = this;
          if (!nokeyword) {
            if (self2.async) {
              output.print("async");
              output.space();
            }
            output.print("function");
            if (self2.is_generator) {
              output.star();
            }
            if (self2.name) {
              output.space();
            }
          }
          if (self2.name instanceof AST_Symbol) {
            self2.name.print(output);
          } else if (nokeyword && self2.name instanceof AST_Node) {
            output.with_square(function() {
              self2.name.print(output);
            });
          }
          output.with_parens(function() {
            self2.argnames.forEach(function(arg, i) {
              if (i)
                output.comma();
              arg.print(output);
            });
          });
          output.space();
          print_braced(self2, output, true);
        });
        DEFPRINT(AST_Lambda, function(self2, output) {
          self2._do_print(output);
          output.gc_scope(self2);
        });
        DEFPRINT(AST_PrefixedTemplateString, function(self2, output) {
          var tag = self2.prefix;
          var parenthesize_tag = tag instanceof AST_Lambda || tag instanceof AST_Binary || tag instanceof AST_Conditional || tag instanceof AST_Sequence || tag instanceof AST_Unary || tag instanceof AST_Dot && tag.expression instanceof AST_Object;
          if (parenthesize_tag)
            output.print("(");
          self2.prefix.print(output);
          if (parenthesize_tag)
            output.print(")");
          self2.template_string.print(output);
        });
        DEFPRINT(AST_TemplateString, function(self2, output) {
          var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;
          output.print("`");
          for (var i = 0; i < self2.segments.length; i++) {
            if (!(self2.segments[i] instanceof AST_TemplateSegment)) {
              output.print("${");
              self2.segments[i].print(output);
              output.print("}");
            } else if (is_tagged) {
              output.print(self2.segments[i].raw);
            } else {
              output.print_template_string_chars(self2.segments[i].value);
            }
          }
          output.print("`");
        });
        DEFPRINT(AST_TemplateSegment, function(self2, output) {
          output.print_template_string_chars(self2.value);
        });
        AST_Arrow.DEFMETHOD("_do_print", function(output) {
          var self2 = this;
          var parent = output.parent();
          var needs_parens = parent instanceof AST_Binary && !(parent instanceof AST_Assign) && !(parent instanceof AST_DefaultAssign) || parent instanceof AST_Unary || parent instanceof AST_Call && self2 === parent.expression;
          if (needs_parens) {
            output.print("(");
          }
          if (self2.async) {
            output.print("async");
            output.space();
          }
          if (self2.argnames.length === 1 && self2.argnames[0] instanceof AST_Symbol) {
            self2.argnames[0].print(output);
          } else {
            output.with_parens(function() {
              self2.argnames.forEach(function(arg, i) {
                if (i)
                  output.comma();
                arg.print(output);
              });
            });
          }
          output.space();
          output.print("=>");
          output.space();
          const first_statement = self2.body[0];
          if (self2.body.length === 1 && first_statement instanceof AST_Return) {
            const returned = first_statement.value;
            if (!returned) {
              output.print("{}");
            } else if (left_is_object(returned)) {
              output.print("(");
              returned.print(output);
              output.print(")");
            } else {
              returned.print(output);
            }
          } else {
            print_braced(self2, output);
          }
          if (needs_parens) {
            output.print(")");
          }
          output.gc_scope(self2);
        });
        AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
          output.print(kind);
          if (this.value) {
            output.space();
            const comments = this.value.start.comments_before;
            if (comments && comments.length && !output.printed_comments.has(comments)) {
              output.print("(");
              this.value.print(output);
              output.print(")");
            } else {
              this.value.print(output);
            }
          }
          output.semicolon();
        });
        DEFPRINT(AST_Return, function(self2, output) {
          self2._do_print(output, "return");
        });
        DEFPRINT(AST_Throw, function(self2, output) {
          self2._do_print(output, "throw");
        });
        DEFPRINT(AST_Yield, function(self2, output) {
          var star = self2.is_star ? "*" : "";
          output.print("yield" + star);
          if (self2.expression) {
            output.space();
            self2.expression.print(output);
          }
        });
        DEFPRINT(AST_Await, function(self2, output) {
          output.print("await");
          output.space();
          var e = self2.expression;
          var parens = !(e instanceof AST_Call || e instanceof AST_SymbolRef || e instanceof AST_PropAccess || e instanceof AST_Unary || e instanceof AST_Constant || e instanceof AST_Await || e instanceof AST_Object);
          if (parens)
            output.print("(");
          self2.expression.print(output);
          if (parens)
            output.print(")");
        });
        AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
          output.print(kind);
          if (this.label) {
            output.space();
            this.label.print(output);
          }
          output.semicolon();
        });
        DEFPRINT(AST_Break, function(self2, output) {
          self2._do_print(output, "break");
        });
        DEFPRINT(AST_Continue, function(self2, output) {
          self2._do_print(output, "continue");
        });
        function make_then(self2, output) {
          var b = self2.body;
          if (output.option("braces") || output.option("ie8") && b instanceof AST_Do)
            return make_block(b, output);
          if (!b)
            return output.force_semicolon();
          while (true) {
            if (b instanceof AST_If) {
              if (!b.alternative) {
                make_block(self2.body, output);
                return;
              }
              b = b.alternative;
            } else if (b instanceof AST_StatementWithBody) {
              b = b.body;
            } else
              break;
          }
          print_maybe_braced_body(self2.body, output);
        }
        DEFPRINT(AST_If, function(self2, output) {
          output.print("if");
          output.space();
          output.with_parens(function() {
            self2.condition.print(output);
          });
          output.space();
          if (self2.alternative) {
            make_then(self2, output);
            output.space();
            output.print("else");
            output.space();
            if (self2.alternative instanceof AST_If)
              self2.alternative.print(output);
            else
              print_maybe_braced_body(self2.alternative, output);
          } else {
            self2._do_print_body(output);
          }
        });
        DEFPRINT(AST_Switch, function(self2, output) {
          output.print("switch");
          output.space();
          output.with_parens(function() {
            self2.expression.print(output);
          });
          output.space();
          var last = self2.body.length - 1;
          if (last < 0)
            print_braced_empty(self2, output);
          else
            output.with_block(function() {
              self2.body.forEach(function(branch, i) {
                output.indent(true);
                branch.print(output);
                if (i < last && branch.body.length > 0)
                  output.newline();
              });
            });
        });
        AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
          output.newline();
          this.body.forEach(function(stmt) {
            output.indent();
            stmt.print(output);
            output.newline();
          });
        });
        DEFPRINT(AST_Default, function(self2, output) {
          output.print("default:");
          self2._do_print_body(output);
        });
        DEFPRINT(AST_Case, function(self2, output) {
          output.print("case");
          output.space();
          self2.expression.print(output);
          output.print(":");
          self2._do_print_body(output);
        });
        DEFPRINT(AST_Try, function(self2, output) {
          output.print("try");
          output.space();
          self2.body.print(output);
          if (self2.bcatch) {
            output.space();
            self2.bcatch.print(output);
          }
          if (self2.bfinally) {
            output.space();
            self2.bfinally.print(output);
          }
        });
        DEFPRINT(AST_TryBlock, function(self2, output) {
          print_braced(self2, output);
        });
        DEFPRINT(AST_Catch, function(self2, output) {
          output.print("catch");
          if (self2.argname) {
            output.space();
            output.with_parens(function() {
              self2.argname.print(output);
            });
          }
          output.space();
          print_braced(self2, output);
        });
        DEFPRINT(AST_Finally, function(self2, output) {
          output.print("finally");
          output.space();
          print_braced(self2, output);
        });
        AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
          output.print(kind);
          output.space();
          this.definitions.forEach(function(def, i) {
            if (i)
              output.comma();
            def.print(output);
          });
          var p = output.parent();
          var in_for = p instanceof AST_For || p instanceof AST_ForIn;
          var output_semicolon = !in_for || p && p.init !== this;
          if (output_semicolon)
            output.semicolon();
        });
        DEFPRINT(AST_Let, function(self2, output) {
          self2._do_print(output, "let");
        });
        DEFPRINT(AST_Var, function(self2, output) {
          self2._do_print(output, "var");
        });
        DEFPRINT(AST_Const, function(self2, output) {
          self2._do_print(output, "const");
        });
        DEFPRINT(AST_Import, function(self2, output) {
          output.print("import");
          output.space();
          if (self2.imported_name) {
            self2.imported_name.print(output);
          }
          if (self2.imported_name && self2.imported_names) {
            output.print(",");
            output.space();
          }
          if (self2.imported_names) {
            if (self2.imported_names.length === 1 && self2.imported_names[0].foreign_name.name === "*" && !self2.imported_names[0].foreign_name.quote) {
              self2.imported_names[0].print(output);
            } else {
              output.print("{");
              self2.imported_names.forEach(function(name_import, i) {
                output.space();
                name_import.print(output);
                if (i < self2.imported_names.length - 1) {
                  output.print(",");
                }
              });
              output.space();
              output.print("}");
            }
          }
          if (self2.imported_name || self2.imported_names) {
            output.space();
            output.print("from");
            output.space();
          }
          self2.module_name.print(output);
          if (self2.attributes) {
            output.print("with");
            self2.attributes.print(output);
          }
          output.semicolon();
        });
        DEFPRINT(AST_ImportMeta, function(self2, output) {
          output.print("import.meta");
        });
        DEFPRINT(AST_NameMapping, function(self2, output) {
          var is_import = output.parent() instanceof AST_Import;
          var definition = self2.name.definition();
          var foreign_name = self2.foreign_name;
          var names_are_different = (definition && definition.mangled_name || self2.name.name) !== foreign_name.name;
          if (!names_are_different && foreign_name.name === "*" && !!foreign_name.quote != !!self2.name.quote) {
            names_are_different = true;
          }
          var foreign_name_is_name = !foreign_name.quote;
          if (names_are_different) {
            if (is_import) {
              if (foreign_name_is_name) {
                output.print(foreign_name.name);
              } else {
                output.print_string(foreign_name.name, foreign_name.quote);
              }
            } else {
              if (!self2.name.quote) {
                self2.name.print(output);
              } else {
                output.print_string(self2.name.name, self2.name.quote);
              }
            }
            output.space();
            output.print("as");
            output.space();
            if (is_import) {
              self2.name.print(output);
            } else {
              if (foreign_name_is_name) {
                output.print(foreign_name.name);
              } else {
                output.print_string(foreign_name.name, foreign_name.quote);
              }
            }
          } else {
            if (!self2.name.quote) {
              self2.name.print(output);
            } else {
              output.print_string(self2.name.name, self2.name.quote);
            }
          }
        });
        DEFPRINT(AST_Export, function(self2, output) {
          output.print("export");
          output.space();
          if (self2.is_default) {
            output.print("default");
            output.space();
          }
          if (self2.exported_names) {
            if (self2.exported_names.length === 1 && self2.exported_names[0].name.name === "*" && !self2.exported_names[0].name.quote) {
              self2.exported_names[0].print(output);
            } else {
              output.print("{");
              self2.exported_names.forEach(function(name_export, i) {
                output.space();
                name_export.print(output);
                if (i < self2.exported_names.length - 1) {
                  output.print(",");
                }
              });
              output.space();
              output.print("}");
            }
          } else if (self2.exported_value) {
            self2.exported_value.print(output);
          } else if (self2.exported_definition) {
            self2.exported_definition.print(output);
            if (self2.exported_definition instanceof AST_Definitions)
              return;
          }
          if (self2.module_name) {
            output.space();
            output.print("from");
            output.space();
            self2.module_name.print(output);
          }
          if (self2.attributes) {
            output.print("with");
            self2.attributes.print(output);
          }
          if (self2.exported_value && !(self2.exported_value instanceof AST_Defun || self2.exported_value instanceof AST_Function || self2.exported_value instanceof AST_Class) || self2.module_name || self2.exported_names) {
            output.semicolon();
          }
        });
        function parenthesize_for_noin(node, output, noin) {
          var parens = false;
          if (noin) {
            parens = walk(node, (node2) => {
              if (node2 instanceof AST_Scope && !(node2 instanceof AST_Arrow)) {
                return true;
              }
              if (node2 instanceof AST_Binary && node2.operator == "in" || node2 instanceof AST_PrivateIn) {
                return walk_abort;
              }
            });
          }
          node.print(output, parens);
        }
        DEFPRINT(AST_VarDef, function(self2, output) {
          self2.name.print(output);
          if (self2.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self2.value, output, noin);
          }
        });
        DEFPRINT(AST_Call, function(self2, output) {
          self2.expression.print(output);
          if (self2 instanceof AST_New && self2.args.length === 0)
            return;
          if (self2.expression instanceof AST_Call || self2.expression instanceof AST_Lambda) {
            output.add_mapping(self2.start);
          }
          if (self2.optional)
            output.print("?.");
          output.with_parens(function() {
            self2.args.forEach(function(expr, i) {
              if (i)
                output.comma();
              expr.print(output);
            });
          });
        });
        DEFPRINT(AST_New, function(self2, output) {
          output.print("new");
          output.space();
          AST_Call.prototype._codegen(self2, output);
        });
        AST_Sequence.DEFMETHOD("_do_print", function(output) {
          this.expressions.forEach(function(node, index) {
            if (index > 0) {
              output.comma();
              if (output.should_break()) {
                output.newline();
                output.indent();
              }
            }
            node.print(output);
          });
        });
        DEFPRINT(AST_Sequence, function(self2, output) {
          self2._do_print(output);
        });
        DEFPRINT(AST_Dot, function(self2, output) {
          var expr = self2.expression;
          expr.print(output);
          var prop = self2.property;
          var print_computed = ALL_RESERVED_WORDS.has(prop) ? output.option("ie8") : !is_identifier_string(prop, output.option("ecma") >= 2015 && !output.option("safari10"));
          if (self2.optional)
            output.print("?.");
          if (print_computed) {
            output.print("[");
            output.add_mapping(self2.end);
            output.print_string(prop);
            output.print("]");
          } else {
            if (expr instanceof AST_Number && expr.getValue() >= 0) {
              if (!/[xa-f.)]/i.test(output.last())) {
                output.print(".");
              }
            }
            if (!self2.optional)
              output.print(".");
            output.add_mapping(self2.end);
            output.print_name(prop);
          }
        });
        DEFPRINT(AST_DotHash, function(self2, output) {
          var expr = self2.expression;
          expr.print(output);
          var prop = self2.property;
          if (self2.optional)
            output.print("?");
          output.print(".#");
          output.add_mapping(self2.end);
          output.print_name(prop);
        });
        DEFPRINT(AST_Sub, function(self2, output) {
          self2.expression.print(output);
          if (self2.optional)
            output.print("?.");
          output.print("[");
          self2.property.print(output);
          output.print("]");
        });
        DEFPRINT(AST_Chain, function(self2, output) {
          self2.expression.print(output);
        });
        DEFPRINT(AST_UnaryPrefix, function(self2, output) {
          var op = self2.operator;
          if (op === "--" && output.last().endsWith("!")) {
            output.print(" ");
          }
          output.print(op);
          if (/^[a-z]/i.test(op) || /[+-]$/.test(op) && self2.expression instanceof AST_UnaryPrefix && /^[+-]/.test(self2.expression.operator)) {
            output.space();
          }
          self2.expression.print(output);
        });
        DEFPRINT(AST_UnaryPostfix, function(self2, output) {
          self2.expression.print(output);
          output.print(self2.operator);
        });
        DEFPRINT(AST_Binary, function(self2, output) {
          var op = self2.operator;
          self2.left.print(output);
          if (op[0] == ">" && output.last().endsWith("--")) {
            output.print(" ");
          } else {
            output.space();
          }
          output.print(op);
          output.space();
          self2.right.print(output);
        });
        DEFPRINT(AST_Conditional, function(self2, output) {
          self2.condition.print(output);
          output.space();
          output.print("?");
          output.space();
          self2.consequent.print(output);
          output.space();
          output.colon();
          self2.alternative.print(output);
        });
        DEFPRINT(AST_Array, function(self2, output) {
          output.with_square(function() {
            var a = self2.elements, len = a.length;
            if (len > 0)
              output.space();
            a.forEach(function(exp, i) {
              if (i)
                output.comma();
              exp.print(output);
              if (i === len - 1 && exp instanceof AST_Hole)
                output.comma();
            });
            if (len > 0)
              output.space();
          });
        });
        DEFPRINT(AST_Object, function(self2, output) {
          if (self2.properties.length > 0)
            output.with_block(function() {
              self2.properties.forEach(function(prop, i) {
                if (i) {
                  output.print(",");
                  output.newline();
                }
                output.indent();
                prop.print(output);
              });
              output.newline();
            });
          else
            print_braced_empty(self2, output);
        });
        DEFPRINT(AST_Class, function(self2, output) {
          output.print("class");
          output.space();
          if (self2.name) {
            self2.name.print(output);
            output.space();
          }
          if (self2.extends) {
            var parens = !(self2.extends instanceof AST_SymbolRef) && !(self2.extends instanceof AST_PropAccess) && !(self2.extends instanceof AST_ClassExpression) && !(self2.extends instanceof AST_Function);
            output.print("extends");
            if (parens) {
              output.print("(");
            } else {
              output.space();
            }
            self2.extends.print(output);
            if (parens) {
              output.print(")");
            } else {
              output.space();
            }
          }
          if (self2.properties.length > 0)
            output.with_block(function() {
              self2.properties.forEach(function(prop, i) {
                if (i) {
                  output.newline();
                }
                output.indent();
                prop.print(output);
              });
              output.newline();
            });
          else
            output.print("{}");
        });
        DEFPRINT(AST_NewTarget, function(self2, output) {
          output.print("new.target");
        });
        function print_property_name(key2, quote, output) {
          if (output.option("quote_keys")) {
            output.print_string(key2);
            return false;
          }
          if ("" + +key2 == key2 && key2 >= 0) {
            if (output.option("keep_numbers")) {
              output.print(key2);
              return false;
            }
            output.print(make_num(key2));
            return false;
          }
          var print_string = ALL_RESERVED_WORDS.has(key2) ? output.option("ie8") : output.option("ecma") < 2015 || output.option("safari10") ? !is_basic_identifier_string(key2) : !is_identifier_string(key2, true);
          if (print_string || quote && output.option("keep_quoted_props")) {
            output.print_string(key2, quote);
            return false;
          }
          output.print_name(key2);
          return true;
        }
        DEFPRINT(AST_ObjectKeyVal, function(self2, output) {
          function get_name(self3) {
            var def = self3.definition();
            return def ? def.mangled_name || def.name : self3.name;
          }
          const try_shorthand = output.option("shorthand") && !(self2.key instanceof AST_Node);
          if (try_shorthand && self2.value instanceof AST_Symbol && get_name(self2.value) === self2.key && !ALL_RESERVED_WORDS.has(self2.key)) {
            const was_shorthand = print_property_name(self2.key, self2.quote, output);
            if (!was_shorthand) {
              output.colon();
              self2.value.print(output);
            }
          } else if (try_shorthand && self2.value instanceof AST_DefaultAssign && self2.value.left instanceof AST_Symbol && get_name(self2.value.left) === self2.key) {
            const was_shorthand = print_property_name(self2.key, self2.quote, output);
            if (!was_shorthand) {
              output.colon();
              self2.value.left.print(output);
            }
            output.space();
            output.print("=");
            output.space();
            self2.value.right.print(output);
          } else {
            if (!(self2.key instanceof AST_Node)) {
              print_property_name(self2.key, self2.quote, output);
            } else {
              output.with_square(function() {
                self2.key.print(output);
              });
            }
            output.colon();
            self2.value.print(output);
          }
        });
        DEFPRINT(AST_ClassPrivateProperty, (self2, output) => {
          if (self2.static) {
            output.print("static");
            output.space();
          }
          output.print("#");
          print_property_name(self2.key.name, void 0, output);
          if (self2.value) {
            output.print("=");
            self2.value.print(output);
          }
          output.semicolon();
        });
        DEFPRINT(AST_ClassProperty, (self2, output) => {
          if (self2.static) {
            output.print("static");
            output.space();
          }
          if (self2.key instanceof AST_SymbolClassProperty) {
            print_property_name(self2.key.name, self2.quote, output);
          } else {
            output.print("[");
            self2.key.print(output);
            output.print("]");
          }
          if (self2.value) {
            output.print("=");
            self2.value.print(output);
          }
          output.semicolon();
        });
        AST_ObjectProperty.DEFMETHOD("_print_getter_setter", function(type, is_private, output) {
          var self2 = this;
          if (self2.static) {
            output.print("static");
            output.space();
          }
          if (type) {
            output.print(type);
            output.space();
          }
          if (self2.key instanceof AST_SymbolMethod) {
            if (is_private)
              output.print("#");
            print_property_name(self2.key.name, self2.quote, output);
            self2.key.add_source_map(output);
          } else {
            output.with_square(function() {
              self2.key.print(output);
            });
          }
          self2.value._do_print(output, true);
        });
        DEFPRINT(AST_ObjectSetter, function(self2, output) {
          self2._print_getter_setter("set", false, output);
        });
        DEFPRINT(AST_ObjectGetter, function(self2, output) {
          self2._print_getter_setter("get", false, output);
        });
        DEFPRINT(AST_PrivateSetter, function(self2, output) {
          self2._print_getter_setter("set", true, output);
        });
        DEFPRINT(AST_PrivateGetter, function(self2, output) {
          self2._print_getter_setter("get", true, output);
        });
        DEFPRINT(AST_ConciseMethod, function(self2, output) {
          var type;
          if (self2.value.is_generator && self2.value.async) {
            type = "async*";
          } else if (self2.value.is_generator) {
            type = "*";
          } else if (self2.value.async) {
            type = "async";
          }
          self2._print_getter_setter(type, false, output);
        });
        DEFPRINT(AST_PrivateMethod, function(self2, output) {
          var type;
          if (self2.value.is_generator && self2.value.async) {
            type = "async*";
          } else if (self2.value.is_generator) {
            type = "*";
          } else if (self2.value.async) {
            type = "async";
          }
          self2._print_getter_setter(type, true, output);
        });
        DEFPRINT(AST_PrivateIn, function(self2, output) {
          self2.key.print(output);
          output.space();
          output.print("in");
          output.space();
          self2.value.print(output);
        });
        DEFPRINT(AST_SymbolPrivateProperty, function(self2, output) {
          output.print("#" + self2.name);
        });
        DEFPRINT(AST_ClassStaticBlock, function(self2, output) {
          output.print("static");
          output.space();
          print_braced(self2, output);
        });
        AST_Symbol.DEFMETHOD("_do_print", function(output) {
          var def = this.definition();
          output.print_name(def ? def.mangled_name || def.name : this.name);
        });
        DEFPRINT(AST_Symbol, function(self2, output) {
          self2._do_print(output);
        });
        DEFPRINT(AST_Hole, noop2);
        DEFPRINT(AST_This, function(self2, output) {
          output.print("this");
        });
        DEFPRINT(AST_Super, function(self2, output) {
          output.print("super");
        });
        DEFPRINT(AST_Constant, function(self2, output) {
          output.print(self2.getValue());
        });
        DEFPRINT(AST_String, function(self2, output) {
          output.print_string(self2.getValue(), self2.quote, output.in_directive);
        });
        DEFPRINT(AST_Number, function(self2, output) {
          if ((output.option("keep_numbers") || output.use_asm) && self2.raw) {
            output.print(self2.raw);
          } else {
            output.print(make_num(self2.getValue()));
          }
        });
        DEFPRINT(AST_BigInt, function(self2, output) {
          if (output.option("keep_numbers") && self2.raw) {
            output.print(self2.raw);
          } else {
            output.print(self2.getValue() + "n");
          }
        });
        const r_slash_script = /(<\s*\/\s*script)/i;
        const r_starts_with_script = /^\s*script/i;
        const slash_script_replace = (_, $1) => $1.replace("/", "\\/");
        DEFPRINT(AST_RegExp, function(self2, output) {
          let { source, flags } = self2.getValue();
          source = regexp_source_fix(source);
          flags = flags ? sort_regexp_flags(flags) : "";
          source = source.replace(r_slash_script, slash_script_replace);
          if (r_starts_with_script.test(source) && output.last().endsWith("<")) {
            output.print(" ");
          }
          output.print(output.to_utf8(`/${source}/${flags}`, false, true));
          const parent = output.parent();
          if (parent instanceof AST_Binary && /^\w/.test(parent.operator) && parent.left === self2) {
            output.print(" ");
          }
        });
        function print_maybe_braced_body(stat, output) {
          if (output.option("braces")) {
            make_block(stat, output);
          } else {
            if (!stat || stat instanceof AST_EmptyStatement)
              output.force_semicolon();
            else if (stat instanceof AST_Let || stat instanceof AST_Const || stat instanceof AST_Class)
              make_block(stat, output);
            else
              stat.print(output);
          }
        }
        function best_of2(a) {
          var best = a[0], len = best.length;
          for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
              best = a[i];
              len = best.length;
            }
          }
          return best;
        }
        function make_num(num) {
          var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
          var candidates = [str];
          if (Math.floor(num) === num) {
            if (num < 0) {
              candidates.push("-0x" + (-num).toString(16).toLowerCase());
            } else {
              candidates.push("0x" + num.toString(16).toLowerCase());
            }
          }
          var match, len, digits;
          if (match = /^\.0+/.exec(str)) {
            len = match[0].length;
            digits = str.slice(len);
            candidates.push(digits + "e-" + (digits.length + len - 1));
          } else if (match = /0+$/.exec(str)) {
            len = match[0].length;
            candidates.push(str.slice(0, -len) + "e" + len);
          } else if (match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
            candidates.push(match[1] + match[2] + "e" + (match[3] - match[2].length));
          }
          return best_of2(candidates);
        }
        function make_block(stmt, output) {
          if (!stmt || stmt instanceof AST_EmptyStatement)
            output.print("{}");
          else if (stmt instanceof AST_BlockStatement)
            stmt.print(output);
          else
            output.with_block(function() {
              output.indent();
              stmt.print(output);
              output.newline();
            });
        }
        function DEFMAP(nodetype, generator) {
          nodetype.forEach(function(nodetype2) {
            nodetype2.DEFMETHOD("add_source_map", generator);
          });
        }
        DEFMAP([
          AST_Node,
          AST_LabeledStatement,
          AST_Toplevel
        ], noop2);
        DEFMAP([
          AST_Array,
          AST_BlockStatement,
          AST_Catch,
          AST_Class,
          AST_Constant,
          AST_Debugger,
          AST_Definitions,
          AST_Directive,
          AST_Finally,
          AST_Jump,
          AST_Lambda,
          AST_New,
          AST_Object,
          AST_StatementWithBody,
          AST_Symbol,
          AST_Switch,
          AST_SwitchBranch,
          AST_TemplateString,
          AST_TemplateSegment,
          AST_Try
        ], function(output) {
          output.add_mapping(this.start);
        });
        DEFMAP([
          AST_ObjectGetter,
          AST_ObjectSetter,
          AST_PrivateGetter,
          AST_PrivateSetter,
          AST_ConciseMethod,
          AST_PrivateMethod
        ], function(output) {
          output.add_mapping(this.start, false);
        });
        DEFMAP([
          AST_SymbolMethod,
          AST_SymbolPrivateProperty
        ], function(output) {
          const tok_type = this.end && this.end.type;
          if (tok_type === "name" || tok_type === "privatename") {
            output.add_mapping(this.end, this.name);
          } else {
            output.add_mapping(this.end);
          }
        });
        DEFMAP([AST_ObjectProperty], function(output) {
          output.add_mapping(this.start, this.key);
        });
      })();
      const shallow_cmp = (node1, node2) => {
        return node1 === null && node2 === null || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2);
      };
      const equivalent_to = (tree1, tree2) => {
        if (!shallow_cmp(tree1, tree2))
          return false;
        const walk_1_state = [tree1];
        const walk_2_state = [tree2];
        const walk_1_push = walk_1_state.push.bind(walk_1_state);
        const walk_2_push = walk_2_state.push.bind(walk_2_state);
        while (walk_1_state.length && walk_2_state.length) {
          const node_1 = walk_1_state.pop();
          const node_2 = walk_2_state.pop();
          if (!shallow_cmp(node_1, node_2))
            return false;
          node_1._children_backwards(walk_1_push);
          node_2._children_backwards(walk_2_push);
          if (walk_1_state.length !== walk_2_state.length) {
            return false;
          }
        }
        return walk_1_state.length == 0 && walk_2_state.length == 0;
      };
      const pass_through = () => true;
      AST_Node.prototype.shallow_cmp = function() {
        throw new Error("did not find a shallow_cmp function for " + this.constructor.name);
      };
      AST_Debugger.prototype.shallow_cmp = pass_through;
      AST_Directive.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_SimpleStatement.prototype.shallow_cmp = pass_through;
      AST_Block.prototype.shallow_cmp = pass_through;
      AST_EmptyStatement.prototype.shallow_cmp = pass_through;
      AST_LabeledStatement.prototype.shallow_cmp = function(other) {
        return this.label.name === other.label.name;
      };
      AST_Do.prototype.shallow_cmp = pass_through;
      AST_While.prototype.shallow_cmp = pass_through;
      AST_For.prototype.shallow_cmp = function(other) {
        return (this.init == null ? other.init == null : this.init === other.init) && (this.condition == null ? other.condition == null : this.condition === other.condition) && (this.step == null ? other.step == null : this.step === other.step);
      };
      AST_ForIn.prototype.shallow_cmp = pass_through;
      AST_ForOf.prototype.shallow_cmp = pass_through;
      AST_With.prototype.shallow_cmp = pass_through;
      AST_Toplevel.prototype.shallow_cmp = pass_through;
      AST_Expansion.prototype.shallow_cmp = pass_through;
      AST_Lambda.prototype.shallow_cmp = function(other) {
        return this.is_generator === other.is_generator && this.async === other.async;
      };
      AST_Destructuring.prototype.shallow_cmp = function(other) {
        return this.is_array === other.is_array;
      };
      AST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;
      AST_TemplateString.prototype.shallow_cmp = pass_through;
      AST_TemplateSegment.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_Jump.prototype.shallow_cmp = pass_through;
      AST_LoopControl.prototype.shallow_cmp = pass_through;
      AST_Await.prototype.shallow_cmp = pass_through;
      AST_Yield.prototype.shallow_cmp = function(other) {
        return this.is_star === other.is_star;
      };
      AST_If.prototype.shallow_cmp = function(other) {
        return this.alternative == null ? other.alternative == null : this.alternative === other.alternative;
      };
      AST_Switch.prototype.shallow_cmp = pass_through;
      AST_SwitchBranch.prototype.shallow_cmp = pass_through;
      AST_Try.prototype.shallow_cmp = function(other) {
        return this.body === other.body && (this.bcatch == null ? other.bcatch == null : this.bcatch === other.bcatch) && (this.bfinally == null ? other.bfinally == null : this.bfinally === other.bfinally);
      };
      AST_Catch.prototype.shallow_cmp = function(other) {
        return this.argname == null ? other.argname == null : this.argname === other.argname;
      };
      AST_Finally.prototype.shallow_cmp = pass_through;
      AST_Definitions.prototype.shallow_cmp = pass_through;
      AST_VarDef.prototype.shallow_cmp = function(other) {
        return this.value == null ? other.value == null : this.value === other.value;
      };
      AST_NameMapping.prototype.shallow_cmp = pass_through;
      AST_Import.prototype.shallow_cmp = function(other) {
        return (this.imported_name == null ? other.imported_name == null : this.imported_name === other.imported_name) && (this.imported_names == null ? other.imported_names == null : this.imported_names === other.imported_names) && (this.attributes == null ? other.attributes == null : this.attributes === other.attributes);
      };
      AST_ImportMeta.prototype.shallow_cmp = pass_through;
      AST_Export.prototype.shallow_cmp = function(other) {
        return (this.exported_definition == null ? other.exported_definition == null : this.exported_definition === other.exported_definition) && (this.exported_value == null ? other.exported_value == null : this.exported_value === other.exported_value) && (this.exported_names == null ? other.exported_names == null : this.exported_names === other.exported_names) && (this.attributes == null ? other.attributes == null : this.attributes === other.attributes) && this.module_name === other.module_name && this.is_default === other.is_default;
      };
      AST_Call.prototype.shallow_cmp = pass_through;
      AST_Sequence.prototype.shallow_cmp = pass_through;
      AST_PropAccess.prototype.shallow_cmp = pass_through;
      AST_Chain.prototype.shallow_cmp = pass_through;
      AST_Dot.prototype.shallow_cmp = function(other) {
        return this.property === other.property;
      };
      AST_DotHash.prototype.shallow_cmp = function(other) {
        return this.property === other.property;
      };
      AST_Unary.prototype.shallow_cmp = function(other) {
        return this.operator === other.operator;
      };
      AST_Binary.prototype.shallow_cmp = function(other) {
        return this.operator === other.operator;
      };
      AST_PrivateIn.prototype.shallow_cmp = pass_through;
      AST_Conditional.prototype.shallow_cmp = pass_through;
      AST_Array.prototype.shallow_cmp = pass_through;
      AST_Object.prototype.shallow_cmp = pass_through;
      AST_ObjectProperty.prototype.shallow_cmp = pass_through;
      AST_ObjectKeyVal.prototype.shallow_cmp = function(other) {
        return this.key === other.key && this.quote === other.quote;
      };
      AST_ObjectSetter.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_ObjectGetter.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_ConciseMethod.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_PrivateMethod.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_Class.prototype.shallow_cmp = function(other) {
        return (this.name == null ? other.name == null : this.name === other.name) && (this.extends == null ? other.extends == null : this.extends === other.extends);
      };
      AST_ClassProperty.prototype.shallow_cmp = function(other) {
        return this.static === other.static && (typeof this.key === "string" ? this.key === other.key : true);
      };
      AST_ClassPrivateProperty.prototype.shallow_cmp = function(other) {
        return this.static === other.static;
      };
      AST_Symbol.prototype.shallow_cmp = function(other) {
        return this.name === other.name;
      };
      AST_NewTarget.prototype.shallow_cmp = pass_through;
      AST_This.prototype.shallow_cmp = pass_through;
      AST_Super.prototype.shallow_cmp = pass_through;
      AST_String.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_Number.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_BigInt.prototype.shallow_cmp = function(other) {
        return this.value === other.value;
      };
      AST_RegExp.prototype.shallow_cmp = function(other) {
        return this.value.flags === other.value.flags && this.value.source === other.value.source;
      };
      AST_Atom.prototype.shallow_cmp = pass_through;
      const MASK_EXPORT_DONT_MANGLE = 1 << 0;
      const MASK_EXPORT_WANT_MANGLE = 1 << 1;
      let function_defs = null;
      let unmangleable_names = null;
      let scopes_with_block_defuns = null;
      class SymbolDef {
        constructor(scope, orig, init2) {
          this.name = orig.name;
          this.orig = [orig];
          this.init = init2;
          this.eliminated = 0;
          this.assignments = 0;
          this.scope = scope;
          this.replaced = 0;
          this.global = false;
          this.export = 0;
          this.mangled_name = null;
          this.undeclared = false;
          this.id = SymbolDef.next_id++;
          this.chained = false;
          this.direct_access = false;
          this.escaped = 0;
          this.recursive_refs = 0;
          this.references = [];
          this.should_replace = void 0;
          this.single_use = false;
          this.fixed = false;
          Object.seal(this);
        }
        fixed_value() {
          if (!this.fixed || this.fixed instanceof AST_Node)
            return this.fixed;
          return this.fixed();
        }
        unmangleable(options) {
          if (!options)
            options = {};
          if (function_defs && function_defs.has(this.id) && keep_name(options.keep_fnames, this.orig[0].name))
            return true;
          return this.global && !options.toplevel || this.export & MASK_EXPORT_DONT_MANGLE || this.undeclared || !options.eval && this.scope.pinned() || (this.orig[0] instanceof AST_SymbolLambda || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name) || this.orig[0] instanceof AST_SymbolMethod || (this.orig[0] instanceof AST_SymbolClass || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);
        }
        mangle(options) {
          const cache = options.cache && options.cache.props;
          if (this.global && cache && cache.has(this.name)) {
            this.mangled_name = cache.get(this.name);
          } else if (!this.mangled_name && !this.unmangleable(options)) {
            var s = this.scope;
            var sym = this.orig[0];
            if (options.ie8 && sym instanceof AST_SymbolLambda)
              s = s.parent_scope;
            const redefinition = redefined_catch_def(this);
            this.mangled_name = redefinition ? redefinition.mangled_name || redefinition.name : s.next_mangled(options, this);
            if (this.global && cache) {
              cache.set(this.name, this.mangled_name);
            }
          }
        }
      }
      SymbolDef.next_id = 1;
      function redefined_catch_def(def) {
        if (def.orig[0] instanceof AST_SymbolCatch && def.scope.is_block_scope()) {
          return def.scope.get_defun_scope().variables.get(def.name);
        }
      }
      AST_Scope.DEFMETHOD("figure_out_scope", function(options, { parent_scope = void 0, toplevel = this } = {}) {
        options = defaults(options, {
          cache: null,
          ie8: false,
          safari10: false,
          module: false
        });
        if (!(toplevel instanceof AST_Toplevel)) {
          throw new Error("Invalid toplevel scope");
        }
        var scope = this.parent_scope = parent_scope;
        var labels = /* @__PURE__ */ new Map();
        var defun = null;
        var in_destructuring = null;
        var for_scopes = [];
        var tw = new TreeWalker((node, descend) => {
          if (node.is_block_scope()) {
            const save_scope2 = scope;
            node.block_scope = scope = new AST_Scope(node);
            scope._block_scope = true;
            scope.init_scope_vars(save_scope2);
            scope.uses_with = save_scope2.uses_with;
            scope.uses_eval = save_scope2.uses_eval;
            if (options.safari10) {
              if (node instanceof AST_For || node instanceof AST_ForIn || node instanceof AST_ForOf) {
                for_scopes.push(scope);
              }
            }
            if (node instanceof AST_Switch) {
              const the_block_scope = scope;
              scope = save_scope2;
              node.expression.walk(tw);
              scope = the_block_scope;
              for (let i = 0; i < node.body.length; i++) {
                node.body[i].walk(tw);
              }
            } else {
              descend();
            }
            scope = save_scope2;
            return true;
          }
          if (node instanceof AST_Destructuring) {
            const save_destructuring = in_destructuring;
            in_destructuring = node;
            descend();
            in_destructuring = save_destructuring;
            return true;
          }
          if (node instanceof AST_Scope) {
            node.init_scope_vars(scope);
            var save_scope = scope;
            var save_defun = defun;
            var save_labels = labels;
            defun = scope = node;
            labels = /* @__PURE__ */ new Map();
            descend();
            scope = save_scope;
            defun = save_defun;
            labels = save_labels;
            return true;
          }
          if (node instanceof AST_LabeledStatement) {
            var l = node.label;
            if (labels.has(l.name)) {
              throw new Error(string_template("Label {name} defined twice", l));
            }
            labels.set(l.name, l);
            descend();
            labels.delete(l.name);
            return true;
          }
          if (node instanceof AST_With) {
            for (var s = scope; s; s = s.parent_scope)
              s.uses_with = true;
            return;
          }
          if (node instanceof AST_Symbol) {
            node.scope = scope;
          }
          if (node instanceof AST_Label) {
            node.thedef = node;
            node.references = [];
          }
          if (node instanceof AST_SymbolLambda) {
            defun.def_function(node, node.name == "arguments" ? void 0 : defun);
          } else if (node instanceof AST_SymbolDefun) {
            const closest_scope = defun.parent_scope;
            node.scope = tw.directives["use strict"] ? closest_scope : closest_scope.get_defun_scope();
            mark_export(node.scope.def_function(node, defun), 1);
          } else if (node instanceof AST_SymbolClass) {
            mark_export(defun.def_variable(node, defun), 1);
          } else if (node instanceof AST_SymbolImport) {
            scope.def_variable(node);
          } else if (node instanceof AST_SymbolDefClass) {
            mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);
          } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolLet || node instanceof AST_SymbolConst || node instanceof AST_SymbolCatch) {
            var def;
            if (node instanceof AST_SymbolBlockDeclaration) {
              def = scope.def_variable(node, null);
            } else {
              def = defun.def_variable(node, node.TYPE == "SymbolVar" ? null : void 0);
            }
            if (!def.orig.every((sym2) => {
              if (sym2 === node)
                return true;
              if (node instanceof AST_SymbolBlockDeclaration) {
                return sym2 instanceof AST_SymbolLambda;
              }
              return !(sym2 instanceof AST_SymbolLet || sym2 instanceof AST_SymbolConst);
            })) {
              js_error(`"${node.name}" is redeclared`, node.start.file, node.start.line, node.start.col, node.start.pos);
            }
            if (!(node instanceof AST_SymbolFunarg))
              mark_export(def, 2);
            if (defun !== scope) {
              node.mark_enclosed();
              var def = scope.find_variable(node);
              if (node.thedef !== def) {
                node.thedef = def;
                node.reference();
              }
            }
          } else if (node instanceof AST_LabelRef) {
            var sym = labels.get(node.name);
            if (!sym)
              throw new Error(string_template("Undefined label {name} [{line},{col}]", {
                name: node.name,
                line: node.start.line,
                col: node.start.col
              }));
            node.thedef = sym;
          }
          if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {
            js_error(`"${node.TYPE}" statement may only appear at the top level`, node.start.file, node.start.line, node.start.col, node.start.pos);
          }
        });
        if (options.module) {
          tw.directives["use strict"] = true;
        }
        this.walk(tw);
        function mark_export(def, level) {
          if (in_destructuring) {
            var i = 0;
            do {
              level++;
            } while (tw.parent(i++) !== in_destructuring);
          }
          var node = tw.parent(level);
          if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {
            var exported = node.exported_definition;
            if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {
              def.export = MASK_EXPORT_WANT_MANGLE;
            }
          }
        }
        const is_toplevel = this instanceof AST_Toplevel;
        if (is_toplevel) {
          this.globals = /* @__PURE__ */ new Map();
        }
        var tw = new TreeWalker((node) => {
          if (node instanceof AST_LoopControl && node.label) {
            node.label.thedef.references.push(node);
            return true;
          }
          if (node instanceof AST_SymbolRef) {
            var name = node.name;
            if (name == "eval" && tw.parent() instanceof AST_Call) {
              for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {
                s.uses_eval = true;
              }
            }
            var sym;
            if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name || !(sym = node.scope.find_variable(name))) {
              sym = toplevel.def_global(node);
              if (node instanceof AST_SymbolExport)
                sym.export = MASK_EXPORT_DONT_MANGLE;
            } else if (sym.scope instanceof AST_Lambda && name == "arguments") {
              sym.scope.get_defun_scope().uses_arguments = true;
            }
            node.thedef = sym;
            node.reference();
            if (node.scope.is_block_scope() && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {
              node.scope = node.scope.get_defun_scope();
            }
            return true;
          }
          var def;
          if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {
            var s = node.scope;
            while (s) {
              push_uniq(s.enclosed, def);
              if (s === def.scope)
                break;
              s = s.parent_scope;
            }
          }
        });
        this.walk(tw);
        if (options.ie8 || options.safari10) {
          walk(this, (node) => {
            if (node instanceof AST_SymbolCatch) {
              var name = node.name;
              var refs = node.thedef.references;
              var scope2 = node.scope.get_defun_scope();
              var def = scope2.find_variable(name) || toplevel.globals.get(name) || scope2.def_variable(node);
              refs.forEach(function(ref) {
                ref.thedef = def;
                ref.reference();
              });
              node.thedef = def;
              node.reference();
              return true;
            }
          });
        }
        if (options.safari10) {
          for (const scope2 of for_scopes) {
            scope2.parent_scope.variables.forEach(function(def) {
              push_uniq(scope2.enclosed, def);
            });
          }
        }
      });
      AST_Toplevel.DEFMETHOD("def_global", function(node) {
        var globals2 = this.globals, name = node.name;
        if (globals2.has(name)) {
          return globals2.get(name);
        } else {
          var g = new SymbolDef(this, node);
          g.undeclared = true;
          g.global = true;
          globals2.set(name, g);
          return g;
        }
      });
      AST_Scope.DEFMETHOD("init_scope_vars", function(parent_scope) {
        this.variables = /* @__PURE__ */ new Map();
        this.uses_with = false;
        this.uses_eval = false;
        this.parent_scope = parent_scope;
        this.enclosed = [];
        this.cname = -1;
      });
      AST_Scope.DEFMETHOD("conflicting_def", function(name) {
        return this.enclosed.find((def) => def.name === name) || this.variables.has(name) || this.parent_scope && this.parent_scope.conflicting_def(name);
      });
      AST_Scope.DEFMETHOD("conflicting_def_shallow", function(name) {
        return this.enclosed.find((def) => def.name === name) || this.variables.has(name);
      });
      AST_Scope.DEFMETHOD("add_child_scope", function(scope) {
        if (scope.parent_scope === this)
          return;
        scope.parent_scope = this;
        if (scope instanceof AST_Arrow && (this instanceof AST_Lambda && !this.uses_arguments)) {
          this.uses_arguments = walk(scope, (node) => {
            if (node instanceof AST_SymbolRef && node.scope instanceof AST_Lambda && node.name === "arguments") {
              return walk_abort;
            }
            if (node instanceof AST_Lambda && !(node instanceof AST_Arrow)) {
              return true;
            }
          });
        }
        this.uses_with = this.uses_with || scope.uses_with;
        this.uses_eval = this.uses_eval || scope.uses_eval;
        const scope_ancestry = (() => {
          const ancestry = [];
          let cur = this;
          do {
            ancestry.push(cur);
          } while (cur = cur.parent_scope);
          ancestry.reverse();
          return ancestry;
        })();
        const new_scope_enclosed_set = new Set(scope.enclosed);
        const to_enclose = [];
        for (const scope_topdown of scope_ancestry) {
          to_enclose.forEach((e) => push_uniq(scope_topdown.enclosed, e));
          for (const def of scope_topdown.variables.values()) {
            if (new_scope_enclosed_set.has(def)) {
              push_uniq(to_enclose, def);
              push_uniq(scope_topdown.enclosed, def);
            }
          }
        }
      });
      function find_scopes_visible_from(scopes) {
        const found_scopes = /* @__PURE__ */ new Set();
        for (const scope of new Set(scopes)) {
          (function bubble_up(scope2) {
            if (scope2 == null || found_scopes.has(scope2))
              return;
            found_scopes.add(scope2);
            bubble_up(scope2.parent_scope);
          })(scope);
        }
        return [...found_scopes];
      }
      AST_Scope.DEFMETHOD("create_symbol", function(SymClass, {
        source,
        tentative_name,
        scope,
        conflict_scopes = [scope],
        init: init2 = null
      } = {}) {
        let symbol_name;
        conflict_scopes = find_scopes_visible_from(conflict_scopes);
        if (tentative_name) {
          tentative_name = symbol_name = tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, "_");
          let i = 0;
          while (conflict_scopes.find((s) => s.conflicting_def_shallow(symbol_name))) {
            symbol_name = tentative_name + "$" + i++;
          }
        }
        if (!symbol_name) {
          throw new Error("No symbol name could be generated in create_symbol()");
        }
        const symbol = make_node(SymClass, source, {
          name: symbol_name,
          scope
        });
        this.def_variable(symbol, init2 || null);
        symbol.mark_enclosed();
        return symbol;
      });
      AST_Node.DEFMETHOD("is_block_scope", return_false);
      AST_Class.DEFMETHOD("is_block_scope", return_false);
      AST_Lambda.DEFMETHOD("is_block_scope", return_false);
      AST_Toplevel.DEFMETHOD("is_block_scope", return_false);
      AST_SwitchBranch.DEFMETHOD("is_block_scope", return_false);
      AST_Block.DEFMETHOD("is_block_scope", return_true);
      AST_Scope.DEFMETHOD("is_block_scope", function() {
        return this._block_scope || false;
      });
      AST_IterationStatement.DEFMETHOD("is_block_scope", return_true);
      AST_Lambda.DEFMETHOD("init_scope_vars", function() {
        AST_Scope.prototype.init_scope_vars.apply(this, arguments);
        this.uses_arguments = false;
        this.def_variable(new AST_SymbolFunarg({
          name: "arguments",
          start: this.start,
          end: this.end
        }));
      });
      AST_Arrow.DEFMETHOD("init_scope_vars", function() {
        AST_Scope.prototype.init_scope_vars.apply(this, arguments);
        this.uses_arguments = false;
      });
      AST_Symbol.DEFMETHOD("mark_enclosed", function() {
        var def = this.definition();
        var s = this.scope;
        while (s) {
          push_uniq(s.enclosed, def);
          if (s === def.scope)
            break;
          s = s.parent_scope;
        }
      });
      AST_Symbol.DEFMETHOD("reference", function() {
        this.definition().references.push(this);
        this.mark_enclosed();
      });
      AST_Scope.DEFMETHOD("find_variable", function(name) {
        if (name instanceof AST_Symbol)
          name = name.name;
        return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);
      });
      AST_Scope.DEFMETHOD("def_function", function(symbol, init2) {
        var def = this.def_variable(symbol, init2);
        if (!def.init || def.init instanceof AST_Defun)
          def.init = init2;
        return def;
      });
      AST_Scope.DEFMETHOD("def_variable", function(symbol, init2) {
        var def = this.variables.get(symbol.name);
        if (def) {
          def.orig.push(symbol);
          if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {
            def.init = init2;
          }
        } else {
          def = new SymbolDef(this, symbol, init2);
          this.variables.set(symbol.name, def);
          def.global = !this.parent_scope;
        }
        return symbol.thedef = def;
      });
      function next_mangled(scope, options) {
        let defun_scope;
        if (scopes_with_block_defuns && (defun_scope = scope.get_defun_scope()) && scopes_with_block_defuns.has(defun_scope)) {
          scope = defun_scope;
        }
        var ext = scope.enclosed;
        var nth_identifier = options.nth_identifier;
        out:
          while (true) {
            var m = nth_identifier.get(++scope.cname);
            if (ALL_RESERVED_WORDS.has(m))
              continue;
            if (options.reserved.has(m))
              continue;
            if (unmangleable_names && unmangleable_names.has(m))
              continue out;
            for (let i = ext.length; --i >= 0; ) {
              const def = ext[i];
              const name = def.mangled_name || def.unmangleable(options) && def.name;
              if (m == name)
                continue out;
            }
            return m;
          }
      }
      AST_Scope.DEFMETHOD("next_mangled", function(options) {
        return next_mangled(this, options);
      });
      AST_Toplevel.DEFMETHOD("next_mangled", function(options) {
        let name;
        const mangled_names = this.mangled_names;
        do {
          name = next_mangled(this, options);
        } while (mangled_names.has(name));
        return name;
      });
      AST_Function.DEFMETHOD("next_mangled", function(options, def) {
        var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();
        var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;
        while (true) {
          var name = next_mangled(this, options);
          if (!tricky_name || tricky_name != name)
            return name;
        }
      });
      AST_Symbol.DEFMETHOD("unmangleable", function(options) {
        var def = this.definition();
        return !def || def.unmangleable(options);
      });
      AST_Label.DEFMETHOD("unmangleable", return_false);
      AST_Symbol.DEFMETHOD("unreferenced", function() {
        return !this.definition().references.length && !this.scope.pinned();
      });
      AST_Symbol.DEFMETHOD("definition", function() {
        return this.thedef;
      });
      AST_Symbol.DEFMETHOD("global", function() {
        return this.thedef.global;
      });
      function format_mangler_options(options) {
        options = defaults(options, {
          eval: false,
          nth_identifier: base54,
          ie8: false,
          keep_classnames: false,
          keep_fnames: false,
          module: false,
          reserved: [],
          toplevel: false
        });
        if (options.module)
          options.toplevel = true;
        if (!Array.isArray(options.reserved) && !(options.reserved instanceof Set)) {
          options.reserved = [];
        }
        options.reserved = new Set(options.reserved);
        options.reserved.add("arguments");
        return options;
      }
      AST_Toplevel.DEFMETHOD("mangle_names", function(options) {
        options = format_mangler_options(options);
        var nth_identifier = options.nth_identifier;
        var lname = -1;
        var to_mangle = [];
        if (options.keep_fnames) {
          function_defs = /* @__PURE__ */ new Set();
        }
        const mangled_names = this.mangled_names = /* @__PURE__ */ new Set();
        unmangleable_names = /* @__PURE__ */ new Set();
        if (options.cache) {
          this.globals.forEach(collect);
          if (options.cache.props) {
            options.cache.props.forEach(function(mangled_name) {
              mangled_names.add(mangled_name);
            });
          }
        }
        var tw = new TreeWalker(function(node, descend) {
          if (node instanceof AST_LabeledStatement) {
            var save_nesting = lname;
            descend();
            lname = save_nesting;
            return true;
          }
          if (node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {
            scopes_with_block_defuns = scopes_with_block_defuns || /* @__PURE__ */ new Set();
            scopes_with_block_defuns.add(node.parent_scope.get_defun_scope());
          }
          if (node instanceof AST_Scope) {
            node.variables.forEach(collect);
            return;
          }
          if (node.is_block_scope()) {
            node.block_scope.variables.forEach(collect);
            return;
          }
          if (function_defs && node instanceof AST_VarDef && node.value instanceof AST_Lambda && !node.value.name && keep_name(options.keep_fnames, node.name.name)) {
            function_defs.add(node.name.definition().id);
            return;
          }
          if (node instanceof AST_Label) {
            let name;
            do {
              name = nth_identifier.get(++lname);
            } while (ALL_RESERVED_WORDS.has(name));
            node.mangled_name = name;
            return true;
          }
          if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {
            to_mangle.push(node.definition());
            return;
          }
        });
        this.walk(tw);
        if (options.keep_fnames || options.keep_classnames) {
          to_mangle.forEach((def) => {
            if (def.name.length < 6 && def.unmangleable(options)) {
              unmangleable_names.add(def.name);
            }
          });
        }
        to_mangle.forEach((def) => {
          def.mangle(options);
        });
        function_defs = null;
        unmangleable_names = null;
        scopes_with_block_defuns = null;
        function collect(symbol) {
          if (symbol.export & MASK_EXPORT_DONT_MANGLE) {
            unmangleable_names.add(symbol.name);
          } else if (!options.reserved.has(symbol.name)) {
            to_mangle.push(symbol);
          }
        }
      });
      AST_Toplevel.DEFMETHOD("find_colliding_names", function(options) {
        const cache = options.cache && options.cache.props;
        const avoid = /* @__PURE__ */ new Set();
        options.reserved.forEach(to_avoid);
        this.globals.forEach(add_def);
        this.walk(new TreeWalker(function(node) {
          if (node instanceof AST_Scope)
            node.variables.forEach(add_def);
          if (node instanceof AST_SymbolCatch)
            add_def(node.definition());
        }));
        return avoid;
        function to_avoid(name) {
          avoid.add(name);
        }
        function add_def(def) {
          var name = def.name;
          if (def.global && cache && cache.has(name))
            name = cache.get(name);
          else if (!def.unmangleable(options))
            return;
          to_avoid(name);
        }
      });
      AST_Toplevel.DEFMETHOD("expand_names", function(options) {
        options = format_mangler_options(options);
        var nth_identifier = options.nth_identifier;
        if (nth_identifier.reset && nth_identifier.sort) {
          nth_identifier.reset();
          nth_identifier.sort();
        }
        var avoid = this.find_colliding_names(options);
        var cname = 0;
        this.globals.forEach(rename);
        this.walk(new TreeWalker(function(node) {
          if (node instanceof AST_Scope)
            node.variables.forEach(rename);
          if (node instanceof AST_SymbolCatch)
            rename(node.definition());
        }));
        function next_name() {
          var name;
          do {
            name = nth_identifier.get(cname++);
          } while (avoid.has(name) || ALL_RESERVED_WORDS.has(name));
          return name;
        }
        function rename(def) {
          if (def.global && options.cache)
            return;
          if (def.unmangleable(options))
            return;
          if (options.reserved.has(def.name))
            return;
          const redefinition = redefined_catch_def(def);
          const name = def.name = redefinition ? redefinition.name : next_name();
          def.orig.forEach(function(sym) {
            sym.name = name;
          });
          def.references.forEach(function(sym) {
            sym.name = name;
          });
        }
      });
      AST_Node.DEFMETHOD("tail_node", return_this);
      AST_Sequence.DEFMETHOD("tail_node", function() {
        return this.expressions[this.expressions.length - 1];
      });
      AST_Toplevel.DEFMETHOD("compute_char_frequency", function(options) {
        options = format_mangler_options(options);
        var nth_identifier = options.nth_identifier;
        if (!nth_identifier.reset || !nth_identifier.consider || !nth_identifier.sort) {
          return;
        }
        nth_identifier.reset();
        try {
          AST_Node.prototype.print = function(stream, force_parens) {
            this._print(stream, force_parens);
            if (this instanceof AST_Symbol && !this.unmangleable(options)) {
              nth_identifier.consider(this.name, -1);
            } else if (options.properties) {
              if (this instanceof AST_DotHash) {
                nth_identifier.consider("#" + this.property, -1);
              } else if (this instanceof AST_Dot) {
                nth_identifier.consider(this.property, -1);
              } else if (this instanceof AST_Sub) {
                skip_string(this.property);
              }
            }
          };
          nth_identifier.consider(this.print_to_string(), 1);
        } finally {
          AST_Node.prototype.print = AST_Node.prototype._print;
        }
        nth_identifier.sort();
        function skip_string(node) {
          if (node instanceof AST_String) {
            nth_identifier.consider(node.value, -1);
          } else if (node instanceof AST_Conditional) {
            skip_string(node.consequent);
            skip_string(node.alternative);
          } else if (node instanceof AST_Sequence) {
            skip_string(node.tail_node());
          }
        }
      });
      const base54 = (() => {
        const leading = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split("");
        const digits = "0123456789".split("");
        let chars;
        let frequency;
        function reset() {
          frequency = /* @__PURE__ */ new Map();
          leading.forEach(function(ch) {
            frequency.set(ch, 0);
          });
          digits.forEach(function(ch) {
            frequency.set(ch, 0);
          });
        }
        function consider(str, delta) {
          for (var i = str.length; --i >= 0; ) {
            frequency.set(str[i], frequency.get(str[i]) + delta);
          }
        }
        function compare(a, b) {
          return frequency.get(b) - frequency.get(a);
        }
        function sort() {
          chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));
        }
        reset();
        sort();
        function base542(num) {
          var ret = "", base = 54;
          num++;
          do {
            num--;
            ret += chars[num % base];
            num = Math.floor(num / base);
            base = 64;
          } while (num > 0);
          return ret;
        }
        return {
          get: base542,
          consider,
          reset,
          sort
        };
      })();
      let mangle_options = void 0;
      AST_Node.prototype.size = function(compressor, stack) {
        mangle_options = compressor && compressor._mangle_options;
        let size = 0;
        walk_parent(this, (node, info) => {
          size += node._size(info);
          if (node instanceof AST_Arrow && node.is_braceless()) {
            size += node.body[0].value._size(info);
            return true;
          }
        }, stack || compressor && compressor.stack);
        mangle_options = void 0;
        return size;
      };
      AST_Node.prototype._size = () => 0;
      AST_Debugger.prototype._size = () => 8;
      AST_Directive.prototype._size = function() {
        return 2 + this.value.length;
      };
      const list_overhead = (array) => array.length && array.length - 1;
      AST_Block.prototype._size = function() {
        return 2 + list_overhead(this.body);
      };
      AST_Toplevel.prototype._size = function() {
        return list_overhead(this.body);
      };
      AST_EmptyStatement.prototype._size = () => 1;
      AST_LabeledStatement.prototype._size = () => 2;
      AST_Do.prototype._size = () => 9;
      AST_While.prototype._size = () => 7;
      AST_For.prototype._size = () => 8;
      AST_ForIn.prototype._size = () => 8;
      AST_With.prototype._size = () => 6;
      AST_Expansion.prototype._size = () => 3;
      const lambda_modifiers = (func) => (func.is_generator ? 1 : 0) + (func.async ? 6 : 0);
      AST_Accessor.prototype._size = function() {
        return lambda_modifiers(this) + 4 + list_overhead(this.argnames) + list_overhead(this.body);
      };
      AST_Function.prototype._size = function(info) {
        const first = !!first_in_statement(info);
        return first * 2 + lambda_modifiers(this) + 12 + list_overhead(this.argnames) + list_overhead(this.body);
      };
      AST_Defun.prototype._size = function() {
        return lambda_modifiers(this) + 13 + list_overhead(this.argnames) + list_overhead(this.body);
      };
      AST_Arrow.prototype._size = function() {
        let args_and_arrow = 2 + list_overhead(this.argnames);
        if (!(this.argnames.length === 1 && this.argnames[0] instanceof AST_Symbol)) {
          args_and_arrow += 2;
        }
        const body_overhead = this.is_braceless() ? 0 : list_overhead(this.body) + 2;
        return lambda_modifiers(this) + args_and_arrow + body_overhead;
      };
      AST_Destructuring.prototype._size = () => 2;
      AST_TemplateString.prototype._size = function() {
        return 2 + Math.floor(this.segments.length / 2) * 3;
      };
      AST_TemplateSegment.prototype._size = function() {
        return this.value.length;
      };
      AST_Return.prototype._size = function() {
        return this.value ? 7 : 6;
      };
      AST_Throw.prototype._size = () => 6;
      AST_Break.prototype._size = function() {
        return this.label ? 6 : 5;
      };
      AST_Continue.prototype._size = function() {
        return this.label ? 9 : 8;
      };
      AST_If.prototype._size = () => 4;
      AST_Switch.prototype._size = function() {
        return 8 + list_overhead(this.body);
      };
      AST_Case.prototype._size = function() {
        return 5 + list_overhead(this.body);
      };
      AST_Default.prototype._size = function() {
        return 8 + list_overhead(this.body);
      };
      AST_Try.prototype._size = () => 3;
      AST_Catch.prototype._size = function() {
        let size = 7 + list_overhead(this.body);
        if (this.argname) {
          size += 2;
        }
        return size;
      };
      AST_Finally.prototype._size = function() {
        return 7 + list_overhead(this.body);
      };
      AST_Var.prototype._size = function() {
        return 4 + list_overhead(this.definitions);
      };
      AST_Let.prototype._size = function() {
        return 4 + list_overhead(this.definitions);
      };
      AST_Const.prototype._size = function() {
        return 6 + list_overhead(this.definitions);
      };
      AST_VarDef.prototype._size = function() {
        return this.value ? 1 : 0;
      };
      AST_NameMapping.prototype._size = function() {
        return this.name ? 4 : 0;
      };
      AST_Import.prototype._size = function() {
        let size = 6;
        if (this.imported_name)
          size += 1;
        if (this.imported_name || this.imported_names)
          size += 5;
        if (this.imported_names) {
          size += 2 + list_overhead(this.imported_names);
        }
        return size;
      };
      AST_ImportMeta.prototype._size = () => 11;
      AST_Export.prototype._size = function() {
        let size = 7 + (this.is_default ? 8 : 0);
        if (this.exported_value) {
          size += this.exported_value._size();
        }
        if (this.exported_names) {
          size += 2 + list_overhead(this.exported_names);
        }
        if (this.module_name) {
          size += 5;
        }
        return size;
      };
      AST_Call.prototype._size = function() {
        if (this.optional) {
          return 4 + list_overhead(this.args);
        }
        return 2 + list_overhead(this.args);
      };
      AST_New.prototype._size = function() {
        return 6 + list_overhead(this.args);
      };
      AST_Sequence.prototype._size = function() {
        return list_overhead(this.expressions);
      };
      AST_Dot.prototype._size = function() {
        if (this.optional) {
          return this.property.length + 2;
        }
        return this.property.length + 1;
      };
      AST_DotHash.prototype._size = function() {
        if (this.optional) {
          return this.property.length + 3;
        }
        return this.property.length + 2;
      };
      AST_Sub.prototype._size = function() {
        return this.optional ? 4 : 2;
      };
      AST_Unary.prototype._size = function() {
        if (this.operator === "typeof")
          return 7;
        if (this.operator === "void")
          return 5;
        return this.operator.length;
      };
      AST_Binary.prototype._size = function(info) {
        if (this.operator === "in")
          return 4;
        let size = this.operator.length;
        if ((this.operator === "+" || this.operator === "-") && this.right instanceof AST_Unary && this.right.operator === this.operator) {
          size += 1;
        }
        if (this.needs_parens(info)) {
          size += 2;
        }
        return size;
      };
      AST_Conditional.prototype._size = () => 3;
      AST_Array.prototype._size = function() {
        return 2 + list_overhead(this.elements);
      };
      AST_Object.prototype._size = function(info) {
        let base = 2;
        if (first_in_statement(info)) {
          base += 2;
        }
        return base + list_overhead(this.properties);
      };
      const key_size = (key2) => typeof key2 === "string" ? key2.length : 0;
      AST_ObjectKeyVal.prototype._size = function() {
        return key_size(this.key) + 1;
      };
      const static_size = (is_static) => is_static ? 7 : 0;
      AST_ObjectGetter.prototype._size = function() {
        return 5 + static_size(this.static) + key_size(this.key);
      };
      AST_ObjectSetter.prototype._size = function() {
        return 5 + static_size(this.static) + key_size(this.key);
      };
      AST_ConciseMethod.prototype._size = function() {
        return static_size(this.static) + key_size(this.key);
      };
      AST_PrivateMethod.prototype._size = function() {
        return AST_ConciseMethod.prototype._size.call(this) + 1;
      };
      AST_PrivateGetter.prototype._size = function() {
        return AST_ConciseMethod.prototype._size.call(this) + 4;
      };
      AST_PrivateSetter.prototype._size = function() {
        return AST_ConciseMethod.prototype._size.call(this) + 4;
      };
      AST_PrivateIn.prototype._size = function() {
        return 5;
      };
      AST_Class.prototype._size = function() {
        return (this.name ? 8 : 7) + (this.extends ? 8 : 0);
      };
      AST_ClassStaticBlock.prototype._size = function() {
        return 8 + list_overhead(this.body);
      };
      AST_ClassProperty.prototype._size = function() {
        return static_size(this.static) + (typeof this.key === "string" ? this.key.length + 2 : 0) + (this.value ? 1 : 0);
      };
      AST_ClassPrivateProperty.prototype._size = function() {
        return AST_ClassProperty.prototype._size.call(this) + 1;
      };
      AST_Symbol.prototype._size = function() {
        if (!(mangle_options && this.thedef && !this.thedef.unmangleable(mangle_options))) {
          return this.name.length;
        } else {
          return 1;
        }
      };
      AST_SymbolClassProperty.prototype._size = function() {
        return this.name.length;
      };
      AST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = function() {
        if (this.name === "arguments")
          return 9;
        return AST_Symbol.prototype._size.call(this);
      };
      AST_NewTarget.prototype._size = () => 10;
      AST_SymbolImportForeign.prototype._size = function() {
        return this.name.length;
      };
      AST_SymbolExportForeign.prototype._size = function() {
        return this.name.length;
      };
      AST_This.prototype._size = () => 4;
      AST_Super.prototype._size = () => 5;
      AST_String.prototype._size = function() {
        return this.value.length + 2;
      };
      AST_Number.prototype._size = function() {
        const { value: value2 } = this;
        if (value2 === 0)
          return 1;
        if (value2 > 0 && Math.floor(value2) === value2) {
          return Math.floor(Math.log10(value2) + 1);
        }
        return value2.toString().length;
      };
      AST_BigInt.prototype._size = function() {
        return this.value.length;
      };
      AST_RegExp.prototype._size = function() {
        return this.value.toString().length;
      };
      AST_Null.prototype._size = () => 4;
      AST_NaN.prototype._size = () => 3;
      AST_Undefined.prototype._size = () => 6;
      AST_Hole.prototype._size = () => 0;
      AST_Infinity.prototype._size = () => 8;
      AST_True.prototype._size = () => 4;
      AST_False.prototype._size = () => 5;
      AST_Await.prototype._size = () => 6;
      AST_Yield.prototype._size = () => 6;
      const UNUSED = 1;
      const TRUTHY = 2;
      const FALSY = 4;
      const UNDEFINED = 8;
      const INLINED = 16;
      const WRITE_ONLY = 32;
      const SQUEEZED = 256;
      const OPTIMIZED = 512;
      const TOP = 1024;
      const CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;
      const has_flag = (node, flag) => node.flags & flag;
      const set_flag = (node, flag) => {
        node.flags |= flag;
      };
      const clear_flag = (node, flag) => {
        node.flags &= ~flag;
      };
      function merge_sequence(array, node) {
        if (node instanceof AST_Sequence) {
          array.push(...node.expressions);
        } else {
          array.push(node);
        }
        return array;
      }
      function make_sequence(orig, expressions) {
        if (expressions.length == 1)
          return expressions[0];
        if (expressions.length == 0)
          throw new Error("trying to create a sequence with length zero!");
        return make_node(AST_Sequence, orig, {
          expressions: expressions.reduce(merge_sequence, [])
        });
      }
      function make_empty_function(self2) {
        return make_node(AST_Function, self2, {
          uses_arguments: false,
          argnames: [],
          body: [],
          is_generator: false,
          async: false,
          variables: /* @__PURE__ */ new Map(),
          uses_with: false,
          uses_eval: false,
          parent_scope: null,
          enclosed: [],
          cname: 0,
          block_scope: void 0
        });
      }
      function make_node_from_constant(val, orig) {
        switch (typeof val) {
          case "string":
            return make_node(AST_String, orig, {
              value: val
            });
          case "number":
            if (isNaN(val))
              return make_node(AST_NaN, orig);
            if (isFinite(val)) {
              return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {
                operator: "-",
                expression: make_node(AST_Number, orig, { value: -val })
              }) : make_node(AST_Number, orig, { value: val });
            }
            return val < 0 ? make_node(AST_UnaryPrefix, orig, {
              operator: "-",
              expression: make_node(AST_Infinity, orig)
            }) : make_node(AST_Infinity, orig);
          case "bigint":
            return make_node(AST_BigInt, orig, { value: val.toString() });
          case "boolean":
            return make_node(val ? AST_True : AST_False, orig);
          case "undefined":
            return make_node(AST_Undefined, orig);
          default:
            if (val === null) {
              return make_node(AST_Null, orig, { value: null });
            }
            if (val instanceof RegExp) {
              return make_node(AST_RegExp, orig, {
                value: {
                  source: regexp_source_fix(val.source),
                  flags: val.flags
                }
              });
            }
            throw new Error(string_template("Can't handle constant of type: {type}", {
              type: typeof val
            }));
        }
      }
      function best_of_expression(ast1, ast2) {
        return ast1.size() > ast2.size() ? ast2 : ast1;
      }
      function best_of_statement(ast1, ast2) {
        return best_of_expression(make_node(AST_SimpleStatement, ast1, {
          body: ast1
        }), make_node(AST_SimpleStatement, ast2, {
          body: ast2
        })).body;
      }
      function best_of(compressor, ast1, ast2) {
        if (first_in_statement(compressor)) {
          return best_of_statement(ast1, ast2);
        } else {
          return best_of_expression(ast1, ast2);
        }
      }
      function get_simple_key(key2) {
        if (key2 instanceof AST_Constant) {
          return key2.getValue();
        }
        if (key2 instanceof AST_UnaryPrefix && key2.operator == "void" && key2.expression instanceof AST_Constant) {
          return;
        }
        return key2;
      }
      function read_property(obj, key2) {
        key2 = get_simple_key(key2);
        if (key2 instanceof AST_Node)
          return;
        var value2;
        if (obj instanceof AST_Array) {
          var elements = obj.elements;
          if (key2 == "length")
            return make_node_from_constant(elements.length, obj);
          if (typeof key2 == "number" && key2 in elements)
            value2 = elements[key2];
        } else if (obj instanceof AST_Object) {
          key2 = "" + key2;
          var props = obj.properties;
          for (var i = props.length; --i >= 0; ) {
            var prop = props[i];
            if (!(prop instanceof AST_ObjectKeyVal))
              return;
            if (!value2 && props[i].key === key2)
              value2 = props[i].value;
          }
        }
        return value2 instanceof AST_SymbolRef && value2.fixed_value() || value2;
      }
      function has_break_or_continue(loop, parent) {
        var found = false;
        var tw = new TreeWalker(function(node) {
          if (found || node instanceof AST_Scope)
            return true;
          if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === loop) {
            return found = true;
          }
        });
        if (parent instanceof AST_LabeledStatement)
          tw.push(parent);
        tw.push(loop);
        loop.body.walk(tw);
        return found;
      }
      function maintain_this_binding(parent, orig, val) {
        if (requires_sequence_to_maintain_binding(parent, orig, val)) {
          const zero = make_node(AST_Number, orig, { value: 0 });
          return make_sequence(orig, [zero, val]);
        } else {
          return val;
        }
      }
      function requires_sequence_to_maintain_binding(parent, orig, val) {
        return parent instanceof AST_UnaryPrefix && parent.operator == "delete" || parent instanceof AST_Call && parent.expression === orig && (val instanceof AST_Chain || val instanceof AST_PropAccess || val instanceof AST_SymbolRef && val.name == "eval");
      }
      function is_func_expr(node) {
        return node instanceof AST_Arrow || node instanceof AST_Function;
      }
      function is_iife_call(node) {
        if (node.TYPE != "Call")
          return false;
        return node.expression instanceof AST_Function || is_iife_call(node.expression);
      }
      function is_empty2(thing) {
        if (thing === null)
          return true;
        if (thing instanceof AST_EmptyStatement)
          return true;
        if (thing instanceof AST_BlockStatement)
          return thing.body.length == 0;
        return false;
      }
      const identifier_atom = makePredicate("Infinity NaN undefined");
      function is_identifier_atom(node) {
        return node instanceof AST_Infinity || node instanceof AST_NaN || node instanceof AST_Undefined;
      }
      function is_ref_of(ref, type) {
        if (!(ref instanceof AST_SymbolRef))
          return false;
        var orig = ref.definition().orig;
        for (var i = orig.length; --i >= 0; ) {
          if (orig[i] instanceof type)
            return true;
        }
      }
      function can_be_evicted_from_block(node) {
        return !(node instanceof AST_DefClass || node instanceof AST_Defun || node instanceof AST_Let || node instanceof AST_Const || node instanceof AST_Export || node instanceof AST_Import);
      }
      function as_statement_array(thing) {
        if (thing === null)
          return [];
        if (thing instanceof AST_BlockStatement)
          return thing.body;
        if (thing instanceof AST_EmptyStatement)
          return [];
        if (thing instanceof AST_Statement)
          return [thing];
        throw new Error("Can't convert thing to statement array");
      }
      function is_reachable(scope_node, defs) {
        const find_ref = (node) => {
          if (node instanceof AST_SymbolRef && defs.includes(node.definition())) {
            return walk_abort;
          }
        };
        return walk_parent(scope_node, (node, info) => {
          if (node instanceof AST_Scope && node !== scope_node) {
            var parent = info.parent();
            if (parent instanceof AST_Call && parent.expression === node && !(node.async || node.is_generator)) {
              return;
            }
            if (walk(node, find_ref))
              return walk_abort;
            return true;
          }
        });
      }
      function is_recursive_ref(tw, def) {
        var node;
        for (var i = 0; node = tw.parent(i); i++) {
          if (node instanceof AST_Lambda || node instanceof AST_Class) {
            var name = node.name;
            if (name && name.definition() === def) {
              return true;
            }
          }
        }
        return false;
      }
      function retain_top_func(fn, compressor) {
        return compressor.top_retain && fn instanceof AST_Defun && has_flag(fn, TOP) && fn.name && compressor.top_retain(fn.name.definition());
      }
      function make_nested_lookup(obj) {
        const out = /* @__PURE__ */ new Map();
        for (var key2 of Object.keys(obj)) {
          out.set(key2, makePredicate(obj[key2]));
        }
        const does_have = (global_name, fname) => {
          const inner_map = out.get(global_name);
          return inner_map != null && inner_map.has(fname);
        };
        return does_have;
      }
      const pure_prop_access_globals = /* @__PURE__ */ new Set([
        "Number",
        "String",
        "Array",
        "Object",
        "Function",
        "Promise"
      ]);
      const object_methods = [
        "constructor",
        "toString",
        "valueOf"
      ];
      const is_pure_native_method = make_nested_lookup({
        Array: [
          "at",
          "flat",
          "includes",
          "indexOf",
          "join",
          "lastIndexOf",
          "slice",
          ...object_methods
        ],
        Boolean: object_methods,
        Function: object_methods,
        Number: [
          "toExponential",
          "toFixed",
          "toPrecision",
          ...object_methods
        ],
        Object: object_methods,
        RegExp: [
          "test",
          ...object_methods
        ],
        String: [
          "at",
          "charAt",
          "charCodeAt",
          "charPointAt",
          "concat",
          "endsWith",
          "fromCharCode",
          "fromCodePoint",
          "includes",
          "indexOf",
          "italics",
          "lastIndexOf",
          "localeCompare",
          "match",
          "matchAll",
          "normalize",
          "padStart",
          "padEnd",
          "repeat",
          "replace",
          "replaceAll",
          "search",
          "slice",
          "split",
          "startsWith",
          "substr",
          "substring",
          "repeat",
          "toLocaleLowerCase",
          "toLocaleUpperCase",
          "toLowerCase",
          "toUpperCase",
          "trim",
          "trimEnd",
          "trimStart",
          ...object_methods
        ]
      });
      const is_pure_native_fn = make_nested_lookup({
        Array: [
          "isArray"
        ],
        Math: [
          "abs",
          "acos",
          "asin",
          "atan",
          "ceil",
          "cos",
          "exp",
          "floor",
          "log",
          "round",
          "sin",
          "sqrt",
          "tan",
          "atan2",
          "pow",
          "max",
          "min"
        ],
        Number: [
          "isFinite",
          "isNaN"
        ],
        Object: [
          "create",
          "getOwnPropertyDescriptor",
          "getOwnPropertyNames",
          "getPrototypeOf",
          "isExtensible",
          "isFrozen",
          "isSealed",
          "hasOwn",
          "keys"
        ],
        String: [
          "fromCharCode"
        ]
      });
      const is_pure_native_value = make_nested_lookup({
        Math: [
          "E",
          "LN10",
          "LN2",
          "LOG2E",
          "LOG10E",
          "PI",
          "SQRT1_2",
          "SQRT2"
        ],
        Number: [
          "MAX_VALUE",
          "MIN_VALUE",
          "NaN",
          "NEGATIVE_INFINITY",
          "POSITIVE_INFINITY"
        ]
      });
      const is_undeclared_ref = (node) => node instanceof AST_SymbolRef && node.definition().undeclared;
      const bitwise_binop = makePredicate("<<< >> << & | ^ ~");
      const lazy_op = makePredicate("&& || ??");
      const unary_side_effects = makePredicate("delete ++ --");
      (function(def_is_boolean) {
        const unary_bool = makePredicate("! delete");
        const binary_bool = makePredicate("in instanceof == != === !== < <= >= >");
        def_is_boolean(AST_Node, return_false);
        def_is_boolean(AST_UnaryPrefix, function() {
          return unary_bool.has(this.operator);
        });
        def_is_boolean(AST_Binary, function() {
          return binary_bool.has(this.operator) || lazy_op.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();
        });
        def_is_boolean(AST_Conditional, function() {
          return this.consequent.is_boolean() && this.alternative.is_boolean();
        });
        def_is_boolean(AST_Assign, function() {
          return this.operator == "=" && this.right.is_boolean();
        });
        def_is_boolean(AST_Sequence, function() {
          return this.tail_node().is_boolean();
        });
        def_is_boolean(AST_True, return_true);
        def_is_boolean(AST_False, return_true);
      })(function(node, func) {
        node.DEFMETHOD("is_boolean", func);
      });
      (function(def_is_number) {
        def_is_number(AST_Node, return_false);
        def_is_number(AST_Number, return_true);
        const unary = makePredicate("+ - ~ ++ --");
        def_is_number(AST_Unary, function(compressor) {
          return unary.has(this.operator) && this.expression.is_number(compressor);
        });
        const numeric_ops = makePredicate("- * / % & | ^ << >> >>>");
        def_is_number(AST_Binary, function(compressor) {
          if (this.operator === "+") {
            return this.left.is_number(compressor) && this.right.is_number_or_bigint(compressor) || this.right.is_number(compressor) && this.left.is_number_or_bigint(compressor);
          } else if (numeric_ops.has(this.operator)) {
            return this.left.is_number(compressor) || this.right.is_number(compressor);
          } else {
            return false;
          }
        });
        def_is_number(AST_Assign, function(compressor) {
          return (this.operator === "=" || numeric_ops.has(this.operator.slice(0, -1))) && this.right.is_number(compressor);
        });
        def_is_number(AST_Sequence, function(compressor) {
          return this.tail_node().is_number(compressor);
        });
        def_is_number(AST_Conditional, function(compressor) {
          return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_number", func);
      });
      (function(def_is_bigint) {
        def_is_bigint(AST_Node, return_false);
        def_is_bigint(AST_BigInt, return_true);
        const unary = makePredicate("+ - ~ ++ --");
        def_is_bigint(AST_Unary, function(compressor) {
          return unary.has(this.operator) && this.expression.is_bigint(compressor);
        });
        const numeric_ops = makePredicate("- * / % & | ^ << >>");
        def_is_bigint(AST_Binary, function(compressor) {
          if (this.operator === "+") {
            return this.left.is_bigint(compressor) && this.right.is_number_or_bigint(compressor) || this.right.is_bigint(compressor) && this.left.is_number_or_bigint(compressor);
          } else if (numeric_ops.has(this.operator)) {
            return this.left.is_bigint(compressor) || this.right.is_bigint(compressor);
          } else {
            return false;
          }
        });
        def_is_bigint(AST_Assign, function(compressor) {
          return (numeric_ops.has(this.operator.slice(0, -1)) || this.operator == "=") && this.right.is_bigint(compressor);
        });
        def_is_bigint(AST_Sequence, function(compressor) {
          return this.tail_node().is_bigint(compressor);
        });
        def_is_bigint(AST_Conditional, function(compressor) {
          return this.consequent.is_bigint(compressor) && this.alternative.is_bigint(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_bigint", func);
      });
      (function(def_is_number_or_bigint) {
        def_is_number_or_bigint(AST_Node, return_false);
        def_is_number_or_bigint(AST_Number, return_true);
        def_is_number_or_bigint(AST_BigInt, return_true);
        const numeric_unary_ops = makePredicate("+ - ~ ++ --");
        def_is_number_or_bigint(AST_Unary, function(_compressor) {
          return numeric_unary_ops.has(this.operator);
        });
        const numeric_ops = makePredicate("- * / % & | ^ << >>");
        def_is_number_or_bigint(AST_Binary, function(compressor) {
          return this.operator === "+" ? this.left.is_number_or_bigint(compressor) && this.right.is_number_or_bigint(compressor) : numeric_ops.has(this.operator);
        });
        def_is_number_or_bigint(AST_Assign, function(compressor) {
          return numeric_ops.has(this.operator.slice(0, -1)) || this.operator == "=" && this.right.is_number_or_bigint(compressor);
        });
        def_is_number_or_bigint(AST_Sequence, function(compressor) {
          return this.tail_node().is_number_or_bigint(compressor);
        });
        def_is_number_or_bigint(AST_Conditional, function(compressor) {
          return this.consequent.is_number_or_bigint(compressor) && this.alternative.is_number_or_bigint(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_number_or_bigint", func);
      });
      (function(def_is_32_bit_integer) {
        def_is_32_bit_integer(AST_Node, return_false);
        def_is_32_bit_integer(AST_Number, function(_compressor) {
          return this.value === (this.value | 0);
        });
        def_is_32_bit_integer(AST_UnaryPrefix, function(compressor) {
          return this.operator == "~" ? this.expression.is_number(compressor) : this.operator === "+" ? this.expression.is_32_bit_integer(compressor) : false;
        });
        def_is_32_bit_integer(AST_Binary, function(compressor) {
          return bitwise_binop.has(this.operator) && (this.left.is_number(compressor) || this.right.is_number(compressor));
        });
      })(function(node, func) {
        node.DEFMETHOD("is_32_bit_integer", func);
      });
      (function(def_is_string) {
        def_is_string(AST_Node, return_false);
        def_is_string(AST_String, return_true);
        def_is_string(AST_TemplateString, return_true);
        def_is_string(AST_UnaryPrefix, function() {
          return this.operator == "typeof";
        });
        def_is_string(AST_Binary, function(compressor) {
          return this.operator == "+" && (this.left.is_string(compressor) || this.right.is_string(compressor));
        });
        def_is_string(AST_Assign, function(compressor) {
          return (this.operator == "=" || this.operator == "+=") && this.right.is_string(compressor);
        });
        def_is_string(AST_Sequence, function(compressor) {
          return this.tail_node().is_string(compressor);
        });
        def_is_string(AST_Conditional, function(compressor) {
          return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("is_string", func);
      });
      function is_undefined(node, compressor) {
        return has_flag(node, UNDEFINED) || node instanceof AST_Undefined || node instanceof AST_UnaryPrefix && node.operator == "void" && !node.expression.has_side_effects(compressor);
      }
      function is_null_or_undefined(node, compressor) {
        let fixed;
        return node instanceof AST_Null || is_undefined(node, compressor) || node instanceof AST_SymbolRef && (fixed = node.definition().fixed) instanceof AST_Node && is_nullish(fixed, compressor);
      }
      function is_nullish_shortcircuited(node, compressor) {
        if (node instanceof AST_PropAccess || node instanceof AST_Call) {
          return node.optional && is_null_or_undefined(node.expression, compressor) || is_nullish_shortcircuited(node.expression, compressor);
        }
        if (node instanceof AST_Chain)
          return is_nullish_shortcircuited(node.expression, compressor);
        return false;
      }
      function is_nullish(node, compressor) {
        if (is_null_or_undefined(node, compressor))
          return true;
        return is_nullish_shortcircuited(node, compressor);
      }
      (function(def_has_side_effects) {
        def_has_side_effects(AST_Node, return_true);
        def_has_side_effects(AST_EmptyStatement, return_false);
        def_has_side_effects(AST_Constant, return_false);
        def_has_side_effects(AST_This, return_false);
        function any(list, compressor) {
          for (var i = list.length; --i >= 0; )
            if (list[i].has_side_effects(compressor))
              return true;
          return false;
        }
        def_has_side_effects(AST_Block, function(compressor) {
          return any(this.body, compressor);
        });
        def_has_side_effects(AST_Call, function(compressor) {
          if (!this.is_callee_pure(compressor) && (!this.expression.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {
            return true;
          }
          return any(this.args, compressor);
        });
        def_has_side_effects(AST_Switch, function(compressor) {
          return this.expression.has_side_effects(compressor) || any(this.body, compressor);
        });
        def_has_side_effects(AST_Case, function(compressor) {
          return this.expression.has_side_effects(compressor) || any(this.body, compressor);
        });
        def_has_side_effects(AST_Try, function(compressor) {
          return this.body.has_side_effects(compressor) || this.bcatch && this.bcatch.has_side_effects(compressor) || this.bfinally && this.bfinally.has_side_effects(compressor);
        });
        def_has_side_effects(AST_If, function(compressor) {
          return this.condition.has_side_effects(compressor) || this.body && this.body.has_side_effects(compressor) || this.alternative && this.alternative.has_side_effects(compressor);
        });
        def_has_side_effects(AST_ImportMeta, return_false);
        def_has_side_effects(AST_LabeledStatement, function(compressor) {
          return this.body.has_side_effects(compressor);
        });
        def_has_side_effects(AST_SimpleStatement, function(compressor) {
          return this.body.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Lambda, return_false);
        def_has_side_effects(AST_Class, function(compressor) {
          if (this.extends && this.extends.has_side_effects(compressor)) {
            return true;
          }
          return any(this.properties, compressor);
        });
        def_has_side_effects(AST_ClassStaticBlock, function(compressor) {
          return any(this.body, compressor);
        });
        def_has_side_effects(AST_Binary, function(compressor) {
          return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Assign, return_true);
        def_has_side_effects(AST_Conditional, function(compressor) {
          return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Unary, function(compressor) {
          return unary_side_effects.has(this.operator) || this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_SymbolRef, function(compressor) {
          return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
        });
        def_has_side_effects(AST_SymbolClassProperty, return_false);
        def_has_side_effects(AST_SymbolDeclaration, return_false);
        def_has_side_effects(AST_Object, function(compressor) {
          return any(this.properties, compressor);
        });
        def_has_side_effects(AST_ObjectKeyVal, function(compressor) {
          return this.computed_key() && this.key.has_side_effects(compressor) || this.value && this.value.has_side_effects(compressor);
        });
        def_has_side_effects([
          AST_ClassProperty,
          AST_ClassPrivateProperty
        ], function(compressor) {
          return this.computed_key() && this.key.has_side_effects(compressor) || this.static && this.value && this.value.has_side_effects(compressor);
        });
        def_has_side_effects([
          AST_PrivateMethod,
          AST_PrivateGetter,
          AST_PrivateSetter,
          AST_ConciseMethod,
          AST_ObjectGetter,
          AST_ObjectSetter
        ], function(compressor) {
          return this.computed_key() && this.key.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Array, function(compressor) {
          return any(this.elements, compressor);
        });
        def_has_side_effects(AST_Dot, function(compressor) {
          if (is_nullish(this, compressor)) {
            return this.expression.has_side_effects(compressor);
          }
          if (!this.optional && this.expression.may_throw_on_access(compressor)) {
            return true;
          }
          return this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Sub, function(compressor) {
          if (is_nullish(this, compressor)) {
            return this.expression.has_side_effects(compressor);
          }
          if (!this.optional && this.expression.may_throw_on_access(compressor)) {
            return true;
          }
          var property = this.property.has_side_effects(compressor);
          if (property && this.optional)
            return true;
          return property || this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Chain, function(compressor) {
          return this.expression.has_side_effects(compressor);
        });
        def_has_side_effects(AST_Sequence, function(compressor) {
          return any(this.expressions, compressor);
        });
        def_has_side_effects(AST_Definitions, function(compressor) {
          return any(this.definitions, compressor);
        });
        def_has_side_effects(AST_VarDef, function() {
          return this.value != null;
        });
        def_has_side_effects(AST_TemplateSegment, return_false);
        def_has_side_effects(AST_TemplateString, function(compressor) {
          return any(this.segments, compressor);
        });
      })(function(node_or_nodes, func) {
        for (const node of [].concat(node_or_nodes)) {
          node.DEFMETHOD("has_side_effects", func);
        }
      });
      (function(def_may_throw) {
        def_may_throw(AST_Node, return_true);
        def_may_throw(AST_Constant, return_false);
        def_may_throw(AST_EmptyStatement, return_false);
        def_may_throw(AST_Lambda, return_false);
        def_may_throw(AST_SymbolDeclaration, return_false);
        def_may_throw(AST_This, return_false);
        def_may_throw(AST_ImportMeta, return_false);
        function any(list, compressor) {
          for (var i = list.length; --i >= 0; )
            if (list[i].may_throw(compressor))
              return true;
          return false;
        }
        def_may_throw(AST_Class, function(compressor) {
          if (this.extends && this.extends.may_throw(compressor))
            return true;
          return any(this.properties, compressor);
        });
        def_may_throw(AST_ClassStaticBlock, function(compressor) {
          return any(this.body, compressor);
        });
        def_may_throw(AST_Array, function(compressor) {
          return any(this.elements, compressor);
        });
        def_may_throw(AST_Assign, function(compressor) {
          if (this.right.may_throw(compressor))
            return true;
          if (!compressor.has_directive("use strict") && this.operator == "=" && this.left instanceof AST_SymbolRef) {
            return false;
          }
          return this.left.may_throw(compressor);
        });
        def_may_throw(AST_Binary, function(compressor) {
          return this.left.may_throw(compressor) || this.right.may_throw(compressor);
        });
        def_may_throw(AST_Block, function(compressor) {
          return any(this.body, compressor);
        });
        def_may_throw(AST_Call, function(compressor) {
          if (is_nullish(this, compressor))
            return false;
          if (any(this.args, compressor))
            return true;
          if (this.is_callee_pure(compressor))
            return false;
          if (this.expression.may_throw(compressor))
            return true;
          return !(this.expression instanceof AST_Lambda) || any(this.expression.body, compressor);
        });
        def_may_throw(AST_Case, function(compressor) {
          return this.expression.may_throw(compressor) || any(this.body, compressor);
        });
        def_may_throw(AST_Conditional, function(compressor) {
          return this.condition.may_throw(compressor) || this.consequent.may_throw(compressor) || this.alternative.may_throw(compressor);
        });
        def_may_throw(AST_Definitions, function(compressor) {
          return any(this.definitions, compressor);
        });
        def_may_throw(AST_If, function(compressor) {
          return this.condition.may_throw(compressor) || this.body && this.body.may_throw(compressor) || this.alternative && this.alternative.may_throw(compressor);
        });
        def_may_throw(AST_LabeledStatement, function(compressor) {
          return this.body.may_throw(compressor);
        });
        def_may_throw(AST_Object, function(compressor) {
          return any(this.properties, compressor);
        });
        def_may_throw(AST_ObjectKeyVal, function(compressor) {
          return this.computed_key() && this.key.may_throw(compressor) || this.value ? this.value.may_throw(compressor) : false;
        });
        def_may_throw([
          AST_ClassProperty,
          AST_ClassPrivateProperty
        ], function(compressor) {
          return this.computed_key() && this.key.may_throw(compressor) || this.static && this.value && this.value.may_throw(compressor);
        });
        def_may_throw([
          AST_ConciseMethod,
          AST_ObjectGetter,
          AST_ObjectSetter
        ], function(compressor) {
          return this.computed_key() && this.key.may_throw(compressor);
        });
        def_may_throw([
          AST_PrivateMethod,
          AST_PrivateGetter,
          AST_PrivateSetter
        ], return_false);
        def_may_throw(AST_Return, function(compressor) {
          return this.value && this.value.may_throw(compressor);
        });
        def_may_throw(AST_Sequence, function(compressor) {
          return any(this.expressions, compressor);
        });
        def_may_throw(AST_SimpleStatement, function(compressor) {
          return this.body.may_throw(compressor);
        });
        def_may_throw(AST_Dot, function(compressor) {
          if (is_nullish(this, compressor))
            return false;
          return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor);
        });
        def_may_throw(AST_Sub, function(compressor) {
          if (is_nullish(this, compressor))
            return false;
          return !this.optional && this.expression.may_throw_on_access(compressor) || this.expression.may_throw(compressor) || this.property.may_throw(compressor);
        });
        def_may_throw(AST_Chain, function(compressor) {
          return this.expression.may_throw(compressor);
        });
        def_may_throw(AST_Switch, function(compressor) {
          return this.expression.may_throw(compressor) || any(this.body, compressor);
        });
        def_may_throw(AST_SymbolRef, function(compressor) {
          return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);
        });
        def_may_throw(AST_SymbolClassProperty, return_false);
        def_may_throw(AST_Try, function(compressor) {
          return this.bcatch ? this.bcatch.may_throw(compressor) : this.body.may_throw(compressor) || this.bfinally && this.bfinally.may_throw(compressor);
        });
        def_may_throw(AST_Unary, function(compressor) {
          if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
            return false;
          return this.expression.may_throw(compressor);
        });
        def_may_throw(AST_VarDef, function(compressor) {
          if (!this.value)
            return false;
          return this.value.may_throw(compressor);
        });
      })(function(node_or_nodes, func) {
        for (const node of [].concat(node_or_nodes)) {
          node.DEFMETHOD("may_throw", func);
        }
      });
      (function(def_is_constant_expression) {
        function all_refs_local(scope) {
          let result = true;
          walk(this, (node) => {
            if (node instanceof AST_SymbolRef) {
              if (has_flag(this, INLINED)) {
                result = false;
                return walk_abort;
              }
              var def = node.definition();
              if (member(def, this.enclosed) && !this.variables.has(def.name)) {
                if (scope) {
                  var scope_def = scope.find_variable(node);
                  if (def.undeclared ? !scope_def : scope_def === def) {
                    result = "f";
                    return true;
                  }
                }
                result = false;
                return walk_abort;
              }
              return true;
            }
            if (node instanceof AST_This && this instanceof AST_Arrow) {
              result = false;
              return walk_abort;
            }
          });
          return result;
        }
        def_is_constant_expression(AST_Node, return_false);
        def_is_constant_expression(AST_Constant, return_true);
        def_is_constant_expression(AST_Class, function(scope) {
          if (this.extends && !this.extends.is_constant_expression(scope)) {
            return false;
          }
          for (const prop of this.properties) {
            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {
              return false;
            }
            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {
              return false;
            }
            if (prop instanceof AST_ClassStaticBlock) {
              return false;
            }
          }
          return all_refs_local.call(this, scope);
        });
        def_is_constant_expression(AST_Lambda, all_refs_local);
        def_is_constant_expression(AST_Unary, function() {
          return this.expression.is_constant_expression();
        });
        def_is_constant_expression(AST_Binary, function() {
          return this.left.is_constant_expression() && this.right.is_constant_expression();
        });
        def_is_constant_expression(AST_Array, function() {
          return this.elements.every((l) => l.is_constant_expression());
        });
        def_is_constant_expression(AST_Object, function() {
          return this.properties.every((l) => l.is_constant_expression());
        });
        def_is_constant_expression(AST_ObjectProperty, function() {
          return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());
        });
      })(function(node, func) {
        node.DEFMETHOD("is_constant_expression", func);
      });
      (function(def_may_throw_on_access) {
        AST_Node.DEFMETHOD("may_throw_on_access", function(compressor) {
          return !compressor.option("pure_getters") || this._dot_throw(compressor);
        });
        function is_strict(compressor) {
          return /strict/.test(compressor.option("pure_getters"));
        }
        def_may_throw_on_access(AST_Node, is_strict);
        def_may_throw_on_access(AST_Null, return_true);
        def_may_throw_on_access(AST_Undefined, return_true);
        def_may_throw_on_access(AST_Constant, return_false);
        def_may_throw_on_access(AST_Array, return_false);
        def_may_throw_on_access(AST_Object, function(compressor) {
          if (!is_strict(compressor))
            return false;
          for (var i = this.properties.length; --i >= 0; )
            if (this.properties[i]._dot_throw(compressor))
              return true;
          return false;
        });
        def_may_throw_on_access(AST_Class, return_false);
        def_may_throw_on_access(AST_ObjectProperty, return_false);
        def_may_throw_on_access(AST_ObjectGetter, return_true);
        def_may_throw_on_access(AST_Expansion, function(compressor) {
          return this.expression._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Function, return_false);
        def_may_throw_on_access(AST_Arrow, return_false);
        def_may_throw_on_access(AST_UnaryPostfix, return_false);
        def_may_throw_on_access(AST_UnaryPrefix, function() {
          return this.operator == "void";
        });
        def_may_throw_on_access(AST_Binary, function(compressor) {
          return (this.operator == "&&" || this.operator == "||" || this.operator == "??") && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));
        });
        def_may_throw_on_access(AST_Assign, function(compressor) {
          if (this.logical)
            return true;
          return this.operator == "=" && this.right._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Conditional, function(compressor) {
          return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Dot, function(compressor) {
          if (!is_strict(compressor))
            return false;
          if (this.property == "prototype") {
            return !(this.expression instanceof AST_Function || this.expression instanceof AST_Class);
          }
          return true;
        });
        def_may_throw_on_access(AST_Chain, function(compressor) {
          return this.expression._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_Sequence, function(compressor) {
          return this.tail_node()._dot_throw(compressor);
        });
        def_may_throw_on_access(AST_SymbolRef, function(compressor) {
          if (this.name === "arguments" && this.scope instanceof AST_Lambda)
            return false;
          if (has_flag(this, UNDEFINED))
            return true;
          if (!is_strict(compressor))
            return false;
          if (is_undeclared_ref(this) && this.is_declared(compressor))
            return false;
          if (this.is_immutable())
            return false;
          var fixed = this.fixed_value();
          return !fixed || fixed._dot_throw(compressor);
        });
      })(function(node, func) {
        node.DEFMETHOD("_dot_throw", func);
      });
      function is_lhs(node, parent) {
        if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator))
          return parent.expression;
        if (parent instanceof AST_Assign && parent.left === node)
          return node;
        if (parent instanceof AST_ForIn && parent.init === node)
          return node;
      }
      (function(def_negate) {
        function basic_negation(exp) {
          return make_node(AST_UnaryPrefix, exp, {
            operator: "!",
            expression: exp
          });
        }
        function best(orig, alt, first_in_statement2) {
          var negated = basic_negation(orig);
          if (first_in_statement2) {
            var stat = make_node(AST_SimpleStatement, alt, {
              body: alt
            });
            return best_of_expression(negated, stat) === stat ? alt : negated;
          }
          return best_of_expression(negated, alt);
        }
        def_negate(AST_Node, function() {
          return basic_negation(this);
        });
        def_negate(AST_Statement, function() {
          throw new Error("Cannot negate a statement");
        });
        def_negate(AST_Function, function() {
          return basic_negation(this);
        });
        def_negate(AST_Class, function() {
          return basic_negation(this);
        });
        def_negate(AST_Arrow, function() {
          return basic_negation(this);
        });
        def_negate(AST_UnaryPrefix, function() {
          if (this.operator == "!")
            return this.expression;
          return basic_negation(this);
        });
        def_negate(AST_Sequence, function(compressor) {
          var expressions = this.expressions.slice();
          expressions.push(expressions.pop().negate(compressor));
          return make_sequence(this, expressions);
        });
        def_negate(AST_Conditional, function(compressor, first_in_statement2) {
          var self2 = this.clone();
          self2.consequent = self2.consequent.negate(compressor);
          self2.alternative = self2.alternative.negate(compressor);
          return best(this, self2, first_in_statement2);
        });
        def_negate(AST_Binary, function(compressor, first_in_statement2) {
          var self2 = this.clone(), op = this.operator;
          if (compressor.option("unsafe_comps")) {
            switch (op) {
              case "<=":
                self2.operator = ">";
                return self2;
              case "<":
                self2.operator = ">=";
                return self2;
              case ">=":
                self2.operator = "<";
                return self2;
              case ">":
                self2.operator = "<=";
                return self2;
            }
          }
          switch (op) {
            case "==":
              self2.operator = "!=";
              return self2;
            case "!=":
              self2.operator = "==";
              return self2;
            case "===":
              self2.operator = "!==";
              return self2;
            case "!==":
              self2.operator = "===";
              return self2;
            case "&&":
              self2.operator = "||";
              self2.left = self2.left.negate(compressor, first_in_statement2);
              self2.right = self2.right.negate(compressor);
              return best(this, self2, first_in_statement2);
            case "||":
              self2.operator = "&&";
              self2.left = self2.left.negate(compressor, first_in_statement2);
              self2.right = self2.right.negate(compressor);
              return best(this, self2, first_in_statement2);
          }
          return basic_negation(this);
        });
      })(function(node, func) {
        node.DEFMETHOD("negate", function(compressor, first_in_statement2) {
          return func.call(this, compressor, first_in_statement2);
        });
      });
      (function(def_bitwise_negate) {
        function basic_bitwise_negation(exp) {
          return make_node(AST_UnaryPrefix, exp, {
            operator: "~",
            expression: exp
          });
        }
        def_bitwise_negate(AST_Node, function(_compressor) {
          return basic_bitwise_negation(this);
        });
        def_bitwise_negate(AST_Number, function(_compressor) {
          const neg = ~this.value;
          if (neg.toString().length > this.value.toString().length) {
            return basic_bitwise_negation(this);
          }
          return make_node(AST_Number, this, { value: neg });
        });
        def_bitwise_negate(AST_UnaryPrefix, function(compressor, in_32_bit_context) {
          if (this.operator == "~" && (this.expression.is_32_bit_integer(compressor) || (in_32_bit_context != null ? in_32_bit_context : compressor.in_32_bit_context()))) {
            return this.expression;
          } else {
            return basic_bitwise_negation(this);
          }
        });
      })(function(node, func) {
        node.DEFMETHOD("bitwise_negate", func);
      });
      var global_pure_fns = makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
      AST_Call.DEFMETHOD("is_callee_pure", function(compressor) {
        if (compressor.option("unsafe")) {
          var expr = this.expression;
          var first_arg = this.args && this.args[0] && this.args[0].evaluate(compressor);
          if (expr.expression && expr.expression.name === "hasOwnProperty" && (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {
            return false;
          }
          if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name))
            return true;
          if (expr instanceof AST_Dot && is_undeclared_ref(expr.expression) && is_pure_native_fn(expr.expression.name, expr.property)) {
            return true;
          }
        }
        if (this instanceof AST_New && compressor.option("pure_new")) {
          return true;
        }
        if (compressor.option("side_effects") && has_annotation(this, _PURE)) {
          return true;
        }
        return !compressor.pure_funcs(this);
      });
      AST_Node.DEFMETHOD("is_call_pure", return_false);
      AST_Dot.DEFMETHOD("is_call_pure", function(compressor) {
        if (!compressor.option("unsafe"))
          return;
        const expr = this.expression;
        let native_obj;
        if (expr instanceof AST_Array) {
          native_obj = "Array";
        } else if (expr.is_boolean()) {
          native_obj = "Boolean";
        } else if (expr.is_number(compressor)) {
          native_obj = "Number";
        } else if (expr instanceof AST_RegExp) {
          native_obj = "RegExp";
        } else if (expr.is_string(compressor)) {
          native_obj = "String";
        } else if (!this.may_throw_on_access(compressor)) {
          native_obj = "Object";
        }
        return native_obj != null && is_pure_native_method(native_obj, this.property);
      });
      const aborts = (thing) => thing && thing.aborts();
      (function(def_aborts) {
        def_aborts(AST_Statement, return_null);
        def_aborts(AST_Jump, return_this);
        function block_aborts() {
          for (var i = 0; i < this.body.length; i++) {
            if (aborts(this.body[i])) {
              return this.body[i];
            }
          }
          return null;
        }
        def_aborts(AST_Import, return_null);
        def_aborts(AST_BlockStatement, block_aborts);
        def_aborts(AST_SwitchBranch, block_aborts);
        def_aborts(AST_DefClass, function() {
          for (const prop of this.properties) {
            if (prop instanceof AST_ClassStaticBlock) {
              if (prop.aborts())
                return prop;
            }
          }
          return null;
        });
        def_aborts(AST_ClassStaticBlock, block_aborts);
        def_aborts(AST_If, function() {
          return this.alternative && aborts(this.body) && aborts(this.alternative) && this;
        });
      })(function(node, func) {
        node.DEFMETHOD("aborts", func);
      });
      AST_Node.DEFMETHOD("contains_this", function() {
        return walk(this, (node) => {
          if (node instanceof AST_This)
            return walk_abort;
          if (node !== this && node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
            return true;
          }
        });
      });
      function is_modified(compressor, tw, node, value2, level, immutable) {
        var parent = tw.parent(level);
        var lhs = is_lhs(node, parent);
        if (lhs)
          return lhs;
        if (!immutable && parent instanceof AST_Call && parent.expression === node && !(value2 instanceof AST_Arrow) && !(value2 instanceof AST_Class) && !parent.is_callee_pure(compressor) && (!(value2 instanceof AST_Function) || !(parent instanceof AST_New) && value2.contains_this())) {
          return true;
        }
        if (parent instanceof AST_Array) {
          return is_modified(compressor, tw, parent, parent, level + 1);
        }
        if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
          var obj = tw.parent(level + 1);
          return is_modified(compressor, tw, obj, obj, level + 2);
        }
        if (parent instanceof AST_PropAccess && parent.expression === node) {
          var prop = read_property(value2, parent.property);
          return !immutable && is_modified(compressor, tw, parent, prop, level + 1);
        }
      }
      function is_used_in_expression(tw) {
        for (let p = -1, node, parent; node = tw.parent(p), parent = tw.parent(p + 1); p++) {
          if (parent instanceof AST_Sequence) {
            const nth_expression = parent.expressions.indexOf(node);
            if (nth_expression !== parent.expressions.length - 1) {
              const grandparent = tw.parent(p + 2);
              if (parent.expressions.length > 2 || parent.expressions.length === 1 || !requires_sequence_to_maintain_binding(grandparent, parent, parent.expressions[1])) {
                return false;
              }
              return true;
            } else {
              continue;
            }
          }
          if (parent instanceof AST_Unary) {
            const op = parent.operator;
            if (op === "void") {
              return false;
            }
            if (op === "typeof" || op === "+" || op === "-" || op === "!" || op === "~") {
              continue;
            }
          }
          if (parent instanceof AST_SimpleStatement || parent instanceof AST_LabeledStatement) {
            return false;
          }
          if (parent instanceof AST_Scope) {
            return false;
          }
          return true;
        }
        return true;
      }
      function def_eval(node, func) {
        node.DEFMETHOD("_eval", func);
      }
      const nullish = Symbol("This AST_Chain is nullish");
      AST_Node.DEFMETHOD("evaluate", function(compressor) {
        if (!compressor.option("evaluate"))
          return this;
        var val = this._eval(compressor, 1);
        if (!val || val instanceof RegExp)
          return val;
        if (typeof val == "function" || typeof val == "object" || val == nullish)
          return this;
        if (typeof val === "string") {
          const unevaluated_size = this.size(compressor);
          if (val.length + 2 > unevaluated_size)
            return this;
        }
        return val;
      });
      var unaryPrefix = makePredicate("! ~ - + void");
      AST_Node.DEFMETHOD("is_constant", function() {
        if (this instanceof AST_Constant) {
          return !(this instanceof AST_RegExp);
        } else {
          return this instanceof AST_UnaryPrefix && unaryPrefix.has(this.operator) && (this.expression instanceof AST_Constant || this.expression.is_constant());
        }
      });
      def_eval(AST_Statement, function() {
        throw new Error(string_template("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
      });
      def_eval(AST_Lambda, return_this);
      def_eval(AST_Class, return_this);
      def_eval(AST_Node, return_this);
      def_eval(AST_Constant, function() {
        return this.getValue();
      });
      const supports_bigint = typeof BigInt === "function";
      def_eval(AST_BigInt, function() {
        if (supports_bigint) {
          return BigInt(this.value);
        } else {
          return this;
        }
      });
      def_eval(AST_RegExp, function(compressor) {
        let evaluated = compressor.evaluated_regexps.get(this.value);
        if (evaluated === void 0 && regexp_is_safe(this.value.source)) {
          try {
            const { source, flags } = this.value;
            evaluated = new RegExp(source, flags);
          } catch (e) {
            evaluated = null;
          }
          compressor.evaluated_regexps.set(this.value, evaluated);
        }
        return evaluated || this;
      });
      def_eval(AST_TemplateString, function() {
        if (this.segments.length !== 1)
          return this;
        return this.segments[0].value;
      });
      def_eval(AST_Function, function(compressor) {
        if (compressor.option("unsafe")) {
          var fn = function() {
          };
          fn.node = this;
          fn.toString = () => this.print_to_string();
          return fn;
        }
        return this;
      });
      def_eval(AST_Array, function(compressor, depth) {
        if (compressor.option("unsafe")) {
          var elements = [];
          for (var i = 0, len = this.elements.length; i < len; i++) {
            var element2 = this.elements[i];
            var value2 = element2._eval(compressor, depth);
            if (element2 === value2)
              return this;
            elements.push(value2);
          }
          return elements;
        }
        return this;
      });
      def_eval(AST_Object, function(compressor, depth) {
        if (compressor.option("unsafe")) {
          var val = {};
          for (var i = 0, len = this.properties.length; i < len; i++) {
            var prop = this.properties[i];
            if (prop instanceof AST_Expansion)
              return this;
            var key2 = prop.key;
            if (key2 instanceof AST_Symbol) {
              key2 = key2.name;
            } else if (key2 instanceof AST_Node) {
              key2 = key2._eval(compressor, depth);
              if (key2 === prop.key)
                return this;
            }
            if (typeof Object.prototype[key2] === "function") {
              return this;
            }
            if (prop.value instanceof AST_Function)
              continue;
            val[key2] = prop.value._eval(compressor, depth);
            if (val[key2] === prop.value)
              return this;
          }
          return val;
        }
        return this;
      });
      var non_converting_unary = makePredicate("! typeof void");
      def_eval(AST_UnaryPrefix, function(compressor, depth) {
        var e = this.expression;
        if (compressor.option("typeofs") && this.operator == "typeof") {
          if (e instanceof AST_Lambda || e instanceof AST_SymbolRef && e.fixed_value() instanceof AST_Lambda) {
            return "function";
          }
          if ((e instanceof AST_Object || e instanceof AST_Array || e instanceof AST_SymbolRef && (e.fixed_value() instanceof AST_Object || e.fixed_value() instanceof AST_Array)) && !e.has_side_effects(compressor)) {
            return typeof {};
          }
        }
        if (!non_converting_unary.has(this.operator))
          depth++;
        e = e._eval(compressor, depth);
        if (e === this.expression)
          return this;
        switch (this.operator) {
          case "!":
            return !e;
          case "typeof":
            if (e instanceof RegExp)
              return this;
            return typeof e;
          case "void":
            return void 0;
          case "~":
            return ~e;
          case "-":
            return -e;
          case "+":
            return +e;
        }
        return this;
      });
      var non_converting_binary = makePredicate("&& || ?? === !==");
      const identity_comparison = makePredicate("== != === !==");
      const has_identity = (value2) => typeof value2 === "object" || typeof value2 === "function" || typeof value2 === "symbol";
      def_eval(AST_Binary, function(compressor, depth) {
        if (!non_converting_binary.has(this.operator))
          depth++;
        var left = this.left._eval(compressor, depth);
        if (left === this.left)
          return this;
        var right = this.right._eval(compressor, depth);
        if (right === this.right)
          return this;
        if (left != null && right != null && identity_comparison.has(this.operator) && has_identity(left) && has_identity(right) && typeof left === typeof right) {
          return this;
        }
        if (typeof left === "bigint" !== (typeof right === "bigint") || typeof left === "bigint" && (this.operator === ">>>" || this.operator === "/" && Number(right) === 0)) {
          return this;
        }
        var result;
        switch (this.operator) {
          case "&&":
            result = left && right;
            break;
          case "||":
            result = left || right;
            break;
          case "??":
            result = left != null ? left : right;
            break;
          case "|":
            result = left | right;
            break;
          case "&":
            result = left & right;
            break;
          case "^":
            result = left ^ right;
            break;
          case "+":
            result = left + right;
            break;
          case "*":
            result = left * right;
            break;
          case "**":
            result = left ** right;
            break;
          case "/":
            result = left / right;
            break;
          case "%":
            result = left % right;
            break;
          case "-":
            result = left - right;
            break;
          case "<<":
            result = left << right;
            break;
          case ">>":
            result = left >> right;
            break;
          case ">>>":
            result = left >>> right;
            break;
          case "==":
            result = left == right;
            break;
          case "===":
            result = left === right;
            break;
          case "!=":
            result = left != right;
            break;
          case "!==":
            result = left !== right;
            break;
          case "<":
            result = left < right;
            break;
          case "<=":
            result = left <= right;
            break;
          case ">":
            result = left > right;
            break;
          case ">=":
            result = left >= right;
            break;
          default:
            return this;
        }
        if (typeof result === "number" && isNaN(result) && compressor.find_parent(AST_With)) {
          return this;
        }
        return result;
      });
      def_eval(AST_Conditional, function(compressor, depth) {
        var condition = this.condition._eval(compressor, depth);
        if (condition === this.condition)
          return this;
        var node = condition ? this.consequent : this.alternative;
        var value2 = node._eval(compressor, depth);
        return value2 === node ? this : value2;
      });
      const reentrant_ref_eval = /* @__PURE__ */ new Set();
      def_eval(AST_SymbolRef, function(compressor, depth) {
        if (reentrant_ref_eval.has(this))
          return this;
        var fixed = this.fixed_value();
        if (!fixed)
          return this;
        reentrant_ref_eval.add(this);
        const value2 = fixed._eval(compressor, depth);
        reentrant_ref_eval.delete(this);
        if (value2 === fixed)
          return this;
        if (value2 && typeof value2 == "object") {
          var escaped = this.definition().escaped;
          if (escaped && depth > escaped)
            return this;
        }
        return value2;
      });
      const global_objs = { Array, Math, Number, Object, String };
      const regexp_flags = /* @__PURE__ */ new Set([
        "dotAll",
        "global",
        "ignoreCase",
        "multiline",
        "sticky",
        "unicode"
      ]);
      def_eval(AST_PropAccess, function(compressor, depth) {
        let obj = this.expression._eval(compressor, depth + 1);
        if (obj === nullish || this.optional && obj == null)
          return nullish;
        if (this.property === "length") {
          if (typeof obj === "string") {
            return obj.length;
          }
          const is_spreadless_array = obj instanceof AST_Array && obj.elements.every((el) => !(el instanceof AST_Expansion));
          if (is_spreadless_array && obj.elements.every((el) => !el.has_side_effects(compressor))) {
            return obj.elements.length;
          }
        }
        if (compressor.option("unsafe")) {
          var key2 = this.property;
          if (key2 instanceof AST_Node) {
            key2 = key2._eval(compressor, depth);
            if (key2 === this.property)
              return this;
          }
          var exp = this.expression;
          if (is_undeclared_ref(exp)) {
            var aa;
            var first_arg = exp.name === "hasOwnProperty" && key2 === "call" && (aa = compressor.parent() && compressor.parent().args) && (aa && aa[0] && aa[0].evaluate(compressor));
            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;
            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
              return this.clone();
            }
            if (!is_pure_native_value(exp.name, key2))
              return this;
            obj = global_objs[exp.name];
          } else {
            if (obj instanceof RegExp) {
              if (key2 == "source") {
                return regexp_source_fix(obj.source);
              } else if (key2 == "flags" || regexp_flags.has(key2)) {
                return obj[key2];
              }
            }
            if (!obj || obj === exp || !HOP(obj, key2))
              return this;
            if (typeof obj == "function")
              switch (key2) {
                case "name":
                  return obj.node.name ? obj.node.name.name : "";
                case "length":
                  return obj.node.length_property();
                default:
                  return this;
              }
          }
          return obj[key2];
        }
        return this;
      });
      def_eval(AST_Chain, function(compressor, depth) {
        const evaluated = this.expression._eval(compressor, depth);
        return evaluated === nullish ? void 0 : evaluated === this.expression ? this : evaluated;
      });
      def_eval(AST_Call, function(compressor, depth) {
        var exp = this.expression;
        const callee = exp._eval(compressor, depth);
        if (callee === nullish || this.optional && callee == null)
          return nullish;
        if (compressor.option("unsafe") && exp instanceof AST_PropAccess) {
          var key2 = exp.property;
          if (key2 instanceof AST_Node) {
            key2 = key2._eval(compressor, depth);
            if (key2 === exp.property)
              return this;
          }
          var val;
          var e = exp.expression;
          if (is_undeclared_ref(e)) {
            var first_arg = e.name === "hasOwnProperty" && key2 === "call" && (this.args[0] && this.args[0].evaluate(compressor));
            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;
            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {
              return this.clone();
            }
            if (!is_pure_native_fn(e.name, key2))
              return this;
            val = global_objs[e.name];
          } else {
            val = e._eval(compressor, depth + 1);
            if (val === e || !val)
              return this;
            if (!is_pure_native_method(val.constructor.name, key2))
              return this;
          }
          var args = [];
          for (var i = 0, len = this.args.length; i < len; i++) {
            var arg = this.args[i];
            var value2 = arg._eval(compressor, depth);
            if (arg === value2)
              return this;
            if (arg instanceof AST_Lambda)
              return this;
            args.push(value2);
          }
          try {
            return val[key2].apply(val, args);
          } catch (ex) {
          }
        }
        return this;
      });
      def_eval(AST_New, return_this);
      function def_drop_side_effect_free(node_or_nodes, func) {
        for (const node of [].concat(node_or_nodes)) {
          node.DEFMETHOD("drop_side_effect_free", func);
        }
      }
      function trim(nodes, compressor, first_in_statement2) {
        var len = nodes.length;
        if (!len)
          return null;
        var ret = [], changed = false;
        for (var i = 0; i < len; i++) {
          var node = nodes[i].drop_side_effect_free(compressor, first_in_statement2);
          changed |= node !== nodes[i];
          if (node) {
            ret.push(node);
            first_in_statement2 = false;
          }
        }
        return changed ? ret.length ? ret : null : nodes;
      }
      def_drop_side_effect_free(AST_Node, return_this);
      def_drop_side_effect_free(AST_Constant, return_null);
      def_drop_side_effect_free(AST_This, return_null);
      def_drop_side_effect_free(AST_Call, function(compressor, first_in_statement2) {
        if (is_nullish_shortcircuited(this, compressor)) {
          return this.expression.drop_side_effect_free(compressor, first_in_statement2);
        }
        if (!this.is_callee_pure(compressor)) {
          if (this.expression.is_call_pure(compressor)) {
            var exprs = this.args.slice();
            exprs.unshift(this.expression.expression);
            exprs = trim(exprs, compressor, first_in_statement2);
            return exprs && make_sequence(this, exprs);
          }
          if (is_func_expr(this.expression) && (!this.expression.name || !this.expression.name.definition().references.length)) {
            var node = this.clone();
            node.expression.process_expression(false, compressor);
            return node;
          }
          return this;
        }
        var args = trim(this.args, compressor, first_in_statement2);
        return args && make_sequence(this, args);
      });
      def_drop_side_effect_free(AST_Accessor, return_null);
      def_drop_side_effect_free(AST_Function, return_null);
      def_drop_side_effect_free(AST_Arrow, return_null);
      def_drop_side_effect_free(AST_Class, function(compressor) {
        const with_effects = [];
        if (this.is_self_referential() && this.has_side_effects(compressor)) {
          return this;
        }
        const trimmed_extends = this.extends && this.extends.drop_side_effect_free(compressor);
        if (trimmed_extends)
          with_effects.push(trimmed_extends);
        for (const prop of this.properties) {
          if (prop instanceof AST_ClassStaticBlock) {
            if (prop.has_side_effects(compressor)) {
              return this;
            }
          } else {
            const trimmed_prop = prop.drop_side_effect_free(compressor);
            if (trimmed_prop)
              with_effects.push(trimmed_prop);
          }
        }
        if (!with_effects.length)
          return null;
        const exprs = make_sequence(this, with_effects);
        if (this instanceof AST_DefClass) {
          return make_node(AST_SimpleStatement, this, { body: exprs });
        } else {
          return exprs;
        }
      });
      def_drop_side_effect_free([
        AST_ClassProperty,
        AST_ClassPrivateProperty
      ], function(compressor) {
        const key2 = this.computed_key() && this.key.drop_side_effect_free(compressor);
        const value2 = this.static && this.value && this.value.drop_side_effect_free(compressor);
        if (key2 && value2)
          return make_sequence(this, [key2, value2]);
        return key2 || value2 || null;
      });
      def_drop_side_effect_free(AST_Binary, function(compressor, first_in_statement2) {
        var right = this.right.drop_side_effect_free(compressor);
        if (!right)
          return this.left.drop_side_effect_free(compressor, first_in_statement2);
        if (lazy_op.has(this.operator)) {
          if (right === this.right)
            return this;
          var node = this.clone();
          node.right = right;
          return node;
        } else {
          var left = this.left.drop_side_effect_free(compressor, first_in_statement2);
          if (!left)
            return this.right.drop_side_effect_free(compressor, first_in_statement2);
          return make_sequence(this, [left, right]);
        }
      });
      def_drop_side_effect_free(AST_Assign, function(compressor) {
        if (this.logical)
          return this;
        var left = this.left;
        if (left.has_side_effects(compressor) || compressor.has_directive("use strict") && left instanceof AST_PropAccess && left.expression.is_constant()) {
          return this;
        }
        set_flag(this, WRITE_ONLY);
        while (left instanceof AST_PropAccess) {
          left = left.expression;
        }
        if (left.is_constant_expression(compressor.find_parent(AST_Scope))) {
          return this.right.drop_side_effect_free(compressor);
        }
        return this;
      });
      def_drop_side_effect_free(AST_Conditional, function(compressor) {
        var consequent = this.consequent.drop_side_effect_free(compressor);
        var alternative = this.alternative.drop_side_effect_free(compressor);
        if (consequent === this.consequent && alternative === this.alternative)
          return this;
        if (!consequent)
          return alternative ? make_node(AST_Binary, this, {
            operator: "||",
            left: this.condition,
            right: alternative
          }) : this.condition.drop_side_effect_free(compressor);
        if (!alternative)
          return make_node(AST_Binary, this, {
            operator: "&&",
            left: this.condition,
            right: consequent
          });
        var node = this.clone();
        node.consequent = consequent;
        node.alternative = alternative;
        return node;
      });
      def_drop_side_effect_free(AST_Unary, function(compressor, first_in_statement2) {
        if (unary_side_effects.has(this.operator)) {
          if (!this.expression.has_side_effects(compressor)) {
            set_flag(this, WRITE_ONLY);
          } else {
            clear_flag(this, WRITE_ONLY);
          }
          return this;
        }
        if (this.operator == "typeof" && this.expression instanceof AST_SymbolRef)
          return null;
        var expression = this.expression.drop_side_effect_free(compressor, first_in_statement2);
        if (first_in_statement2 && expression && is_iife_call(expression)) {
          if (expression === this.expression && this.operator == "!")
            return this;
          return expression.negate(compressor, first_in_statement2);
        }
        return expression;
      });
      def_drop_side_effect_free(AST_SymbolRef, function(compressor) {
        const safe_access = this.is_declared(compressor) || pure_prop_access_globals.has(this.name);
        return safe_access ? null : this;
      });
      def_drop_side_effect_free(AST_Object, function(compressor, first_in_statement2) {
        var values = trim(this.properties, compressor, first_in_statement2);
        return values && make_sequence(this, values);
      });
      def_drop_side_effect_free(AST_ObjectKeyVal, function(compressor, first_in_statement2) {
        const computed_key = this.key instanceof AST_Node;
        const key2 = computed_key && this.key.drop_side_effect_free(compressor, first_in_statement2);
        const value2 = this.value.drop_side_effect_free(compressor, first_in_statement2);
        if (key2 && value2) {
          return make_sequence(this, [key2, value2]);
        }
        return key2 || value2;
      });
      def_drop_side_effect_free([
        AST_ConciseMethod,
        AST_ObjectGetter,
        AST_ObjectSetter
      ], function() {
        return this.computed_key() ? this.key : null;
      });
      def_drop_side_effect_free([
        AST_PrivateMethod,
        AST_PrivateGetter,
        AST_PrivateSetter
      ], function() {
        return null;
      });
      def_drop_side_effect_free(AST_Array, function(compressor, first_in_statement2) {
        var values = trim(this.elements, compressor, first_in_statement2);
        return values && make_sequence(this, values);
      });
      def_drop_side_effect_free(AST_Dot, function(compressor, first_in_statement2) {
        if (is_nullish_shortcircuited(this, compressor)) {
          return this.expression.drop_side_effect_free(compressor, first_in_statement2);
        }
        if (!this.optional && this.expression.may_throw_on_access(compressor)) {
          return this;
        }
        return this.expression.drop_side_effect_free(compressor, first_in_statement2);
      });
      def_drop_side_effect_free(AST_Sub, function(compressor, first_in_statement2) {
        if (is_nullish_shortcircuited(this, compressor)) {
          return this.expression.drop_side_effect_free(compressor, first_in_statement2);
        }
        if (!this.optional && this.expression.may_throw_on_access(compressor)) {
          return this;
        }
        var property = this.property.drop_side_effect_free(compressor);
        if (property && this.optional)
          return this;
        var expression = this.expression.drop_side_effect_free(compressor, first_in_statement2);
        if (expression && property)
          return make_sequence(this, [expression, property]);
        return expression || property;
      });
      def_drop_side_effect_free(AST_Chain, function(compressor, first_in_statement2) {
        return this.expression.drop_side_effect_free(compressor, first_in_statement2);
      });
      def_drop_side_effect_free(AST_Sequence, function(compressor) {
        var last = this.tail_node();
        var expr = last.drop_side_effect_free(compressor);
        if (expr === last)
          return this;
        var expressions = this.expressions.slice(0, -1);
        if (expr)
          expressions.push(expr);
        if (!expressions.length) {
          return make_node(AST_Number, this, { value: 0 });
        }
        return make_sequence(this, expressions);
      });
      def_drop_side_effect_free(AST_Expansion, function(compressor, first_in_statement2) {
        return this.expression.drop_side_effect_free(compressor, first_in_statement2);
      });
      def_drop_side_effect_free(AST_TemplateSegment, return_null);
      def_drop_side_effect_free(AST_TemplateString, function(compressor) {
        var values = trim(this.segments, compressor, first_in_statement);
        return values && make_sequence(this, values);
      });
      const r_keep_assign = /keep_assign/;
      AST_Scope.DEFMETHOD("drop_unused", function(compressor) {
        if (!compressor.option("unused"))
          return;
        if (compressor.has_directive("use asm"))
          return;
        if (!this.variables)
          return;
        var self2 = this;
        if (self2.pinned())
          return;
        var drop_funcs = !(self2 instanceof AST_Toplevel) || compressor.toplevel.funcs;
        var drop_vars = !(self2 instanceof AST_Toplevel) || compressor.toplevel.vars;
        const assign_as_unused = r_keep_assign.test(compressor.option("unused")) ? return_false : function(node) {
          if (node instanceof AST_Assign && !node.logical && (has_flag(node, WRITE_ONLY) || node.operator == "=")) {
            return node.left;
          }
          if (node instanceof AST_Unary && has_flag(node, WRITE_ONLY)) {
            return node.expression;
          }
        };
        var in_use_ids = /* @__PURE__ */ new Map();
        var fixed_ids = /* @__PURE__ */ new Map();
        if (self2 instanceof AST_Toplevel && compressor.top_retain) {
          self2.variables.forEach(function(def) {
            if (compressor.top_retain(def)) {
              in_use_ids.set(def.id, def);
            }
          });
        }
        var var_defs_by_id = /* @__PURE__ */ new Map();
        var initializations = /* @__PURE__ */ new Map();
        var scope = this;
        var tw = new TreeWalker(function(node, descend) {
          if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive("use strict")) {
            node.argnames.forEach(function(argname) {
              if (!(argname instanceof AST_SymbolDeclaration))
                return;
              var def = argname.definition();
              in_use_ids.set(def.id, def);
            });
          }
          if (node === self2)
            return;
          if (node instanceof AST_Class && node.has_side_effects(compressor)) {
            if (node.is_self_referential()) {
              descend();
            } else {
              node.visit_nondeferred_class_parts(tw);
            }
          }
          if (node instanceof AST_Defun || node instanceof AST_DefClass) {
            var node_def = node.name.definition();
            const in_export = tw.parent() instanceof AST_Export;
            if (in_export || !drop_funcs && scope === self2) {
              if (node_def.global) {
                in_use_ids.set(node_def.id, node_def);
              }
            }
            map_add(initializations, node_def.id, node);
            return true;
          }
          const in_root_scope = scope === self2;
          if (node instanceof AST_SymbolFunarg && in_root_scope) {
            map_add(var_defs_by_id, node.definition().id, node);
          }
          if (node instanceof AST_Definitions && in_root_scope) {
            const in_export = tw.parent() instanceof AST_Export;
            node.definitions.forEach(function(def) {
              if (def.name instanceof AST_SymbolVar) {
                map_add(var_defs_by_id, def.name.definition().id, def);
              }
              if (in_export || !drop_vars) {
                walk(def.name, (node2) => {
                  if (node2 instanceof AST_SymbolDeclaration) {
                    const def2 = node2.definition();
                    if (def2.global) {
                      in_use_ids.set(def2.id, def2);
                    }
                  }
                });
              }
              if (def.name instanceof AST_Destructuring) {
                def.walk(tw);
              }
              if (def.name instanceof AST_SymbolDeclaration && def.value) {
                var node_def2 = def.name.definition();
                map_add(initializations, node_def2.id, def.value);
                if (!node_def2.chained && def.name.fixed_value() === def.value) {
                  fixed_ids.set(node_def2.id, def);
                }
                if (def.value.has_side_effects(compressor)) {
                  def.value.walk(tw);
                }
              }
            });
            return true;
          }
          return scan_ref_scoped(node, descend);
        });
        self2.walk(tw);
        tw = new TreeWalker(scan_ref_scoped);
        in_use_ids.forEach(function(def) {
          var init2 = initializations.get(def.id);
          if (init2)
            init2.forEach(function(init3) {
              init3.walk(tw);
            });
        });
        var tt = new TreeTransformer(function before(node, descend, in_list) {
          var parent = tt.parent();
          if (drop_vars) {
            const sym2 = assign_as_unused(node);
            if (sym2 instanceof AST_SymbolRef) {
              var def = sym2.definition();
              var in_use = in_use_ids.has(def.id);
              if (node instanceof AST_Assign) {
                if (!in_use || fixed_ids.has(def.id) && fixed_ids.get(def.id) !== node) {
                  const assignee = node.right.transform(tt);
                  if (!in_use && !assignee.has_side_effects(compressor) && !is_used_in_expression(tt)) {
                    return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
                  }
                  return maintain_this_binding(parent, node, assignee);
                }
              } else if (!in_use) {
                return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
              }
            }
          }
          if (scope !== self2)
            return;
          var def;
          if (node.name && (node instanceof AST_ClassExpression && !keep_name(compressor.option("keep_classnames"), (def = node.name.definition()).name) || node instanceof AST_Function && !keep_name(compressor.option("keep_fnames"), (def = node.name.definition()).name))) {
            if (!in_use_ids.has(def.id) || def.orig.length > 1)
              node.name = null;
          }
          if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {
            var trim2 = !compressor.option("keep_fargs") || parent instanceof AST_Call && parent.expression === node && !node.pinned() && (!node.name || node.name.unreferenced());
            for (var a = node.argnames, i = a.length; --i >= 0; ) {
              var sym = a[i];
              if (sym instanceof AST_Expansion) {
                sym = sym.expression;
              }
              if (sym instanceof AST_DefaultAssign) {
                sym = sym.left;
              }
              if (!(sym instanceof AST_Destructuring) && !in_use_ids.has(sym.definition().id)) {
                set_flag(sym, UNUSED);
                if (trim2) {
                  a.pop();
                }
              } else {
                trim2 = false;
              }
            }
          }
          if (node instanceof AST_DefClass && node !== self2) {
            const def2 = node.name.definition();
            descend(node, this);
            const keep_class = def2.global && !drop_funcs || in_use_ids.has(def2.id);
            if (!keep_class) {
              const kept = node.drop_side_effect_free(compressor);
              if (kept == null) {
                def2.eliminated++;
                return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
              }
              return kept;
            }
            return node;
          }
          if (node instanceof AST_Defun && node !== self2) {
            const def2 = node.name.definition();
            const keep = def2.global && !drop_funcs || in_use_ids.has(def2.id);
            if (!keep) {
              def2.eliminated++;
              return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
            }
          }
          if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {
            var drop_block = !(parent instanceof AST_Toplevel) && !(node instanceof AST_Var);
            var body = [], head = [], tail = [];
            var side_effects = [];
            node.definitions.forEach(function(def2) {
              if (def2.value)
                def2.value = def2.value.transform(tt);
              var is_destructure = def2.name instanceof AST_Destructuring;
              var sym2 = is_destructure ? new SymbolDef(null, { name: "<destructure>" }) : def2.name.definition();
              if (drop_block && sym2.global)
                return tail.push(def2);
              if (!(drop_vars || drop_block) || is_destructure && (def2.name.names.length || def2.name.is_array || compressor.option("pure_getters") != true) || in_use_ids.has(sym2.id)) {
                if (def2.value && fixed_ids.has(sym2.id) && fixed_ids.get(sym2.id) !== def2) {
                  def2.value = def2.value.drop_side_effect_free(compressor);
                }
                if (def2.name instanceof AST_SymbolVar) {
                  var var_defs = var_defs_by_id.get(sym2.id);
                  if (var_defs.length > 1 && (!def2.value || sym2.orig.indexOf(def2.name) > sym2.eliminated)) {
                    if (def2.value) {
                      var ref = make_node(AST_SymbolRef, def2.name, def2.name);
                      sym2.references.push(ref);
                      var assign = make_node(AST_Assign, def2, {
                        operator: "=",
                        logical: false,
                        left: ref,
                        right: def2.value
                      });
                      if (fixed_ids.get(sym2.id) === def2) {
                        fixed_ids.set(sym2.id, assign);
                      }
                      side_effects.push(assign.transform(tt));
                    }
                    remove(var_defs, def2);
                    sym2.eliminated++;
                    return;
                  }
                }
                if (def2.value) {
                  if (side_effects.length > 0) {
                    if (tail.length > 0) {
                      side_effects.push(def2.value);
                      def2.value = make_sequence(def2.value, side_effects);
                    } else {
                      body.push(make_node(AST_SimpleStatement, node, {
                        body: make_sequence(node, side_effects)
                      }));
                    }
                    side_effects = [];
                  }
                  tail.push(def2);
                } else {
                  head.push(def2);
                }
              } else if (sym2.orig[0] instanceof AST_SymbolCatch) {
                var value2 = def2.value && def2.value.drop_side_effect_free(compressor);
                if (value2)
                  side_effects.push(value2);
                def2.value = null;
                head.push(def2);
              } else {
                var value2 = def2.value && def2.value.drop_side_effect_free(compressor);
                if (value2) {
                  side_effects.push(value2);
                }
                sym2.eliminated++;
              }
            });
            if (head.length > 0 || tail.length > 0) {
              node.definitions = head.concat(tail);
              body.push(node);
            }
            if (side_effects.length > 0) {
              body.push(make_node(AST_SimpleStatement, node, {
                body: make_sequence(node, side_effects)
              }));
            }
            switch (body.length) {
              case 0:
                return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);
              case 1:
                return body[0];
              default:
                return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body });
            }
          }
          if (node instanceof AST_For) {
            descend(node, this);
            var block;
            if (node.init instanceof AST_BlockStatement) {
              block = node.init;
              node.init = block.body.pop();
              block.body.push(node);
            }
            if (node.init instanceof AST_SimpleStatement) {
              node.init = node.init.body;
            } else if (is_empty2(node.init)) {
              node.init = null;
            }
            return !block ? node : in_list ? MAP.splice(block.body) : block;
          }
          if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {
            descend(node, this);
            if (node.body instanceof AST_BlockStatement) {
              var block = node.body;
              node.body = block.body.pop();
              block.body.push(node);
              return in_list ? MAP.splice(block.body) : block;
            }
            return node;
          }
          if (node instanceof AST_BlockStatement) {
            descend(node, this);
            if (in_list && node.body.every(can_be_evicted_from_block)) {
              return MAP.splice(node.body);
            }
            return node;
          }
          if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
            const save_scope = scope;
            scope = node;
            descend(node, this);
            scope = save_scope;
            return node;
          }
        }, function after(node, in_list) {
          if (node instanceof AST_Sequence) {
            switch (node.expressions.length) {
              case 0:
                return in_list ? MAP.skip : make_node(AST_Number, node, { value: 0 });
              case 1:
                return node.expressions[0];
            }
          }
        });
        self2.transform(tt);
        function scan_ref_scoped(node, descend) {
          var node_def;
          const sym = assign_as_unused(node);
          if (sym instanceof AST_SymbolRef && !is_ref_of(node.left, AST_SymbolBlockDeclaration) && self2.variables.get(sym.name) === (node_def = sym.definition())) {
            if (node instanceof AST_Assign) {
              node.right.walk(tw);
              if (!node_def.chained && node.left.fixed_value() === node.right) {
                fixed_ids.set(node_def.id, node);
              }
            }
            return true;
          }
          if (node instanceof AST_SymbolRef) {
            node_def = node.definition();
            if (!in_use_ids.has(node_def.id)) {
              in_use_ids.set(node_def.id, node_def);
              if (node_def.orig[0] instanceof AST_SymbolCatch) {
                const redef = node_def.scope.is_block_scope() && node_def.scope.get_defun_scope().variables.get(node_def.name);
                if (redef)
                  in_use_ids.set(redef.id, redef);
              }
            }
            return true;
          }
          if (node instanceof AST_Class) {
            descend();
            return true;
          }
          if (node instanceof AST_Scope && !(node instanceof AST_ClassStaticBlock)) {
            var save_scope = scope;
            scope = node;
            descend();
            scope = save_scope;
            return true;
          }
        }
      });
      function def_reduce_vars(node, func) {
        node.DEFMETHOD("reduce_vars", func);
      }
      def_reduce_vars(AST_Node, noop2);
      function reset_def(compressor, def) {
        def.assignments = 0;
        def.chained = false;
        def.direct_access = false;
        def.escaped = 0;
        def.recursive_refs = 0;
        def.references = [];
        def.single_use = void 0;
        if (def.scope.pinned() || def.orig[0] instanceof AST_SymbolFunarg && def.scope.uses_arguments) {
          def.fixed = false;
        } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {
          def.fixed = def.init;
        } else {
          def.fixed = false;
        }
      }
      function reset_variables(tw, compressor, node) {
        node.variables.forEach(function(def) {
          reset_def(compressor, def);
          if (def.fixed === null) {
            tw.defs_to_safe_ids.set(def.id, tw.safe_ids);
            mark(tw, def, true);
          } else if (def.fixed) {
            tw.loop_ids.set(def.id, tw.in_loop);
            mark(tw, def, true);
          }
        });
      }
      function reset_block_variables(compressor, node) {
        if (node.block_scope)
          node.block_scope.variables.forEach((def) => {
            reset_def(compressor, def);
          });
      }
      function push(tw) {
        tw.safe_ids = Object.create(tw.safe_ids);
      }
      function pop(tw) {
        tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);
      }
      function mark(tw, def, safe) {
        tw.safe_ids[def.id] = safe;
      }
      function safe_to_read(tw, def) {
        if (def.single_use == "m")
          return false;
        if (tw.safe_ids[def.id]) {
          if (def.fixed == null) {
            var orig = def.orig[0];
            if (orig instanceof AST_SymbolFunarg || orig.name == "arguments")
              return false;
            def.fixed = make_node(AST_Undefined, orig);
          }
          return true;
        }
        return def.fixed instanceof AST_Defun;
      }
      function safe_to_assign(tw, def, scope, value2) {
        if (def.fixed === void 0)
          return true;
        let def_safe_ids;
        if (def.fixed === null && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))) {
          def_safe_ids[def.id] = false;
          tw.defs_to_safe_ids.delete(def.id);
          return true;
        }
        if (!HOP(tw.safe_ids, def.id))
          return false;
        if (!safe_to_read(tw, def))
          return false;
        if (def.fixed === false)
          return false;
        if (def.fixed != null && (!value2 || def.references.length > def.assignments))
          return false;
        if (def.fixed instanceof AST_Defun) {
          return value2 instanceof AST_Node && def.fixed.parent_scope === scope;
        }
        return def.orig.every((sym) => {
          return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolDefun || sym instanceof AST_SymbolLambda);
        });
      }
      function ref_once(tw, compressor, def) {
        return compressor.option("unused") && !def.scope.pinned() && def.references.length - def.recursive_refs == 1 && tw.loop_ids.get(def.id) === tw.in_loop;
      }
      function is_immutable(value2) {
        if (!value2)
          return false;
        return value2.is_constant() || value2 instanceof AST_Lambda || value2 instanceof AST_This;
      }
      function mark_escaped(tw, d, scope, node, value2, level = 0, depth = 1) {
        var parent = tw.parent(level);
        if (value2) {
          if (value2.is_constant())
            return;
          if (value2 instanceof AST_ClassExpression)
            return;
        }
        if (parent instanceof AST_Assign && (parent.operator === "=" || parent.logical) && node === parent.right || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New) || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope || parent instanceof AST_VarDef && node === parent.value || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope) {
          if (depth > 1 && !(value2 && value2.is_constant_expression(scope)))
            depth = 1;
          if (!d.escaped || d.escaped > depth)
            d.escaped = depth;
          return;
        } else if (parent instanceof AST_Array || parent instanceof AST_Await || parent instanceof AST_Binary && lazy_op.has(parent.operator) || parent instanceof AST_Conditional && node !== parent.condition || parent instanceof AST_Expansion || parent instanceof AST_Sequence && node === parent.tail_node()) {
          mark_escaped(tw, d, scope, parent, parent, level + 1, depth);
        } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {
          var obj = tw.parent(level + 1);
          mark_escaped(tw, d, scope, obj, obj, level + 2, depth);
        } else if (parent instanceof AST_PropAccess && node === parent.expression) {
          value2 = read_property(value2, parent.property);
          mark_escaped(tw, d, scope, parent, value2, level + 1, depth + 1);
          if (value2)
            return;
        }
        if (level > 0)
          return;
        if (parent instanceof AST_Sequence && node !== parent.tail_node())
          return;
        if (parent instanceof AST_SimpleStatement)
          return;
        d.direct_access = true;
      }
      const suppress = (node) => walk(node, (node2) => {
        if (!(node2 instanceof AST_Symbol))
          return;
        var d = node2.definition();
        if (!d)
          return;
        if (node2 instanceof AST_SymbolRef)
          d.references.push(node2);
        d.fixed = false;
      });
      def_reduce_vars(AST_Accessor, function(tw, descend, compressor) {
        push(tw);
        reset_variables(tw, compressor, this);
        descend();
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Assign, function(tw, descend, compressor) {
        var node = this;
        if (node.left instanceof AST_Destructuring) {
          suppress(node.left);
          return;
        }
        const finish_walk = () => {
          if (node.logical) {
            node.left.walk(tw);
            push(tw);
            node.right.walk(tw);
            pop(tw);
            return true;
          }
        };
        var sym = node.left;
        if (!(sym instanceof AST_SymbolRef))
          return finish_walk();
        var def = sym.definition();
        var safe = safe_to_assign(tw, def, sym.scope, node.right);
        def.assignments++;
        if (!safe)
          return finish_walk();
        var fixed = def.fixed;
        if (!fixed && node.operator != "=" && !node.logical)
          return finish_walk();
        var eq = node.operator == "=";
        var value2 = eq ? node.right : node;
        if (is_modified(compressor, tw, node, value2, 0))
          return finish_walk();
        def.references.push(sym);
        if (!node.logical) {
          if (!eq)
            def.chained = true;
          def.fixed = eq ? function() {
            return node.right;
          } : function() {
            return make_node(AST_Binary, node, {
              operator: node.operator.slice(0, -1),
              left: fixed instanceof AST_Node ? fixed : fixed(),
              right: node.right
            });
          };
        }
        if (node.logical) {
          mark(tw, def, false);
          push(tw);
          node.right.walk(tw);
          pop(tw);
          return true;
        }
        mark(tw, def, false);
        node.right.walk(tw);
        mark(tw, def, true);
        mark_escaped(tw, def, sym.scope, node, value2, 0, 1);
        return true;
      });
      def_reduce_vars(AST_Binary, function(tw) {
        if (!lazy_op.has(this.operator))
          return;
        this.left.walk(tw);
        push(tw);
        this.right.walk(tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Block, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
      });
      def_reduce_vars(AST_Case, function(tw) {
        push(tw);
        this.expression.walk(tw);
        pop(tw);
        push(tw);
        walk_body(this, tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Class, function(tw, descend) {
        clear_flag(this, INLINED);
        push(tw);
        descend();
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
      });
      def_reduce_vars(AST_Conditional, function(tw) {
        this.condition.walk(tw);
        push(tw);
        this.consequent.walk(tw);
        pop(tw);
        push(tw);
        this.alternative.walk(tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_Chain, function(tw, descend) {
        const safe_ids = tw.safe_ids;
        descend();
        tw.safe_ids = safe_ids;
        return true;
      });
      def_reduce_vars(AST_Call, function(tw) {
        this.expression.walk(tw);
        if (this.optional) {
          push(tw);
        }
        for (const arg of this.args)
          arg.walk(tw);
        return true;
      });
      def_reduce_vars(AST_PropAccess, function(tw) {
        if (!this.optional)
          return;
        this.expression.walk(tw);
        push(tw);
        if (this.property instanceof AST_Node)
          this.property.walk(tw);
        return true;
      });
      def_reduce_vars(AST_Default, function(tw, descend) {
        push(tw);
        descend();
        pop(tw);
        return true;
      });
      function mark_lambda(tw, descend, compressor) {
        clear_flag(this, INLINED);
        push(tw);
        reset_variables(tw, compressor, this);
        var iife;
        if (!this.name && !this.uses_arguments && !this.pinned() && (iife = tw.parent()) instanceof AST_Call && iife.expression === this && !iife.args.some((arg) => arg instanceof AST_Expansion) && this.argnames.every((arg_name) => arg_name instanceof AST_Symbol)) {
          this.argnames.forEach((arg, i) => {
            if (!arg.definition)
              return;
            var d = arg.definition();
            if (d.orig.length > 1)
              return;
            if (d.fixed === void 0 && (!this.uses_arguments || tw.has_directive("use strict"))) {
              d.fixed = function() {
                return iife.args[i] || make_node(AST_Undefined, iife);
              };
              tw.loop_ids.set(d.id, tw.in_loop);
              mark(tw, d, true);
            } else {
              d.fixed = false;
            }
          });
        }
        descend();
        pop(tw);
        handle_defined_after_hoist(this);
        return true;
      }
      function handle_defined_after_hoist(parent) {
        const defuns = [];
        walk(parent, (node) => {
          if (node === parent)
            return;
          if (node instanceof AST_Defun) {
            defuns.push(node);
            return true;
          }
          if (node instanceof AST_Scope || node instanceof AST_SimpleStatement)
            return true;
        });
        const defun_dependencies_map = /* @__PURE__ */ new Map();
        const dependencies_map = /* @__PURE__ */ new Map();
        const symbols_of_interest = /* @__PURE__ */ new Set();
        const defuns_of_interest = /* @__PURE__ */ new Set();
        for (const defun of defuns) {
          const fname_def = defun.name.definition();
          const enclosing_defs = [];
          for (const def of defun.enclosed) {
            if (def.fixed === false || def === fname_def || def.scope.get_defun_scope() !== parent) {
              continue;
            }
            symbols_of_interest.add(def.id);
            if (def.assignments === 0 && def.orig.length === 1 && def.orig[0] instanceof AST_SymbolDefun) {
              defuns_of_interest.add(def.id);
              symbols_of_interest.add(def.id);
              defuns_of_interest.add(fname_def.id);
              symbols_of_interest.add(fname_def.id);
              if (!defun_dependencies_map.has(fname_def.id)) {
                defun_dependencies_map.set(fname_def.id, []);
              }
              defun_dependencies_map.get(fname_def.id).push(def.id);
              continue;
            }
            enclosing_defs.push(def);
          }
          if (enclosing_defs.length) {
            dependencies_map.set(fname_def.id, enclosing_defs);
            defuns_of_interest.add(fname_def.id);
            symbols_of_interest.add(fname_def.id);
          }
        }
        if (!dependencies_map.size) {
          return;
        }
        let symbol_index = 1;
        const defun_first_read_map = /* @__PURE__ */ new Map();
        const symbol_last_write_map = /* @__PURE__ */ new Map();
        walk_parent(parent, (node, walk_info) => {
          if (node instanceof AST_Symbol && node.thedef) {
            const id = node.definition().id;
            symbol_index++;
            if (symbols_of_interest.has(id)) {
              if (node instanceof AST_SymbolDeclaration || is_lhs(node, walk_info.parent())) {
                symbol_last_write_map.set(id, symbol_index);
              }
            }
            if (defuns_of_interest.has(id)) {
              if (!defun_first_read_map.has(id) && !is_recursive_ref(walk_info, id)) {
                defun_first_read_map.set(id, symbol_index);
              }
            }
          }
        });
        for (const [defun, defun_first_read] of defun_first_read_map) {
          const queue = new Set(defun_dependencies_map.get(defun));
          for (const enclosed_defun of queue) {
            let enclosed_defun_first_read = defun_first_read_map.get(enclosed_defun);
            if (enclosed_defun_first_read != null && enclosed_defun_first_read < defun_first_read) {
              continue;
            }
            defun_first_read_map.set(enclosed_defun, defun_first_read);
            for (const enclosed_enclosed_defun of defun_dependencies_map.get(enclosed_defun) || []) {
              queue.add(enclosed_enclosed_defun);
            }
          }
        }
        for (const [defun, defs] of dependencies_map) {
          const defun_first_read = defun_first_read_map.get(defun);
          if (defun_first_read === void 0) {
            continue;
          }
          for (const def of defs) {
            if (def.fixed === false) {
              continue;
            }
            let def_last_write = symbol_last_write_map.get(def.id) || 0;
            if (defun_first_read < def_last_write) {
              def.fixed = false;
            }
          }
        }
      }
      def_reduce_vars(AST_Lambda, mark_lambda);
      def_reduce_vars(AST_Do, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        this.body.walk(tw);
        if (has_break_or_continue(this)) {
          pop(tw);
          push(tw);
        }
        this.condition.walk(tw);
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      def_reduce_vars(AST_For, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        if (this.init)
          this.init.walk(tw);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        if (this.condition)
          this.condition.walk(tw);
        this.body.walk(tw);
        if (this.step) {
          if (has_break_or_continue(this)) {
            pop(tw);
            push(tw);
          }
          this.step.walk(tw);
        }
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      def_reduce_vars(AST_ForIn, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        suppress(this.init);
        this.object.walk(tw);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        this.body.walk(tw);
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      def_reduce_vars(AST_If, function(tw) {
        this.condition.walk(tw);
        push(tw);
        this.body.walk(tw);
        pop(tw);
        if (this.alternative) {
          push(tw);
          this.alternative.walk(tw);
          pop(tw);
        }
        return true;
      });
      def_reduce_vars(AST_LabeledStatement, function(tw) {
        push(tw);
        this.body.walk(tw);
        pop(tw);
        return true;
      });
      def_reduce_vars(AST_SymbolCatch, function() {
        this.definition().fixed = false;
      });
      def_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {
        var d = this.definition();
        d.references.push(this);
        if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {
          tw.loop_ids.set(d.id, tw.in_loop);
        }
        var fixed_value;
        if (d.fixed === void 0 || !safe_to_read(tw, d)) {
          d.fixed = false;
        } else if (d.fixed) {
          fixed_value = this.fixed_value();
          if (fixed_value instanceof AST_Lambda && is_recursive_ref(tw, d)) {
            d.recursive_refs++;
          } else if (fixed_value && !compressor.exposed(d) && ref_once(tw, compressor, d)) {
            d.single_use = fixed_value instanceof AST_Lambda && !fixed_value.pinned() || fixed_value instanceof AST_Class || d.scope === this.scope && fixed_value.is_constant_expression();
          } else {
            d.single_use = false;
          }
          if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {
            if (d.single_use) {
              d.single_use = "m";
            } else {
              d.fixed = false;
            }
          }
        }
        mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);
      });
      def_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {
        this.globals.forEach(function(def) {
          reset_def(compressor, def);
        });
        reset_variables(tw, compressor, this);
        descend();
        handle_defined_after_hoist(this);
        return true;
      });
      def_reduce_vars(AST_Try, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        push(tw);
        this.body.walk(tw);
        pop(tw);
        if (this.bcatch) {
          push(tw);
          this.bcatch.walk(tw);
          pop(tw);
        }
        if (this.bfinally)
          this.bfinally.walk(tw);
        return true;
      });
      def_reduce_vars(AST_Unary, function(tw) {
        var node = this;
        if (node.operator !== "++" && node.operator !== "--")
          return;
        var exp = node.expression;
        if (!(exp instanceof AST_SymbolRef))
          return;
        var def = exp.definition();
        var safe = safe_to_assign(tw, def, exp.scope, true);
        def.assignments++;
        if (!safe)
          return;
        var fixed = def.fixed;
        if (!fixed)
          return;
        def.references.push(exp);
        def.chained = true;
        def.fixed = function() {
          return make_node(AST_Binary, node, {
            operator: node.operator.slice(0, -1),
            left: make_node(AST_UnaryPrefix, node, {
              operator: "+",
              expression: fixed instanceof AST_Node ? fixed : fixed()
            }),
            right: make_node(AST_Number, node, {
              value: 1
            })
          });
        };
        mark(tw, def, true);
        return true;
      });
      def_reduce_vars(AST_VarDef, function(tw, descend) {
        var node = this;
        if (node.name instanceof AST_Destructuring) {
          suppress(node.name);
          return;
        }
        var d = node.name.definition();
        if (node.value) {
          if (safe_to_assign(tw, d, node.name.scope, node.value)) {
            d.fixed = function() {
              return node.value;
            };
            tw.loop_ids.set(d.id, tw.in_loop);
            mark(tw, d, false);
            descend();
            mark(tw, d, true);
            return true;
          } else {
            d.fixed = false;
          }
        }
      });
      def_reduce_vars(AST_While, function(tw, descend, compressor) {
        reset_block_variables(compressor, this);
        const saved_loop = tw.in_loop;
        tw.in_loop = this;
        push(tw);
        descend();
        pop(tw);
        tw.in_loop = saved_loop;
        return true;
      });
      function loop_body(x) {
        if (x instanceof AST_IterationStatement) {
          return x.body instanceof AST_BlockStatement ? x.body : x;
        }
        return x;
      }
      function is_lhs_read_only(lhs) {
        if (lhs instanceof AST_This)
          return true;
        if (lhs instanceof AST_SymbolRef)
          return lhs.definition().orig[0] instanceof AST_SymbolLambda;
        if (lhs instanceof AST_PropAccess) {
          lhs = lhs.expression;
          if (lhs instanceof AST_SymbolRef) {
            if (lhs.is_immutable())
              return false;
            lhs = lhs.fixed_value();
          }
          if (!lhs)
            return true;
          if (lhs instanceof AST_RegExp)
            return false;
          if (lhs instanceof AST_Constant)
            return true;
          return is_lhs_read_only(lhs);
        }
        return false;
      }
      function remove_initializers(var_statement) {
        var decls = [];
        var_statement.definitions.forEach(function(def) {
          if (def.name instanceof AST_SymbolDeclaration) {
            def.value = null;
            decls.push(def);
          } else {
            def.declarations_as_names().forEach((name) => {
              decls.push(make_node(AST_VarDef, def, {
                name,
                value: null
              }));
            });
          }
        });
        return decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : null;
      }
      function trim_unreachable_code(compressor, stat, target) {
        walk(stat, (node) => {
          if (node instanceof AST_Var) {
            const no_initializers = remove_initializers(node);
            if (no_initializers)
              target.push(no_initializers);
            return true;
          }
          if (node instanceof AST_Defun && (node === stat || !compressor.has_directive("use strict"))) {
            target.push(node === stat ? node : make_node(AST_Var, node, {
              definitions: [
                make_node(AST_VarDef, node, {
                  name: make_node(AST_SymbolVar, node.name, node.name),
                  value: null
                })
              ]
            }));
            return true;
          }
          if (node instanceof AST_Export || node instanceof AST_Import) {
            target.push(node);
            return true;
          }
          if (node instanceof AST_Scope) {
            return true;
          }
        });
      }
      function tighten_body(statements, compressor) {
        const nearest_scope = compressor.find_scope();
        const defun_scope = nearest_scope.get_defun_scope();
        const { in_loop, in_try } = find_loop_scope_try();
        var CHANGED, max_iter = 10;
        do {
          CHANGED = false;
          eliminate_spurious_blocks(statements);
          if (compressor.option("dead_code")) {
            eliminate_dead_code(statements, compressor);
          }
          if (compressor.option("if_return")) {
            handle_if_return(statements, compressor);
          }
          if (compressor.sequences_limit > 0) {
            sequencesize(statements, compressor);
            sequencesize_2(statements, compressor);
          }
          if (compressor.option("join_vars")) {
            join_consecutive_vars(statements);
          }
          if (compressor.option("collapse_vars")) {
            collapse(statements, compressor);
          }
        } while (CHANGED && max_iter-- > 0);
        function find_loop_scope_try() {
          var node = compressor.self(), level = 0, in_loop2 = false, in_try2 = false;
          do {
            if (node instanceof AST_IterationStatement) {
              in_loop2 = true;
            } else if (node instanceof AST_Scope) {
              break;
            } else if (node instanceof AST_TryBlock) {
              in_try2 = true;
            }
          } while (node = compressor.parent(level++));
          return { in_loop: in_loop2, in_try: in_try2 };
        }
        function collapse(statements2, compressor2) {
          if (nearest_scope.pinned() || defun_scope.pinned())
            return statements2;
          var args;
          var candidates = [];
          var stat_index = statements2.length;
          var scanner = new TreeTransformer(function(node) {
            if (abort)
              return node;
            if (!hit) {
              if (node !== hit_stack[hit_index])
                return node;
              hit_index++;
              if (hit_index < hit_stack.length)
                return handle_custom_scan_order(node);
              hit = true;
              stop_after = find_stop(node, 0);
              if (stop_after === node)
                abort = true;
              return node;
            }
            var parent = scanner.parent();
            if (node instanceof AST_Assign && (node.logical || node.operator != "=" && lhs.equivalent_to(node.left)) || node instanceof AST_Await || node instanceof AST_Call && lhs instanceof AST_PropAccess && lhs.equivalent_to(node.expression) || (node instanceof AST_Call || node instanceof AST_PropAccess) && node.optional || node instanceof AST_Debugger || node instanceof AST_Destructuring || node instanceof AST_Expansion && node.expression instanceof AST_Symbol && (node.expression instanceof AST_This || node.expression.definition().references.length > 1) || node instanceof AST_IterationStatement && !(node instanceof AST_For) || node instanceof AST_LoopControl || node instanceof AST_Try || node instanceof AST_With || node instanceof AST_Yield || node instanceof AST_Export || node instanceof AST_Class || parent instanceof AST_For && node !== parent.init || !replace_all && (node instanceof AST_SymbolRef && !node.is_declared(compressor2) && !pure_prop_access_globals.has(node)) || node instanceof AST_SymbolRef && parent instanceof AST_Call && has_annotation(parent, _NOINLINE) || node instanceof AST_ObjectProperty && node.key instanceof AST_Node) {
              abort = true;
              return node;
            }
            if (!stop_if_hit && (!lhs_local || !replace_all) && (parent instanceof AST_Binary && lazy_op.has(parent.operator) && parent.left !== node || parent instanceof AST_Conditional && parent.condition !== node || parent instanceof AST_If && parent.condition !== node)) {
              stop_if_hit = parent;
            }
            if (can_replace && !(node instanceof AST_SymbolDeclaration) && lhs.equivalent_to(node) && !shadows(scanner.find_scope() || nearest_scope, lvalues)) {
              if (stop_if_hit) {
                abort = true;
                return node;
              }
              if (is_lhs(node, parent)) {
                if (value_def)
                  replaced++;
                return node;
              } else {
                replaced++;
                if (value_def && candidate instanceof AST_VarDef)
                  return node;
              }
              CHANGED = abort = true;
              if (candidate instanceof AST_UnaryPostfix) {
                return make_node(AST_UnaryPrefix, candidate, candidate);
              }
              if (candidate instanceof AST_VarDef) {
                var def2 = candidate.name.definition();
                var value2 = candidate.value;
                if (def2.references.length - def2.replaced == 1 && !compressor2.exposed(def2)) {
                  def2.replaced++;
                  if (funarg && is_identifier_atom(value2)) {
                    return value2.transform(compressor2);
                  } else {
                    return maintain_this_binding(parent, node, value2);
                  }
                }
                return make_node(AST_Assign, candidate, {
                  operator: "=",
                  logical: false,
                  left: make_node(AST_SymbolRef, candidate.name, candidate.name),
                  right: value2
                });
              }
              clear_flag(candidate, WRITE_ONLY);
              return candidate;
            }
            var sym;
            if (node instanceof AST_Call || node instanceof AST_Exit && (side_effects || lhs instanceof AST_PropAccess || may_modify(lhs)) || node instanceof AST_PropAccess && (side_effects || node.expression.may_throw_on_access(compressor2)) || node instanceof AST_SymbolRef && (lvalues.has(node.name) && lvalues.get(node.name).modified || side_effects && may_modify(node)) || node instanceof AST_VarDef && node.value && (lvalues.has(node.name.name) || side_effects && may_modify(node.name)) || (sym = is_lhs(node.left, node)) && (sym instanceof AST_PropAccess || lvalues.has(sym.name)) || may_throw && (in_try ? node.has_side_effects(compressor2) : side_effects_external(node))) {
              stop_after = node;
              if (node instanceof AST_Scope)
                abort = true;
            }
            return handle_custom_scan_order(node);
          }, function(node) {
            if (abort)
              return;
            if (stop_after === node)
              abort = true;
            if (stop_if_hit === node)
              stop_if_hit = null;
          });
          var multi_replacer = new TreeTransformer(function(node) {
            if (abort)
              return node;
            if (!hit) {
              if (node !== hit_stack[hit_index])
                return node;
              hit_index++;
              if (hit_index < hit_stack.length)
                return;
              hit = true;
              return node;
            }
            if (node instanceof AST_SymbolRef && node.name == def.name) {
              if (!--replaced)
                abort = true;
              if (is_lhs(node, multi_replacer.parent()))
                return node;
              def.replaced++;
              value_def.replaced--;
              return candidate.value;
            }
            if (node instanceof AST_Default || node instanceof AST_Scope)
              return node;
          });
          while (--stat_index >= 0) {
            if (stat_index == 0 && compressor2.option("unused"))
              extract_args();
            var hit_stack = [];
            extract_candidates(statements2[stat_index]);
            while (candidates.length > 0) {
              hit_stack = candidates.pop();
              var hit_index = 0;
              var candidate = hit_stack[hit_stack.length - 1];
              var value_def = null;
              var stop_after = null;
              var stop_if_hit = null;
              var lhs = get_lhs(candidate);
              if (!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor2))
                continue;
              var lvalues = get_lvalues(candidate);
              var lhs_local = is_lhs_local(lhs);
              if (lhs instanceof AST_SymbolRef) {
                lvalues.set(lhs.name, { def: lhs.definition(), modified: false });
              }
              var side_effects = value_has_side_effects(candidate);
              var replace_all = replace_all_symbols();
              var may_throw = candidate.may_throw(compressor2);
              var funarg = candidate.name instanceof AST_SymbolFunarg;
              var hit = funarg;
              var abort = false, replaced = 0, can_replace = !args || !hit;
              if (!can_replace) {
                for (let j = compressor2.self().argnames.lastIndexOf(candidate.name) + 1; !abort && j < args.length; j++) {
                  args[j].transform(scanner);
                }
                can_replace = true;
              }
              for (var i = stat_index; !abort && i < statements2.length; i++) {
                statements2[i].transform(scanner);
              }
              if (value_def) {
                var def = candidate.name.definition();
                if (abort && def.references.length - def.replaced > replaced)
                  replaced = false;
                else {
                  abort = false;
                  hit_index = 0;
                  hit = funarg;
                  for (var i = stat_index; !abort && i < statements2.length; i++) {
                    statements2[i].transform(multi_replacer);
                  }
                  value_def.single_use = false;
                }
              }
              if (replaced && !remove_candidate(candidate))
                statements2.splice(stat_index, 1);
            }
          }
          function handle_custom_scan_order(node) {
            if (node instanceof AST_Scope)
              return node;
            if (node instanceof AST_Switch) {
              node.expression = node.expression.transform(scanner);
              for (var i2 = 0, len = node.body.length; !abort && i2 < len; i2++) {
                var branch = node.body[i2];
                if (branch instanceof AST_Case) {
                  if (!hit) {
                    if (branch !== hit_stack[hit_index])
                      continue;
                    hit_index++;
                  }
                  branch.expression = branch.expression.transform(scanner);
                  if (!replace_all)
                    break;
                }
              }
              abort = true;
              return node;
            }
          }
          function redefined_within_scope(def2, scope) {
            if (def2.global)
              return false;
            let cur_scope = def2.scope;
            while (cur_scope && cur_scope !== scope) {
              if (cur_scope.variables.has(def2.name)) {
                return true;
              }
              cur_scope = cur_scope.parent_scope;
            }
            return false;
          }
          function has_overlapping_symbol(fn, arg, fn_strict) {
            var found = false, scan_this = !(fn instanceof AST_Arrow);
            arg.walk(new TreeWalker(function(node, descend) {
              if (found)
                return true;
              if (node instanceof AST_SymbolRef && (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {
                var s = node.definition().scope;
                if (s !== defun_scope)
                  while (s = s.parent_scope) {
                    if (s === defun_scope)
                      return true;
                  }
                return found = true;
              }
              if ((fn_strict || scan_this) && node instanceof AST_This) {
                return found = true;
              }
              if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
                var prev = scan_this;
                scan_this = false;
                descend();
                scan_this = prev;
                return true;
              }
            }));
            return found;
          }
          function arg_is_injectable(arg) {
            if (arg instanceof AST_Expansion)
              return false;
            const contains_await = walk(arg, (node) => {
              if (node instanceof AST_Await)
                return walk_abort;
            });
            if (contains_await)
              return false;
            return true;
          }
          function extract_args() {
            var iife, fn = compressor2.self();
            if (is_func_expr(fn) && !fn.name && !fn.uses_arguments && !fn.pinned() && (iife = compressor2.parent()) instanceof AST_Call && iife.expression === fn && iife.args.every(arg_is_injectable)) {
              var fn_strict = compressor2.has_directive("use strict");
              if (fn_strict && !member(fn_strict, fn.body))
                fn_strict = false;
              var len = fn.argnames.length;
              args = iife.args.slice(len);
              var names = /* @__PURE__ */ new Set();
              for (var i2 = len; --i2 >= 0; ) {
                var sym = fn.argnames[i2];
                var arg = iife.args[i2];
                const def2 = sym.definition && sym.definition();
                const is_reassigned = def2 && def2.orig.length > 1;
                if (is_reassigned)
                  continue;
                args.unshift(make_node(AST_VarDef, sym, {
                  name: sym,
                  value: arg
                }));
                if (names.has(sym.name))
                  continue;
                names.add(sym.name);
                if (sym instanceof AST_Expansion) {
                  var elements = iife.args.slice(i2);
                  if (elements.every((arg2) => !has_overlapping_symbol(fn, arg2, fn_strict))) {
                    candidates.unshift([make_node(AST_VarDef, sym, {
                      name: sym.expression,
                      value: make_node(AST_Array, iife, {
                        elements
                      })
                    })]);
                  }
                } else {
                  if (!arg) {
                    arg = make_node(AST_Undefined, sym).transform(compressor2);
                  } else if (arg instanceof AST_Lambda && arg.pinned() || has_overlapping_symbol(fn, arg, fn_strict)) {
                    arg = null;
                  }
                  if (arg)
                    candidates.unshift([make_node(AST_VarDef, sym, {
                      name: sym,
                      value: arg
                    })]);
                }
              }
            }
          }
          function extract_candidates(expr) {
            hit_stack.push(expr);
            if (expr instanceof AST_Assign) {
              if (!expr.left.has_side_effects(compressor2) && !(expr.right instanceof AST_Chain)) {
                candidates.push(hit_stack.slice());
              }
              extract_candidates(expr.right);
            } else if (expr instanceof AST_Binary) {
              extract_candidates(expr.left);
              extract_candidates(expr.right);
            } else if (expr instanceof AST_Call && !has_annotation(expr, _NOINLINE)) {
              extract_candidates(expr.expression);
              expr.args.forEach(extract_candidates);
            } else if (expr instanceof AST_Case) {
              extract_candidates(expr.expression);
            } else if (expr instanceof AST_Conditional) {
              extract_candidates(expr.condition);
              extract_candidates(expr.consequent);
              extract_candidates(expr.alternative);
            } else if (expr instanceof AST_Definitions) {
              var len = expr.definitions.length;
              var i2 = len - 200;
              if (i2 < 0)
                i2 = 0;
              for (; i2 < len; i2++) {
                extract_candidates(expr.definitions[i2]);
              }
            } else if (expr instanceof AST_DWLoop) {
              extract_candidates(expr.condition);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
            } else if (expr instanceof AST_Exit) {
              if (expr.value)
                extract_candidates(expr.value);
            } else if (expr instanceof AST_For) {
              if (expr.init)
                extract_candidates(expr.init);
              if (expr.condition)
                extract_candidates(expr.condition);
              if (expr.step)
                extract_candidates(expr.step);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
            } else if (expr instanceof AST_ForIn) {
              extract_candidates(expr.object);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
            } else if (expr instanceof AST_If) {
              extract_candidates(expr.condition);
              if (!(expr.body instanceof AST_Block)) {
                extract_candidates(expr.body);
              }
              if (expr.alternative && !(expr.alternative instanceof AST_Block)) {
                extract_candidates(expr.alternative);
              }
            } else if (expr instanceof AST_Sequence) {
              expr.expressions.forEach(extract_candidates);
            } else if (expr instanceof AST_SimpleStatement) {
              extract_candidates(expr.body);
            } else if (expr instanceof AST_Switch) {
              extract_candidates(expr.expression);
              expr.body.forEach(extract_candidates);
            } else if (expr instanceof AST_Unary) {
              if (expr.operator == "++" || expr.operator == "--") {
                candidates.push(hit_stack.slice());
              }
            } else if (expr instanceof AST_VarDef) {
              if (expr.value && !(expr.value instanceof AST_Chain)) {
                candidates.push(hit_stack.slice());
                extract_candidates(expr.value);
              }
            }
            hit_stack.pop();
          }
          function find_stop(node, level, write_only) {
            var parent = scanner.parent(level);
            if (parent instanceof AST_Assign) {
              if (write_only && !parent.logical && !(parent.left instanceof AST_PropAccess || lvalues.has(parent.left.name))) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_Binary) {
              if (write_only && (!lazy_op.has(parent.operator) || parent.left === node)) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_Call)
              return node;
            if (parent instanceof AST_Case)
              return node;
            if (parent instanceof AST_Conditional) {
              if (write_only && parent.condition === node) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_Definitions) {
              return find_stop(parent, level + 1, true);
            }
            if (parent instanceof AST_Exit) {
              return write_only ? find_stop(parent, level + 1, write_only) : node;
            }
            if (parent instanceof AST_If) {
              if (write_only && parent.condition === node) {
                return find_stop(parent, level + 1, write_only);
              }
              return node;
            }
            if (parent instanceof AST_IterationStatement)
              return node;
            if (parent instanceof AST_Sequence) {
              return find_stop(parent, level + 1, parent.tail_node() !== node);
            }
            if (parent instanceof AST_SimpleStatement) {
              return find_stop(parent, level + 1, true);
            }
            if (parent instanceof AST_Switch)
              return node;
            if (parent instanceof AST_VarDef)
              return node;
            return null;
          }
          function mangleable_var(var_def) {
            var value2 = var_def.value;
            if (!(value2 instanceof AST_SymbolRef))
              return;
            if (value2.name == "arguments")
              return;
            var def2 = value2.definition();
            if (def2.undeclared)
              return;
            return value_def = def2;
          }
          function get_lhs(expr) {
            if (expr instanceof AST_Assign && expr.logical) {
              return false;
            } else if (expr instanceof AST_VarDef && expr.name instanceof AST_SymbolDeclaration) {
              var def2 = expr.name.definition();
              if (!member(expr.name, def2.orig))
                return;
              var referenced = def2.references.length - def2.replaced;
              if (!referenced)
                return;
              var declared = def2.orig.length - def2.eliminated;
              if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg) || (referenced > 1 ? mangleable_var(expr) : !compressor2.exposed(def2))) {
                return make_node(AST_SymbolRef, expr.name, expr.name);
              }
            } else {
              const lhs2 = expr instanceof AST_Assign ? expr.left : expr.expression;
              return !is_ref_of(lhs2, AST_SymbolConst) && !is_ref_of(lhs2, AST_SymbolLet) && lhs2;
            }
          }
          function get_rvalue(expr) {
            if (expr instanceof AST_Assign) {
              return expr.right;
            } else {
              return expr.value;
            }
          }
          function get_lvalues(expr) {
            var lvalues2 = /* @__PURE__ */ new Map();
            if (expr instanceof AST_Unary)
              return lvalues2;
            var tw = new TreeWalker(function(node) {
              var sym = node;
              while (sym instanceof AST_PropAccess)
                sym = sym.expression;
              if (sym instanceof AST_SymbolRef) {
                const prev = lvalues2.get(sym.name);
                if (!prev || !prev.modified) {
                  lvalues2.set(sym.name, {
                    def: sym.definition(),
                    modified: is_modified(compressor2, tw, node, node, 0)
                  });
                }
              }
            });
            get_rvalue(expr).walk(tw);
            return lvalues2;
          }
          function remove_candidate(expr) {
            if (expr.name instanceof AST_SymbolFunarg) {
              var iife = compressor2.parent(), argnames = compressor2.self().argnames;
              var index = argnames.indexOf(expr.name);
              if (index < 0) {
                iife.args.length = Math.min(iife.args.length, argnames.length - 1);
              } else {
                var args2 = iife.args;
                if (args2[index])
                  args2[index] = make_node(AST_Number, args2[index], {
                    value: 0
                  });
              }
              return true;
            }
            var found = false;
            return statements2[stat_index].transform(new TreeTransformer(function(node, descend, in_list) {
              if (found)
                return node;
              if (node === expr || node.body === expr) {
                found = true;
                if (node instanceof AST_VarDef) {
                  node.value = node.name instanceof AST_SymbolConst ? make_node(AST_Undefined, node.value) : null;
                  return node;
                }
                return in_list ? MAP.skip : null;
              }
            }, function(node) {
              if (node instanceof AST_Sequence)
                switch (node.expressions.length) {
                  case 0:
                    return null;
                  case 1:
                    return node.expressions[0];
                }
            }));
          }
          function is_lhs_local(lhs2) {
            while (lhs2 instanceof AST_PropAccess)
              lhs2 = lhs2.expression;
            return lhs2 instanceof AST_SymbolRef && lhs2.definition().scope.get_defun_scope() === defun_scope && !(in_loop && (lvalues.has(lhs2.name) || candidate instanceof AST_Unary || candidate instanceof AST_Assign && !candidate.logical && candidate.operator != "="));
          }
          function value_has_side_effects(expr) {
            if (expr instanceof AST_Unary)
              return unary_side_effects.has(expr.operator);
            return get_rvalue(expr).has_side_effects(compressor2);
          }
          function replace_all_symbols() {
            if (side_effects)
              return false;
            if (value_def)
              return true;
            if (lhs instanceof AST_SymbolRef) {
              var def2 = lhs.definition();
              if (def2.references.length - def2.replaced == (candidate instanceof AST_VarDef ? 1 : 2)) {
                return true;
              }
            }
            return false;
          }
          function may_modify(sym) {
            if (!sym.definition)
              return true;
            var def2 = sym.definition();
            if (def2.orig.length == 1 && def2.orig[0] instanceof AST_SymbolDefun)
              return false;
            if (def2.scope.get_defun_scope() !== defun_scope)
              return true;
            return def2.references.some((ref) => ref.scope.get_defun_scope() !== defun_scope);
          }
          function side_effects_external(node, lhs2) {
            if (node instanceof AST_Assign)
              return side_effects_external(node.left, true);
            if (node instanceof AST_Unary)
              return side_effects_external(node.expression, true);
            if (node instanceof AST_VarDef)
              return node.value && side_effects_external(node.value);
            if (lhs2) {
              if (node instanceof AST_Dot)
                return side_effects_external(node.expression, true);
              if (node instanceof AST_Sub)
                return side_effects_external(node.expression, true);
              if (node instanceof AST_SymbolRef)
                return node.definition().scope.get_defun_scope() !== defun_scope;
            }
            return false;
          }
          function shadows(my_scope, lvalues2) {
            for (const { def: def2 } of lvalues2.values()) {
              const looked_up = my_scope.find_variable(def2.name);
              if (looked_up) {
                if (looked_up === def2)
                  continue;
                return true;
              }
            }
            return false;
          }
        }
        function eliminate_spurious_blocks(statements2) {
          var seen_dirs = [];
          for (var i = 0; i < statements2.length; ) {
            var stat = statements2[i];
            if (stat instanceof AST_BlockStatement && stat.body.every(can_be_evicted_from_block)) {
              CHANGED = true;
              eliminate_spurious_blocks(stat.body);
              statements2.splice(i, 1, ...stat.body);
              i += stat.body.length;
            } else if (stat instanceof AST_EmptyStatement) {
              CHANGED = true;
              statements2.splice(i, 1);
            } else if (stat instanceof AST_Directive) {
              if (seen_dirs.indexOf(stat.value) < 0) {
                i++;
                seen_dirs.push(stat.value);
              } else {
                CHANGED = true;
                statements2.splice(i, 1);
              }
            } else
              i++;
          }
        }
        function handle_if_return(statements2, compressor2) {
          var self2 = compressor2.self();
          var multiple_if_returns = has_multiple_if_returns(statements2);
          var in_lambda = self2 instanceof AST_Lambda;
          const iteration_start = Math.min(statements2.length, 500);
          for (var i = iteration_start; --i >= 0; ) {
            var stat = statements2[i];
            var j = next_index(i);
            var next = statements2[j];
            if (in_lambda && !next && stat instanceof AST_Return) {
              if (!stat.value) {
                CHANGED = true;
                statements2.splice(i, 1);
                continue;
              }
              if (stat.value instanceof AST_UnaryPrefix && stat.value.operator == "void") {
                CHANGED = true;
                statements2[i] = make_node(AST_SimpleStatement, stat, {
                  body: stat.value.expression
                });
                continue;
              }
            }
            if (stat instanceof AST_If) {
              let ab, new_else;
              ab = aborts(stat.body);
              if (can_merge_flow(ab) && (new_else = as_statement_array_with_return(stat.body, ab))) {
                if (ab.label) {
                  remove(ab.label.thedef.references, ab);
                }
                CHANGED = true;
                stat = stat.clone();
                stat.condition = stat.condition.negate(compressor2);
                stat.body = make_node(AST_BlockStatement, stat, {
                  body: as_statement_array(stat.alternative).concat(extract_defuns())
                });
                stat.alternative = make_node(AST_BlockStatement, stat, {
                  body: new_else
                });
                statements2[i] = stat.transform(compressor2);
                continue;
              }
              ab = aborts(stat.alternative);
              if (can_merge_flow(ab) && (new_else = as_statement_array_with_return(stat.alternative, ab))) {
                if (ab.label) {
                  remove(ab.label.thedef.references, ab);
                }
                CHANGED = true;
                stat = stat.clone();
                stat.body = make_node(AST_BlockStatement, stat.body, {
                  body: as_statement_array(stat.body).concat(extract_defuns())
                });
                stat.alternative = make_node(AST_BlockStatement, stat.alternative, {
                  body: new_else
                });
                statements2[i] = stat.transform(compressor2);
                continue;
              }
            }
            if (stat instanceof AST_If && stat.body instanceof AST_Return) {
              var value2 = stat.body.value;
              if (!value2 && !stat.alternative && (in_lambda && !next || next instanceof AST_Return && !next.value)) {
                CHANGED = true;
                statements2[i] = make_node(AST_SimpleStatement, stat.condition, {
                  body: stat.condition
                });
                continue;
              }
              if (value2 && !stat.alternative && next instanceof AST_Return && next.value) {
                CHANGED = true;
                stat = stat.clone();
                stat.alternative = next;
                statements2[i] = stat.transform(compressor2);
                statements2.splice(j, 1);
                continue;
              }
              if (value2 && !stat.alternative && (!next && in_lambda && multiple_if_returns || next instanceof AST_Return)) {
                CHANGED = true;
                stat = stat.clone();
                stat.alternative = next || make_node(AST_Return, stat, {
                  value: null
                });
                statements2[i] = stat.transform(compressor2);
                if (next)
                  statements2.splice(j, 1);
                continue;
              }
              var prev = statements2[prev_index(i)];
              if (compressor2.option("sequences") && in_lambda && !stat.alternative && prev instanceof AST_If && prev.body instanceof AST_Return && next_index(j) == statements2.length && next instanceof AST_SimpleStatement) {
                CHANGED = true;
                stat = stat.clone();
                stat.alternative = make_node(AST_BlockStatement, next, {
                  body: [
                    next,
                    make_node(AST_Return, next, {
                      value: null
                    })
                  ]
                });
                statements2[i] = stat.transform(compressor2);
                statements2.splice(j, 1);
                continue;
              }
            }
          }
          function has_multiple_if_returns(statements3) {
            var n2 = 0;
            for (var i2 = statements3.length; --i2 >= 0; ) {
              var stat2 = statements3[i2];
              if (stat2 instanceof AST_If && stat2.body instanceof AST_Return) {
                if (++n2 > 1)
                  return true;
              }
            }
            return false;
          }
          function is_return_void(value3) {
            return !value3 || value3 instanceof AST_UnaryPrefix && value3.operator == "void";
          }
          function can_merge_flow(ab) {
            if (!ab)
              return false;
            for (var j2 = i + 1, len = statements2.length; j2 < len; j2++) {
              var stat2 = statements2[j2];
              if (stat2 instanceof AST_Const || stat2 instanceof AST_Let)
                return false;
            }
            var lct = ab instanceof AST_LoopControl ? compressor2.loopcontrol_target(ab) : null;
            return ab instanceof AST_Return && in_lambda && is_return_void(ab.value) || ab instanceof AST_Continue && self2 === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self2 === lct;
          }
          function extract_defuns() {
            var tail = statements2.slice(i + 1);
            statements2.length = i + 1;
            return tail.filter(function(stat2) {
              if (stat2 instanceof AST_Defun) {
                statements2.push(stat2);
                return false;
              }
              return true;
            });
          }
          function as_statement_array_with_return(node, ab) {
            var body = as_statement_array(node);
            if (ab !== body[body.length - 1]) {
              return void 0;
            }
            body = body.slice(0, -1);
            if (!body.every((stat2) => can_be_evicted_from_block(stat2))) {
              return void 0;
            }
            if (ab.value) {
              body.push(make_node(AST_SimpleStatement, ab.value, {
                body: ab.value.expression
              }));
            }
            return body;
          }
          function next_index(i2) {
            for (var j2 = i2 + 1, len = statements2.length; j2 < len; j2++) {
              var stat2 = statements2[j2];
              if (!(stat2 instanceof AST_Var && declarations_only(stat2))) {
                break;
              }
            }
            return j2;
          }
          function prev_index(i2) {
            for (var j2 = i2; --j2 >= 0; ) {
              var stat2 = statements2[j2];
              if (!(stat2 instanceof AST_Var && declarations_only(stat2))) {
                break;
              }
            }
            return j2;
          }
        }
        function eliminate_dead_code(statements2, compressor2) {
          var has_quit;
          var self2 = compressor2.self();
          for (var i = 0, n2 = 0, len = statements2.length; i < len; i++) {
            var stat = statements2[i];
            if (stat instanceof AST_LoopControl) {
              var lct = compressor2.loopcontrol_target(stat);
              if (stat instanceof AST_Break && !(lct instanceof AST_IterationStatement) && loop_body(lct) === self2 || stat instanceof AST_Continue && loop_body(lct) === self2) {
                if (stat.label) {
                  remove(stat.label.thedef.references, stat);
                }
              } else {
                statements2[n2++] = stat;
              }
            } else {
              statements2[n2++] = stat;
            }
            if (aborts(stat)) {
              has_quit = statements2.slice(i + 1);
              break;
            }
          }
          statements2.length = n2;
          CHANGED = n2 != len;
          if (has_quit)
            has_quit.forEach(function(stat2) {
              trim_unreachable_code(compressor2, stat2, statements2);
            });
        }
        function declarations_only(node) {
          return node.definitions.every((var_def) => !var_def.value);
        }
        function sequencesize(statements2, compressor2) {
          if (statements2.length < 2)
            return;
          var seq = [], n2 = 0;
          function push_seq() {
            if (!seq.length)
              return;
            var body2 = make_sequence(seq[0], seq);
            statements2[n2++] = make_node(AST_SimpleStatement, body2, { body: body2 });
            seq = [];
          }
          for (var i = 0, len = statements2.length; i < len; i++) {
            var stat = statements2[i];
            if (stat instanceof AST_SimpleStatement) {
              if (seq.length >= compressor2.sequences_limit)
                push_seq();
              var body = stat.body;
              if (seq.length > 0)
                body = body.drop_side_effect_free(compressor2);
              if (body)
                merge_sequence(seq, body);
            } else if (stat instanceof AST_Definitions && declarations_only(stat) || stat instanceof AST_Defun) {
              statements2[n2++] = stat;
            } else {
              push_seq();
              statements2[n2++] = stat;
            }
          }
          push_seq();
          statements2.length = n2;
          if (n2 != len)
            CHANGED = true;
        }
        function to_simple_statement(block, decls) {
          if (!(block instanceof AST_BlockStatement))
            return block;
          var stat = null;
          for (var i = 0, len = block.body.length; i < len; i++) {
            var line = block.body[i];
            if (line instanceof AST_Var && declarations_only(line)) {
              decls.push(line);
            } else if (stat || line instanceof AST_Const || line instanceof AST_Let) {
              return false;
            } else {
              stat = line;
            }
          }
          return stat;
        }
        function sequencesize_2(statements2, compressor2) {
          function cons_seq(right) {
            n2--;
            CHANGED = true;
            var left = prev.body;
            return make_sequence(left, [left, right]).transform(compressor2);
          }
          var n2 = 0, prev;
          for (var i = 0; i < statements2.length; i++) {
            var stat = statements2[i];
            if (prev) {
              if (stat instanceof AST_Exit) {
                stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor2));
              } else if (stat instanceof AST_For) {
                if (!(stat.init instanceof AST_Definitions)) {
                  const abort = walk(prev.body, (node) => {
                    if (node instanceof AST_Scope)
                      return true;
                    if (node instanceof AST_Binary && node.operator === "in") {
                      return walk_abort;
                    }
                  });
                  if (!abort) {
                    if (stat.init)
                      stat.init = cons_seq(stat.init);
                    else {
                      stat.init = prev.body;
                      n2--;
                      CHANGED = true;
                    }
                  }
                }
              } else if (stat instanceof AST_ForIn) {
                if (!(stat.init instanceof AST_Const) && !(stat.init instanceof AST_Let)) {
                  stat.object = cons_seq(stat.object);
                }
              } else if (stat instanceof AST_If) {
                stat.condition = cons_seq(stat.condition);
              } else if (stat instanceof AST_Switch) {
                stat.expression = cons_seq(stat.expression);
              } else if (stat instanceof AST_With) {
                stat.expression = cons_seq(stat.expression);
              }
            }
            if (compressor2.option("conditionals") && stat instanceof AST_If) {
              var decls = [];
              var body = to_simple_statement(stat.body, decls);
              var alt = to_simple_statement(stat.alternative, decls);
              if (body !== false && alt !== false && decls.length > 0) {
                var len = decls.length;
                decls.push(make_node(AST_If, stat, {
                  condition: stat.condition,
                  body: body || make_node(AST_EmptyStatement, stat.body),
                  alternative: alt
                }));
                decls.unshift(n2, 1);
                [].splice.apply(statements2, decls);
                i += len;
                n2 += len + 1;
                prev = null;
                CHANGED = true;
                continue;
              }
            }
            statements2[n2++] = stat;
            prev = stat instanceof AST_SimpleStatement ? stat : null;
          }
          statements2.length = n2;
        }
        function join_object_assignments(defn, body) {
          if (!(defn instanceof AST_Definitions))
            return;
          var def = defn.definitions[defn.definitions.length - 1];
          if (!(def.value instanceof AST_Object))
            return;
          var exprs;
          if (body instanceof AST_Assign && !body.logical) {
            exprs = [body];
          } else if (body instanceof AST_Sequence) {
            exprs = body.expressions.slice();
          }
          if (!exprs)
            return;
          var trimmed = false;
          do {
            var node = exprs[0];
            if (!(node instanceof AST_Assign))
              break;
            if (node.operator != "=")
              break;
            if (!(node.left instanceof AST_PropAccess))
              break;
            var sym = node.left.expression;
            if (!(sym instanceof AST_SymbolRef))
              break;
            if (def.name.name != sym.name)
              break;
            if (!node.right.is_constant_expression(nearest_scope))
              break;
            var prop = node.left.property;
            if (prop instanceof AST_Node) {
              prop = prop.evaluate(compressor);
            }
            if (prop instanceof AST_Node)
              break;
            prop = "" + prop;
            var diff = compressor.option("ecma") < 2015 && compressor.has_directive("use strict") ? function(node2) {
              return node2.key != prop && (node2.key && node2.key.name != prop);
            } : function(node2) {
              return node2.key && node2.key.name != prop;
            };
            if (!def.value.properties.every(diff))
              break;
            var p = def.value.properties.filter(function(p2) {
              return p2.key === prop;
            })[0];
            if (!p) {
              def.value.properties.push(make_node(AST_ObjectKeyVal, node, {
                key: prop,
                value: node.right
              }));
            } else {
              p.value = new AST_Sequence({
                start: p.start,
                expressions: [p.value.clone(), node.right.clone()],
                end: p.end
              });
            }
            exprs.shift();
            trimmed = true;
          } while (exprs.length);
          return trimmed && exprs;
        }
        function join_consecutive_vars(statements2) {
          var defs;
          for (var i = 0, j = -1, len = statements2.length; i < len; i++) {
            var stat = statements2[i];
            var prev = statements2[j];
            if (stat instanceof AST_Definitions) {
              if (prev && prev.TYPE == stat.TYPE) {
                prev.definitions = prev.definitions.concat(stat.definitions);
                CHANGED = true;
              } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {
                defs.definitions = defs.definitions.concat(stat.definitions);
                CHANGED = true;
              } else {
                statements2[++j] = stat;
                defs = stat;
              }
            } else if (stat instanceof AST_Exit) {
              stat.value = extract_object_assignments(stat.value);
            } else if (stat instanceof AST_For) {
              var exprs = join_object_assignments(prev, stat.init);
              if (exprs) {
                CHANGED = true;
                stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;
                statements2[++j] = stat;
              } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {
                if (stat.init) {
                  prev.definitions = prev.definitions.concat(stat.init.definitions);
                }
                stat.init = prev;
                statements2[j] = stat;
                CHANGED = true;
              } else if (defs instanceof AST_Var && stat.init instanceof AST_Var && declarations_only(stat.init)) {
                defs.definitions = defs.definitions.concat(stat.init.definitions);
                stat.init = null;
                statements2[++j] = stat;
                CHANGED = true;
              } else {
                statements2[++j] = stat;
              }
            } else if (stat instanceof AST_ForIn) {
              stat.object = extract_object_assignments(stat.object);
            } else if (stat instanceof AST_If) {
              stat.condition = extract_object_assignments(stat.condition);
            } else if (stat instanceof AST_SimpleStatement) {
              var exprs = join_object_assignments(prev, stat.body);
              if (exprs) {
                CHANGED = true;
                if (!exprs.length)
                  continue;
                stat.body = make_sequence(stat.body, exprs);
              }
              statements2[++j] = stat;
            } else if (stat instanceof AST_Switch) {
              stat.expression = extract_object_assignments(stat.expression);
            } else if (stat instanceof AST_With) {
              stat.expression = extract_object_assignments(stat.expression);
            } else {
              statements2[++j] = stat;
            }
          }
          statements2.length = j + 1;
          function extract_object_assignments(value2) {
            statements2[++j] = stat;
            var exprs2 = join_object_assignments(prev, value2);
            if (exprs2) {
              CHANGED = true;
              if (exprs2.length) {
                return make_sequence(value2, exprs2);
              } else if (value2 instanceof AST_Sequence) {
                return value2.tail_node().left;
              } else {
                return value2.left;
              }
            }
            return value2;
          }
        }
      }
      function within_array_or_object_literal(compressor) {
        var node, level = 0;
        while (node = compressor.parent(level++)) {
          if (node instanceof AST_Statement)
            return false;
          if (node instanceof AST_Array || node instanceof AST_ObjectKeyVal || node instanceof AST_Object) {
            return true;
          }
        }
        return false;
      }
      function scope_encloses_variables_in_this_scope(scope, pulled_scope) {
        for (const enclosed of pulled_scope.enclosed) {
          if (pulled_scope.variables.has(enclosed.name)) {
            continue;
          }
          const looked_up = scope.find_variable(enclosed.name);
          if (looked_up) {
            if (looked_up === enclosed)
              continue;
            return true;
          }
        }
        return false;
      }
      function is_const_symbol_short_than_init_value(def, fixed_value) {
        if (def.orig.length === 1 && fixed_value) {
          const init_value_length = fixed_value.size();
          const identifer_length = def.name.length;
          return init_value_length > identifer_length;
        }
        return true;
      }
      function inline_into_symbolref(self2, compressor) {
        if (compressor.in_computed_key())
          return self2;
        const parent = compressor.parent();
        const def = self2.definition();
        const nearest_scope = compressor.find_scope();
        let fixed = self2.fixed_value();
        if (compressor.top_retain && def.global && compressor.top_retain(def) && is_const_symbol_short_than_init_value(def, fixed)) {
          def.fixed = false;
          def.single_use = false;
          return self2;
        }
        if (dont_inline_lambda_in_loop(compressor, fixed))
          return self2;
        let single_use = def.single_use && !(parent instanceof AST_Call && parent.is_callee_pure(compressor) || has_annotation(parent, _NOINLINE)) && !(parent instanceof AST_Export && fixed instanceof AST_Lambda && fixed.name);
        if (single_use && fixed instanceof AST_Node) {
          single_use = !fixed.has_side_effects(compressor) && !fixed.may_throw(compressor);
        }
        if (fixed instanceof AST_Class && def.scope !== self2.scope) {
          return self2;
        }
        if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {
          if (retain_top_func(fixed, compressor)) {
            single_use = false;
          } else if (def.scope !== self2.scope && (def.escaped == 1 || has_flag(fixed, INLINED) || within_array_or_object_literal(compressor) || !compressor.option("reduce_funcs"))) {
            single_use = false;
          } else if (is_recursive_ref(compressor, def)) {
            single_use = false;
          } else if (def.scope !== self2.scope || def.orig[0] instanceof AST_SymbolFunarg) {
            single_use = fixed.is_constant_expression(self2.scope);
            if (single_use == "f") {
              var scope = self2.scope;
              do {
                if (scope instanceof AST_Defun || is_func_expr(scope)) {
                  set_flag(scope, INLINED);
                }
              } while (scope = scope.parent_scope);
            }
          }
        }
        if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {
          single_use = def.scope === self2.scope && !scope_encloses_variables_in_this_scope(nearest_scope, fixed) || parent instanceof AST_Call && parent.expression === self2 && !scope_encloses_variables_in_this_scope(nearest_scope, fixed) && !(fixed.name && fixed.name.definition().recursive_refs > 0);
        }
        if (single_use && fixed) {
          if (fixed instanceof AST_DefClass) {
            set_flag(fixed, SQUEEZED);
            fixed = make_node(AST_ClassExpression, fixed, fixed);
          }
          if (fixed instanceof AST_Defun) {
            set_flag(fixed, SQUEEZED);
            fixed = make_node(AST_Function, fixed, fixed);
          }
          if (def.recursive_refs > 0 && fixed.name instanceof AST_SymbolDefun) {
            const defun_def = fixed.name.definition();
            let lambda_def = fixed.variables.get(fixed.name.name);
            let name = lambda_def && lambda_def.orig[0];
            if (!(name instanceof AST_SymbolLambda)) {
              name = make_node(AST_SymbolLambda, fixed.name, fixed.name);
              name.scope = fixed;
              fixed.name = name;
              lambda_def = fixed.def_function(name);
            }
            walk(fixed, (node) => {
              if (node instanceof AST_SymbolRef && node.definition() === defun_def) {
                node.thedef = lambda_def;
                lambda_def.references.push(node);
              }
            });
          }
          if ((fixed instanceof AST_Lambda || fixed instanceof AST_Class) && fixed.parent_scope !== nearest_scope) {
            fixed = fixed.clone(true, compressor.get_toplevel());
            nearest_scope.add_child_scope(fixed);
          }
          return fixed.optimize(compressor);
        }
        if (fixed) {
          let replace;
          if (fixed instanceof AST_This) {
            if (!(def.orig[0] instanceof AST_SymbolFunarg) && def.references.every((ref) => def.scope === ref.scope)) {
              replace = fixed;
            }
          } else {
            var ev = fixed.evaluate(compressor);
            if (ev !== fixed && (compressor.option("unsafe_regexp") || !(ev instanceof RegExp))) {
              replace = make_node_from_constant(ev, fixed);
            }
          }
          if (replace) {
            const name_length = self2.size(compressor);
            const replace_size = replace.size(compressor);
            let overhead = 0;
            if (compressor.option("unused") && !compressor.exposed(def)) {
              overhead = (name_length + 2 + fixed.size(compressor)) / (def.references.length - def.assignments);
            }
            if (replace_size <= name_length + overhead) {
              return replace;
            }
          }
        }
        return self2;
      }
      function inline_into_call(self2, compressor) {
        if (compressor.in_computed_key())
          return self2;
        var exp = self2.expression;
        var fn = exp;
        var simple_args = self2.args.every((arg) => !(arg instanceof AST_Expansion));
        if (compressor.option("reduce_vars") && fn instanceof AST_SymbolRef && !has_annotation(self2, _NOINLINE)) {
          const fixed = fn.fixed_value();
          if (retain_top_func(fixed, compressor) || !compressor.toplevel.funcs && exp.definition().global) {
            return self2;
          }
          fn = fixed;
        }
        if (dont_inline_lambda_in_loop(compressor, fn) && !has_annotation(self2, _INLINE))
          return self2;
        var is_func = fn instanceof AST_Lambda;
        var stat = is_func && fn.body[0];
        var is_regular_func = is_func && !fn.is_generator && !fn.async;
        var can_inline = is_regular_func && compressor.option("inline") && !self2.is_callee_pure(compressor);
        if (can_inline && stat instanceof AST_Return) {
          let returned = stat.value;
          if (!returned || returned.is_constant_expression()) {
            if (returned) {
              returned = returned.clone(true);
            } else {
              returned = make_node(AST_Undefined, self2);
            }
            const args2 = self2.args.concat(returned);
            return make_sequence(self2, args2).optimize(compressor);
          }
          if (fn.argnames.length === 1 && fn.argnames[0] instanceof AST_SymbolFunarg && self2.args.length < 2 && !(self2.args[0] instanceof AST_Expansion) && returned instanceof AST_SymbolRef && returned.name === fn.argnames[0].name) {
            const replacement = (self2.args[0] || make_node(AST_Undefined)).optimize(compressor);
            let parent;
            if (replacement instanceof AST_PropAccess && (parent = compressor.parent()) instanceof AST_Call && parent.expression === self2) {
              return make_sequence(self2, [
                make_node(AST_Number, self2, { value: 0 }),
                replacement
              ]);
            }
            return replacement;
          }
        }
        if (can_inline) {
          var scope, in_loop, level = -1;
          let def;
          let returned_value;
          let nearest_scope;
          if (simple_args && !fn.uses_arguments && !(compressor.parent() instanceof AST_Class) && !(fn.name && fn instanceof AST_Function) && (returned_value = can_flatten_body(stat)) && (exp === fn || has_annotation(self2, _INLINE) || compressor.option("unused") && (def = exp.definition()).references.length == 1 && !is_recursive_ref(compressor, def) && fn.is_constant_expression(exp.scope)) && !has_annotation(self2, _PURE | _NOINLINE) && !fn.contains_this() && can_inject_symbols() && (nearest_scope = compressor.find_scope()) && !scope_encloses_variables_in_this_scope(nearest_scope, fn) && !function in_default_assign() {
            let i = 0;
            let p;
            while (p = compressor.parent(i++)) {
              if (p instanceof AST_DefaultAssign)
                return true;
              if (p instanceof AST_Block)
                break;
            }
            return false;
          }() && !(scope instanceof AST_Class)) {
            set_flag(fn, SQUEEZED);
            nearest_scope.add_child_scope(fn);
            return make_sequence(self2, flatten_fn(returned_value)).optimize(compressor);
          }
        }
        if (can_inline && has_annotation(self2, _INLINE)) {
          set_flag(fn, SQUEEZED);
          fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);
          fn = fn.clone(true);
          fn.figure_out_scope({}, {
            parent_scope: compressor.find_scope(),
            toplevel: compressor.get_toplevel()
          });
          return make_node(AST_Call, self2, {
            expression: fn,
            args: self2.args
          }).optimize(compressor);
        }
        const can_drop_this_call = is_regular_func && compressor.option("side_effects") && fn.body.every(is_empty2);
        if (can_drop_this_call) {
          var args = self2.args.concat(make_node(AST_Undefined, self2));
          return make_sequence(self2, args).optimize(compressor);
        }
        if (compressor.option("negate_iife") && compressor.parent() instanceof AST_SimpleStatement && is_iife_call(self2)) {
          return self2.negate(compressor, true);
        }
        var ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
        function return_value(stat2) {
          if (!stat2)
            return make_node(AST_Undefined, self2);
          if (stat2 instanceof AST_Return) {
            if (!stat2.value)
              return make_node(AST_Undefined, self2);
            return stat2.value.clone(true);
          }
          if (stat2 instanceof AST_SimpleStatement) {
            return make_node(AST_UnaryPrefix, stat2, {
              operator: "void",
              expression: stat2.body.clone(true)
            });
          }
        }
        function can_flatten_body(stat2) {
          var body = fn.body;
          var len = body.length;
          if (compressor.option("inline") < 3) {
            return len == 1 && return_value(stat2);
          }
          stat2 = null;
          for (var i = 0; i < len; i++) {
            var line = body[i];
            if (line instanceof AST_Var) {
              if (stat2 && !line.definitions.every((var_def) => !var_def.value)) {
                return false;
              }
            } else if (stat2) {
              return false;
            } else if (!(line instanceof AST_EmptyStatement)) {
              stat2 = line;
            }
          }
          return return_value(stat2);
        }
        function can_inject_args(block_scoped, safe_to_inject) {
          for (var i = 0, len = fn.argnames.length; i < len; i++) {
            var arg = fn.argnames[i];
            if (arg instanceof AST_DefaultAssign) {
              if (has_flag(arg.left, UNUSED))
                continue;
              return false;
            }
            if (arg instanceof AST_Destructuring)
              return false;
            if (arg instanceof AST_Expansion) {
              if (has_flag(arg.expression, UNUSED))
                continue;
              return false;
            }
            if (has_flag(arg, UNUSED))
              continue;
            if (!safe_to_inject || block_scoped.has(arg.name) || identifier_atom.has(arg.name) || scope.conflicting_def(arg.name)) {
              return false;
            }
            if (in_loop)
              in_loop.push(arg.definition());
          }
          return true;
        }
        function can_inject_vars(block_scoped, safe_to_inject) {
          var len = fn.body.length;
          for (var i = 0; i < len; i++) {
            var stat2 = fn.body[i];
            if (!(stat2 instanceof AST_Var))
              continue;
            if (!safe_to_inject)
              return false;
            for (var j = stat2.definitions.length; --j >= 0; ) {
              var name = stat2.definitions[j].name;
              if (name instanceof AST_Destructuring || block_scoped.has(name.name) || identifier_atom.has(name.name) || scope.conflicting_def(name.name)) {
                return false;
              }
              if (in_loop)
                in_loop.push(name.definition());
            }
          }
          return true;
        }
        function can_inject_symbols() {
          var block_scoped = /* @__PURE__ */ new Set();
          do {
            scope = compressor.parent(++level);
            if (scope.is_block_scope() && scope.block_scope) {
              scope.block_scope.variables.forEach(function(variable) {
                block_scoped.add(variable.name);
              });
            }
            if (scope instanceof AST_Catch) {
              if (scope.argname) {
                block_scoped.add(scope.argname.name);
              }
            } else if (scope instanceof AST_IterationStatement) {
              in_loop = [];
            } else if (scope instanceof AST_SymbolRef) {
              if (scope.fixed_value() instanceof AST_Scope)
                return false;
            }
          } while (!(scope instanceof AST_Scope));
          var safe_to_inject = !(scope instanceof AST_Toplevel) || compressor.toplevel.vars;
          var inline = compressor.option("inline");
          if (!can_inject_vars(block_scoped, inline >= 3 && safe_to_inject))
            return false;
          if (!can_inject_args(block_scoped, inline >= 2 && safe_to_inject))
            return false;
          return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);
        }
        function append_var(decls, expressions, name, value2) {
          var def = name.definition();
          const already_appended = scope.variables.has(name.name);
          if (!already_appended) {
            scope.variables.set(name.name, def);
            scope.enclosed.push(def);
            decls.push(make_node(AST_VarDef, name, {
              name,
              value: null
            }));
          }
          var sym = make_node(AST_SymbolRef, name, name);
          def.references.push(sym);
          if (value2)
            expressions.push(make_node(AST_Assign, self2, {
              operator: "=",
              logical: false,
              left: sym,
              right: value2.clone()
            }));
        }
        function flatten_args(decls, expressions) {
          var len = fn.argnames.length;
          for (var i = self2.args.length; --i >= len; ) {
            expressions.push(self2.args[i]);
          }
          for (i = len; --i >= 0; ) {
            var name = fn.argnames[i];
            var value2 = self2.args[i];
            if (has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {
              if (value2)
                expressions.push(value2);
            } else {
              var symbol = make_node(AST_SymbolVar, name, name);
              name.definition().orig.push(symbol);
              if (!value2 && in_loop)
                value2 = make_node(AST_Undefined, self2);
              append_var(decls, expressions, symbol, value2);
            }
          }
          decls.reverse();
          expressions.reverse();
        }
        function flatten_vars(decls, expressions) {
          var pos2 = expressions.length;
          for (var i = 0, lines = fn.body.length; i < lines; i++) {
            var stat2 = fn.body[i];
            if (!(stat2 instanceof AST_Var))
              continue;
            for (var j = 0, defs = stat2.definitions.length; j < defs; j++) {
              var var_def = stat2.definitions[j];
              var name = var_def.name;
              append_var(decls, expressions, name, var_def.value);
              if (in_loop && fn.argnames.every((argname) => argname.name != name.name)) {
                var def = fn.variables.get(name.name);
                var sym = make_node(AST_SymbolRef, name, name);
                def.references.push(sym);
                expressions.splice(pos2++, 0, make_node(AST_Assign, var_def, {
                  operator: "=",
                  logical: false,
                  left: sym,
                  right: make_node(AST_Undefined, name)
                }));
              }
            }
          }
        }
        function flatten_fn(returned_value) {
          var decls = [];
          var expressions = [];
          flatten_args(decls, expressions);
          flatten_vars(decls, expressions);
          expressions.push(returned_value);
          if (decls.length) {
            const i = scope.body.indexOf(compressor.parent(level - 1)) + 1;
            scope.body.splice(i, 0, make_node(AST_Var, fn, {
              definitions: decls
            }));
          }
          return expressions.map((exp2) => exp2.clone(true));
        }
      }
      function dont_inline_lambda_in_loop(compressor, maybe_lambda) {
        return (maybe_lambda instanceof AST_Lambda || maybe_lambda instanceof AST_Class) && !!compressor.is_within_loop();
      }
      (function(def_find_defs) {
        function to_node(value2, orig) {
          if (value2 instanceof AST_Node) {
            if (!(value2 instanceof AST_Constant)) {
              value2 = value2.clone(true);
            }
            return make_node(value2.CTOR, orig, value2);
          }
          if (Array.isArray(value2))
            return make_node(AST_Array, orig, {
              elements: value2.map(function(value3) {
                return to_node(value3, orig);
              })
            });
          if (value2 && typeof value2 == "object") {
            var props = [];
            for (var key2 in value2)
              if (HOP(value2, key2)) {
                props.push(make_node(AST_ObjectKeyVal, orig, {
                  key: key2,
                  value: to_node(value2[key2], orig)
                }));
              }
            return make_node(AST_Object, orig, {
              properties: props
            });
          }
          return make_node_from_constant(value2, orig);
        }
        AST_Toplevel.DEFMETHOD("resolve_defines", function(compressor) {
          if (!compressor.option("global_defs"))
            return this;
          this.figure_out_scope({ ie8: compressor.option("ie8") });
          return this.transform(new TreeTransformer(function(node) {
            var def = node._find_defs(compressor, "");
            if (!def)
              return;
            var level = 0, child = node, parent;
            while (parent = this.parent(level++)) {
              if (!(parent instanceof AST_PropAccess))
                break;
              if (parent.expression !== child)
                break;
              child = parent;
            }
            if (is_lhs(child, parent)) {
              return;
            }
            return def;
          }));
        });
        def_find_defs(AST_Node, noop2);
        def_find_defs(AST_Chain, function(compressor, suffix) {
          return this.expression._find_defs(compressor, suffix);
        });
        def_find_defs(AST_Dot, function(compressor, suffix) {
          return this.expression._find_defs(compressor, "." + this.property + suffix);
        });
        def_find_defs(AST_SymbolDeclaration, function() {
          if (!this.global())
            return;
        });
        def_find_defs(AST_SymbolRef, function(compressor, suffix) {
          if (!this.global())
            return;
          var defines = compressor.option("global_defs");
          var name = this.name + suffix;
          if (HOP(defines, name))
            return to_node(defines[name], this);
        });
        def_find_defs(AST_ImportMeta, function(compressor, suffix) {
          var defines = compressor.option("global_defs");
          var name = "import.meta" + suffix;
          if (HOP(defines, name))
            return to_node(defines[name], this);
        });
      })(function(node, func) {
        node.DEFMETHOD("_find_defs", func);
      });
      class Compressor extends TreeWalker {
        constructor(options, { false_by_default = false, mangle_options: mangle_options2 = false }) {
          super();
          if (options.defaults !== void 0 && !options.defaults)
            false_by_default = true;
          this.options = defaults(options, {
            arguments: false,
            arrows: !false_by_default,
            booleans: !false_by_default,
            booleans_as_integers: false,
            collapse_vars: !false_by_default,
            comparisons: !false_by_default,
            computed_props: !false_by_default,
            conditionals: !false_by_default,
            dead_code: !false_by_default,
            defaults: true,
            directives: !false_by_default,
            drop_console: false,
            drop_debugger: !false_by_default,
            ecma: 5,
            evaluate: !false_by_default,
            expression: false,
            global_defs: false,
            hoist_funs: false,
            hoist_props: !false_by_default,
            hoist_vars: false,
            ie8: false,
            if_return: !false_by_default,
            inline: !false_by_default,
            join_vars: !false_by_default,
            keep_classnames: false,
            keep_fargs: true,
            keep_fnames: false,
            keep_infinity: false,
            lhs_constants: !false_by_default,
            loops: !false_by_default,
            module: false,
            negate_iife: !false_by_default,
            passes: 1,
            properties: !false_by_default,
            pure_getters: !false_by_default && "strict",
            pure_funcs: null,
            pure_new: false,
            reduce_funcs: !false_by_default,
            reduce_vars: !false_by_default,
            sequences: !false_by_default,
            side_effects: !false_by_default,
            switches: !false_by_default,
            top_retain: null,
            toplevel: !!(options && options["top_retain"]),
            typeofs: !false_by_default,
            unsafe: false,
            unsafe_arrows: false,
            unsafe_comps: false,
            unsafe_Function: false,
            unsafe_math: false,
            unsafe_symbols: false,
            unsafe_methods: false,
            unsafe_proto: false,
            unsafe_regexp: false,
            unsafe_undefined: false,
            unused: !false_by_default,
            warnings: false
          }, true);
          var global_defs = this.options["global_defs"];
          if (typeof global_defs == "object")
            for (var key2 in global_defs) {
              if (key2[0] === "@" && HOP(global_defs, key2)) {
                global_defs[key2.slice(1)] = parse2(global_defs[key2], {
                  expression: true
                });
              }
            }
          if (this.options["inline"] === true)
            this.options["inline"] = 3;
          var pure_funcs = this.options["pure_funcs"];
          if (typeof pure_funcs == "function") {
            this.pure_funcs = pure_funcs;
          } else {
            this.pure_funcs = pure_funcs ? function(node) {
              return !pure_funcs.includes(node.expression.print_to_string());
            } : return_true;
          }
          var top_retain = this.options["top_retain"];
          if (top_retain instanceof RegExp) {
            this.top_retain = function(def) {
              return top_retain.test(def.name);
            };
          } else if (typeof top_retain == "function") {
            this.top_retain = top_retain;
          } else if (top_retain) {
            if (typeof top_retain == "string") {
              top_retain = top_retain.split(/,/);
            }
            this.top_retain = function(def) {
              return top_retain.includes(def.name);
            };
          }
          if (this.options["module"]) {
            this.directives["use strict"] = true;
            this.options["toplevel"] = true;
          }
          var toplevel = this.options["toplevel"];
          this.toplevel = typeof toplevel == "string" ? {
            funcs: /funcs/.test(toplevel),
            vars: /vars/.test(toplevel)
          } : {
            funcs: toplevel,
            vars: toplevel
          };
          var sequences = this.options["sequences"];
          this.sequences_limit = sequences == 1 ? 800 : sequences | 0;
          this.evaluated_regexps = /* @__PURE__ */ new Map();
          this._toplevel = void 0;
          this._mangle_options = mangle_options2 ? format_mangler_options(mangle_options2) : mangle_options2;
        }
        mangle_options() {
          var nth_identifier = this._mangle_options && this._mangle_options.nth_identifier || base54;
          var module3 = this._mangle_options && this._mangle_options.module || this.option("module");
          return { ie8: this.option("ie8"), nth_identifier, module: module3 };
        }
        option(key2) {
          return this.options[key2];
        }
        exposed(def) {
          if (def.export)
            return true;
          if (def.global) {
            for (var i = 0, len = def.orig.length; i < len; i++)
              if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? "funcs" : "vars"])
                return true;
          }
          return false;
        }
        in_boolean_context() {
          if (!this.option("booleans"))
            return false;
          var self2 = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
            if (p instanceof AST_SimpleStatement || p instanceof AST_Conditional && p.condition === self2 || p instanceof AST_DWLoop && p.condition === self2 || p instanceof AST_For && p.condition === self2 || p instanceof AST_If && p.condition === self2 || p instanceof AST_UnaryPrefix && p.operator == "!" && p.expression === self2) {
              return true;
            }
            if (p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||" || p.operator == "??") || p instanceof AST_Conditional || p.tail_node() === self2) {
              self2 = p;
            } else {
              return false;
            }
          }
        }
        in_32_bit_context(other_operand_must_be_number) {
          if (!this.option("evaluate"))
            return false;
          var self2 = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
            if (p instanceof AST_Binary && bitwise_binop.has(p.operator)) {
              if (other_operand_must_be_number) {
                return (self2 === p.left ? p.right : p.left).is_number(this);
              } else {
                return true;
              }
            }
            if (p instanceof AST_UnaryPrefix) {
              return p.operator === "~";
            }
            if (p instanceof AST_Binary && (p.operator == "&&" || p.operator == "||" || p.operator == "??") || p instanceof AST_Conditional && p.condition !== self2 || p.tail_node() === self2) {
              self2 = p;
            } else {
              return false;
            }
          }
        }
        in_computed_key() {
          if (!this.option("evaluate"))
            return false;
          var self2 = this.self();
          for (var i = 0, p; p = this.parent(i); i++) {
            if (p instanceof AST_ObjectProperty && p.key === self2) {
              return true;
            }
          }
          return false;
        }
        get_toplevel() {
          return this._toplevel;
        }
        compress(toplevel) {
          toplevel = toplevel.resolve_defines(this);
          this._toplevel = toplevel;
          if (this.option("expression")) {
            this._toplevel.process_expression(true);
          }
          var passes = +this.options.passes || 1;
          var min_count = 1 / 0;
          var stopping = false;
          var mangle = this.mangle_options();
          for (var pass = 0; pass < passes; pass++) {
            this._toplevel.figure_out_scope(mangle);
            if (pass === 0 && this.option("drop_console")) {
              this._toplevel = this._toplevel.drop_console(this.option("drop_console"));
            }
            if (pass > 0 || this.option("reduce_vars")) {
              this._toplevel.reset_opt_flags(this);
            }
            this._toplevel = this._toplevel.transform(this);
            if (passes > 1) {
              let count = 0;
              walk(this._toplevel, () => {
                count++;
              });
              if (count < min_count) {
                min_count = count;
                stopping = false;
              } else if (stopping) {
                break;
              } else {
                stopping = true;
              }
            }
          }
          if (this.option("expression")) {
            this._toplevel.process_expression(false);
          }
          toplevel = this._toplevel;
          this._toplevel = void 0;
          return toplevel;
        }
        before(node, descend) {
          if (has_flag(node, SQUEEZED))
            return node;
          var was_scope = false;
          if (node instanceof AST_Scope) {
            node = node.hoist_properties(this);
            node = node.hoist_declarations(this);
            was_scope = true;
          }
          descend(node, this);
          descend(node, this);
          var opt = node.optimize(this);
          if (was_scope && opt instanceof AST_Scope) {
            opt.drop_unused(this);
            descend(opt, this);
          }
          if (opt === node)
            set_flag(opt, SQUEEZED);
          return opt;
        }
        is_lhs() {
          const self2 = this.stack[this.stack.length - 1];
          const parent = this.stack[this.stack.length - 2];
          return is_lhs(self2, parent);
        }
      }
      function def_optimize(node, optimizer) {
        node.DEFMETHOD("optimize", function(compressor) {
          var self2 = this;
          if (has_flag(self2, OPTIMIZED))
            return self2;
          if (compressor.has_directive("use asm"))
            return self2;
          var opt = optimizer(self2, compressor);
          set_flag(opt, OPTIMIZED);
          return opt;
        });
      }
      def_optimize(AST_Node, function(self2) {
        return self2;
      });
      AST_Toplevel.DEFMETHOD("drop_console", function(options) {
        const isArray = Array.isArray(options);
        const tt = new TreeTransformer(function(self2) {
          if (self2.TYPE !== "Call") {
            return;
          }
          var exp = self2.expression;
          if (!(exp instanceof AST_PropAccess)) {
            return;
          }
          var name = exp.expression;
          var property = exp.property;
          var depth = 2;
          while (name.expression) {
            property = name.property;
            name = name.expression;
            depth++;
          }
          if (isArray && !options.includes(property)) {
            return;
          }
          if (is_undeclared_ref(name) && name.name == "console") {
            if (depth === 3 && !["call", "apply"].includes(exp.property) && is_used_in_expression(tt)) {
              exp.expression = make_empty_function(self2);
              set_flag(exp.expression, SQUEEZED);
              self2.args = [];
            } else {
              return make_node(AST_Undefined, self2);
            }
          }
        });
        return this.transform(tt);
      });
      AST_Node.DEFMETHOD("equivalent_to", function(node) {
        return equivalent_to(this, node);
      });
      AST_Scope.DEFMETHOD("process_expression", function(insert2, compressor) {
        var self2 = this;
        var tt = new TreeTransformer(function(node) {
          if (insert2 && node instanceof AST_SimpleStatement) {
            return make_node(AST_Return, node, {
              value: node.body
            });
          }
          if (!insert2 && node instanceof AST_Return) {
            if (compressor) {
              var value2 = node.value && node.value.drop_side_effect_free(compressor, true);
              return value2 ? make_node(AST_SimpleStatement, node, { body: value2 }) : make_node(AST_EmptyStatement, node);
            }
            return make_node(AST_SimpleStatement, node, {
              body: node.value || make_node(AST_UnaryPrefix, node, {
                operator: "void",
                expression: make_node(AST_Number, node, {
                  value: 0
                })
              })
            });
          }
          if (node instanceof AST_Class || node instanceof AST_Lambda && node !== self2) {
            return node;
          }
          if (node instanceof AST_Block) {
            var index = node.body.length - 1;
            if (index >= 0) {
              node.body[index] = node.body[index].transform(tt);
            }
          } else if (node instanceof AST_If) {
            node.body = node.body.transform(tt);
            if (node.alternative) {
              node.alternative = node.alternative.transform(tt);
            }
          } else if (node instanceof AST_With) {
            node.body = node.body.transform(tt);
          }
          return node;
        });
        self2.transform(tt);
      });
      AST_Toplevel.DEFMETHOD("reset_opt_flags", function(compressor) {
        const self2 = this;
        const reduce_vars = compressor.option("reduce_vars");
        const preparation = new TreeWalker(function(node, descend) {
          clear_flag(node, CLEAR_BETWEEN_PASSES);
          if (reduce_vars) {
            if (compressor.top_retain && node instanceof AST_Defun && preparation.parent() === self2) {
              set_flag(node, TOP);
            }
            return node.reduce_vars(preparation, descend, compressor);
          }
        });
        preparation.safe_ids = /* @__PURE__ */ Object.create(null);
        preparation.in_loop = null;
        preparation.loop_ids = /* @__PURE__ */ new Map();
        preparation.defs_to_safe_ids = /* @__PURE__ */ new Map();
        self2.walk(preparation);
      });
      AST_Symbol.DEFMETHOD("fixed_value", function() {
        var fixed = this.thedef.fixed;
        if (!fixed || fixed instanceof AST_Node)
          return fixed;
        return fixed();
      });
      AST_SymbolRef.DEFMETHOD("is_immutable", function() {
        var orig = this.definition().orig;
        return orig.length == 1 && orig[0] instanceof AST_SymbolLambda;
      });
      function find_variable(compressor, name) {
        var scope, i = 0;
        while (scope = compressor.parent(i++)) {
          if (scope instanceof AST_Scope)
            break;
          if (scope instanceof AST_Catch && scope.argname) {
            scope = scope.argname.definition().scope;
            break;
          }
        }
        return scope.find_variable(name);
      }
      var global_names = makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError");
      AST_SymbolRef.DEFMETHOD("is_declared", function(compressor) {
        return !this.definition().undeclared || compressor.option("unsafe") && global_names.has(this.name);
      });
      var directives = /* @__PURE__ */ new Set(["use asm", "use strict"]);
      def_optimize(AST_Directive, function(self2, compressor) {
        if (compressor.option("directives") && (!directives.has(self2.value) || compressor.has_directive(self2.value) !== self2)) {
          return make_node(AST_EmptyStatement, self2);
        }
        return self2;
      });
      def_optimize(AST_Debugger, function(self2, compressor) {
        if (compressor.option("drop_debugger"))
          return make_node(AST_EmptyStatement, self2);
        return self2;
      });
      def_optimize(AST_LabeledStatement, function(self2, compressor) {
        if (self2.body instanceof AST_Break && compressor.loopcontrol_target(self2.body) === self2.body) {
          return make_node(AST_EmptyStatement, self2);
        }
        return self2.label.references.length == 0 ? self2.body : self2;
      });
      def_optimize(AST_Block, function(self2, compressor) {
        tighten_body(self2.body, compressor);
        return self2;
      });
      function can_be_extracted_from_if_block(node) {
        return !(node instanceof AST_Const || node instanceof AST_Let || node instanceof AST_Class);
      }
      def_optimize(AST_BlockStatement, function(self2, compressor) {
        tighten_body(self2.body, compressor);
        switch (self2.body.length) {
          case 1:
            if (!compressor.has_directive("use strict") && compressor.parent() instanceof AST_If && can_be_extracted_from_if_block(self2.body[0]) || can_be_evicted_from_block(self2.body[0])) {
              return self2.body[0];
            }
            break;
          case 0:
            return make_node(AST_EmptyStatement, self2);
        }
        return self2;
      });
      function opt_AST_Lambda(self2, compressor) {
        tighten_body(self2.body, compressor);
        if (compressor.option("side_effects") && self2.body.length == 1 && self2.body[0] === compressor.has_directive("use strict")) {
          self2.body.length = 0;
        }
        return self2;
      }
      def_optimize(AST_Lambda, opt_AST_Lambda);
      AST_Scope.DEFMETHOD("hoist_declarations", function(compressor) {
        var self2 = this;
        if (compressor.has_directive("use asm"))
          return self2;
        var hoist_funs = compressor.option("hoist_funs");
        var hoist_vars = compressor.option("hoist_vars");
        if (hoist_funs || hoist_vars) {
          var dirs = [];
          var hoisted = [];
          var vars = /* @__PURE__ */ new Map(), vars_found = 0, var_decl = 0;
          walk(self2, (node) => {
            if (node instanceof AST_Scope && node !== self2)
              return true;
            if (node instanceof AST_Var) {
              ++var_decl;
              return true;
            }
          });
          hoist_vars = hoist_vars && var_decl > 1;
          var tt = new TreeTransformer(function before(node) {
            if (node !== self2) {
              if (node instanceof AST_Directive) {
                dirs.push(node);
                return make_node(AST_EmptyStatement, node);
              }
              if (hoist_funs && node instanceof AST_Defun && !(tt.parent() instanceof AST_Export) && tt.parent() === self2) {
                hoisted.push(node);
                return make_node(AST_EmptyStatement, node);
              }
              if (hoist_vars && node instanceof AST_Var && !node.definitions.some((def3) => def3.name instanceof AST_Destructuring)) {
                node.definitions.forEach(function(def3) {
                  vars.set(def3.name.name, def3);
                  ++vars_found;
                });
                var seq = node.to_assignments(compressor);
                var p = tt.parent();
                if (p instanceof AST_ForIn && p.init === node) {
                  if (seq == null) {
                    var def2 = node.definitions[0].name;
                    return make_node(AST_SymbolRef, def2, def2);
                  }
                  return seq;
                }
                if (p instanceof AST_For && p.init === node) {
                  return seq;
                }
                if (!seq)
                  return make_node(AST_EmptyStatement, node);
                return make_node(AST_SimpleStatement, node, {
                  body: seq
                });
              }
              if (node instanceof AST_Scope)
                return node;
            }
          });
          self2 = self2.transform(tt);
          if (vars_found > 0) {
            var defs = [];
            const is_lambda = self2 instanceof AST_Lambda;
            const args_as_names = is_lambda ? self2.args_as_names() : null;
            vars.forEach((def2, name) => {
              if (is_lambda && args_as_names.some((x) => x.name === def2.name.name)) {
                vars.delete(name);
              } else {
                def2 = def2.clone();
                def2.value = null;
                defs.push(def2);
                vars.set(name, def2);
              }
            });
            if (defs.length > 0) {
              for (var i = 0; i < self2.body.length; ) {
                if (self2.body[i] instanceof AST_SimpleStatement) {
                  var expr = self2.body[i].body, sym, assign;
                  if (expr instanceof AST_Assign && expr.operator == "=" && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {
                    var def = vars.get(sym.name);
                    if (def.value)
                      break;
                    def.value = expr.right;
                    remove(defs, def);
                    defs.push(def);
                    self2.body.splice(i, 1);
                    continue;
                  }
                  if (expr instanceof AST_Sequence && (assign = expr.expressions[0]) instanceof AST_Assign && assign.operator == "=" && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {
                    var def = vars.get(sym.name);
                    if (def.value)
                      break;
                    def.value = assign.right;
                    remove(defs, def);
                    defs.push(def);
                    self2.body[i].body = make_sequence(expr, expr.expressions.slice(1));
                    continue;
                  }
                }
                if (self2.body[i] instanceof AST_EmptyStatement) {
                  self2.body.splice(i, 1);
                  continue;
                }
                if (self2.body[i] instanceof AST_BlockStatement) {
                  self2.body.splice(i, 1, ...self2.body[i].body);
                  continue;
                }
                break;
              }
              defs = make_node(AST_Var, self2, {
                definitions: defs
              });
              hoisted.push(defs);
            }
          }
          self2.body = dirs.concat(hoisted, self2.body);
        }
        return self2;
      });
      AST_Scope.DEFMETHOD("hoist_properties", function(compressor) {
        var self2 = this;
        if (!compressor.option("hoist_props") || compressor.has_directive("use asm"))
          return self2;
        var top_retain = self2 instanceof AST_Toplevel && compressor.top_retain || return_false;
        var defs_by_id = /* @__PURE__ */ new Map();
        var hoister = new TreeTransformer(function(node, descend) {
          if (node instanceof AST_VarDef) {
            const sym = node.name;
            let def;
            let value2;
            if (sym.scope === self2 && (def = sym.definition()).escaped != 1 && !def.assignments && !def.direct_access && !def.single_use && !compressor.exposed(def) && !top_retain(def) && (value2 = sym.fixed_value()) === node.value && value2 instanceof AST_Object && !value2.properties.some((prop) => prop instanceof AST_Expansion || prop.computed_key())) {
              descend(node, this);
              const defs = /* @__PURE__ */ new Map();
              const assignments = [];
              value2.properties.forEach(({ key: key2, value: value3 }) => {
                const scope = hoister.find_scope();
                const symbol = self2.create_symbol(sym.CTOR, {
                  source: sym,
                  scope,
                  conflict_scopes: /* @__PURE__ */ new Set([
                    scope,
                    ...sym.definition().references.map((ref) => ref.scope)
                  ]),
                  tentative_name: sym.name + "_" + key2
                });
                defs.set(String(key2), symbol.definition());
                assignments.push(make_node(AST_VarDef, node, {
                  name: symbol,
                  value: value3
                }));
              });
              defs_by_id.set(def.id, defs);
              return MAP.splice(assignments);
            }
          } else if (node instanceof AST_PropAccess && node.expression instanceof AST_SymbolRef) {
            const defs = defs_by_id.get(node.expression.definition().id);
            if (defs) {
              const def = defs.get(String(get_simple_key(node.property)));
              const sym = make_node(AST_SymbolRef, node, {
                name: def.name,
                scope: node.expression.scope,
                thedef: def
              });
              sym.reference({});
              return sym;
            }
          }
        });
        return self2.transform(hoister);
      });
      def_optimize(AST_SimpleStatement, function(self2, compressor) {
        if (compressor.option("side_effects")) {
          var body = self2.body;
          var node = body.drop_side_effect_free(compressor, true);
          if (!node) {
            return make_node(AST_EmptyStatement, self2);
          }
          if (node !== body) {
            return make_node(AST_SimpleStatement, self2, { body: node });
          }
        }
        return self2;
      });
      def_optimize(AST_While, function(self2, compressor) {
        return compressor.option("loops") ? make_node(AST_For, self2, self2).optimize(compressor) : self2;
      });
      def_optimize(AST_Do, function(self2, compressor) {
        if (!compressor.option("loops"))
          return self2;
        var cond = self2.condition.tail_node().evaluate(compressor);
        if (!(cond instanceof AST_Node)) {
          if (cond)
            return make_node(AST_For, self2, {
              body: make_node(AST_BlockStatement, self2.body, {
                body: [
                  self2.body,
                  make_node(AST_SimpleStatement, self2.condition, {
                    body: self2.condition
                  })
                ]
              })
            }).optimize(compressor);
          if (!has_break_or_continue(self2, compressor.parent())) {
            return make_node(AST_BlockStatement, self2.body, {
              body: [
                self2.body,
                make_node(AST_SimpleStatement, self2.condition, {
                  body: self2.condition
                })
              ]
            }).optimize(compressor);
          }
        }
        return self2;
      });
      function if_break_in_loop(self2, compressor) {
        var first = self2.body instanceof AST_BlockStatement ? self2.body.body[0] : self2.body;
        if (compressor.option("dead_code") && is_break(first)) {
          var body = [];
          if (self2.init instanceof AST_Statement) {
            body.push(self2.init);
          } else if (self2.init) {
            body.push(make_node(AST_SimpleStatement, self2.init, {
              body: self2.init
            }));
          }
          if (self2.condition) {
            body.push(make_node(AST_SimpleStatement, self2.condition, {
              body: self2.condition
            }));
          }
          trim_unreachable_code(compressor, self2.body, body);
          return make_node(AST_BlockStatement, self2, {
            body
          });
        }
        if (first instanceof AST_If) {
          if (is_break(first.body)) {
            if (self2.condition) {
              self2.condition = make_node(AST_Binary, self2.condition, {
                left: self2.condition,
                operator: "&&",
                right: first.condition.negate(compressor)
              });
            } else {
              self2.condition = first.condition.negate(compressor);
            }
            drop_it(first.alternative);
          } else if (is_break(first.alternative)) {
            if (self2.condition) {
              self2.condition = make_node(AST_Binary, self2.condition, {
                left: self2.condition,
                operator: "&&",
                right: first.condition
              });
            } else {
              self2.condition = first.condition;
            }
            drop_it(first.body);
          }
        }
        return self2;
        function is_break(node) {
          return node instanceof AST_Break && compressor.loopcontrol_target(node) === compressor.self();
        }
        function drop_it(rest) {
          rest = as_statement_array(rest);
          if (self2.body instanceof AST_BlockStatement) {
            self2.body = self2.body.clone();
            self2.body.body = rest.concat(self2.body.body.slice(1));
            self2.body = self2.body.transform(compressor);
          } else {
            self2.body = make_node(AST_BlockStatement, self2.body, {
              body: rest
            }).transform(compressor);
          }
          self2 = if_break_in_loop(self2, compressor);
        }
      }
      def_optimize(AST_For, function(self2, compressor) {
        if (!compressor.option("loops"))
          return self2;
        if (compressor.option("side_effects") && self2.init) {
          self2.init = self2.init.drop_side_effect_free(compressor);
        }
        if (self2.condition) {
          var cond = self2.condition.evaluate(compressor);
          if (!(cond instanceof AST_Node)) {
            if (cond)
              self2.condition = null;
            else if (!compressor.option("dead_code")) {
              var orig = self2.condition;
              self2.condition = make_node_from_constant(cond, self2.condition);
              self2.condition = best_of_expression(self2.condition.transform(compressor), orig);
            }
          }
          if (compressor.option("dead_code")) {
            if (cond instanceof AST_Node)
              cond = self2.condition.tail_node().evaluate(compressor);
            if (!cond) {
              var body = [];
              trim_unreachable_code(compressor, self2.body, body);
              if (self2.init instanceof AST_Statement) {
                body.push(self2.init);
              } else if (self2.init) {
                body.push(make_node(AST_SimpleStatement, self2.init, {
                  body: self2.init
                }));
              }
              body.push(make_node(AST_SimpleStatement, self2.condition, {
                body: self2.condition
              }));
              return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
            }
          }
        }
        return if_break_in_loop(self2, compressor);
      });
      def_optimize(AST_If, function(self2, compressor) {
        if (is_empty2(self2.alternative))
          self2.alternative = null;
        if (!compressor.option("conditionals"))
          return self2;
        var cond = self2.condition.evaluate(compressor);
        if (!compressor.option("dead_code") && !(cond instanceof AST_Node)) {
          var orig = self2.condition;
          self2.condition = make_node_from_constant(cond, orig);
          self2.condition = best_of_expression(self2.condition.transform(compressor), orig);
        }
        if (compressor.option("dead_code")) {
          if (cond instanceof AST_Node)
            cond = self2.condition.tail_node().evaluate(compressor);
          if (!cond) {
            var body = [];
            trim_unreachable_code(compressor, self2.body, body);
            body.push(make_node(AST_SimpleStatement, self2.condition, {
              body: self2.condition
            }));
            if (self2.alternative)
              body.push(self2.alternative);
            return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
          } else if (!(cond instanceof AST_Node)) {
            var body = [];
            body.push(make_node(AST_SimpleStatement, self2.condition, {
              body: self2.condition
            }));
            body.push(self2.body);
            if (self2.alternative) {
              trim_unreachable_code(compressor, self2.alternative, body);
            }
            return make_node(AST_BlockStatement, self2, { body }).optimize(compressor);
          }
        }
        var negated = self2.condition.negate(compressor);
        var self_condition_length = self2.condition.size();
        var negated_length = negated.size();
        var negated_is_best = negated_length < self_condition_length;
        if (self2.alternative && negated_is_best) {
          negated_is_best = false;
          self2.condition = negated;
          var tmp = self2.body;
          self2.body = self2.alternative || make_node(AST_EmptyStatement, self2);
          self2.alternative = tmp;
        }
        if (is_empty2(self2.body) && is_empty2(self2.alternative)) {
          return make_node(AST_SimpleStatement, self2.condition, {
            body: self2.condition.clone()
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_SimpleStatement && self2.alternative instanceof AST_SimpleStatement) {
          return make_node(AST_SimpleStatement, self2, {
            body: make_node(AST_Conditional, self2, {
              condition: self2.condition,
              consequent: self2.body.body,
              alternative: self2.alternative.body
            })
          }).optimize(compressor);
        }
        if (is_empty2(self2.alternative) && self2.body instanceof AST_SimpleStatement) {
          if (self_condition_length === negated_length && !negated_is_best && self2.condition instanceof AST_Binary && self2.condition.operator == "||") {
            negated_is_best = true;
          }
          if (negated_is_best)
            return make_node(AST_SimpleStatement, self2, {
              body: make_node(AST_Binary, self2, {
                operator: "||",
                left: negated,
                right: self2.body.body
              })
            }).optimize(compressor);
          return make_node(AST_SimpleStatement, self2, {
            body: make_node(AST_Binary, self2, {
              operator: "&&",
              left: self2.condition,
              right: self2.body.body
            })
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_EmptyStatement && self2.alternative instanceof AST_SimpleStatement) {
          return make_node(AST_SimpleStatement, self2, {
            body: make_node(AST_Binary, self2, {
              operator: "||",
              left: self2.condition,
              right: self2.alternative.body
            })
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_Exit && self2.alternative instanceof AST_Exit && self2.body.TYPE == self2.alternative.TYPE) {
          return make_node(self2.body.CTOR, self2, {
            value: make_node(AST_Conditional, self2, {
              condition: self2.condition,
              consequent: self2.body.value || make_node(AST_Undefined, self2.body),
              alternative: self2.alternative.value || make_node(AST_Undefined, self2.alternative)
            }).transform(compressor)
          }).optimize(compressor);
        }
        if (self2.body instanceof AST_If && !self2.body.alternative && !self2.alternative) {
          self2 = make_node(AST_If, self2, {
            condition: make_node(AST_Binary, self2.condition, {
              operator: "&&",
              left: self2.condition,
              right: self2.body.condition
            }),
            body: self2.body.body,
            alternative: null
          });
        }
        if (aborts(self2.body)) {
          if (self2.alternative) {
            var alt = self2.alternative;
            self2.alternative = null;
            return make_node(AST_BlockStatement, self2, {
              body: [self2, alt]
            }).optimize(compressor);
          }
        }
        if (aborts(self2.alternative)) {
          var body = self2.body;
          self2.body = self2.alternative;
          self2.condition = negated_is_best ? negated : self2.condition.negate(compressor);
          self2.alternative = null;
          return make_node(AST_BlockStatement, self2, {
            body: [self2, body]
          }).optimize(compressor);
        }
        return self2;
      });
      def_optimize(AST_Switch, function(self2, compressor) {
        if (!compressor.option("switches"))
          return self2;
        var branch;
        var value2 = self2.expression.evaluate(compressor);
        if (!(value2 instanceof AST_Node)) {
          var orig = self2.expression;
          self2.expression = make_node_from_constant(value2, orig);
          self2.expression = best_of_expression(self2.expression.transform(compressor), orig);
        }
        if (!compressor.option("dead_code"))
          return self2;
        if (value2 instanceof AST_Node) {
          value2 = self2.expression.tail_node().evaluate(compressor);
        }
        var decl = [];
        var body = [];
        var default_branch;
        var exact_match;
        for (var i = 0, len = self2.body.length; i < len && !exact_match; i++) {
          branch = self2.body[i];
          if (branch instanceof AST_Default) {
            if (!default_branch) {
              default_branch = branch;
            } else {
              eliminate_branch(branch, body[body.length - 1]);
            }
          } else if (!(value2 instanceof AST_Node)) {
            var exp = branch.expression.evaluate(compressor);
            if (!(exp instanceof AST_Node) && exp !== value2) {
              eliminate_branch(branch, body[body.length - 1]);
              continue;
            }
            if (exp instanceof AST_Node && !exp.has_side_effects(compressor)) {
              exp = branch.expression.tail_node().evaluate(compressor);
            }
            if (exp === value2) {
              exact_match = branch;
              if (default_branch) {
                var default_index = body.indexOf(default_branch);
                body.splice(default_index, 1);
                eliminate_branch(default_branch, body[default_index - 1]);
                default_branch = null;
              }
            }
          }
          body.push(branch);
        }
        while (i < len)
          eliminate_branch(self2.body[i++], body[body.length - 1]);
        self2.body = body;
        let default_or_exact = default_branch || exact_match;
        default_branch = null;
        exact_match = null;
        if (body.every((branch2, i2) => (branch2 === default_or_exact || branch2.expression instanceof AST_Constant) && (branch2.body.length === 0 || aborts(branch2) || body.length - 1 === i2))) {
          for (let i2 = 0; i2 < body.length; i2++) {
            const branch2 = body[i2];
            for (let j = i2 + 1; j < body.length; j++) {
              const next = body[j];
              if (next.body.length === 0)
                continue;
              const last_branch = j === body.length - 1;
              const equivalentBranch = branches_equivalent(next, branch2, false);
              if (equivalentBranch || last_branch && branches_equivalent(next, branch2, true)) {
                if (!equivalentBranch && last_branch) {
                  next.body.push(make_node(AST_Break));
                }
                let x = j - 1;
                let fallthroughDepth = 0;
                while (x > i2) {
                  if (is_inert_body(body[x--])) {
                    fallthroughDepth++;
                  } else {
                    break;
                  }
                }
                const plucked = body.splice(j - fallthroughDepth, 1 + fallthroughDepth);
                body.splice(i2 + 1, 0, ...plucked);
                i2 += plucked.length;
              }
            }
          }
        }
        for (let i2 = 0; i2 < body.length; i2++) {
          let branch2 = body[i2];
          if (branch2.body.length === 0)
            continue;
          if (!aborts(branch2))
            continue;
          for (let j = i2 + 1; j < body.length; i2++, j++) {
            let next = body[j];
            if (next.body.length === 0)
              continue;
            if (branches_equivalent(next, branch2, false) || j === body.length - 1 && branches_equivalent(next, branch2, true)) {
              branch2.body = [];
              branch2 = next;
              continue;
            }
            break;
          }
        }
        {
          let i2 = body.length - 1;
          for (; i2 >= 0; i2--) {
            let bbody = body[i2].body;
            if (is_break(bbody[bbody.length - 1], compressor))
              bbody.pop();
            if (!is_inert_body(body[i2]))
              break;
          }
          i2++;
          if (!default_or_exact || body.indexOf(default_or_exact) >= i2) {
            for (let j = body.length - 1; j >= i2; j--) {
              let branch2 = body[j];
              if (branch2 === default_or_exact) {
                default_or_exact = null;
                body.pop();
              } else if (!branch2.expression.has_side_effects(compressor)) {
                body.pop();
              } else {
                break;
              }
            }
          }
        }
        DEFAULT:
          if (default_or_exact) {
            let default_index2 = body.indexOf(default_or_exact);
            let default_body_index = default_index2;
            for (; default_body_index < body.length - 1; default_body_index++) {
              if (!is_inert_body(body[default_body_index]))
                break;
            }
            if (default_body_index < body.length - 1) {
              break DEFAULT;
            }
            let side_effect_index = body.length - 1;
            for (; side_effect_index >= 0; side_effect_index--) {
              let branch2 = body[side_effect_index];
              if (branch2 === default_or_exact)
                continue;
              if (branch2.expression.has_side_effects(compressor))
                break;
            }
            if (default_body_index > side_effect_index) {
              let prev_body_index = default_index2 - 1;
              for (; prev_body_index >= 0; prev_body_index--) {
                if (!is_inert_body(body[prev_body_index]))
                  break;
              }
              let before = Math.max(side_effect_index, prev_body_index) + 1;
              let after = default_index2;
              if (side_effect_index > default_index2) {
                after = side_effect_index;
                body[side_effect_index].body = body[default_body_index].body;
              } else {
                default_or_exact.body = body[default_body_index].body;
              }
              body.splice(after + 1, default_body_index - after);
              body.splice(before, default_index2 - before);
            }
          }
        DEFAULT:
          if (default_or_exact) {
            let i2 = body.findIndex((branch2) => !is_inert_body(branch2));
            let caseBody;
            if (i2 === body.length - 1) {
              let branch2 = body[i2];
              if (has_nested_break(self2))
                break DEFAULT;
              caseBody = make_node(AST_BlockStatement, branch2, {
                body: branch2.body
              });
              branch2.body = [];
            } else if (i2 !== -1) {
              break DEFAULT;
            }
            let sideEffect = body.find((branch2) => branch2 !== default_or_exact && branch2.expression.has_side_effects(compressor));
            if (!sideEffect) {
              return make_node(AST_BlockStatement, self2, {
                body: decl.concat(statement(self2.expression), default_or_exact.expression ? statement(default_or_exact.expression) : [], caseBody || [])
              }).optimize(compressor);
            }
            const default_index2 = body.indexOf(default_or_exact);
            body.splice(default_index2, 1);
            default_or_exact = null;
            if (caseBody) {
              return make_node(AST_BlockStatement, self2, {
                body: decl.concat(self2, caseBody)
              }).optimize(compressor);
            }
          }
        if (body.length > 0) {
          body[0].body = decl.concat(body[0].body);
        }
        if (body.length == 0) {
          return make_node(AST_BlockStatement, self2, {
            body: decl.concat(statement(self2.expression))
          }).optimize(compressor);
        }
        if (body.length == 1 && !has_nested_break(self2)) {
          let branch2 = body[0];
          return make_node(AST_If, self2, {
            condition: make_node(AST_Binary, self2, {
              operator: "===",
              left: self2.expression,
              right: branch2.expression
            }),
            body: make_node(AST_BlockStatement, branch2, {
              body: branch2.body
            }),
            alternative: null
          }).optimize(compressor);
        }
        if (body.length === 2 && default_or_exact && !has_nested_break(self2)) {
          let branch2 = body[0] === default_or_exact ? body[1] : body[0];
          let exact_exp = default_or_exact.expression && statement(default_or_exact.expression);
          if (aborts(body[0])) {
            let first = body[0];
            if (is_break(first.body[first.body.length - 1], compressor)) {
              first.body.pop();
            }
            return make_node(AST_If, self2, {
              condition: make_node(AST_Binary, self2, {
                operator: "===",
                left: self2.expression,
                right: branch2.expression
              }),
              body: make_node(AST_BlockStatement, branch2, {
                body: branch2.body
              }),
              alternative: make_node(AST_BlockStatement, default_or_exact, {
                body: [].concat(exact_exp || [], default_or_exact.body)
              })
            }).optimize(compressor);
          }
          let operator = "===";
          let consequent = make_node(AST_BlockStatement, branch2, {
            body: branch2.body
          });
          let always = make_node(AST_BlockStatement, default_or_exact, {
            body: [].concat(exact_exp || [], default_or_exact.body)
          });
          if (body[0] === default_or_exact) {
            operator = "!==";
            let tmp = always;
            always = consequent;
            consequent = tmp;
          }
          return make_node(AST_BlockStatement, self2, {
            body: [
              make_node(AST_If, self2, {
                condition: make_node(AST_Binary, self2, {
                  operator,
                  left: self2.expression,
                  right: branch2.expression
                }),
                body: consequent,
                alternative: null
              }),
              always
            ]
          }).optimize(compressor);
        }
        return self2;
        function eliminate_branch(branch2, prev) {
          if (prev && !aborts(prev)) {
            prev.body = prev.body.concat(branch2.body);
          } else {
            trim_unreachable_code(compressor, branch2, decl);
          }
        }
        function branches_equivalent(branch2, prev, insertBreak) {
          let bbody = branch2.body;
          let pbody = prev.body;
          if (insertBreak) {
            bbody = bbody.concat(make_node(AST_Break));
          }
          if (bbody.length !== pbody.length)
            return false;
          let bblock = make_node(AST_BlockStatement, branch2, { body: bbody });
          let pblock = make_node(AST_BlockStatement, prev, { body: pbody });
          return bblock.equivalent_to(pblock);
        }
        function statement(body2) {
          return make_node(AST_SimpleStatement, body2, { body: body2 });
        }
        function has_nested_break(root) {
          let has_break = false;
          let tw = new TreeWalker((node) => {
            if (has_break)
              return true;
            if (node instanceof AST_Lambda)
              return true;
            if (node instanceof AST_SimpleStatement)
              return true;
            if (!is_break(node, tw))
              return;
            let parent = tw.parent();
            if (parent instanceof AST_SwitchBranch && parent.body[parent.body.length - 1] === node) {
              return;
            }
            has_break = true;
          });
          root.walk(tw);
          return has_break;
        }
        function is_break(node, stack) {
          return node instanceof AST_Break && stack.loopcontrol_target(node) === self2;
        }
        function is_inert_body(branch2) {
          return !aborts(branch2) && !make_node(AST_BlockStatement, branch2, {
            body: branch2.body
          }).has_side_effects(compressor);
        }
      });
      def_optimize(AST_Try, function(self2, compressor) {
        if (self2.bcatch && self2.bfinally && self2.bfinally.body.every(is_empty2))
          self2.bfinally = null;
        if (compressor.option("dead_code") && self2.body.body.every(is_empty2)) {
          var body = [];
          if (self2.bcatch) {
            trim_unreachable_code(compressor, self2.bcatch, body);
          }
          if (self2.bfinally)
            body.push(...self2.bfinally.body);
          return make_node(AST_BlockStatement, self2, {
            body
          }).optimize(compressor);
        }
        return self2;
      });
      AST_Definitions.DEFMETHOD("to_assignments", function(compressor) {
        var reduce_vars = compressor.option("reduce_vars");
        var assignments = [];
        for (const def of this.definitions) {
          if (def.value) {
            var name = make_node(AST_SymbolRef, def.name, def.name);
            assignments.push(make_node(AST_Assign, def, {
              operator: "=",
              logical: false,
              left: name,
              right: def.value
            }));
            if (reduce_vars)
              name.definition().fixed = false;
          }
          const thedef = def.name.definition();
          thedef.eliminated++;
          thedef.replaced--;
        }
        if (assignments.length == 0)
          return null;
        return make_sequence(this, assignments);
      });
      def_optimize(AST_Definitions, function(self2) {
        if (self2.definitions.length == 0) {
          return make_node(AST_EmptyStatement, self2);
        }
        return self2;
      });
      def_optimize(AST_VarDef, function(self2, compressor) {
        if (self2.name instanceof AST_SymbolLet && self2.value != null && is_undefined(self2.value, compressor)) {
          self2.value = null;
        }
        return self2;
      });
      def_optimize(AST_Import, function(self2) {
        return self2;
      });
      def_optimize(AST_Call, function(self2, compressor) {
        var exp = self2.expression;
        var fn = exp;
        inline_array_like_spread(self2.args);
        var simple_args = self2.args.every((arg2) => !(arg2 instanceof AST_Expansion));
        if (compressor.option("reduce_vars") && fn instanceof AST_SymbolRef) {
          fn = fn.fixed_value();
        }
        var is_func = fn instanceof AST_Lambda;
        if (is_func && fn.pinned())
          return self2;
        if (compressor.option("unused") && simple_args && is_func && !fn.uses_arguments) {
          var pos2 = 0, last = 0;
          for (var i = 0, len = self2.args.length; i < len; i++) {
            if (fn.argnames[i] instanceof AST_Expansion) {
              if (has_flag(fn.argnames[i].expression, UNUSED))
                while (i < len) {
                  var node = self2.args[i++].drop_side_effect_free(compressor);
                  if (node) {
                    self2.args[pos2++] = node;
                  }
                }
              else
                while (i < len) {
                  self2.args[pos2++] = self2.args[i++];
                }
              last = pos2;
              break;
            }
            var trim2 = i >= fn.argnames.length;
            if (trim2 || has_flag(fn.argnames[i], UNUSED)) {
              var node = self2.args[i].drop_side_effect_free(compressor);
              if (node) {
                self2.args[pos2++] = node;
              } else if (!trim2) {
                self2.args[pos2++] = make_node(AST_Number, self2.args[i], {
                  value: 0
                });
                continue;
              }
            } else {
              self2.args[pos2++] = self2.args[i];
            }
            last = pos2;
          }
          self2.args.length = last;
        }
        if (exp instanceof AST_Dot && exp.expression instanceof AST_SymbolRef && exp.expression.name === "console" && exp.expression.definition().undeclared && exp.property === "assert") {
          const condition = self2.args[0];
          if (condition) {
            const value3 = condition.evaluate(compressor);
            if (value3 === 1 || value3 === true) {
              return make_node(AST_Undefined, self2);
            }
          }
        }
        if (compressor.option("unsafe") && !exp.contains_optional()) {
          if (exp instanceof AST_Dot && exp.start.value === "Array" && exp.property === "from" && self2.args.length === 1) {
            const [argument] = self2.args;
            if (argument instanceof AST_Array) {
              return make_node(AST_Array, argument, {
                elements: argument.elements
              }).optimize(compressor);
            }
          }
          if (is_undeclared_ref(exp))
            switch (exp.name) {
              case "Array":
                if (self2.args.length != 1) {
                  return make_node(AST_Array, self2, {
                    elements: self2.args
                  }).optimize(compressor);
                } else if (self2.args[0] instanceof AST_Number && self2.args[0].value <= 11) {
                  const elements2 = [];
                  for (let i2 = 0; i2 < self2.args[0].value; i2++)
                    elements2.push(new AST_Hole());
                  return new AST_Array({ elements: elements2 });
                }
                break;
              case "Object":
                if (self2.args.length == 0) {
                  return make_node(AST_Object, self2, {
                    properties: []
                  });
                }
                break;
              case "String":
                if (self2.args.length == 0)
                  return make_node(AST_String, self2, {
                    value: ""
                  });
                if (self2.args.length <= 1)
                  return make_node(AST_Binary, self2, {
                    left: self2.args[0],
                    operator: "+",
                    right: make_node(AST_String, self2, { value: "" })
                  }).optimize(compressor);
                break;
              case "Number":
                if (self2.args.length == 0)
                  return make_node(AST_Number, self2, {
                    value: 0
                  });
                if (self2.args.length == 1 && compressor.option("unsafe_math")) {
                  return make_node(AST_UnaryPrefix, self2, {
                    expression: self2.args[0],
                    operator: "+"
                  }).optimize(compressor);
                }
                break;
              case "Symbol":
                if (self2.args.length == 1 && self2.args[0] instanceof AST_String && compressor.option("unsafe_symbols"))
                  self2.args.length = 0;
                break;
              case "Boolean":
                if (self2.args.length == 0)
                  return make_node(AST_False, self2);
                if (self2.args.length == 1)
                  return make_node(AST_UnaryPrefix, self2, {
                    expression: make_node(AST_UnaryPrefix, self2, {
                      expression: self2.args[0],
                      operator: "!"
                    }),
                    operator: "!"
                  }).optimize(compressor);
                break;
              case "RegExp":
                var params = [];
                if (self2.args.length >= 1 && self2.args.length <= 2 && self2.args.every((arg2) => {
                  var value3 = arg2.evaluate(compressor);
                  params.push(value3);
                  return arg2 !== value3;
                }) && regexp_is_safe(params[0])) {
                  let [source, flags] = params;
                  source = regexp_source_fix(new RegExp(source).source);
                  const rx = make_node(AST_RegExp, self2, {
                    value: { source, flags }
                  });
                  if (rx._eval(compressor) !== rx) {
                    return rx;
                  }
                }
                break;
            }
          else if (exp instanceof AST_Dot)
            switch (exp.property) {
              case "toString":
                if (self2.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {
                  return make_node(AST_Binary, self2, {
                    left: make_node(AST_String, self2, { value: "" }),
                    operator: "+",
                    right: exp.expression
                  }).optimize(compressor);
                }
                break;
              case "join":
                if (exp.expression instanceof AST_Array)
                  EXIT: {
                    var separator;
                    if (self2.args.length > 0) {
                      separator = self2.args[0].evaluate(compressor);
                      if (separator === self2.args[0])
                        break EXIT;
                    }
                    var elements = [];
                    var consts = [];
                    for (var i = 0, len = exp.expression.elements.length; i < len; i++) {
                      var el = exp.expression.elements[i];
                      if (el instanceof AST_Expansion)
                        break EXIT;
                      var value2 = el.evaluate(compressor);
                      if (value2 !== el) {
                        consts.push(value2);
                      } else {
                        if (consts.length > 0) {
                          elements.push(make_node(AST_String, self2, {
                            value: consts.join(separator)
                          }));
                          consts.length = 0;
                        }
                        elements.push(el);
                      }
                    }
                    if (consts.length > 0) {
                      elements.push(make_node(AST_String, self2, {
                        value: consts.join(separator)
                      }));
                    }
                    if (elements.length == 0)
                      return make_node(AST_String, self2, { value: "" });
                    if (elements.length == 1) {
                      if (elements[0].is_string(compressor)) {
                        return elements[0];
                      }
                      return make_node(AST_Binary, elements[0], {
                        operator: "+",
                        left: make_node(AST_String, self2, { value: "" }),
                        right: elements[0]
                      });
                    }
                    if (separator == "") {
                      var first;
                      if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {
                        first = elements.shift();
                      } else {
                        first = make_node(AST_String, self2, { value: "" });
                      }
                      return elements.reduce(function(prev, el2) {
                        return make_node(AST_Binary, el2, {
                          operator: "+",
                          left: prev,
                          right: el2
                        });
                      }, first).optimize(compressor);
                    }
                    var node = self2.clone();
                    node.expression = node.expression.clone();
                    node.expression.expression = node.expression.expression.clone();
                    node.expression.expression.elements = elements;
                    return best_of(compressor, self2, node);
                  }
                break;
              case "charAt":
                if (exp.expression.is_string(compressor)) {
                  var arg = self2.args[0];
                  var index = arg ? arg.evaluate(compressor) : 0;
                  if (index !== arg) {
                    return make_node(AST_Sub, exp, {
                      expression: exp.expression,
                      property: make_node_from_constant(index | 0, arg || exp)
                    }).optimize(compressor);
                  }
                }
                break;
              case "apply":
                if (self2.args.length == 2 && self2.args[1] instanceof AST_Array) {
                  var args = self2.args[1].elements.slice();
                  args.unshift(self2.args[0]);
                  return make_node(AST_Call, self2, {
                    expression: make_node(AST_Dot, exp, {
                      expression: exp.expression,
                      optional: false,
                      property: "call"
                    }),
                    args
                  }).optimize(compressor);
                }
                break;
              case "call":
                var func = exp.expression;
                if (func instanceof AST_SymbolRef) {
                  func = func.fixed_value();
                }
                if (func instanceof AST_Lambda && !func.contains_this()) {
                  return (self2.args.length ? make_sequence(this, [
                    self2.args[0],
                    make_node(AST_Call, self2, {
                      expression: exp.expression,
                      args: self2.args.slice(1)
                    })
                  ]) : make_node(AST_Call, self2, {
                    expression: exp.expression,
                    args: []
                  })).optimize(compressor);
                }
                break;
            }
        }
        if (compressor.option("unsafe_Function") && is_undeclared_ref(exp) && exp.name == "Function") {
          if (self2.args.length == 0)
            return make_empty_function(self2).optimize(compressor);
          if (self2.args.every((x) => x instanceof AST_String)) {
            try {
              var code = "n(function(" + self2.args.slice(0, -1).map(function(arg2) {
                return arg2.value;
              }).join(",") + "){" + self2.args[self2.args.length - 1].value + "})";
              var ast = parse2(code);
              var mangle = compressor.mangle_options();
              ast.figure_out_scope(mangle);
              var comp = new Compressor(compressor.options, {
                mangle_options: compressor._mangle_options
              });
              ast = ast.transform(comp);
              ast.figure_out_scope(mangle);
              ast.compute_char_frequency(mangle);
              ast.mangle_names(mangle);
              var fun;
              walk(ast, (node2) => {
                if (is_func_expr(node2)) {
                  fun = node2;
                  return walk_abort;
                }
              });
              var code = OutputStream();
              AST_BlockStatement.prototype._codegen.call(fun, fun, code);
              self2.args = [
                make_node(AST_String, self2, {
                  value: fun.argnames.map(function(arg2) {
                    return arg2.print_to_string();
                  }).join(",")
                }),
                make_node(AST_String, self2.args[self2.args.length - 1], {
                  value: code.get().replace(/^{|}$/g, "")
                })
              ];
              return self2;
            } catch (ex) {
              if (!(ex instanceof JS_Parse_Error)) {
                throw ex;
              }
            }
          }
        }
        return inline_into_call(self2, compressor);
      });
      AST_Node.DEFMETHOD("contains_optional", function() {
        if (this instanceof AST_PropAccess || this instanceof AST_Call || this instanceof AST_Chain) {
          if (this.optional) {
            return true;
          } else {
            return this.expression.contains_optional();
          }
        } else {
          return false;
        }
      });
      def_optimize(AST_New, function(self2, compressor) {
        if (compressor.option("unsafe") && is_undeclared_ref(self2.expression) && ["Object", "RegExp", "Function", "Error", "Array"].includes(self2.expression.name))
          return make_node(AST_Call, self2, self2).transform(compressor);
        return self2;
      });
      def_optimize(AST_Sequence, function(self2, compressor) {
        if (!compressor.option("side_effects"))
          return self2;
        var expressions = [];
        filter_for_side_effects();
        var end = expressions.length - 1;
        trim_right_for_undefined();
        if (end == 0) {
          self2 = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);
          if (!(self2 instanceof AST_Sequence))
            self2 = self2.optimize(compressor);
          return self2;
        }
        self2.expressions = expressions;
        return self2;
        function filter_for_side_effects() {
          var first = first_in_statement(compressor);
          var last = self2.expressions.length - 1;
          self2.expressions.forEach(function(expr, index) {
            if (index < last)
              expr = expr.drop_side_effect_free(compressor, first);
            if (expr) {
              merge_sequence(expressions, expr);
              first = false;
            }
          });
        }
        function trim_right_for_undefined() {
          while (end > 0 && is_undefined(expressions[end], compressor))
            end--;
          if (end < expressions.length - 1) {
            expressions[end] = make_node(AST_UnaryPrefix, self2, {
              operator: "void",
              expression: expressions[end]
            });
            expressions.length = end + 1;
          }
        }
      });
      AST_Unary.DEFMETHOD("lift_sequences", function(compressor) {
        if (compressor.option("sequences")) {
          if (this.expression instanceof AST_Sequence) {
            var x = this.expression.expressions.slice();
            var e = this.clone();
            e.expression = x.pop();
            x.push(e);
            return make_sequence(this, x).optimize(compressor);
          }
        }
        return this;
      });
      def_optimize(AST_UnaryPostfix, function(self2, compressor) {
        return self2.lift_sequences(compressor);
      });
      def_optimize(AST_UnaryPrefix, function(self2, compressor) {
        var e = self2.expression;
        if (self2.operator == "delete" && !(e instanceof AST_SymbolRef || e instanceof AST_PropAccess || e instanceof AST_Chain || is_identifier_atom(e))) {
          return make_sequence(self2, [e, make_node(AST_True, self2)]).optimize(compressor);
        }
        var seq = self2.lift_sequences(compressor);
        if (seq !== self2) {
          return seq;
        }
        if (compressor.option("side_effects") && self2.operator == "void") {
          e = e.drop_side_effect_free(compressor);
          if (e) {
            self2.expression = e;
            return self2;
          } else {
            return make_node(AST_Undefined, self2).optimize(compressor);
          }
        }
        if (compressor.in_boolean_context()) {
          switch (self2.operator) {
            case "!":
              if (e instanceof AST_UnaryPrefix && e.operator == "!") {
                return e.expression;
              }
              if (e instanceof AST_Binary) {
                self2 = best_of(compressor, self2, e.negate(compressor, first_in_statement(compressor)));
              }
              break;
            case "typeof":
              return (e instanceof AST_SymbolRef ? make_node(AST_True, self2) : make_sequence(self2, [
                e,
                make_node(AST_True, self2)
              ])).optimize(compressor);
          }
        }
        if (self2.operator == "-" && e instanceof AST_Infinity) {
          e = e.transform(compressor);
        }
        if (e instanceof AST_Binary && (self2.operator == "+" || self2.operator == "-") && (e.operator == "*" || e.operator == "/" || e.operator == "%")) {
          return make_node(AST_Binary, self2, {
            operator: e.operator,
            left: make_node(AST_UnaryPrefix, e.left, {
              operator: self2.operator,
              expression: e.left
            }),
            right: e.right
          });
        }
        if (compressor.option("evaluate")) {
          if (self2.operator === "~" && self2.expression instanceof AST_UnaryPrefix && self2.expression.operator === "~" && (compressor.in_32_bit_context(false) || self2.expression.expression.is_32_bit_integer(compressor))) {
            return self2.expression.expression;
          }
          if (self2.operator === "~" && e instanceof AST_Binary && e.operator === "^") {
            if (e.left instanceof AST_UnaryPrefix && e.left.operator === "~") {
              e.left = e.left.bitwise_negate(compressor, true);
            } else {
              e.right = e.right.bitwise_negate(compressor, true);
            }
            return e;
          }
        }
        if (self2.operator != "-" || !(e instanceof AST_Number || e instanceof AST_Infinity || e instanceof AST_BigInt)) {
          var ev = self2.evaluate(compressor);
          if (ev !== self2) {
            ev = make_node_from_constant(ev, self2).optimize(compressor);
            return best_of(compressor, ev, self2);
          }
        }
        return self2;
      });
      AST_Binary.DEFMETHOD("lift_sequences", function(compressor) {
        if (compressor.option("sequences")) {
          if (this.left instanceof AST_Sequence) {
            var x = this.left.expressions.slice();
            var e = this.clone();
            e.left = x.pop();
            x.push(e);
            return make_sequence(this, x).optimize(compressor);
          }
          if (this.right instanceof AST_Sequence && !this.left.has_side_effects(compressor)) {
            var assign = this.operator == "=" && this.left instanceof AST_SymbolRef;
            var x = this.right.expressions;
            var last = x.length - 1;
            for (var i = 0; i < last; i++) {
              if (!assign && x[i].has_side_effects(compressor))
                break;
            }
            if (i == last) {
              x = x.slice();
              var e = this.clone();
              e.right = x.pop();
              x.push(e);
              return make_sequence(this, x).optimize(compressor);
            } else if (i > 0) {
              var e = this.clone();
              e.right = make_sequence(this.right, x.slice(i));
              x = x.slice(0, i);
              x.push(e);
              return make_sequence(this, x).optimize(compressor);
            }
          }
        }
        return this;
      });
      var commutativeOperators = makePredicate("== === != !== * & | ^");
      function is_object(node) {
        return node instanceof AST_Array || node instanceof AST_Lambda || node instanceof AST_Object || node instanceof AST_Class;
      }
      def_optimize(AST_Binary, function(self2, compressor) {
        function reversible() {
          return self2.left.is_constant() || self2.right.is_constant() || !self2.left.has_side_effects(compressor) && !self2.right.has_side_effects(compressor);
        }
        function reverse(op) {
          if (reversible()) {
            if (op)
              self2.operator = op;
            var tmp = self2.left;
            self2.left = self2.right;
            self2.right = tmp;
          }
        }
        if (compressor.option("lhs_constants") && commutativeOperators.has(self2.operator)) {
          if (self2.right.is_constant() && !self2.left.is_constant()) {
            if (!(self2.left instanceof AST_Binary && PRECEDENCE[self2.left.operator] >= PRECEDENCE[self2.operator])) {
              reverse();
            }
          }
        }
        self2 = self2.lift_sequences(compressor);
        if (compressor.option("comparisons"))
          switch (self2.operator) {
            case "===":
            case "!==":
              var is_strict_comparison = true;
              if (self2.left.is_string(compressor) && self2.right.is_string(compressor) || self2.left.is_number(compressor) && self2.right.is_number(compressor) || self2.left.is_bigint(compressor) && self2.right.is_bigint(compressor) || self2.left.is_boolean() && self2.right.is_boolean() || self2.left.equivalent_to(self2.right)) {
                self2.operator = self2.operator.substr(0, 2);
              }
            case "==":
            case "!=":
              if (!is_strict_comparison && is_undefined(self2.left, compressor)) {
                self2.left = make_node(AST_Null, self2.left);
              } else if (!is_strict_comparison && is_undefined(self2.right, compressor)) {
                self2.right = make_node(AST_Null, self2.right);
              } else if (compressor.option("typeofs") && self2.left instanceof AST_String && self2.left.value == "undefined" && self2.right instanceof AST_UnaryPrefix && self2.right.operator == "typeof") {
                var expr = self2.right.expression;
                if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
                  self2.right = expr;
                  self2.left = make_node(AST_Undefined, self2.left).optimize(compressor);
                  if (self2.operator.length == 2)
                    self2.operator += "=";
                }
              } else if (compressor.option("typeofs") && self2.left instanceof AST_UnaryPrefix && self2.left.operator == "typeof" && self2.right instanceof AST_String && self2.right.value == "undefined") {
                var expr = self2.left.expression;
                if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor) : !(expr instanceof AST_PropAccess && compressor.option("ie8"))) {
                  self2.left = expr;
                  self2.right = make_node(AST_Undefined, self2.right).optimize(compressor);
                  if (self2.operator.length == 2)
                    self2.operator += "=";
                }
              } else if (self2.left instanceof AST_SymbolRef && self2.right instanceof AST_SymbolRef && self2.left.definition() === self2.right.definition() && is_object(self2.left.fixed_value())) {
                return make_node(self2.operator[0] == "=" ? AST_True : AST_False, self2);
              } else if (self2.left.is_32_bit_integer(compressor) && self2.right.is_32_bit_integer(compressor)) {
                const not = (node) => make_node(AST_UnaryPrefix, node, {
                  operator: "!",
                  expression: node
                });
                const booleanify = (node, truthy) => {
                  if (truthy) {
                    return compressor.in_boolean_context() ? node : not(not(node));
                  } else {
                    return not(node);
                  }
                };
                if (self2.left instanceof AST_Number && self2.left.value === 0) {
                  return booleanify(self2.right, self2.operator[0] === "!");
                }
                if (self2.right instanceof AST_Number && self2.right.value === 0) {
                  return booleanify(self2.left, self2.operator[0] === "!");
                }
                let and_op, x, mask;
                if ((and_op = self2.left instanceof AST_Binary ? self2.left : self2.right instanceof AST_Binary ? self2.right : null) && (mask = and_op === self2.left ? self2.right : self2.left) && and_op.operator === "&" && mask instanceof AST_Number && mask.is_32_bit_integer(compressor) && (x = and_op.left.equivalent_to(mask) ? and_op.right : and_op.right.equivalent_to(mask) ? and_op.left : null)) {
                  let optimized = booleanify(make_node(AST_Binary, self2, {
                    operator: "&",
                    left: mask,
                    right: make_node(AST_UnaryPrefix, self2, {
                      operator: "~",
                      expression: x
                    })
                  }), self2.operator[0] === "!");
                  return best_of(compressor, optimized, self2);
                }
              }
              break;
            case "&&":
            case "||":
              var lhs = self2.left;
              if (lhs.operator == self2.operator) {
                lhs = lhs.right;
              }
              if (lhs instanceof AST_Binary && lhs.operator == (self2.operator == "&&" ? "!==" : "===") && self2.right instanceof AST_Binary && lhs.operator == self2.right.operator && (is_undefined(lhs.left, compressor) && self2.right.left instanceof AST_Null || lhs.left instanceof AST_Null && is_undefined(self2.right.left, compressor)) && !lhs.right.has_side_effects(compressor) && lhs.right.equivalent_to(self2.right.right)) {
                var combined = make_node(AST_Binary, self2, {
                  operator: lhs.operator.slice(0, -1),
                  left: make_node(AST_Null, self2),
                  right: lhs.right
                });
                if (lhs !== self2.left) {
                  combined = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: self2.left.left,
                    right: combined
                  });
                }
                return combined;
              }
              break;
          }
        if (self2.operator == "+" && compressor.in_boolean_context()) {
          var ll = self2.left.evaluate(compressor);
          var rr = self2.right.evaluate(compressor);
          if (ll && typeof ll == "string") {
            return make_sequence(self2, [
              self2.right,
              make_node(AST_True, self2)
            ]).optimize(compressor);
          }
          if (rr && typeof rr == "string") {
            return make_sequence(self2, [
              self2.left,
              make_node(AST_True, self2)
            ]).optimize(compressor);
          }
        }
        if (compressor.option("comparisons") && self2.is_boolean()) {
          if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {
            var negated = make_node(AST_UnaryPrefix, self2, {
              operator: "!",
              expression: self2.negate(compressor, first_in_statement(compressor))
            });
            self2 = best_of(compressor, self2, negated);
          }
          if (compressor.option("unsafe_comps")) {
            switch (self2.operator) {
              case "<":
                reverse(">");
                break;
              case "<=":
                reverse(">=");
                break;
            }
          }
        }
        if (self2.operator == "+") {
          if (self2.right instanceof AST_String && self2.right.getValue() == "" && self2.left.is_string(compressor)) {
            return self2.left;
          }
          if (self2.left instanceof AST_String && self2.left.getValue() == "" && self2.right.is_string(compressor)) {
            return self2.right;
          }
          if (self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.left instanceof AST_String && self2.left.left.getValue() == "" && self2.right.is_string(compressor)) {
            self2.left = self2.left.right;
            return self2;
          }
        }
        if (compressor.option("evaluate")) {
          switch (self2.operator) {
            case "&&":
              var ll = has_flag(self2.left, TRUTHY) ? true : has_flag(self2.left, FALSY) ? false : self2.left.evaluate(compressor);
              if (!ll) {
                return maintain_this_binding(compressor.parent(), compressor.self(), self2.left).optimize(compressor);
              } else if (!(ll instanceof AST_Node)) {
                return make_sequence(self2, [self2.left, self2.right]).optimize(compressor);
              }
              var rr = self2.right.evaluate(compressor);
              if (!rr) {
                if (compressor.in_boolean_context()) {
                  return make_sequence(self2, [
                    self2.left,
                    make_node(AST_False, self2)
                  ]).optimize(compressor);
                } else {
                  set_flag(self2, FALSY);
                }
              } else if (!(rr instanceof AST_Node)) {
                var parent = compressor.parent();
                if (parent.operator == "&&" && parent.left === compressor.self() || compressor.in_boolean_context()) {
                  return self2.left.optimize(compressor);
                }
              }
              if (self2.left.operator == "||") {
                var lr = self2.left.right.evaluate(compressor);
                if (!lr)
                  return make_node(AST_Conditional, self2, {
                    condition: self2.left.left,
                    consequent: self2.right,
                    alternative: self2.left.right
                  }).optimize(compressor);
              }
              break;
            case "||":
              var ll = has_flag(self2.left, TRUTHY) ? true : has_flag(self2.left, FALSY) ? false : self2.left.evaluate(compressor);
              if (!ll) {
                return make_sequence(self2, [self2.left, self2.right]).optimize(compressor);
              } else if (!(ll instanceof AST_Node)) {
                return maintain_this_binding(compressor.parent(), compressor.self(), self2.left).optimize(compressor);
              }
              var rr = self2.right.evaluate(compressor);
              if (!rr) {
                var parent = compressor.parent();
                if (parent.operator == "||" && parent.left === compressor.self() || compressor.in_boolean_context()) {
                  return self2.left.optimize(compressor);
                }
              } else if (!(rr instanceof AST_Node)) {
                if (compressor.in_boolean_context()) {
                  return make_sequence(self2, [
                    self2.left,
                    make_node(AST_True, self2)
                  ]).optimize(compressor);
                } else {
                  set_flag(self2, TRUTHY);
                }
              }
              if (self2.left.operator == "&&") {
                var lr = self2.left.right.evaluate(compressor);
                if (lr && !(lr instanceof AST_Node))
                  return make_node(AST_Conditional, self2, {
                    condition: self2.left.left,
                    consequent: self2.left.right,
                    alternative: self2.right
                  }).optimize(compressor);
              }
              break;
            case "??":
              if (is_nullish(self2.left, compressor)) {
                return self2.right;
              }
              var ll = self2.left.evaluate(compressor);
              if (!(ll instanceof AST_Node)) {
                return ll == null ? self2.right : self2.left;
              }
              if (compressor.in_boolean_context()) {
                const rr2 = self2.right.evaluate(compressor);
                if (!(rr2 instanceof AST_Node) && !rr2) {
                  return self2.left;
                }
              }
          }
          var associative = true;
          switch (self2.operator) {
            case "+":
              if (self2.right instanceof AST_Constant && self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.is_string(compressor)) {
                var binary = make_node(AST_Binary, self2, {
                  operator: "+",
                  left: self2.left.right,
                  right: self2.right
                });
                var r = binary.optimize(compressor);
                if (binary !== r) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: "+",
                    left: self2.left.left,
                    right: r
                  });
                }
              }
              if (self2.left instanceof AST_Binary && self2.left.operator == "+" && self2.left.is_string(compressor) && self2.right instanceof AST_Binary && self2.right.operator == "+" && self2.right.is_string(compressor)) {
                var binary = make_node(AST_Binary, self2, {
                  operator: "+",
                  left: self2.left.right,
                  right: self2.right.left
                });
                var m = binary.optimize(compressor);
                if (binary !== m) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: "+",
                    left: make_node(AST_Binary, self2.left, {
                      operator: "+",
                      left: self2.left.left,
                      right: m
                    }),
                    right: self2.right.right
                  });
                }
              }
              if (self2.right instanceof AST_UnaryPrefix && self2.right.operator == "-" && self2.left.is_number_or_bigint(compressor)) {
                self2 = make_node(AST_Binary, self2, {
                  operator: "-",
                  left: self2.left,
                  right: self2.right.expression
                });
                break;
              }
              if (self2.left instanceof AST_UnaryPrefix && self2.left.operator == "-" && reversible() && self2.right.is_number_or_bigint(compressor)) {
                self2 = make_node(AST_Binary, self2, {
                  operator: "-",
                  left: self2.right,
                  right: self2.left.expression
                });
                break;
              }
              if (self2.left instanceof AST_TemplateString) {
                var l = self2.left;
                var r = self2.right.evaluate(compressor);
                if (r != self2.right) {
                  l.segments[l.segments.length - 1].value += String(r);
                  return l;
                }
              }
              if (self2.right instanceof AST_TemplateString) {
                var r = self2.right;
                var l = self2.left.evaluate(compressor);
                if (l != self2.left) {
                  r.segments[0].value = String(l) + r.segments[0].value;
                  return r;
                }
              }
              if (self2.left instanceof AST_TemplateString && self2.right instanceof AST_TemplateString) {
                var l = self2.left;
                var segments = l.segments;
                var r = self2.right;
                segments[segments.length - 1].value += r.segments[0].value;
                for (var i = 1; i < r.segments.length; i++) {
                  segments.push(r.segments[i]);
                }
                return l;
              }
            case "*":
              associative = compressor.option("unsafe_math");
            case "&":
            case "|":
            case "^":
              if (self2.left.is_number_or_bigint(compressor) && self2.right.is_number_or_bigint(compressor) && reversible() && !(self2.left instanceof AST_Binary && self2.left.operator != self2.operator && PRECEDENCE[self2.left.operator] >= PRECEDENCE[self2.operator])) {
                var reversed = make_node(AST_Binary, self2, {
                  operator: self2.operator,
                  left: self2.right,
                  right: self2.left
                });
                if (self2.right instanceof AST_Constant && !(self2.left instanceof AST_Constant)) {
                  self2 = best_of(compressor, reversed, self2);
                } else {
                  self2 = best_of(compressor, self2, reversed);
                }
              }
              if (associative && self2.is_number_or_bigint(compressor)) {
                if (self2.right instanceof AST_Binary && self2.right.operator == self2.operator) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: make_node(AST_Binary, self2.left, {
                      operator: self2.operator,
                      left: self2.left,
                      right: self2.right.left,
                      start: self2.left.start,
                      end: self2.right.left.end
                    }),
                    right: self2.right.right
                  });
                }
                if (self2.right instanceof AST_Constant && self2.left instanceof AST_Binary && self2.left.operator == self2.operator) {
                  if (self2.left.left instanceof AST_Constant) {
                    self2 = make_node(AST_Binary, self2, {
                      operator: self2.operator,
                      left: make_node(AST_Binary, self2.left, {
                        operator: self2.operator,
                        left: self2.left.left,
                        right: self2.right,
                        start: self2.left.left.start,
                        end: self2.right.end
                      }),
                      right: self2.left.right
                    });
                  } else if (self2.left.right instanceof AST_Constant) {
                    self2 = make_node(AST_Binary, self2, {
                      operator: self2.operator,
                      left: make_node(AST_Binary, self2.left, {
                        operator: self2.operator,
                        left: self2.left.right,
                        right: self2.right,
                        start: self2.left.right.start,
                        end: self2.right.end
                      }),
                      right: self2.left.left
                    });
                  }
                }
                if (self2.left instanceof AST_Binary && self2.left.operator == self2.operator && self2.left.right instanceof AST_Constant && self2.right instanceof AST_Binary && self2.right.operator == self2.operator && self2.right.left instanceof AST_Constant) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: make_node(AST_Binary, self2.left, {
                      operator: self2.operator,
                      left: make_node(AST_Binary, self2.left.left, {
                        operator: self2.operator,
                        left: self2.left.right,
                        right: self2.right.left,
                        start: self2.left.right.start,
                        end: self2.right.left.end
                      }),
                      right: self2.left.left
                    }),
                    right: self2.right.right
                  });
                }
              }
          }
          if (bitwise_binop.has(self2.operator)) {
            let y, z, x_node, y_node, z_node = self2.left;
            if (self2.operator === "&" && self2.right instanceof AST_Binary && self2.right.operator === "|" && typeof (z = self2.left.evaluate(compressor)) === "number") {
              if (typeof (y = self2.right.right.evaluate(compressor)) === "number") {
                x_node = self2.right.left;
                y_node = self2.right.right;
              } else if (typeof (y = self2.right.left.evaluate(compressor)) === "number") {
                x_node = self2.right.right;
                y_node = self2.right.left;
              }
              if (x_node && y_node) {
                if ((y & z) === 0) {
                  self2 = make_node(AST_Binary, self2, {
                    operator: self2.operator,
                    left: z_node,
                    right: x_node
                  });
                } else {
                  const reordered_ops = make_node(AST_Binary, self2, {
                    operator: "|",
                    left: make_node(AST_Binary, self2, {
                      operator: "&",
                      left: x_node,
                      right: z_node
                    }),
                    right: make_node_from_constant(y & z, y_node)
                  });
                  self2 = best_of(compressor, self2, reordered_ops);
                }
              }
            }
            if ((self2.operator === "|" || self2.operator === "&") && self2.left.equivalent_to(self2.right) && !self2.left.has_side_effects(compressor) && compressor.in_32_bit_context(true)) {
              self2.left = make_node(AST_Number, self2, { value: 0 });
              self2.operator = "|";
            }
            if (self2.operator === "^" && self2.left instanceof AST_UnaryPrefix && self2.left.operator === "~" && self2.right instanceof AST_UnaryPrefix && self2.right.operator === "~") {
              self2 = make_node(AST_Binary, self2, {
                operator: "^",
                left: self2.left.expression,
                right: self2.right.expression
              });
            }
            if ((self2.operator === "<<" || self2.operator === ">>") && self2.right instanceof AST_Number && self2.right.value === 0) {
              self2.operator = "|";
            }
            const zero_side = self2.right instanceof AST_Number && self2.right.value === 0 ? self2.right : self2.left instanceof AST_Number && self2.left.value === 0 ? self2.left : null;
            const non_zero_side = zero_side && (zero_side === self2.right ? self2.left : self2.right);
            if (zero_side && (self2.operator === "|" || self2.operator === "^") && (non_zero_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))) {
              return non_zero_side;
            }
            if (zero_side && self2.operator === "&" && !non_zero_side.has_side_effects(compressor) && non_zero_side.is_32_bit_integer(compressor)) {
              return zero_side;
            }
            const is_full_mask = (node) => node instanceof AST_Number && node.value === -1 || node instanceof AST_UnaryPrefix && node.operator === "-" && node.expression instanceof AST_Number && node.expression.value === 1;
            const full_mask = is_full_mask(self2.right) ? self2.right : is_full_mask(self2.left) ? self2.left : null;
            const other_side = full_mask === self2.right ? self2.left : self2.right;
            if (full_mask && self2.operator === "&" && (other_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))) {
              return other_side;
            }
            if (full_mask && self2.operator === "^" && (other_side.is_32_bit_integer(compressor) || compressor.in_32_bit_context(true))) {
              return other_side.bitwise_negate(compressor);
            }
          }
        }
        if (self2.right instanceof AST_Binary && self2.right.operator == self2.operator && (lazy_op.has(self2.operator) || self2.operator == "+" && (self2.right.left.is_string(compressor) || self2.left.is_string(compressor) && self2.right.right.is_string(compressor)))) {
          self2.left = make_node(AST_Binary, self2.left, {
            operator: self2.operator,
            left: self2.left.transform(compressor),
            right: self2.right.left.transform(compressor)
          });
          self2.right = self2.right.right.transform(compressor);
          return self2.transform(compressor);
        }
        var ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
      });
      def_optimize(AST_SymbolExport, function(self2) {
        return self2;
      });
      def_optimize(AST_SymbolRef, function(self2, compressor) {
        if (!compressor.option("ie8") && is_undeclared_ref(self2) && !compressor.find_parent(AST_With)) {
          switch (self2.name) {
            case "undefined":
              return make_node(AST_Undefined, self2).optimize(compressor);
            case "NaN":
              return make_node(AST_NaN, self2).optimize(compressor);
            case "Infinity":
              return make_node(AST_Infinity, self2).optimize(compressor);
          }
        }
        if (compressor.option("reduce_vars") && !compressor.is_lhs()) {
          return inline_into_symbolref(self2, compressor);
        } else {
          return self2;
        }
      });
      function is_atomic(lhs, self2) {
        return lhs instanceof AST_SymbolRef || lhs.TYPE === self2.TYPE;
      }
      def_optimize(AST_Undefined, function(self2, compressor) {
        if (compressor.option("unsafe_undefined")) {
          var undef = find_variable(compressor, "undefined");
          if (undef) {
            var ref = make_node(AST_SymbolRef, self2, {
              name: "undefined",
              scope: undef.scope,
              thedef: undef
            });
            set_flag(ref, UNDEFINED);
            return ref;
          }
        }
        var lhs = compressor.is_lhs();
        if (lhs && is_atomic(lhs, self2))
          return self2;
        return make_node(AST_UnaryPrefix, self2, {
          operator: "void",
          expression: make_node(AST_Number, self2, {
            value: 0
          })
        });
      });
      def_optimize(AST_Infinity, function(self2, compressor) {
        var lhs = compressor.is_lhs();
        if (lhs && is_atomic(lhs, self2))
          return self2;
        if (compressor.option("keep_infinity") && !(lhs && !is_atomic(lhs, self2)) && !find_variable(compressor, "Infinity")) {
          return self2;
        }
        return make_node(AST_Binary, self2, {
          operator: "/",
          left: make_node(AST_Number, self2, {
            value: 1
          }),
          right: make_node(AST_Number, self2, {
            value: 0
          })
        });
      });
      def_optimize(AST_NaN, function(self2, compressor) {
        var lhs = compressor.is_lhs();
        if (lhs && !is_atomic(lhs, self2) || find_variable(compressor, "NaN")) {
          return make_node(AST_Binary, self2, {
            operator: "/",
            left: make_node(AST_Number, self2, {
              value: 0
            }),
            right: make_node(AST_Number, self2, {
              value: 0
            })
          });
        }
        return self2;
      });
      const ASSIGN_OPS = makePredicate("+ - / * % >> << >>> | ^ &");
      const ASSIGN_OPS_COMMUTATIVE = makePredicate("* | ^ &");
      def_optimize(AST_Assign, function(self2, compressor) {
        if (self2.logical) {
          return self2.lift_sequences(compressor);
        }
        var def;
        if (self2.operator === "=" && self2.left instanceof AST_SymbolRef && self2.left.name !== "arguments" && !(def = self2.left.definition()).undeclared && self2.right.equivalent_to(self2.left)) {
          return self2.right;
        }
        if (compressor.option("dead_code") && self2.left instanceof AST_SymbolRef && (def = self2.left.definition()).scope === compressor.find_parent(AST_Lambda)) {
          var level = 0, node, parent = self2;
          do {
            node = parent;
            parent = compressor.parent(level++);
            if (parent instanceof AST_Exit) {
              if (in_try(level, parent))
                break;
              if (is_reachable(def.scope, [def]))
                break;
              if (self2.operator == "=")
                return self2.right;
              def.fixed = false;
              return make_node(AST_Binary, self2, {
                operator: self2.operator.slice(0, -1),
                left: self2.left,
                right: self2.right
              }).optimize(compressor);
            }
          } while (parent instanceof AST_Binary && parent.right === node || parent instanceof AST_Sequence && parent.tail_node() === node);
        }
        self2 = self2.lift_sequences(compressor);
        if (self2.operator == "=" && self2.left instanceof AST_SymbolRef && self2.right instanceof AST_Binary) {
          if (self2.right.left instanceof AST_SymbolRef && self2.right.left.name == self2.left.name && ASSIGN_OPS.has(self2.right.operator)) {
            self2.operator = self2.right.operator + "=";
            self2.right = self2.right.right;
          } else if (self2.right.right instanceof AST_SymbolRef && self2.right.right.name == self2.left.name && ASSIGN_OPS_COMMUTATIVE.has(self2.right.operator) && !self2.right.left.has_side_effects(compressor)) {
            self2.operator = self2.right.operator + "=";
            self2.right = self2.right.left;
          }
        }
        return self2;
        function in_try(level2, node2) {
          function may_assignment_throw() {
            const right = self2.right;
            self2.right = make_node(AST_Null, right);
            const may_throw = node2.may_throw(compressor);
            self2.right = right;
            return may_throw;
          }
          var stop_at = self2.left.definition().scope.get_defun_scope();
          var parent2;
          while ((parent2 = compressor.parent(level2++)) !== stop_at) {
            if (parent2 instanceof AST_Try) {
              if (parent2.bfinally)
                return true;
              if (parent2.bcatch && may_assignment_throw())
                return true;
            }
          }
        }
      });
      def_optimize(AST_DefaultAssign, function(self2, compressor) {
        if (!compressor.option("evaluate")) {
          return self2;
        }
        var evaluateRight = self2.right.evaluate(compressor);
        let lambda, iife;
        if (evaluateRight === void 0) {
          if ((lambda = compressor.parent()) instanceof AST_Lambda ? compressor.option("keep_fargs") === false || (iife = compressor.parent(1)).TYPE === "Call" && iife.expression === lambda : true) {
            self2 = self2.left;
          }
        } else if (evaluateRight !== self2.right) {
          evaluateRight = make_node_from_constant(evaluateRight, self2.right);
          self2.right = best_of_expression(evaluateRight, self2.right);
        }
        return self2;
      });
      function is_nullish_check(check, check_subject, compressor) {
        if (check_subject.may_throw(compressor))
          return false;
        let nullish_side;
        if (check instanceof AST_Binary && check.operator === "==" && ((nullish_side = is_nullish(check.left, compressor) && check.left) || (nullish_side = is_nullish(check.right, compressor) && check.right)) && (nullish_side === check.left ? check.right : check.left).equivalent_to(check_subject)) {
          return true;
        }
        if (check instanceof AST_Binary && check.operator === "||") {
          let null_cmp;
          let undefined_cmp;
          const find_comparison = (cmp) => {
            if (!(cmp instanceof AST_Binary && (cmp.operator === "===" || cmp.operator === "=="))) {
              return false;
            }
            let found = 0;
            let defined_side;
            if (cmp.left instanceof AST_Null) {
              found++;
              null_cmp = cmp;
              defined_side = cmp.right;
            }
            if (cmp.right instanceof AST_Null) {
              found++;
              null_cmp = cmp;
              defined_side = cmp.left;
            }
            if (is_undefined(cmp.left, compressor)) {
              found++;
              undefined_cmp = cmp;
              defined_side = cmp.right;
            }
            if (is_undefined(cmp.right, compressor)) {
              found++;
              undefined_cmp = cmp;
              defined_side = cmp.left;
            }
            if (found !== 1) {
              return false;
            }
            if (!defined_side.equivalent_to(check_subject)) {
              return false;
            }
            return true;
          };
          if (!find_comparison(check.left))
            return false;
          if (!find_comparison(check.right))
            return false;
          if (null_cmp && undefined_cmp && null_cmp !== undefined_cmp) {
            return true;
          }
        }
        return false;
      }
      def_optimize(AST_Conditional, function(self2, compressor) {
        if (!compressor.option("conditionals"))
          return self2;
        if (self2.condition instanceof AST_Sequence) {
          var expressions = self2.condition.expressions.slice();
          self2.condition = expressions.pop();
          expressions.push(self2);
          return make_sequence(self2, expressions);
        }
        var cond = self2.condition.evaluate(compressor);
        if (cond !== self2.condition) {
          if (cond) {
            return maintain_this_binding(compressor.parent(), compressor.self(), self2.consequent);
          } else {
            return maintain_this_binding(compressor.parent(), compressor.self(), self2.alternative);
          }
        }
        var negated = cond.negate(compressor, first_in_statement(compressor));
        if (best_of(compressor, cond, negated) === negated) {
          self2 = make_node(AST_Conditional, self2, {
            condition: negated,
            consequent: self2.alternative,
            alternative: self2.consequent
          });
        }
        var condition = self2.condition;
        var consequent = self2.consequent;
        var alternative = self2.alternative;
        if (condition instanceof AST_SymbolRef && consequent instanceof AST_SymbolRef && condition.definition() === consequent.definition()) {
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: condition,
            right: alternative
          });
        }
        if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator === alternative.operator && consequent.logical === alternative.logical && consequent.left.equivalent_to(alternative.left) && (!self2.condition.has_side_effects(compressor) || consequent.operator == "=" && !consequent.left.has_side_effects(compressor))) {
          return make_node(AST_Assign, self2, {
            operator: consequent.operator,
            left: consequent.left,
            logical: consequent.logical,
            right: make_node(AST_Conditional, self2, {
              condition: self2.condition,
              consequent: consequent.right,
              alternative: alternative.right
            })
          });
        }
        var arg_index;
        if (consequent instanceof AST_Call && alternative.TYPE === consequent.TYPE && consequent.args.length > 0 && consequent.args.length == alternative.args.length && consequent.expression.equivalent_to(alternative.expression) && !self2.condition.has_side_effects(compressor) && !consequent.expression.has_side_effects(compressor) && typeof (arg_index = single_arg_diff()) == "number") {
          var node = consequent.clone();
          node.args[arg_index] = make_node(AST_Conditional, self2, {
            condition: self2.condition,
            consequent: consequent.args[arg_index],
            alternative: alternative.args[arg_index]
          });
          return node;
        }
        if (alternative instanceof AST_Conditional && consequent.equivalent_to(alternative.consequent)) {
          return make_node(AST_Conditional, self2, {
            condition: make_node(AST_Binary, self2, {
              operator: "||",
              left: condition,
              right: alternative.condition
            }),
            consequent,
            alternative: alternative.alternative
          }).optimize(compressor);
        }
        if (compressor.option("ecma") >= 2020 && is_nullish_check(condition, alternative, compressor)) {
          return make_node(AST_Binary, self2, {
            operator: "??",
            left: alternative,
            right: consequent
          }).optimize(compressor);
        }
        if (alternative instanceof AST_Sequence && consequent.equivalent_to(alternative.expressions[alternative.expressions.length - 1])) {
          return make_sequence(self2, [
            make_node(AST_Binary, self2, {
              operator: "||",
              left: condition,
              right: make_sequence(self2, alternative.expressions.slice(0, -1))
            }),
            consequent
          ]).optimize(compressor);
        }
        if (alternative instanceof AST_Binary && alternative.operator == "&&" && consequent.equivalent_to(alternative.right)) {
          return make_node(AST_Binary, self2, {
            operator: "&&",
            left: make_node(AST_Binary, self2, {
              operator: "||",
              left: condition,
              right: alternative.left
            }),
            right: consequent
          }).optimize(compressor);
        }
        if (consequent instanceof AST_Conditional && consequent.alternative.equivalent_to(alternative)) {
          return make_node(AST_Conditional, self2, {
            condition: make_node(AST_Binary, self2, {
              left: self2.condition,
              operator: "&&",
              right: consequent.condition
            }),
            consequent: consequent.consequent,
            alternative
          });
        }
        if (consequent.equivalent_to(alternative)) {
          return make_sequence(self2, [
            self2.condition,
            consequent
          ]).optimize(compressor);
        }
        if (consequent instanceof AST_Binary && consequent.operator == "||" && consequent.right.equivalent_to(alternative)) {
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: make_node(AST_Binary, self2, {
              operator: "&&",
              left: self2.condition,
              right: consequent.left
            }),
            right: alternative
          }).optimize(compressor);
        }
        const in_bool = compressor.in_boolean_context();
        if (is_true(self2.consequent)) {
          if (is_false(self2.alternative)) {
            return booleanize(self2.condition);
          }
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: booleanize(self2.condition),
            right: self2.alternative
          });
        }
        if (is_false(self2.consequent)) {
          if (is_true(self2.alternative)) {
            return booleanize(self2.condition.negate(compressor));
          }
          return make_node(AST_Binary, self2, {
            operator: "&&",
            left: booleanize(self2.condition.negate(compressor)),
            right: self2.alternative
          });
        }
        if (is_true(self2.alternative)) {
          return make_node(AST_Binary, self2, {
            operator: "||",
            left: booleanize(self2.condition.negate(compressor)),
            right: self2.consequent
          });
        }
        if (is_false(self2.alternative)) {
          return make_node(AST_Binary, self2, {
            operator: "&&",
            left: booleanize(self2.condition),
            right: self2.consequent
          });
        }
        return self2;
        function booleanize(node2) {
          if (node2.is_boolean())
            return node2;
          return make_node(AST_UnaryPrefix, node2, {
            operator: "!",
            expression: node2.negate(compressor)
          });
        }
        function is_true(node2) {
          return node2 instanceof AST_True || in_bool && node2 instanceof AST_Constant && node2.getValue() || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && !node2.expression.getValue();
        }
        function is_false(node2) {
          return node2 instanceof AST_False || in_bool && node2 instanceof AST_Constant && !node2.getValue() || node2 instanceof AST_UnaryPrefix && node2.operator == "!" && node2.expression instanceof AST_Constant && node2.expression.getValue();
        }
        function single_arg_diff() {
          var a = consequent.args;
          var b = alternative.args;
          for (var i = 0, len = a.length; i < len; i++) {
            if (a[i] instanceof AST_Expansion)
              return;
            if (!a[i].equivalent_to(b[i])) {
              if (b[i] instanceof AST_Expansion)
                return;
              for (var j = i + 1; j < len; j++) {
                if (a[j] instanceof AST_Expansion)
                  return;
                if (!a[j].equivalent_to(b[j]))
                  return;
              }
              return i;
            }
          }
        }
      });
      def_optimize(AST_Boolean, function(self2, compressor) {
        if (compressor.in_boolean_context())
          return make_node(AST_Number, self2, {
            value: +self2.value
          });
        var p = compressor.parent();
        if (compressor.option("booleans_as_integers")) {
          if (p instanceof AST_Binary && (p.operator == "===" || p.operator == "!==")) {
            p.operator = p.operator.replace(/=$/, "");
          }
          return make_node(AST_Number, self2, {
            value: +self2.value
          });
        }
        if (compressor.option("booleans")) {
          if (p instanceof AST_Binary && (p.operator == "==" || p.operator == "!=")) {
            return make_node(AST_Number, self2, {
              value: +self2.value
            });
          }
          return make_node(AST_UnaryPrefix, self2, {
            operator: "!",
            expression: make_node(AST_Number, self2, {
              value: 1 - self2.value
            })
          });
        }
        return self2;
      });
      function safe_to_flatten(value2, compressor) {
        if (value2 instanceof AST_SymbolRef) {
          value2 = value2.fixed_value();
        }
        if (!value2)
          return false;
        if (!(value2 instanceof AST_Lambda || value2 instanceof AST_Class))
          return true;
        if (!(value2 instanceof AST_Lambda && value2.contains_this()))
          return true;
        return compressor.parent() instanceof AST_New;
      }
      AST_PropAccess.DEFMETHOD("flatten_object", function(key2, compressor) {
        if (!compressor.option("properties"))
          return;
        if (key2 === "__proto__")
          return;
        if (this instanceof AST_DotHash)
          return;
        var arrows = compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015;
        var expr = this.expression;
        if (expr instanceof AST_Object) {
          var props = expr.properties;
          for (var i = props.length; --i >= 0; ) {
            var prop = props[i];
            if ("" + (prop instanceof AST_ConciseMethod ? prop.key.name : prop.key) == key2) {
              const all_props_flattenable = props.every((p) => (p instanceof AST_ObjectKeyVal || arrows && p instanceof AST_ConciseMethod && !p.value.is_generator) && !p.computed_key());
              if (!all_props_flattenable)
                return;
              if (!safe_to_flatten(prop.value, compressor))
                return;
              return make_node(AST_Sub, this, {
                expression: make_node(AST_Array, expr, {
                  elements: props.map(function(prop2) {
                    var v = prop2.value;
                    if (v instanceof AST_Accessor) {
                      v = make_node(AST_Function, v, v);
                    }
                    var k = prop2.key;
                    if (k instanceof AST_Node && !(k instanceof AST_SymbolMethod)) {
                      return make_sequence(prop2, [k, v]);
                    }
                    return v;
                  })
                }),
                property: make_node(AST_Number, this, {
                  value: i
                })
              });
            }
          }
        }
      });
      def_optimize(AST_Sub, function(self2, compressor) {
        var expr = self2.expression;
        var prop = self2.property;
        if (compressor.option("properties")) {
          var key2 = prop.evaluate(compressor);
          if (key2 !== prop) {
            if (typeof key2 == "string") {
              if (key2 == "undefined") {
                key2 = void 0;
              } else {
                var value2 = parseFloat(key2);
                if (value2.toString() == key2) {
                  key2 = value2;
                }
              }
            }
            prop = self2.property = best_of_expression(prop, make_node_from_constant(key2, prop).transform(compressor));
            var property = "" + key2;
            if (is_basic_identifier_string(property) && property.length <= prop.size() + 1) {
              return make_node(AST_Dot, self2, {
                expression: expr,
                optional: self2.optional,
                property,
                quote: prop.quote
              }).optimize(compressor);
            }
          }
        }
        var fn;
        OPT_ARGUMENTS:
          if (compressor.option("arguments") && expr instanceof AST_SymbolRef && expr.name == "arguments" && expr.definition().orig.length == 1 && (fn = expr.scope) instanceof AST_Lambda && fn.uses_arguments && !(fn instanceof AST_Arrow) && prop instanceof AST_Number) {
            var index = prop.getValue();
            var params = /* @__PURE__ */ new Set();
            var argnames = fn.argnames;
            for (var n2 = 0; n2 < argnames.length; n2++) {
              if (!(argnames[n2] instanceof AST_SymbolFunarg)) {
                break OPT_ARGUMENTS;
              }
              var param = argnames[n2].name;
              if (params.has(param)) {
                break OPT_ARGUMENTS;
              }
              params.add(param);
            }
            var argname = fn.argnames[index];
            if (argname && compressor.has_directive("use strict")) {
              var def = argname.definition();
              if (!compressor.option("reduce_vars") || def.assignments || def.orig.length > 1) {
                argname = null;
              }
            } else if (!argname && !compressor.option("keep_fargs") && index < fn.argnames.length + 5) {
              while (index >= fn.argnames.length) {
                argname = fn.create_symbol(AST_SymbolFunarg, {
                  source: fn,
                  scope: fn,
                  tentative_name: "argument_" + fn.argnames.length
                });
                fn.argnames.push(argname);
              }
            }
            if (argname) {
              var sym = make_node(AST_SymbolRef, self2, argname);
              sym.reference({});
              clear_flag(argname, UNUSED);
              return sym;
            }
          }
        if (compressor.is_lhs())
          return self2;
        if (key2 !== prop) {
          var sub = self2.flatten_object(property, compressor);
          if (sub) {
            expr = self2.expression = sub.expression;
            prop = self2.property = sub.property;
          }
        }
        if (compressor.option("properties") && compressor.option("side_effects") && prop instanceof AST_Number && expr instanceof AST_Array) {
          var index = prop.getValue();
          var elements = expr.elements;
          var retValue = elements[index];
          FLATTEN:
            if (safe_to_flatten(retValue, compressor)) {
              var flatten = true;
              var values = [];
              for (var i = elements.length; --i > index; ) {
                var value2 = elements[i].drop_side_effect_free(compressor);
                if (value2) {
                  values.unshift(value2);
                  if (flatten && value2.has_side_effects(compressor))
                    flatten = false;
                }
              }
              if (retValue instanceof AST_Expansion)
                break FLATTEN;
              retValue = retValue instanceof AST_Hole ? make_node(AST_Undefined, retValue) : retValue;
              if (!flatten)
                values.unshift(retValue);
              while (--i >= 0) {
                var value2 = elements[i];
                if (value2 instanceof AST_Expansion)
                  break FLATTEN;
                value2 = value2.drop_side_effect_free(compressor);
                if (value2)
                  values.unshift(value2);
                else
                  index--;
              }
              if (flatten) {
                values.push(retValue);
                return make_sequence(self2, values).optimize(compressor);
              } else
                return make_node(AST_Sub, self2, {
                  expression: make_node(AST_Array, expr, {
                    elements: values
                  }),
                  property: make_node(AST_Number, prop, {
                    value: index
                  })
                });
            }
        }
        var ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
      });
      def_optimize(AST_Chain, function(self2, compressor) {
        if (is_nullish(self2.expression, compressor)) {
          let parent = compressor.parent();
          if (parent instanceof AST_UnaryPrefix && parent.operator === "delete") {
            return make_node_from_constant(0, self2);
          }
          return make_node(AST_Undefined, self2);
        }
        if (self2.expression instanceof AST_PropAccess || self2.expression instanceof AST_Call) {
          return self2;
        } else {
          return self2.expression;
        }
      });
      def_optimize(AST_Dot, function(self2, compressor) {
        const parent = compressor.parent();
        if (compressor.is_lhs())
          return self2;
        if (compressor.option("unsafe_proto") && self2.expression instanceof AST_Dot && self2.expression.property == "prototype") {
          var exp = self2.expression.expression;
          if (is_undeclared_ref(exp))
            switch (exp.name) {
              case "Array":
                self2.expression = make_node(AST_Array, self2.expression, {
                  elements: []
                });
                break;
              case "Function":
                self2.expression = make_empty_function(self2.expression);
                break;
              case "Number":
                self2.expression = make_node(AST_Number, self2.expression, {
                  value: 0
                });
                break;
              case "Object":
                self2.expression = make_node(AST_Object, self2.expression, {
                  properties: []
                });
                break;
              case "RegExp":
                self2.expression = make_node(AST_RegExp, self2.expression, {
                  value: { source: "t", flags: "" }
                });
                break;
              case "String":
                self2.expression = make_node(AST_String, self2.expression, {
                  value: ""
                });
                break;
            }
        }
        if (!(parent instanceof AST_Call) || !has_annotation(parent, _NOINLINE)) {
          const sub = self2.flatten_object(self2.property, compressor);
          if (sub)
            return sub.optimize(compressor);
        }
        if (self2.expression instanceof AST_PropAccess && parent instanceof AST_PropAccess) {
          return self2;
        }
        let ev = self2.evaluate(compressor);
        if (ev !== self2) {
          ev = make_node_from_constant(ev, self2).optimize(compressor);
          return best_of(compressor, ev, self2);
        }
        return self2;
      });
      function literals_in_boolean_context(self2, compressor) {
        if (compressor.in_boolean_context()) {
          return best_of(compressor, self2, make_sequence(self2, [
            self2,
            make_node(AST_True, self2)
          ]).optimize(compressor));
        }
        return self2;
      }
      function inline_array_like_spread(elements) {
        for (var i = 0; i < elements.length; i++) {
          var el = elements[i];
          if (el instanceof AST_Expansion) {
            var expr = el.expression;
            if (expr instanceof AST_Array && !expr.elements.some((elm) => elm instanceof AST_Hole)) {
              elements.splice(i, 1, ...expr.elements);
              i--;
            }
          }
        }
      }
      def_optimize(AST_Array, function(self2, compressor) {
        var optimized = literals_in_boolean_context(self2, compressor);
        if (optimized !== self2) {
          return optimized;
        }
        inline_array_like_spread(self2.elements);
        return self2;
      });
      function inline_object_prop_spread(props) {
        for (var i = 0; i < props.length; i++) {
          var prop = props[i];
          if (prop instanceof AST_Expansion) {
            const expr = prop.expression;
            if (expr instanceof AST_Object && expr.properties.every((prop2) => prop2 instanceof AST_ObjectKeyVal)) {
              props.splice(i, 1, ...expr.properties);
              i--;
            } else if ((expr instanceof AST_Constant || expr.is_constant()) && !(expr instanceof AST_String)) {
              props.splice(i, 1);
              i--;
            }
          }
        }
      }
      def_optimize(AST_Object, function(self2, compressor) {
        var optimized = literals_in_boolean_context(self2, compressor);
        if (optimized !== self2) {
          return optimized;
        }
        inline_object_prop_spread(self2.properties);
        return self2;
      });
      def_optimize(AST_RegExp, literals_in_boolean_context);
      def_optimize(AST_Return, function(self2, compressor) {
        if (self2.value && is_undefined(self2.value, compressor)) {
          self2.value = null;
        }
        return self2;
      });
      def_optimize(AST_Arrow, opt_AST_Lambda);
      def_optimize(AST_Function, function(self2, compressor) {
        self2 = opt_AST_Lambda(self2, compressor);
        if (compressor.option("unsafe_arrows") && compressor.option("ecma") >= 2015 && !self2.name && !self2.is_generator && !self2.uses_arguments && !self2.pinned()) {
          const uses_this = walk(self2, (node) => {
            if (node instanceof AST_This)
              return walk_abort;
          });
          if (!uses_this)
            return make_node(AST_Arrow, self2, self2).optimize(compressor);
        }
        return self2;
      });
      def_optimize(AST_Class, function(self2) {
        for (let i = 0; i < self2.properties.length; i++) {
          const prop = self2.properties[i];
          if (prop instanceof AST_ClassStaticBlock && prop.body.length == 0) {
            self2.properties.splice(i, 1);
            i--;
          }
        }
        return self2;
      });
      def_optimize(AST_ClassStaticBlock, function(self2, compressor) {
        tighten_body(self2.body, compressor);
        return self2;
      });
      def_optimize(AST_Yield, function(self2, compressor) {
        if (self2.expression && !self2.is_star && is_undefined(self2.expression, compressor)) {
          self2.expression = null;
        }
        return self2;
      });
      def_optimize(AST_TemplateString, function(self2, compressor) {
        if (!compressor.option("evaluate") || compressor.parent() instanceof AST_PrefixedTemplateString) {
          return self2;
        }
        var segments = [];
        for (var i = 0; i < self2.segments.length; i++) {
          var segment = self2.segments[i];
          if (segment instanceof AST_Node) {
            var result = segment.evaluate(compressor);
            if (result !== segment && (result + "").length <= segment.size() + "${}".length) {
              segments[segments.length - 1].value = segments[segments.length - 1].value + result + self2.segments[++i].value;
              continue;
            }
            if (segment instanceof AST_TemplateString) {
              var inners = segment.segments;
              segments[segments.length - 1].value += inners[0].value;
              for (var j = 1; j < inners.length; j++) {
                segment = inners[j];
                segments.push(segment);
              }
              continue;
            }
          }
          segments.push(segment);
        }
        self2.segments = segments;
        if (segments.length == 1) {
          return make_node(AST_String, self2, segments[0]);
        }
        if (segments.length === 3 && segments[1] instanceof AST_Node && (segments[1].is_string(compressor) || segments[1].is_number_or_bigint(compressor) || is_nullish(segments[1], compressor) || compressor.option("unsafe"))) {
          if (segments[2].value === "") {
            return make_node(AST_Binary, self2, {
              operator: "+",
              left: make_node(AST_String, self2, {
                value: segments[0].value
              }),
              right: segments[1]
            });
          }
          if (segments[0].value === "") {
            return make_node(AST_Binary, self2, {
              operator: "+",
              left: segments[1],
              right: make_node(AST_String, self2, {
                value: segments[2].value
              })
            });
          }
        }
        return self2;
      });
      def_optimize(AST_PrefixedTemplateString, function(self2) {
        return self2;
      });
      function lift_key(self2, compressor) {
        if (!compressor.option("computed_props"))
          return self2;
        if (!(self2.key instanceof AST_Constant))
          return self2;
        if (self2.key instanceof AST_String || self2.key instanceof AST_Number) {
          const key2 = self2.key.value.toString();
          if (key2 === "__proto__")
            return self2;
          if (key2 == "constructor" && compressor.parent() instanceof AST_Class)
            return self2;
          if (self2 instanceof AST_ObjectKeyVal) {
            self2.quote = self2.key.quote;
            self2.key = key2;
          } else if (self2 instanceof AST_ClassProperty) {
            self2.quote = self2.key.quote;
            self2.key = make_node(AST_SymbolClassProperty, self2.key, {
              name: key2
            });
          } else {
            self2.quote = self2.key.quote;
            self2.key = make_node(AST_SymbolMethod, self2.key, {
              name: key2
            });
          }
        }
        return self2;
      }
      def_optimize(AST_ObjectProperty, lift_key);
      def_optimize(AST_ConciseMethod, function(self2, compressor) {
        lift_key(self2, compressor);
        if (compressor.option("arrows") && compressor.parent() instanceof AST_Object && !self2.value.is_generator && !self2.value.uses_arguments && !self2.value.pinned() && self2.value.body.length == 1 && self2.value.body[0] instanceof AST_Return && self2.value.body[0].value && !self2.value.contains_this()) {
          var arrow = make_node(AST_Arrow, self2.value, self2.value);
          arrow.async = self2.value.async;
          arrow.is_generator = self2.value.is_generator;
          return make_node(AST_ObjectKeyVal, self2, {
            key: self2.key instanceof AST_SymbolMethod ? self2.key.name : self2.key,
            value: arrow,
            quote: self2.quote
          });
        }
        return self2;
      });
      def_optimize(AST_ObjectKeyVal, function(self2, compressor) {
        lift_key(self2, compressor);
        var unsafe_methods = compressor.option("unsafe_methods");
        if (unsafe_methods && compressor.option("ecma") >= 2015 && (!(unsafe_methods instanceof RegExp) || unsafe_methods.test(self2.key + ""))) {
          var key2 = self2.key;
          var value2 = self2.value;
          var is_arrow_with_block = value2 instanceof AST_Arrow && Array.isArray(value2.body) && !value2.contains_this();
          if ((is_arrow_with_block || value2 instanceof AST_Function) && !value2.name) {
            return make_node(AST_ConciseMethod, self2, {
              key: key2 instanceof AST_Node ? key2 : make_node(AST_SymbolMethod, self2, {
                name: key2
              }),
              value: make_node(AST_Accessor, value2, value2),
              quote: self2.quote
            });
          }
        }
        return self2;
      });
      def_optimize(AST_Destructuring, function(self2, compressor) {
        if (compressor.option("pure_getters") == true && compressor.option("unused") && !self2.is_array && Array.isArray(self2.names) && !is_destructuring_export_decl(compressor) && !(self2.names[self2.names.length - 1] instanceof AST_Expansion)) {
          var keep = [];
          for (var i = 0; i < self2.names.length; i++) {
            var elem = self2.names[i];
            if (!(elem instanceof AST_ObjectKeyVal && typeof elem.key == "string" && elem.value instanceof AST_SymbolDeclaration && !should_retain(compressor, elem.value.definition()))) {
              keep.push(elem);
            }
          }
          if (keep.length != self2.names.length) {
            self2.names = keep;
          }
        }
        return self2;
        function is_destructuring_export_decl(compressor2) {
          var ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];
          for (var a = 0, p = 0, len = ancestors.length; a < len; p++) {
            var parent = compressor2.parent(p);
            if (!parent)
              return false;
            if (a === 0 && parent.TYPE == "Destructuring")
              continue;
            if (!ancestors[a].test(parent.TYPE)) {
              return false;
            }
            a++;
          }
          return true;
        }
        function should_retain(compressor2, def) {
          if (def.references.length)
            return true;
          if (!def.global)
            return false;
          if (compressor2.toplevel.vars) {
            if (compressor2.top_retain) {
              return compressor2.top_retain(def);
            }
            return false;
          }
          return true;
        }
      });
      function* SourceMap(options) {
        options = defaults(options, {
          file: null,
          root: null,
          orig: null,
          files: {}
        });
        var orig_map;
        var generator = new sourceMap.SourceMapGenerator({
          file: options.file,
          sourceRoot: options.root
        });
        let sourcesContent = { __proto__: null };
        let files = options.files;
        for (var name in files)
          if (HOP(files, name)) {
            sourcesContent[name] = files[name];
          }
        if (options.orig) {
          orig_map = yield new sourceMap.SourceMapConsumer(options.orig);
          if (orig_map.sourcesContent) {
            orig_map.sources.forEach(function(source, i) {
              var content = orig_map.sourcesContent[i];
              if (content) {
                sourcesContent[source] = content;
              }
            });
          }
        }
        function add(source, gen_line, gen_col, orig_line, orig_col, name2) {
          let generatedPos = { line: gen_line, column: gen_col };
          if (orig_map) {
            var info = orig_map.originalPositionFor({
              line: orig_line,
              column: orig_col
            });
            if (info.source === null) {
              generator.addMapping({
                generated: generatedPos,
                original: null,
                source: null,
                name: null
              });
              return;
            }
            source = info.source;
            orig_line = info.line;
            orig_col = info.column;
            name2 = info.name || name2;
          }
          generator.addMapping({
            generated: generatedPos,
            original: { line: orig_line, column: orig_col },
            source,
            name: name2
          });
          generator.setSourceContent(source, sourcesContent[source]);
        }
        function clean(map) {
          const allNull = map.sourcesContent && map.sourcesContent.every((c) => c == null);
          if (allNull)
            delete map.sourcesContent;
          if (map.file === void 0)
            delete map.file;
          if (map.sourceRoot === void 0)
            delete map.sourceRoot;
          return map;
        }
        function getDecoded() {
          if (!generator.toDecodedMap)
            return null;
          return clean(generator.toDecodedMap());
        }
        function getEncoded() {
          return clean(generator.toJSON());
        }
        function destroy() {
          if (orig_map && orig_map.destroy)
            orig_map.destroy();
        }
        return {
          add,
          getDecoded,
          getEncoded,
          destroy
        };
      }
      var domprops = [
        "$&",
        "$'",
        "$*",
        "$+",
        "$1",
        "$2",
        "$3",
        "$4",
        "$5",
        "$6",
        "$7",
        "$8",
        "$9",
        "$_",
        "$`",
        "$input",
        "-moz-animation",
        "-moz-animation-delay",
        "-moz-animation-direction",
        "-moz-animation-duration",
        "-moz-animation-fill-mode",
        "-moz-animation-iteration-count",
        "-moz-animation-name",
        "-moz-animation-play-state",
        "-moz-animation-timing-function",
        "-moz-appearance",
        "-moz-backface-visibility",
        "-moz-border-end",
        "-moz-border-end-color",
        "-moz-border-end-style",
        "-moz-border-end-width",
        "-moz-border-image",
        "-moz-border-start",
        "-moz-border-start-color",
        "-moz-border-start-style",
        "-moz-border-start-width",
        "-moz-box-align",
        "-moz-box-direction",
        "-moz-box-flex",
        "-moz-box-ordinal-group",
        "-moz-box-orient",
        "-moz-box-pack",
        "-moz-box-sizing",
        "-moz-float-edge",
        "-moz-font-feature-settings",
        "-moz-font-language-override",
        "-moz-force-broken-image-icon",
        "-moz-hyphens",
        "-moz-image-region",
        "-moz-margin-end",
        "-moz-margin-start",
        "-moz-orient",
        "-moz-osx-font-smoothing",
        "-moz-outline-radius",
        "-moz-outline-radius-bottomleft",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-padding-end",
        "-moz-padding-start",
        "-moz-perspective",
        "-moz-perspective-origin",
        "-moz-tab-size",
        "-moz-text-size-adjust",
        "-moz-transform",
        "-moz-transform-origin",
        "-moz-transform-style",
        "-moz-transition",
        "-moz-transition-delay",
        "-moz-transition-duration",
        "-moz-transition-property",
        "-moz-transition-timing-function",
        "-moz-user-focus",
        "-moz-user-input",
        "-moz-user-modify",
        "-moz-user-select",
        "-moz-window-dragging",
        "-webkit-align-content",
        "-webkit-align-items",
        "-webkit-align-self",
        "-webkit-animation",
        "-webkit-animation-delay",
        "-webkit-animation-direction",
        "-webkit-animation-duration",
        "-webkit-animation-fill-mode",
        "-webkit-animation-iteration-count",
        "-webkit-animation-name",
        "-webkit-animation-play-state",
        "-webkit-animation-timing-function",
        "-webkit-appearance",
        "-webkit-backface-visibility",
        "-webkit-background-clip",
        "-webkit-background-origin",
        "-webkit-background-size",
        "-webkit-border-bottom-left-radius",
        "-webkit-border-bottom-right-radius",
        "-webkit-border-image",
        "-webkit-border-radius",
        "-webkit-border-top-left-radius",
        "-webkit-border-top-right-radius",
        "-webkit-box-align",
        "-webkit-box-direction",
        "-webkit-box-flex",
        "-webkit-box-ordinal-group",
        "-webkit-box-orient",
        "-webkit-box-pack",
        "-webkit-box-shadow",
        "-webkit-box-sizing",
        "-webkit-clip-path",
        "-webkit-filter",
        "-webkit-flex",
        "-webkit-flex-basis",
        "-webkit-flex-direction",
        "-webkit-flex-flow",
        "-webkit-flex-grow",
        "-webkit-flex-shrink",
        "-webkit-flex-wrap",
        "-webkit-font-feature-settings",
        "-webkit-justify-content",
        "-webkit-line-clamp",
        "-webkit-mask",
        "-webkit-mask-clip",
        "-webkit-mask-composite",
        "-webkit-mask-image",
        "-webkit-mask-origin",
        "-webkit-mask-position",
        "-webkit-mask-position-x",
        "-webkit-mask-position-y",
        "-webkit-mask-repeat",
        "-webkit-mask-size",
        "-webkit-order",
        "-webkit-perspective",
        "-webkit-perspective-origin",
        "-webkit-text-fill-color",
        "-webkit-text-security",
        "-webkit-text-size-adjust",
        "-webkit-text-stroke",
        "-webkit-text-stroke-color",
        "-webkit-text-stroke-width",
        "-webkit-transform",
        "-webkit-transform-origin",
        "-webkit-transform-style",
        "-webkit-transition",
        "-webkit-transition-delay",
        "-webkit-transition-duration",
        "-webkit-transition-property",
        "-webkit-transition-timing-function",
        "-webkit-user-select",
        "@@iterator",
        "ABORT_ERR",
        "ACTIVE",
        "ACTIVE_ATTRIBUTES",
        "ACTIVE_TEXTURE",
        "ACTIVE_UNIFORMS",
        "ACTIVE_UNIFORM_BLOCKS",
        "ADDITION",
        "ALIASED_LINE_WIDTH_RANGE",
        "ALIASED_POINT_SIZE_RANGE",
        "ALL",
        "ALLOW_KEYBOARD_INPUT",
        "ALLPASS",
        "ALPHA",
        "ALPHA_BITS",
        "ALREADY_SIGNALED",
        "ALT_MASK",
        "ALWAYS",
        "ANY_SAMPLES_PASSED",
        "ANY_SAMPLES_PASSED_CONSERVATIVE",
        "ANY_TYPE",
        "ANY_UNORDERED_NODE_TYPE",
        "ARRAY_BUFFER",
        "ARRAY_BUFFER_BINDING",
        "ATTACHED_SHADERS",
        "ATTRIBUTE_NODE",
        "AT_TARGET",
        "AbortController",
        "AbortSignal",
        "AbsoluteOrientationSensor",
        "AbstractRange",
        "Accelerometer",
        "AddSearchProvider",
        "AggregateError",
        "AnalyserNode",
        "Animation",
        "AnimationEffect",
        "AnimationEvent",
        "AnimationPlaybackEvent",
        "AnimationTimeline",
        "AnonXMLHttpRequest",
        "Any",
        "AnyPermissions",
        "ApplicationCache",
        "ApplicationCacheErrorEvent",
        "Array",
        "ArrayBuffer",
        "ArrayType",
        "Atomics",
        "Attr",
        "Audio",
        "AudioBuffer",
        "AudioBufferSourceNode",
        "AudioContext",
        "AudioData",
        "AudioDecoder",
        "AudioDestinationNode",
        "AudioEncoder",
        "AudioListener",
        "AudioNode",
        "AudioParam",
        "AudioParamMap",
        "AudioProcessingEvent",
        "AudioScheduledSourceNode",
        "AudioSinkInfo",
        "AudioStreamTrack",
        "AudioWorklet",
        "AudioWorkletNode",
        "AuthenticatorAssertionResponse",
        "AuthenticatorAttestationResponse",
        "AuthenticatorResponse",
        "AutocompleteErrorEvent",
        "BACK",
        "BAD_BOUNDARYPOINTS_ERR",
        "BAD_REQUEST",
        "BANDPASS",
        "BLEND",
        "BLEND_COLOR",
        "BLEND_DST_ALPHA",
        "BLEND_DST_RGB",
        "BLEND_EQUATION",
        "BLEND_EQUATION_ALPHA",
        "BLEND_EQUATION_RGB",
        "BLEND_SRC_ALPHA",
        "BLEND_SRC_RGB",
        "BLUE",
        "BLUE_BITS",
        "BLUR",
        "BOOL",
        "BOOLEAN_TYPE",
        "BOOL_VEC2",
        "BOOL_VEC3",
        "BOOL_VEC4",
        "BOTH",
        "BROWSER_DEFAULT_WEBGL",
        "BUBBLING_PHASE",
        "BUFFER_SIZE",
        "BUFFER_USAGE",
        "BYTE",
        "BYTES_PER_ELEMENT",
        "BackgroundFetchManager",
        "BackgroundFetchRecord",
        "BackgroundFetchRegistration",
        "BarProp",
        "BarcodeDetector",
        "BaseAudioContext",
        "BaseHref",
        "BatteryManager",
        "BeforeInstallPromptEvent",
        "BeforeLoadEvent",
        "BeforeUnloadEvent",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "BiquadFilterNode",
        "Blob",
        "BlobEvent",
        "Bluetooth",
        "BluetoothCharacteristicProperties",
        "BluetoothDevice",
        "BluetoothRemoteGATTCharacteristic",
        "BluetoothRemoteGATTDescriptor",
        "BluetoothRemoteGATTServer",
        "BluetoothRemoteGATTService",
        "BluetoothUUID",
        "Boolean",
        "BroadcastChannel",
        "BrowserCaptureMediaStreamTrack",
        "BrowserInfo",
        "ByteLengthQueuingStrategy",
        "CAPTURING_PHASE",
        "CCW",
        "CDATASection",
        "CDATA_SECTION_NODE",
        "CHANGE",
        "CHARSET_RULE",
        "CHECKING",
        "CLAMP_TO_EDGE",
        "CLICK",
        "CLOSED",
        "CLOSING",
        "COLOR",
        "COLOR_ATTACHMENT0",
        "COLOR_ATTACHMENT1",
        "COLOR_ATTACHMENT10",
        "COLOR_ATTACHMENT11",
        "COLOR_ATTACHMENT12",
        "COLOR_ATTACHMENT13",
        "COLOR_ATTACHMENT14",
        "COLOR_ATTACHMENT15",
        "COLOR_ATTACHMENT2",
        "COLOR_ATTACHMENT3",
        "COLOR_ATTACHMENT4",
        "COLOR_ATTACHMENT5",
        "COLOR_ATTACHMENT6",
        "COLOR_ATTACHMENT7",
        "COLOR_ATTACHMENT8",
        "COLOR_ATTACHMENT9",
        "COLOR_BUFFER_BIT",
        "COLOR_CLEAR_VALUE",
        "COLOR_WRITEMASK",
        "COMMENT_NODE",
        "COMPARE_REF_TO_TEXTURE",
        "COMPILE_STATUS",
        "COMPLETION_STATUS_KHR",
        "COMPRESSED_RGBA_S3TC_DXT1_EXT",
        "COMPRESSED_RGBA_S3TC_DXT3_EXT",
        "COMPRESSED_RGBA_S3TC_DXT5_EXT",
        "COMPRESSED_RGB_S3TC_DXT1_EXT",
        "COMPRESSED_TEXTURE_FORMATS",
        "COMPUTE",
        "CONDITION_SATISFIED",
        "CONFIGURATION_UNSUPPORTED",
        "CONNECTING",
        "CONSTANT_ALPHA",
        "CONSTANT_COLOR",
        "CONSTRAINT_ERR",
        "CONTEXT_LOST_WEBGL",
        "CONTROL_MASK",
        "COPY_DST",
        "COPY_READ_BUFFER",
        "COPY_READ_BUFFER_BINDING",
        "COPY_SRC",
        "COPY_WRITE_BUFFER",
        "COPY_WRITE_BUFFER_BINDING",
        "COUNTER_STYLE_RULE",
        "CSS",
        "CSS2Properties",
        "CSSAnimation",
        "CSSCharsetRule",
        "CSSConditionRule",
        "CSSContainerRule",
        "CSSCounterStyleRule",
        "CSSFontFaceRule",
        "CSSFontFeatureValuesRule",
        "CSSFontPaletteValuesRule",
        "CSSGroupingRule",
        "CSSImageValue",
        "CSSImportRule",
        "CSSKeyframeRule",
        "CSSKeyframesRule",
        "CSSKeywordValue",
        "CSSLayerBlockRule",
        "CSSLayerStatementRule",
        "CSSMarginRule",
        "CSSMathClamp",
        "CSSMathInvert",
        "CSSMathMax",
        "CSSMathMin",
        "CSSMathNegate",
        "CSSMathProduct",
        "CSSMathSum",
        "CSSMathValue",
        "CSSMatrixComponent",
        "CSSMediaRule",
        "CSSMozDocumentRule",
        "CSSNameSpaceRule",
        "CSSNamespaceRule",
        "CSSNestedDeclarations",
        "CSSNumericArray",
        "CSSNumericValue",
        "CSSPageDescriptors",
        "CSSPageRule",
        "CSSPerspective",
        "CSSPositionTryDescriptors",
        "CSSPositionTryRule",
        "CSSPositionValue",
        "CSSPrimitiveValue",
        "CSSPropertyRule",
        "CSSRotate",
        "CSSRule",
        "CSSRuleList",
        "CSSScale",
        "CSSScopeRule",
        "CSSSkew",
        "CSSSkewX",
        "CSSSkewY",
        "CSSStartingStyleRule",
        "CSSStyleDeclaration",
        "CSSStyleRule",
        "CSSStyleSheet",
        "CSSStyleValue",
        "CSSSupportsRule",
        "CSSTransformComponent",
        "CSSTransformValue",
        "CSSTransition",
        "CSSTranslate",
        "CSSUnitValue",
        "CSSUnknownRule",
        "CSSUnparsedValue",
        "CSSValue",
        "CSSValueList",
        "CSSVariableReferenceValue",
        "CSSVariablesDeclaration",
        "CSSVariablesRule",
        "CSSViewTransitionRule",
        "CSSViewportRule",
        "CSS_ATTR",
        "CSS_CM",
        "CSS_COUNTER",
        "CSS_CUSTOM",
        "CSS_DEG",
        "CSS_DIMENSION",
        "CSS_EMS",
        "CSS_EXS",
        "CSS_FILTER_BLUR",
        "CSS_FILTER_BRIGHTNESS",
        "CSS_FILTER_CONTRAST",
        "CSS_FILTER_CUSTOM",
        "CSS_FILTER_DROP_SHADOW",
        "CSS_FILTER_GRAYSCALE",
        "CSS_FILTER_HUE_ROTATE",
        "CSS_FILTER_INVERT",
        "CSS_FILTER_OPACITY",
        "CSS_FILTER_REFERENCE",
        "CSS_FILTER_SATURATE",
        "CSS_FILTER_SEPIA",
        "CSS_GRAD",
        "CSS_HZ",
        "CSS_IDENT",
        "CSS_IN",
        "CSS_INHERIT",
        "CSS_KHZ",
        "CSS_MATRIX",
        "CSS_MATRIX3D",
        "CSS_MM",
        "CSS_MS",
        "CSS_NUMBER",
        "CSS_PC",
        "CSS_PERCENTAGE",
        "CSS_PERSPECTIVE",
        "CSS_PRIMITIVE_VALUE",
        "CSS_PT",
        "CSS_PX",
        "CSS_RAD",
        "CSS_RECT",
        "CSS_RGBCOLOR",
        "CSS_ROTATE",
        "CSS_ROTATE3D",
        "CSS_ROTATEX",
        "CSS_ROTATEY",
        "CSS_ROTATEZ",
        "CSS_S",
        "CSS_SCALE",
        "CSS_SCALE3D",
        "CSS_SCALEX",
        "CSS_SCALEY",
        "CSS_SCALEZ",
        "CSS_SKEW",
        "CSS_SKEWX",
        "CSS_SKEWY",
        "CSS_STRING",
        "CSS_TRANSLATE",
        "CSS_TRANSLATE3D",
        "CSS_TRANSLATEX",
        "CSS_TRANSLATEY",
        "CSS_TRANSLATEZ",
        "CSS_UNKNOWN",
        "CSS_URI",
        "CSS_VALUE_LIST",
        "CSS_VH",
        "CSS_VMAX",
        "CSS_VMIN",
        "CSS_VW",
        "CULL_FACE",
        "CULL_FACE_MODE",
        "CURRENT_PROGRAM",
        "CURRENT_QUERY",
        "CURRENT_VERTEX_ATTRIB",
        "CUSTOM",
        "CW",
        "Cache",
        "CacheStorage",
        "CanvasCaptureMediaStream",
        "CanvasCaptureMediaStreamTrack",
        "CanvasGradient",
        "CanvasPattern",
        "CanvasRenderingContext2D",
        "CaptureController",
        "CaretPosition",
        "ChannelMergerNode",
        "ChannelSplitterNode",
        "ChapterInformation",
        "CharacterBoundsUpdateEvent",
        "CharacterData",
        "ClientRect",
        "ClientRectList",
        "Clipboard",
        "ClipboardEvent",
        "ClipboardItem",
        "CloseEvent",
        "CloseWatcher",
        "Collator",
        "ColorArray",
        "ColorValue",
        "CommandEvent",
        "Comment",
        "CompileError",
        "CompositionEvent",
        "CompressionStream",
        "Console",
        "ConstantSourceNode",
        "ContentVisibilityAutoStateChangeEvent",
        "ContextFilter",
        "ContextType",
        "Controllers",
        "ConvolverNode",
        "CookieChangeEvent",
        "CookieStore",
        "CookieStoreManager",
        "CountQueuingStrategy",
        "Counter",
        "CreateType",
        "Credential",
        "CredentialsContainer",
        "CropTarget",
        "Crypto",
        "CryptoKey",
        "CustomElementRegistry",
        "CustomEvent",
        "CustomStateSet",
        "DATABASE_ERR",
        "DATA_CLONE_ERR",
        "DATA_ERR",
        "DBLCLICK",
        "DECR",
        "DECR_WRAP",
        "DELETE_STATUS",
        "DEPTH",
        "DEPTH24_STENCIL8",
        "DEPTH32F_STENCIL8",
        "DEPTH_ATTACHMENT",
        "DEPTH_BITS",
        "DEPTH_BUFFER_BIT",
        "DEPTH_CLEAR_VALUE",
        "DEPTH_COMPONENT",
        "DEPTH_COMPONENT16",
        "DEPTH_COMPONENT24",
        "DEPTH_COMPONENT32F",
        "DEPTH_FUNC",
        "DEPTH_RANGE",
        "DEPTH_STENCIL",
        "DEPTH_STENCIL_ATTACHMENT",
        "DEPTH_TEST",
        "DEPTH_WRITEMASK",
        "DEVICE_INELIGIBLE",
        "DIRECTION_DOWN",
        "DIRECTION_LEFT",
        "DIRECTION_RIGHT",
        "DIRECTION_UP",
        "DISABLED",
        "DISPATCH_REQUEST_ERR",
        "DITHER",
        "DOCUMENT_FRAGMENT_NODE",
        "DOCUMENT_NODE",
        "DOCUMENT_POSITION_CONTAINED_BY",
        "DOCUMENT_POSITION_CONTAINS",
        "DOCUMENT_POSITION_DISCONNECTED",
        "DOCUMENT_POSITION_FOLLOWING",
        "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
        "DOCUMENT_POSITION_PRECEDING",
        "DOCUMENT_TYPE_NODE",
        "DOMCursor",
        "DOMError",
        "DOMException",
        "DOMImplementation",
        "DOMImplementationLS",
        "DOMMatrix",
        "DOMMatrixReadOnly",
        "DOMParser",
        "DOMPoint",
        "DOMPointReadOnly",
        "DOMQuad",
        "DOMRect",
        "DOMRectList",
        "DOMRectReadOnly",
        "DOMRequest",
        "DOMSTRING_SIZE_ERR",
        "DOMSettableTokenList",
        "DOMStringList",
        "DOMStringMap",
        "DOMTokenList",
        "DOMTransactionEvent",
        "DOM_DELTA_LINE",
        "DOM_DELTA_PAGE",
        "DOM_DELTA_PIXEL",
        "DOM_INPUT_METHOD_DROP",
        "DOM_INPUT_METHOD_HANDWRITING",
        "DOM_INPUT_METHOD_IME",
        "DOM_INPUT_METHOD_KEYBOARD",
        "DOM_INPUT_METHOD_MULTIMODAL",
        "DOM_INPUT_METHOD_OPTION",
        "DOM_INPUT_METHOD_PASTE",
        "DOM_INPUT_METHOD_SCRIPT",
        "DOM_INPUT_METHOD_UNKNOWN",
        "DOM_INPUT_METHOD_VOICE",
        "DOM_KEY_LOCATION_JOYSTICK",
        "DOM_KEY_LOCATION_LEFT",
        "DOM_KEY_LOCATION_MOBILE",
        "DOM_KEY_LOCATION_NUMPAD",
        "DOM_KEY_LOCATION_RIGHT",
        "DOM_KEY_LOCATION_STANDARD",
        "DOM_VK_0",
        "DOM_VK_1",
        "DOM_VK_2",
        "DOM_VK_3",
        "DOM_VK_4",
        "DOM_VK_5",
        "DOM_VK_6",
        "DOM_VK_7",
        "DOM_VK_8",
        "DOM_VK_9",
        "DOM_VK_A",
        "DOM_VK_ACCEPT",
        "DOM_VK_ADD",
        "DOM_VK_ALT",
        "DOM_VK_ALTGR",
        "DOM_VK_AMPERSAND",
        "DOM_VK_ASTERISK",
        "DOM_VK_AT",
        "DOM_VK_ATTN",
        "DOM_VK_B",
        "DOM_VK_BACKSPACE",
        "DOM_VK_BACK_QUOTE",
        "DOM_VK_BACK_SLASH",
        "DOM_VK_BACK_SPACE",
        "DOM_VK_C",
        "DOM_VK_CANCEL",
        "DOM_VK_CAPS_LOCK",
        "DOM_VK_CIRCUMFLEX",
        "DOM_VK_CLEAR",
        "DOM_VK_CLOSE_BRACKET",
        "DOM_VK_CLOSE_CURLY_BRACKET",
        "DOM_VK_CLOSE_PAREN",
        "DOM_VK_COLON",
        "DOM_VK_COMMA",
        "DOM_VK_CONTEXT_MENU",
        "DOM_VK_CONTROL",
        "DOM_VK_CONVERT",
        "DOM_VK_CRSEL",
        "DOM_VK_CTRL",
        "DOM_VK_D",
        "DOM_VK_DECIMAL",
        "DOM_VK_DELETE",
        "DOM_VK_DIVIDE",
        "DOM_VK_DOLLAR",
        "DOM_VK_DOUBLE_QUOTE",
        "DOM_VK_DOWN",
        "DOM_VK_E",
        "DOM_VK_EISU",
        "DOM_VK_END",
        "DOM_VK_ENTER",
        "DOM_VK_EQUALS",
        "DOM_VK_EREOF",
        "DOM_VK_ESCAPE",
        "DOM_VK_EXCLAMATION",
        "DOM_VK_EXECUTE",
        "DOM_VK_EXSEL",
        "DOM_VK_F",
        "DOM_VK_F1",
        "DOM_VK_F10",
        "DOM_VK_F11",
        "DOM_VK_F12",
        "DOM_VK_F13",
        "DOM_VK_F14",
        "DOM_VK_F15",
        "DOM_VK_F16",
        "DOM_VK_F17",
        "DOM_VK_F18",
        "DOM_VK_F19",
        "DOM_VK_F2",
        "DOM_VK_F20",
        "DOM_VK_F21",
        "DOM_VK_F22",
        "DOM_VK_F23",
        "DOM_VK_F24",
        "DOM_VK_F25",
        "DOM_VK_F26",
        "DOM_VK_F27",
        "DOM_VK_F28",
        "DOM_VK_F29",
        "DOM_VK_F3",
        "DOM_VK_F30",
        "DOM_VK_F31",
        "DOM_VK_F32",
        "DOM_VK_F33",
        "DOM_VK_F34",
        "DOM_VK_F35",
        "DOM_VK_F36",
        "DOM_VK_F4",
        "DOM_VK_F5",
        "DOM_VK_F6",
        "DOM_VK_F7",
        "DOM_VK_F8",
        "DOM_VK_F9",
        "DOM_VK_FINAL",
        "DOM_VK_FRONT",
        "DOM_VK_G",
        "DOM_VK_GREATER_THAN",
        "DOM_VK_H",
        "DOM_VK_HANGUL",
        "DOM_VK_HANJA",
        "DOM_VK_HASH",
        "DOM_VK_HELP",
        "DOM_VK_HK_TOGGLE",
        "DOM_VK_HOME",
        "DOM_VK_HYPHEN_MINUS",
        "DOM_VK_I",
        "DOM_VK_INSERT",
        "DOM_VK_J",
        "DOM_VK_JUNJA",
        "DOM_VK_K",
        "DOM_VK_KANA",
        "DOM_VK_KANJI",
        "DOM_VK_L",
        "DOM_VK_LEFT",
        "DOM_VK_LEFT_TAB",
        "DOM_VK_LESS_THAN",
        "DOM_VK_M",
        "DOM_VK_META",
        "DOM_VK_MODECHANGE",
        "DOM_VK_MULTIPLY",
        "DOM_VK_N",
        "DOM_VK_NONCONVERT",
        "DOM_VK_NUMPAD0",
        "DOM_VK_NUMPAD1",
        "DOM_VK_NUMPAD2",
        "DOM_VK_NUMPAD3",
        "DOM_VK_NUMPAD4",
        "DOM_VK_NUMPAD5",
        "DOM_VK_NUMPAD6",
        "DOM_VK_NUMPAD7",
        "DOM_VK_NUMPAD8",
        "DOM_VK_NUMPAD9",
        "DOM_VK_NUM_LOCK",
        "DOM_VK_O",
        "DOM_VK_OEM_1",
        "DOM_VK_OEM_102",
        "DOM_VK_OEM_2",
        "DOM_VK_OEM_3",
        "DOM_VK_OEM_4",
        "DOM_VK_OEM_5",
        "DOM_VK_OEM_6",
        "DOM_VK_OEM_7",
        "DOM_VK_OEM_8",
        "DOM_VK_OEM_COMMA",
        "DOM_VK_OEM_MINUS",
        "DOM_VK_OEM_PERIOD",
        "DOM_VK_OEM_PLUS",
        "DOM_VK_OPEN_BRACKET",
        "DOM_VK_OPEN_CURLY_BRACKET",
        "DOM_VK_OPEN_PAREN",
        "DOM_VK_P",
        "DOM_VK_PA1",
        "DOM_VK_PAGEDOWN",
        "DOM_VK_PAGEUP",
        "DOM_VK_PAGE_DOWN",
        "DOM_VK_PAGE_UP",
        "DOM_VK_PAUSE",
        "DOM_VK_PERCENT",
        "DOM_VK_PERIOD",
        "DOM_VK_PIPE",
        "DOM_VK_PLAY",
        "DOM_VK_PLUS",
        "DOM_VK_PRINT",
        "DOM_VK_PRINTSCREEN",
        "DOM_VK_PROCESSKEY",
        "DOM_VK_PROPERITES",
        "DOM_VK_Q",
        "DOM_VK_QUESTION_MARK",
        "DOM_VK_QUOTE",
        "DOM_VK_R",
        "DOM_VK_REDO",
        "DOM_VK_RETURN",
        "DOM_VK_RIGHT",
        "DOM_VK_S",
        "DOM_VK_SCROLL_LOCK",
        "DOM_VK_SELECT",
        "DOM_VK_SEMICOLON",
        "DOM_VK_SEPARATOR",
        "DOM_VK_SHIFT",
        "DOM_VK_SLASH",
        "DOM_VK_SLEEP",
        "DOM_VK_SPACE",
        "DOM_VK_SUBTRACT",
        "DOM_VK_T",
        "DOM_VK_TAB",
        "DOM_VK_TILDE",
        "DOM_VK_U",
        "DOM_VK_UNDERSCORE",
        "DOM_VK_UNDO",
        "DOM_VK_UNICODE",
        "DOM_VK_UP",
        "DOM_VK_V",
        "DOM_VK_VOLUME_DOWN",
        "DOM_VK_VOLUME_MUTE",
        "DOM_VK_VOLUME_UP",
        "DOM_VK_W",
        "DOM_VK_WIN",
        "DOM_VK_WINDOW",
        "DOM_VK_WIN_ICO_00",
        "DOM_VK_WIN_ICO_CLEAR",
        "DOM_VK_WIN_ICO_HELP",
        "DOM_VK_WIN_OEM_ATTN",
        "DOM_VK_WIN_OEM_AUTO",
        "DOM_VK_WIN_OEM_BACKTAB",
        "DOM_VK_WIN_OEM_CLEAR",
        "DOM_VK_WIN_OEM_COPY",
        "DOM_VK_WIN_OEM_CUSEL",
        "DOM_VK_WIN_OEM_ENLW",
        "DOM_VK_WIN_OEM_FINISH",
        "DOM_VK_WIN_OEM_FJ_JISHO",
        "DOM_VK_WIN_OEM_FJ_LOYA",
        "DOM_VK_WIN_OEM_FJ_MASSHOU",
        "DOM_VK_WIN_OEM_FJ_ROYA",
        "DOM_VK_WIN_OEM_FJ_TOUROKU",
        "DOM_VK_WIN_OEM_JUMP",
        "DOM_VK_WIN_OEM_PA1",
        "DOM_VK_WIN_OEM_PA2",
        "DOM_VK_WIN_OEM_PA3",
        "DOM_VK_WIN_OEM_RESET",
        "DOM_VK_WIN_OEM_WSCTRL",
        "DOM_VK_X",
        "DOM_VK_XF86XK_ADD_FAVORITE",
        "DOM_VK_XF86XK_APPLICATION_LEFT",
        "DOM_VK_XF86XK_APPLICATION_RIGHT",
        "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK",
        "DOM_VK_XF86XK_AUDIO_FORWARD",
        "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME",
        "DOM_VK_XF86XK_AUDIO_MEDIA",
        "DOM_VK_XF86XK_AUDIO_MUTE",
        "DOM_VK_XF86XK_AUDIO_NEXT",
        "DOM_VK_XF86XK_AUDIO_PAUSE",
        "DOM_VK_XF86XK_AUDIO_PLAY",
        "DOM_VK_XF86XK_AUDIO_PREV",
        "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME",
        "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY",
        "DOM_VK_XF86XK_AUDIO_RECORD",
        "DOM_VK_XF86XK_AUDIO_REPEAT",
        "DOM_VK_XF86XK_AUDIO_REWIND",
        "DOM_VK_XF86XK_AUDIO_STOP",
        "DOM_VK_XF86XK_AWAY",
        "DOM_VK_XF86XK_BACK",
        "DOM_VK_XF86XK_BACK_FORWARD",
        "DOM_VK_XF86XK_BATTERY",
        "DOM_VK_XF86XK_BLUE",
        "DOM_VK_XF86XK_BLUETOOTH",
        "DOM_VK_XF86XK_BOOK",
        "DOM_VK_XF86XK_BRIGHTNESS_ADJUST",
        "DOM_VK_XF86XK_CALCULATOR",
        "DOM_VK_XF86XK_CALENDAR",
        "DOM_VK_XF86XK_CD",
        "DOM_VK_XF86XK_CLOSE",
        "DOM_VK_XF86XK_COMMUNITY",
        "DOM_VK_XF86XK_CONTRAST_ADJUST",
        "DOM_VK_XF86XK_COPY",
        "DOM_VK_XF86XK_CUT",
        "DOM_VK_XF86XK_CYCLE_ANGLE",
        "DOM_VK_XF86XK_DISPLAY",
        "DOM_VK_XF86XK_DOCUMENTS",
        "DOM_VK_XF86XK_DOS",
        "DOM_VK_XF86XK_EJECT",
        "DOM_VK_XF86XK_EXCEL",
        "DOM_VK_XF86XK_EXPLORER",
        "DOM_VK_XF86XK_FAVORITES",
        "DOM_VK_XF86XK_FINANCE",
        "DOM_VK_XF86XK_FORWARD",
        "DOM_VK_XF86XK_FRAME_BACK",
        "DOM_VK_XF86XK_FRAME_FORWARD",
        "DOM_VK_XF86XK_GAME",
        "DOM_VK_XF86XK_GO",
        "DOM_VK_XF86XK_GREEN",
        "DOM_VK_XF86XK_HIBERNATE",
        "DOM_VK_XF86XK_HISTORY",
        "DOM_VK_XF86XK_HOME_PAGE",
        "DOM_VK_XF86XK_HOT_LINKS",
        "DOM_VK_XF86XK_I_TOUCH",
        "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN",
        "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP",
        "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF",
        "DOM_VK_XF86XK_LAUNCH0",
        "DOM_VK_XF86XK_LAUNCH1",
        "DOM_VK_XF86XK_LAUNCH2",
        "DOM_VK_XF86XK_LAUNCH3",
        "DOM_VK_XF86XK_LAUNCH4",
        "DOM_VK_XF86XK_LAUNCH5",
        "DOM_VK_XF86XK_LAUNCH6",
        "DOM_VK_XF86XK_LAUNCH7",
        "DOM_VK_XF86XK_LAUNCH8",
        "DOM_VK_XF86XK_LAUNCH9",
        "DOM_VK_XF86XK_LAUNCH_A",
        "DOM_VK_XF86XK_LAUNCH_B",
        "DOM_VK_XF86XK_LAUNCH_C",
        "DOM_VK_XF86XK_LAUNCH_D",
        "DOM_VK_XF86XK_LAUNCH_E",
        "DOM_VK_XF86XK_LAUNCH_F",
        "DOM_VK_XF86XK_LIGHT_BULB",
        "DOM_VK_XF86XK_LOG_OFF",
        "DOM_VK_XF86XK_MAIL",
        "DOM_VK_XF86XK_MAIL_FORWARD",
        "DOM_VK_XF86XK_MARKET",
        "DOM_VK_XF86XK_MEETING",
        "DOM_VK_XF86XK_MEMO",
        "DOM_VK_XF86XK_MENU_KB",
        "DOM_VK_XF86XK_MENU_PB",
        "DOM_VK_XF86XK_MESSENGER",
        "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN",
        "DOM_VK_XF86XK_MON_BRIGHTNESS_UP",
        "DOM_VK_XF86XK_MUSIC",
        "DOM_VK_XF86XK_MY_COMPUTER",
        "DOM_VK_XF86XK_MY_SITES",
        "DOM_VK_XF86XK_NEW",
        "DOM_VK_XF86XK_NEWS",
        "DOM_VK_XF86XK_OFFICE_HOME",
        "DOM_VK_XF86XK_OPEN",
        "DOM_VK_XF86XK_OPEN_URL",
        "DOM_VK_XF86XK_OPTION",
        "DOM_VK_XF86XK_PASTE",
        "DOM_VK_XF86XK_PHONE",
        "DOM_VK_XF86XK_PICTURES",
        "DOM_VK_XF86XK_POWER_DOWN",
        "DOM_VK_XF86XK_POWER_OFF",
        "DOM_VK_XF86XK_RED",
        "DOM_VK_XF86XK_REFRESH",
        "DOM_VK_XF86XK_RELOAD",
        "DOM_VK_XF86XK_REPLY",
        "DOM_VK_XF86XK_ROCKER_DOWN",
        "DOM_VK_XF86XK_ROCKER_ENTER",
        "DOM_VK_XF86XK_ROCKER_UP",
        "DOM_VK_XF86XK_ROTATE_WINDOWS",
        "DOM_VK_XF86XK_ROTATION_KB",
        "DOM_VK_XF86XK_ROTATION_PB",
        "DOM_VK_XF86XK_SAVE",
        "DOM_VK_XF86XK_SCREEN_SAVER",
        "DOM_VK_XF86XK_SCROLL_CLICK",
        "DOM_VK_XF86XK_SCROLL_DOWN",
        "DOM_VK_XF86XK_SCROLL_UP",
        "DOM_VK_XF86XK_SEARCH",
        "DOM_VK_XF86XK_SEND",
        "DOM_VK_XF86XK_SHOP",
        "DOM_VK_XF86XK_SPELL",
        "DOM_VK_XF86XK_SPLIT_SCREEN",
        "DOM_VK_XF86XK_STANDBY",
        "DOM_VK_XF86XK_START",
        "DOM_VK_XF86XK_STOP",
        "DOM_VK_XF86XK_SUBTITLE",
        "DOM_VK_XF86XK_SUPPORT",
        "DOM_VK_XF86XK_SUSPEND",
        "DOM_VK_XF86XK_TASK_PANE",
        "DOM_VK_XF86XK_TERMINAL",
        "DOM_VK_XF86XK_TIME",
        "DOM_VK_XF86XK_TOOLS",
        "DOM_VK_XF86XK_TOP_MENU",
        "DOM_VK_XF86XK_TO_DO_LIST",
        "DOM_VK_XF86XK_TRAVEL",
        "DOM_VK_XF86XK_USER1KB",
        "DOM_VK_XF86XK_USER2KB",
        "DOM_VK_XF86XK_USER_PB",
        "DOM_VK_XF86XK_UWB",
        "DOM_VK_XF86XK_VENDOR_HOME",
        "DOM_VK_XF86XK_VIDEO",
        "DOM_VK_XF86XK_VIEW",
        "DOM_VK_XF86XK_WAKE_UP",
        "DOM_VK_XF86XK_WEB_CAM",
        "DOM_VK_XF86XK_WHEEL_BUTTON",
        "DOM_VK_XF86XK_WLAN",
        "DOM_VK_XF86XK_WORD",
        "DOM_VK_XF86XK_WWW",
        "DOM_VK_XF86XK_XFER",
        "DOM_VK_XF86XK_YELLOW",
        "DOM_VK_XF86XK_ZOOM_IN",
        "DOM_VK_XF86XK_ZOOM_OUT",
        "DOM_VK_Y",
        "DOM_VK_Z",
        "DOM_VK_ZOOM",
        "DONE",
        "DONT_CARE",
        "DOWNLOADING",
        "DRAGDROP",
        "DRAW_BUFFER0",
        "DRAW_BUFFER1",
        "DRAW_BUFFER10",
        "DRAW_BUFFER11",
        "DRAW_BUFFER12",
        "DRAW_BUFFER13",
        "DRAW_BUFFER14",
        "DRAW_BUFFER15",
        "DRAW_BUFFER2",
        "DRAW_BUFFER3",
        "DRAW_BUFFER4",
        "DRAW_BUFFER5",
        "DRAW_BUFFER6",
        "DRAW_BUFFER7",
        "DRAW_BUFFER8",
        "DRAW_BUFFER9",
        "DRAW_FRAMEBUFFER",
        "DRAW_FRAMEBUFFER_BINDING",
        "DST_ALPHA",
        "DST_COLOR",
        "DYNAMIC_COPY",
        "DYNAMIC_DRAW",
        "DYNAMIC_READ",
        "DataChannel",
        "DataTransfer",
        "DataTransferItem",
        "DataTransferItemList",
        "DataView",
        "Date",
        "DateTimeFormat",
        "DecompressionStream",
        "DelayNode",
        "DelegatedInkTrailPresenter",
        "DeprecationReportBody",
        "DesktopNotification",
        "DesktopNotificationCenter",
        "Details",
        "DeviceLightEvent",
        "DeviceMotionEvent",
        "DeviceMotionEventAcceleration",
        "DeviceMotionEventRotationRate",
        "DeviceOrientationEvent",
        "DeviceProximityEvent",
        "DeviceStorage",
        "DeviceStorageChangeEvent",
        "Directory",
        "DisplayNames",
        "Document",
        "DocumentFragment",
        "DocumentPictureInPicture",
        "DocumentPictureInPictureEvent",
        "DocumentTimeline",
        "DocumentType",
        "DragEvent",
        "DurationFormat",
        "DynamicsCompressorNode",
        "E",
        "ELEMENT_ARRAY_BUFFER",
        "ELEMENT_ARRAY_BUFFER_BINDING",
        "ELEMENT_NODE",
        "EMPTY",
        "ENCODING_ERR",
        "ENDED",
        "END_TO_END",
        "END_TO_START",
        "ENTITY_NODE",
        "ENTITY_REFERENCE_NODE",
        "EPSILON",
        "EQUAL",
        "EQUALPOWER",
        "ERROR",
        "EXPONENTIAL_DISTANCE",
        "EditContext",
        "Element",
        "ElementInternals",
        "ElementQuery",
        "EncodedAudioChunk",
        "EncodedVideoChunk",
        "EnterPictureInPictureEvent",
        "Entity",
        "EntityReference",
        "Error",
        "ErrorEvent",
        "EvalError",
        "Event",
        "EventCounts",
        "EventException",
        "EventSource",
        "EventTarget",
        "Exception",
        "ExtensionContext",
        "ExtensionDisabledReason",
        "ExtensionInfo",
        "ExtensionInstallType",
        "ExtensionType",
        "External",
        "EyeDropper",
        "FASTEST",
        "FIDOSDK",
        "FILTER_ACCEPT",
        "FILTER_INTERRUPT",
        "FILTER_REJECT",
        "FILTER_SKIP",
        "FINISHED_STATE",
        "FIRST_ORDERED_NODE_TYPE",
        "FLOAT",
        "FLOAT_32_UNSIGNED_INT_24_8_REV",
        "FLOAT_MAT2",
        "FLOAT_MAT2x3",
        "FLOAT_MAT2x4",
        "FLOAT_MAT3",
        "FLOAT_MAT3x2",
        "FLOAT_MAT3x4",
        "FLOAT_MAT4",
        "FLOAT_MAT4x2",
        "FLOAT_MAT4x3",
        "FLOAT_VEC2",
        "FLOAT_VEC3",
        "FLOAT_VEC4",
        "FOCUS",
        "FONT_FACE_RULE",
        "FONT_FEATURE_VALUES_RULE",
        "FRAGMENT",
        "FRAGMENT_SHADER",
        "FRAGMENT_SHADER_DERIVATIVE_HINT",
        "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
        "FRAMEBUFFER",
        "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",
        "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",
        "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",
        "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",
        "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",
        "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",
        "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
        "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
        "FRAMEBUFFER_ATTACHMENT_RED_SIZE",
        "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",
        "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
        "FRAMEBUFFER_BINDING",
        "FRAMEBUFFER_COMPLETE",
        "FRAMEBUFFER_DEFAULT",
        "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
        "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
        "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
        "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",
        "FRAMEBUFFER_UNSUPPORTED",
        "FRONT",
        "FRONT_AND_BACK",
        "FRONT_FACE",
        "FUNC_ADD",
        "FUNC_REVERSE_SUBTRACT",
        "FUNC_SUBTRACT",
        "FeaturePolicy",
        "FeaturePolicyViolationReportBody",
        "FederatedCredential",
        "Feed",
        "FeedEntry",
        "Fence",
        "FencedFrameConfig",
        "File",
        "FileError",
        "FileList",
        "FileReader",
        "FileSystem",
        "FileSystemDirectoryEntry",
        "FileSystemDirectoryHandle",
        "FileSystemDirectoryReader",
        "FileSystemEntry",
        "FileSystemFileEntry",
        "FileSystemFileHandle",
        "FileSystemHandle",
        "FileSystemWritableFileStream",
        "FinalizationRegistry",
        "FindInPage",
        "Float16Array",
        "Float32Array",
        "Float64Array",
        "FocusEvent",
        "FontData",
        "FontFace",
        "FontFaceSet",
        "FontFaceSetLoadEvent",
        "FormData",
        "FormDataEvent",
        "FragmentDirective",
        "Function",
        "GENERATE_MIPMAP_HINT",
        "GEQUAL",
        "GPU",
        "GPUAdapter",
        "GPUAdapterInfo",
        "GPUBindGroup",
        "GPUBindGroupLayout",
        "GPUBuffer",
        "GPUBufferUsage",
        "GPUCanvasContext",
        "GPUColorWrite",
        "GPUCommandBuffer",
        "GPUCommandEncoder",
        "GPUCompilationInfo",
        "GPUCompilationMessage",
        "GPUComputePassEncoder",
        "GPUComputePipeline",
        "GPUDevice",
        "GPUDeviceLostInfo",
        "GPUError",
        "GPUExternalTexture",
        "GPUInternalError",
        "GPUMapMode",
        "GPUOutOfMemoryError",
        "GPUPipelineError",
        "GPUPipelineLayout",
        "GPUQuerySet",
        "GPUQueue",
        "GPURenderBundle",
        "GPURenderBundleEncoder",
        "GPURenderPassEncoder",
        "GPURenderPipeline",
        "GPUSampler",
        "GPUShaderModule",
        "GPUShaderStage",
        "GPUSupportedFeatures",
        "GPUSupportedLimits",
        "GPUTexture",
        "GPUTextureUsage",
        "GPUTextureView",
        "GPUUncapturedErrorEvent",
        "GPUValidationError",
        "GREATER",
        "GREEN",
        "GREEN_BITS",
        "GainNode",
        "Gamepad",
        "GamepadAxisMoveEvent",
        "GamepadButton",
        "GamepadButtonEvent",
        "GamepadEvent",
        "GamepadHapticActuator",
        "GamepadPose",
        "Geolocation",
        "GeolocationCoordinates",
        "GeolocationPosition",
        "GeolocationPositionError",
        "GestureEvent",
        "GetInfo",
        "Global",
        "GravitySensor",
        "Gyroscope",
        "HALF_FLOAT",
        "HAVE_CURRENT_DATA",
        "HAVE_ENOUGH_DATA",
        "HAVE_FUTURE_DATA",
        "HAVE_METADATA",
        "HAVE_NOTHING",
        "HEADERS_RECEIVED",
        "HID",
        "HIDConnectionEvent",
        "HIDDEN",
        "HIDDevice",
        "HIDInputReportEvent",
        "HIERARCHY_REQUEST_ERR",
        "HIGHPASS",
        "HIGHSHELF",
        "HIGH_FLOAT",
        "HIGH_INT",
        "HORIZONTAL",
        "HORIZONTAL_AXIS",
        "HRTF",
        "HTMLAllCollection",
        "HTMLAnchorElement",
        "HTMLAppletElement",
        "HTMLAreaElement",
        "HTMLAudioElement",
        "HTMLBRElement",
        "HTMLBaseElement",
        "HTMLBaseFontElement",
        "HTMLBlockquoteElement",
        "HTMLBodyElement",
        "HTMLButtonElement",
        "HTMLCanvasElement",
        "HTMLCollection",
        "HTMLCommandElement",
        "HTMLContentElement",
        "HTMLDListElement",
        "HTMLDataElement",
        "HTMLDataListElement",
        "HTMLDetailsElement",
        "HTMLDialogElement",
        "HTMLDirectoryElement",
        "HTMLDivElement",
        "HTMLDocument",
        "HTMLElement",
        "HTMLEmbedElement",
        "HTMLFencedFrameElement",
        "HTMLFieldSetElement",
        "HTMLFontElement",
        "HTMLFormControlsCollection",
        "HTMLFormElement",
        "HTMLFrameElement",
        "HTMLFrameSetElement",
        "HTMLHRElement",
        "HTMLHeadElement",
        "HTMLHeadingElement",
        "HTMLHtmlElement",
        "HTMLIFrameElement",
        "HTMLImageElement",
        "HTMLInputElement",
        "HTMLIsIndexElement",
        "HTMLKeygenElement",
        "HTMLLIElement",
        "HTMLLabelElement",
        "HTMLLegendElement",
        "HTMLLinkElement",
        "HTMLMapElement",
        "HTMLMarqueeElement",
        "HTMLMediaElement",
        "HTMLMenuElement",
        "HTMLMenuItemElement",
        "HTMLMetaElement",
        "HTMLMeterElement",
        "HTMLModElement",
        "HTMLOListElement",
        "HTMLObjectElement",
        "HTMLOptGroupElement",
        "HTMLOptionElement",
        "HTMLOptionsCollection",
        "HTMLOutputElement",
        "HTMLParagraphElement",
        "HTMLParamElement",
        "HTMLPictureElement",
        "HTMLPreElement",
        "HTMLProgressElement",
        "HTMLPropertiesCollection",
        "HTMLQuoteElement",
        "HTMLScriptElement",
        "HTMLSelectElement",
        "HTMLShadowElement",
        "HTMLSlotElement",
        "HTMLSourceElement",
        "HTMLSpanElement",
        "HTMLStyleElement",
        "HTMLTableCaptionElement",
        "HTMLTableCellElement",
        "HTMLTableColElement",
        "HTMLTableElement",
        "HTMLTableRowElement",
        "HTMLTableSectionElement",
        "HTMLTemplateElement",
        "HTMLTextAreaElement",
        "HTMLTimeElement",
        "HTMLTitleElement",
        "HTMLTrackElement",
        "HTMLUListElement",
        "HTMLUnknownElement",
        "HTMLVideoElement",
        "HashChangeEvent",
        "Headers",
        "Highlight",
        "HighlightRegistry",
        "History",
        "Hz",
        "ICE_CHECKING",
        "ICE_CLOSED",
        "ICE_COMPLETED",
        "ICE_CONNECTED",
        "ICE_FAILED",
        "ICE_GATHERING",
        "ICE_WAITING",
        "IDBCursor",
        "IDBCursorWithValue",
        "IDBDatabase",
        "IDBDatabaseException",
        "IDBFactory",
        "IDBFileHandle",
        "IDBFileRequest",
        "IDBIndex",
        "IDBKeyRange",
        "IDBMutableFile",
        "IDBObjectStore",
        "IDBOpenDBRequest",
        "IDBRequest",
        "IDBTransaction",
        "IDBVersionChangeEvent",
        "IDLE",
        "IIRFilterNode",
        "IMPLEMENTATION_COLOR_READ_FORMAT",
        "IMPLEMENTATION_COLOR_READ_TYPE",
        "IMPORT_RULE",
        "INCR",
        "INCR_WRAP",
        "INDEX",
        "INDEX_SIZE_ERR",
        "INDIRECT",
        "INT",
        "INTERLEAVED_ATTRIBS",
        "INT_2_10_10_10_REV",
        "INT_SAMPLER_2D",
        "INT_SAMPLER_2D_ARRAY",
        "INT_SAMPLER_3D",
        "INT_SAMPLER_CUBE",
        "INT_VEC2",
        "INT_VEC3",
        "INT_VEC4",
        "INUSE_ATTRIBUTE_ERR",
        "INVALID_ACCESS_ERR",
        "INVALID_CHARACTER_ERR",
        "INVALID_ENUM",
        "INVALID_EXPRESSION_ERR",
        "INVALID_FRAMEBUFFER_OPERATION",
        "INVALID_INDEX",
        "INVALID_MODIFICATION_ERR",
        "INVALID_NODE_TYPE_ERR",
        "INVALID_OPERATION",
        "INVALID_STATE_ERR",
        "INVALID_VALUE",
        "INVERSE_DISTANCE",
        "INVERT",
        "IceCandidate",
        "IconInfo",
        "IdentityCredential",
        "IdentityCredentialError",
        "IdentityProvider",
        "IdleDeadline",
        "IdleDetector",
        "Image",
        "ImageBitmap",
        "ImageBitmapRenderingContext",
        "ImageCapture",
        "ImageData",
        "ImageDataType",
        "ImageDecoder",
        "ImageTrack",
        "ImageTrackList",
        "Infinity",
        "Ink",
        "InputDeviceCapabilities",
        "InputDeviceInfo",
        "InputEvent",
        "InputMethodContext",
        "InstallTrigger",
        "InstallTriggerImpl",
        "Instance",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Intent",
        "InternalError",
        "IntersectionObserver",
        "IntersectionObserverEntry",
        "Intl",
        "IsSearchProviderInstalled",
        "Iterator",
        "JSON",
        "JSTag",
        "KEEP",
        "KEYDOWN",
        "KEYFRAMES_RULE",
        "KEYFRAME_RULE",
        "KEYPRESS",
        "KEYUP",
        "KeyEvent",
        "Keyboard",
        "KeyboardEvent",
        "KeyboardLayoutMap",
        "KeyframeEffect",
        "LENGTHADJUST_SPACING",
        "LENGTHADJUST_SPACINGANDGLYPHS",
        "LENGTHADJUST_UNKNOWN",
        "LEQUAL",
        "LESS",
        "LINEAR",
        "LINEAR_DISTANCE",
        "LINEAR_MIPMAP_LINEAR",
        "LINEAR_MIPMAP_NEAREST",
        "LINES",
        "LINE_LOOP",
        "LINE_STRIP",
        "LINE_WIDTH",
        "LINK_STATUS",
        "LIVE",
        "LN10",
        "LN2",
        "LOADED",
        "LOADING",
        "LOG10E",
        "LOG2E",
        "LOWPASS",
        "LOWSHELF",
        "LOW_FLOAT",
        "LOW_INT",
        "LSException",
        "LSParserFilter",
        "LUMINANCE",
        "LUMINANCE_ALPHA",
        "LanguageCode",
        "LargestContentfulPaint",
        "LaunchParams",
        "LaunchQueue",
        "LaunchType",
        "LayoutShift",
        "LayoutShiftAttribution",
        "LinearAccelerationSensor",
        "LinkError",
        "ListFormat",
        "LocalMediaStream",
        "Locale",
        "Location",
        "Lock",
        "LockManager",
        "MAP_READ",
        "MAP_WRITE",
        "MARGIN_RULE",
        "MAX",
        "MAX_3D_TEXTURE_SIZE",
        "MAX_ARRAY_TEXTURE_LAYERS",
        "MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND",
        "MAX_CLIENT_WAIT_TIMEOUT_WEBGL",
        "MAX_COLOR_ATTACHMENTS",
        "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",
        "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
        "MAX_COMBINED_UNIFORM_BLOCKS",
        "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
        "MAX_CUBE_MAP_TEXTURE_SIZE",
        "MAX_DRAW_BUFFERS",
        "MAX_ELEMENTS_INDICES",
        "MAX_ELEMENTS_VERTICES",
        "MAX_ELEMENT_INDEX",
        "MAX_FRAGMENT_INPUT_COMPONENTS",
        "MAX_FRAGMENT_UNIFORM_BLOCKS",
        "MAX_FRAGMENT_UNIFORM_COMPONENTS",
        "MAX_FRAGMENT_UNIFORM_VECTORS",
        "MAX_PROGRAM_TEXEL_OFFSET",
        "MAX_RENDERBUFFER_SIZE",
        "MAX_SAFE_INTEGER",
        "MAX_SAMPLES",
        "MAX_SERVER_WAIT_TIMEOUT",
        "MAX_TEXTURE_IMAGE_UNITS",
        "MAX_TEXTURE_LOD_BIAS",
        "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
        "MAX_TEXTURE_SIZE",
        "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
        "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
        "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
        "MAX_UNIFORM_BLOCK_SIZE",
        "MAX_UNIFORM_BUFFER_BINDINGS",
        "MAX_VALUE",
        "MAX_VARYING_COMPONENTS",
        "MAX_VARYING_VECTORS",
        "MAX_VERTEX_ATTRIBS",
        "MAX_VERTEX_OUTPUT_COMPONENTS",
        "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
        "MAX_VERTEX_UNIFORM_BLOCKS",
        "MAX_VERTEX_UNIFORM_COMPONENTS",
        "MAX_VERTEX_UNIFORM_VECTORS",
        "MAX_VIEWPORT_DIMS",
        "MEDIA_ERR_ABORTED",
        "MEDIA_ERR_DECODE",
        "MEDIA_ERR_ENCRYPTED",
        "MEDIA_ERR_NETWORK",
        "MEDIA_ERR_SRC_NOT_SUPPORTED",
        "MEDIA_KEYERR_CLIENT",
        "MEDIA_KEYERR_DOMAIN",
        "MEDIA_KEYERR_HARDWARECHANGE",
        "MEDIA_KEYERR_OUTPUT",
        "MEDIA_KEYERR_SERVICE",
        "MEDIA_KEYERR_UNKNOWN",
        "MEDIA_RULE",
        "MEDIUM_FLOAT",
        "MEDIUM_INT",
        "META_MASK",
        "MIDIAccess",
        "MIDIConnectionEvent",
        "MIDIInput",
        "MIDIInputMap",
        "MIDIMessageEvent",
        "MIDIOutput",
        "MIDIOutputMap",
        "MIDIPort",
        "MIN",
        "MIN_PROGRAM_TEXEL_OFFSET",
        "MIN_SAFE_INTEGER",
        "MIN_VALUE",
        "MIRRORED_REPEAT",
        "MODE_ASYNCHRONOUS",
        "MODE_SYNCHRONOUS",
        "MODIFICATION",
        "MOUSEDOWN",
        "MOUSEDRAG",
        "MOUSEMOVE",
        "MOUSEOUT",
        "MOUSEOVER",
        "MOUSEUP",
        "MOZ_KEYFRAMES_RULE",
        "MOZ_KEYFRAME_RULE",
        "MOZ_SOURCE_CURSOR",
        "MOZ_SOURCE_ERASER",
        "MOZ_SOURCE_KEYBOARD",
        "MOZ_SOURCE_MOUSE",
        "MOZ_SOURCE_PEN",
        "MOZ_SOURCE_TOUCH",
        "MOZ_SOURCE_UNKNOWN",
        "MSGESTURE_FLAG_BEGIN",
        "MSGESTURE_FLAG_CANCEL",
        "MSGESTURE_FLAG_END",
        "MSGESTURE_FLAG_INERTIA",
        "MSGESTURE_FLAG_NONE",
        "MSPOINTER_TYPE_MOUSE",
        "MSPOINTER_TYPE_PEN",
        "MSPOINTER_TYPE_TOUCH",
        "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE",
        "MS_ASYNC_CALLBACK_STATUS_CANCEL",
        "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY",
        "MS_ASYNC_CALLBACK_STATUS_ERROR",
        "MS_ASYNC_CALLBACK_STATUS_JOIN",
        "MS_ASYNC_OP_STATUS_CANCELED",
        "MS_ASYNC_OP_STATUS_ERROR",
        "MS_ASYNC_OP_STATUS_SUCCESS",
        "MS_MANIPULATION_STATE_ACTIVE",
        "MS_MANIPULATION_STATE_CANCELLED",
        "MS_MANIPULATION_STATE_COMMITTED",
        "MS_MANIPULATION_STATE_DRAGGING",
        "MS_MANIPULATION_STATE_INERTIA",
        "MS_MANIPULATION_STATE_PRESELECT",
        "MS_MANIPULATION_STATE_SELECTING",
        "MS_MANIPULATION_STATE_STOPPED",
        "MS_MEDIA_ERR_ENCRYPTED",
        "MS_MEDIA_KEYERR_CLIENT",
        "MS_MEDIA_KEYERR_DOMAIN",
        "MS_MEDIA_KEYERR_HARDWARECHANGE",
        "MS_MEDIA_KEYERR_OUTPUT",
        "MS_MEDIA_KEYERR_SERVICE",
        "MS_MEDIA_KEYERR_UNKNOWN",
        "Map",
        "Math",
        "MathMLElement",
        "MediaCapabilities",
        "MediaCapabilitiesInfo",
        "MediaController",
        "MediaDeviceInfo",
        "MediaDevices",
        "MediaElementAudioSourceNode",
        "MediaEncryptedEvent",
        "MediaError",
        "MediaKeyError",
        "MediaKeyEvent",
        "MediaKeyMessageEvent",
        "MediaKeyNeededEvent",
        "MediaKeySession",
        "MediaKeyStatusMap",
        "MediaKeySystemAccess",
        "MediaKeys",
        "MediaList",
        "MediaMetadata",
        "MediaQueryList",
        "MediaQueryListEvent",
        "MediaRecorder",
        "MediaRecorderErrorEvent",
        "MediaSession",
        "MediaSettingsRange",
        "MediaSource",
        "MediaSourceHandle",
        "MediaStream",
        "MediaStreamAudioDestinationNode",
        "MediaStreamAudioSourceNode",
        "MediaStreamEvent",
        "MediaStreamTrack",
        "MediaStreamTrackAudioSourceNode",
        "MediaStreamTrackAudioStats",
        "MediaStreamTrackEvent",
        "MediaStreamTrackGenerator",
        "MediaStreamTrackProcessor",
        "MediaStreamTrackVideoStats",
        "Memory",
        "MessageChannel",
        "MessageEvent",
        "MessagePort",
        "MessageSender",
        "Methods",
        "MimeType",
        "MimeTypeArray",
        "Module",
        "MouseEvent",
        "MouseScrollEvent",
        "MozAnimation",
        "MozAnimationDelay",
        "MozAnimationDirection",
        "MozAnimationDuration",
        "MozAnimationFillMode",
        "MozAnimationIterationCount",
        "MozAnimationName",
        "MozAnimationPlayState",
        "MozAnimationTimingFunction",
        "MozAppearance",
        "MozBackfaceVisibility",
        "MozBinding",
        "MozBorderBottomColors",
        "MozBorderEnd",
        "MozBorderEndColor",
        "MozBorderEndStyle",
        "MozBorderEndWidth",
        "MozBorderImage",
        "MozBorderLeftColors",
        "MozBorderRightColors",
        "MozBorderStart",
        "MozBorderStartColor",
        "MozBorderStartStyle",
        "MozBorderStartWidth",
        "MozBorderTopColors",
        "MozBoxAlign",
        "MozBoxDirection",
        "MozBoxFlex",
        "MozBoxOrdinalGroup",
        "MozBoxOrient",
        "MozBoxPack",
        "MozBoxSizing",
        "MozCSSKeyframeRule",
        "MozCSSKeyframesRule",
        "MozColumnCount",
        "MozColumnFill",
        "MozColumnGap",
        "MozColumnRule",
        "MozColumnRuleColor",
        "MozColumnRuleStyle",
        "MozColumnRuleWidth",
        "MozColumnWidth",
        "MozColumns",
        "MozContactChangeEvent",
        "MozFloatEdge",
        "MozFontFeatureSettings",
        "MozFontLanguageOverride",
        "MozForceBrokenImageIcon",
        "MozHyphens",
        "MozImageRegion",
        "MozMarginEnd",
        "MozMarginStart",
        "MozMmsEvent",
        "MozMmsMessage",
        "MozMobileMessageThread",
        "MozOSXFontSmoothing",
        "MozOrient",
        "MozOsxFontSmoothing",
        "MozOutlineRadius",
        "MozOutlineRadiusBottomleft",
        "MozOutlineRadiusBottomright",
        "MozOutlineRadiusTopleft",
        "MozOutlineRadiusTopright",
        "MozPaddingEnd",
        "MozPaddingStart",
        "MozPerspective",
        "MozPerspectiveOrigin",
        "MozPowerManager",
        "MozSettingsEvent",
        "MozSmsEvent",
        "MozSmsMessage",
        "MozStackSizing",
        "MozTabSize",
        "MozTextAlignLast",
        "MozTextDecorationColor",
        "MozTextDecorationLine",
        "MozTextDecorationStyle",
        "MozTextSizeAdjust",
        "MozTransform",
        "MozTransformOrigin",
        "MozTransformStyle",
        "MozTransition",
        "MozTransitionDelay",
        "MozTransitionDuration",
        "MozTransitionProperty",
        "MozTransitionTimingFunction",
        "MozUserFocus",
        "MozUserInput",
        "MozUserModify",
        "MozUserSelect",
        "MozWindowDragging",
        "MozWindowShadow",
        "MutationEvent",
        "MutationObserver",
        "MutationRecord",
        "MutedInfo",
        "MutedInfoReason",
        "NAMESPACE_ERR",
        "NAMESPACE_RULE",
        "NEAREST",
        "NEAREST_MIPMAP_LINEAR",
        "NEAREST_MIPMAP_NEAREST",
        "NEGATIVE_INFINITY",
        "NETWORK_EMPTY",
        "NETWORK_ERR",
        "NETWORK_IDLE",
        "NETWORK_LOADED",
        "NETWORK_LOADING",
        "NETWORK_NO_SOURCE",
        "NEVER",
        "NEW",
        "NEXT",
        "NEXT_NO_DUPLICATE",
        "NICEST",
        "NODE_AFTER",
        "NODE_BEFORE",
        "NODE_BEFORE_AND_AFTER",
        "NODE_INSIDE",
        "NONE",
        "NON_TRANSIENT_ERR",
        "NOTATION_NODE",
        "NOTCH",
        "NOTEQUAL",
        "NOT_ALLOWED_ERR",
        "NOT_FOUND_ERR",
        "NOT_READABLE_ERR",
        "NOT_SUPPORTED_ERR",
        "NO_DATA_ALLOWED_ERR",
        "NO_ERR",
        "NO_ERROR",
        "NO_MODIFICATION_ALLOWED_ERR",
        "NUMBER_TYPE",
        "NUM_COMPRESSED_TEXTURE_FORMATS",
        "NaN",
        "NamedNodeMap",
        "NavigateEvent",
        "Navigation",
        "NavigationActivation",
        "NavigationCurrentEntryChangeEvent",
        "NavigationDestination",
        "NavigationHistoryEntry",
        "NavigationPreloadManager",
        "NavigationTransition",
        "Navigator",
        "NavigatorLogin",
        "NavigatorManagedData",
        "NavigatorUAData",
        "NearbyLinks",
        "NetworkInformation",
        "Node",
        "NodeFilter",
        "NodeIterator",
        "NodeList",
        "NotRestoredReasonDetails",
        "NotRestoredReasons",
        "Notation",
        "Notification",
        "NotifyPaintEvent",
        "Number",
        "NumberFormat",
        "OBJECT_TYPE",
        "OBSOLETE",
        "OK",
        "ONE",
        "ONE_MINUS_CONSTANT_ALPHA",
        "ONE_MINUS_CONSTANT_COLOR",
        "ONE_MINUS_DST_ALPHA",
        "ONE_MINUS_DST_COLOR",
        "ONE_MINUS_SRC_ALPHA",
        "ONE_MINUS_SRC_COLOR",
        "OPEN",
        "OPENED",
        "OPENING",
        "ORDERED_NODE_ITERATOR_TYPE",
        "ORDERED_NODE_SNAPSHOT_TYPE",
        "OTHER_ERROR",
        "OTPCredential",
        "OUT_OF_MEMORY",
        "Object",
        "OfflineAudioCompletionEvent",
        "OfflineAudioContext",
        "OfflineResourceList",
        "OffscreenCanvas",
        "OffscreenCanvasRenderingContext2D",
        "OnClickData",
        "OnInstalledReason",
        "OnPerformanceWarningCategory",
        "OnPerformanceWarningSeverity",
        "OnRestartRequiredReason",
        "Option",
        "OrientationSensor",
        "OscillatorNode",
        "OverconstrainedError",
        "OverflowEvent",
        "PACK_ALIGNMENT",
        "PACK_ROW_LENGTH",
        "PACK_SKIP_PIXELS",
        "PACK_SKIP_ROWS",
        "PAGE_RULE",
        "PARSE_ERR",
        "PATHSEG_ARC_ABS",
        "PATHSEG_ARC_REL",
        "PATHSEG_CLOSEPATH",
        "PATHSEG_CURVETO_CUBIC_ABS",
        "PATHSEG_CURVETO_CUBIC_REL",
        "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS",
        "PATHSEG_CURVETO_CUBIC_SMOOTH_REL",
        "PATHSEG_CURVETO_QUADRATIC_ABS",
        "PATHSEG_CURVETO_QUADRATIC_REL",
        "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS",
        "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL",
        "PATHSEG_LINETO_ABS",
        "PATHSEG_LINETO_HORIZONTAL_ABS",
        "PATHSEG_LINETO_HORIZONTAL_REL",
        "PATHSEG_LINETO_REL",
        "PATHSEG_LINETO_VERTICAL_ABS",
        "PATHSEG_LINETO_VERTICAL_REL",
        "PATHSEG_MOVETO_ABS",
        "PATHSEG_MOVETO_REL",
        "PATHSEG_UNKNOWN",
        "PATH_EXISTS_ERR",
        "PEAKING",
        "PERMISSION_DENIED",
        "PERSISTENT",
        "PI",
        "PIXEL_PACK_BUFFER",
        "PIXEL_PACK_BUFFER_BINDING",
        "PIXEL_UNPACK_BUFFER",
        "PIXEL_UNPACK_BUFFER_BINDING",
        "PLAYING_STATE",
        "POINTS",
        "POLYGON_OFFSET_FACTOR",
        "POLYGON_OFFSET_FILL",
        "POLYGON_OFFSET_UNITS",
        "POSITION_UNAVAILABLE",
        "POSITIVE_INFINITY",
        "PREV",
        "PREV_NO_DUPLICATE",
        "PROCESSING_INSTRUCTION_NODE",
        "PageChangeEvent",
        "PageRevealEvent",
        "PageSettings",
        "PageSwapEvent",
        "PageTransitionEvent",
        "PaintRequest",
        "PaintRequestList",
        "PannerNode",
        "PasswordCredential",
        "Path2D",
        "PaymentAddress",
        "PaymentInstruments",
        "PaymentManager",
        "PaymentMethodChangeEvent",
        "PaymentRequest",
        "PaymentRequestUpdateEvent",
        "PaymentResponse",
        "Performance",
        "PerformanceElementTiming",
        "PerformanceEntry",
        "PerformanceEventTiming",
        "PerformanceLongAnimationFrameTiming",
        "PerformanceLongTaskTiming",
        "PerformanceMark",
        "PerformanceMeasure",
        "PerformanceNavigation",
        "PerformanceNavigationTiming",
        "PerformanceObserver",
        "PerformanceObserverEntryList",
        "PerformancePaintTiming",
        "PerformanceResourceTiming",
        "PerformanceScriptTiming",
        "PerformanceServerTiming",
        "PerformanceTiming",
        "PeriodicSyncManager",
        "PeriodicWave",
        "PermissionStatus",
        "Permissions",
        "PhotoCapabilities",
        "PictureInPictureEvent",
        "PictureInPictureWindow",
        "PlatformArch",
        "PlatformInfo",
        "PlatformNaclArch",
        "PlatformOs",
        "Plugin",
        "PluginArray",
        "PluralRules",
        "PointerEvent",
        "PopStateEvent",
        "PopupBlockedEvent",
        "Port",
        "Presentation",
        "PresentationAvailability",
        "PresentationConnection",
        "PresentationConnectionAvailableEvent",
        "PresentationConnectionCloseEvent",
        "PresentationConnectionList",
        "PresentationReceiver",
        "PresentationRequest",
        "PressureObserver",
        "PressureRecord",
        "ProcessingInstruction",
        "Profiler",
        "ProgressEvent",
        "Promise",
        "PromiseRejectionEvent",
        "PropertyNodeList",
        "ProtectedAudience",
        "Proxy",
        "PublicKeyCredential",
        "PushManager",
        "PushSubscription",
        "PushSubscriptionOptions",
        "Q",
        "QUERY_RESOLVE",
        "QUERY_RESULT",
        "QUERY_RESULT_AVAILABLE",
        "QUOTA_ERR",
        "QUOTA_EXCEEDED_ERR",
        "QueryInterface",
        "R11F_G11F_B10F",
        "R16F",
        "R16I",
        "R16UI",
        "R32F",
        "R32I",
        "R32UI",
        "R8",
        "R8I",
        "R8UI",
        "R8_SNORM",
        "RASTERIZER_DISCARD",
        "READ",
        "READ_BUFFER",
        "READ_FRAMEBUFFER",
        "READ_FRAMEBUFFER_BINDING",
        "READ_ONLY",
        "READ_ONLY_ERR",
        "READ_WRITE",
        "RED",
        "RED_BITS",
        "RED_INTEGER",
        "REMOVAL",
        "RENDERBUFFER",
        "RENDERBUFFER_ALPHA_SIZE",
        "RENDERBUFFER_BINDING",
        "RENDERBUFFER_BLUE_SIZE",
        "RENDERBUFFER_DEPTH_SIZE",
        "RENDERBUFFER_GREEN_SIZE",
        "RENDERBUFFER_HEIGHT",
        "RENDERBUFFER_INTERNAL_FORMAT",
        "RENDERBUFFER_RED_SIZE",
        "RENDERBUFFER_SAMPLES",
        "RENDERBUFFER_STENCIL_SIZE",
        "RENDERBUFFER_WIDTH",
        "RENDERER",
        "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC",
        "RENDERING_INTENT_AUTO",
        "RENDERING_INTENT_PERCEPTUAL",
        "RENDERING_INTENT_RELATIVE_COLORIMETRIC",
        "RENDERING_INTENT_SATURATION",
        "RENDERING_INTENT_UNKNOWN",
        "RENDER_ATTACHMENT",
        "REPEAT",
        "REPLACE",
        "RG",
        "RG16F",
        "RG16I",
        "RG16UI",
        "RG32F",
        "RG32I",
        "RG32UI",
        "RG8",
        "RG8I",
        "RG8UI",
        "RG8_SNORM",
        "RGB",
        "RGB10_A2",
        "RGB10_A2UI",
        "RGB16F",
        "RGB16I",
        "RGB16UI",
        "RGB32F",
        "RGB32I",
        "RGB32UI",
        "RGB565",
        "RGB5_A1",
        "RGB8",
        "RGB8I",
        "RGB8UI",
        "RGB8_SNORM",
        "RGB9_E5",
        "RGBA",
        "RGBA16F",
        "RGBA16I",
        "RGBA16UI",
        "RGBA32F",
        "RGBA32I",
        "RGBA32UI",
        "RGBA4",
        "RGBA8",
        "RGBA8I",
        "RGBA8UI",
        "RGBA8_SNORM",
        "RGBA_INTEGER",
        "RGBColor",
        "RGB_INTEGER",
        "RG_INTEGER",
        "ROTATION_CLOCKWISE",
        "ROTATION_COUNTERCLOCKWISE",
        "RTCCertificate",
        "RTCDTMFSender",
        "RTCDTMFToneChangeEvent",
        "RTCDataChannel",
        "RTCDataChannelEvent",
        "RTCDtlsTransport",
        "RTCEncodedAudioFrame",
        "RTCEncodedVideoFrame",
        "RTCError",
        "RTCErrorEvent",
        "RTCIceCandidate",
        "RTCIceTransport",
        "RTCPeerConnection",
        "RTCPeerConnectionIceErrorEvent",
        "RTCPeerConnectionIceEvent",
        "RTCRtpReceiver",
        "RTCRtpScriptTransform",
        "RTCRtpSender",
        "RTCRtpTransceiver",
        "RTCSctpTransport",
        "RTCSessionDescription",
        "RTCStatsReport",
        "RTCTrackEvent",
        "RadioNodeList",
        "Range",
        "RangeError",
        "RangeException",
        "ReadableByteStreamController",
        "ReadableStream",
        "ReadableStreamBYOBReader",
        "ReadableStreamBYOBRequest",
        "ReadableStreamDefaultController",
        "ReadableStreamDefaultReader",
        "RecordErrorEvent",
        "Rect",
        "ReferenceError",
        "Reflect",
        "RegExp",
        "RelativeOrientationSensor",
        "RelativeTimeFormat",
        "RemotePlayback",
        "Report",
        "ReportBody",
        "ReportingObserver",
        "Request",
        "RequestUpdateCheckStatus",
        "ResizeObserver",
        "ResizeObserverEntry",
        "ResizeObserverSize",
        "Response",
        "RuntimeError",
        "SAMPLER_2D",
        "SAMPLER_2D_ARRAY",
        "SAMPLER_2D_ARRAY_SHADOW",
        "SAMPLER_2D_SHADOW",
        "SAMPLER_3D",
        "SAMPLER_BINDING",
        "SAMPLER_CUBE",
        "SAMPLER_CUBE_SHADOW",
        "SAMPLES",
        "SAMPLE_ALPHA_TO_COVERAGE",
        "SAMPLE_BUFFERS",
        "SAMPLE_COVERAGE",
        "SAMPLE_COVERAGE_INVERT",
        "SAMPLE_COVERAGE_VALUE",
        "SAWTOOTH",
        "SCHEDULED_STATE",
        "SCISSOR_BOX",
        "SCISSOR_TEST",
        "SCROLL_PAGE_DOWN",
        "SCROLL_PAGE_UP",
        "SDP_ANSWER",
        "SDP_OFFER",
        "SDP_PRANSWER",
        "SECURITY_ERR",
        "SELECT",
        "SEPARATE_ATTRIBS",
        "SERIALIZE_ERR",
        "SEVERITY_ERROR",
        "SEVERITY_FATAL_ERROR",
        "SEVERITY_WARNING",
        "SHADER_COMPILER",
        "SHADER_TYPE",
        "SHADING_LANGUAGE_VERSION",
        "SHIFT_MASK",
        "SHORT",
        "SHOWING",
        "SHOW_ALL",
        "SHOW_ATTRIBUTE",
        "SHOW_CDATA_SECTION",
        "SHOW_COMMENT",
        "SHOW_DOCUMENT",
        "SHOW_DOCUMENT_FRAGMENT",
        "SHOW_DOCUMENT_TYPE",
        "SHOW_ELEMENT",
        "SHOW_ENTITY",
        "SHOW_ENTITY_REFERENCE",
        "SHOW_NOTATION",
        "SHOW_PROCESSING_INSTRUCTION",
        "SHOW_TEXT",
        "SIGNALED",
        "SIGNED_NORMALIZED",
        "SINE",
        "SOUNDFIELD",
        "SQLException",
        "SQRT1_2",
        "SQRT2",
        "SQUARE",
        "SRC_ALPHA",
        "SRC_ALPHA_SATURATE",
        "SRC_COLOR",
        "SRGB",
        "SRGB8",
        "SRGB8_ALPHA8",
        "START_TO_END",
        "START_TO_START",
        "STATIC_COPY",
        "STATIC_DRAW",
        "STATIC_READ",
        "STENCIL",
        "STENCIL_ATTACHMENT",
        "STENCIL_BACK_FAIL",
        "STENCIL_BACK_FUNC",
        "STENCIL_BACK_PASS_DEPTH_FAIL",
        "STENCIL_BACK_PASS_DEPTH_PASS",
        "STENCIL_BACK_REF",
        "STENCIL_BACK_VALUE_MASK",
        "STENCIL_BACK_WRITEMASK",
        "STENCIL_BITS",
        "STENCIL_BUFFER_BIT",
        "STENCIL_CLEAR_VALUE",
        "STENCIL_FAIL",
        "STENCIL_FUNC",
        "STENCIL_INDEX",
        "STENCIL_INDEX8",
        "STENCIL_PASS_DEPTH_FAIL",
        "STENCIL_PASS_DEPTH_PASS",
        "STENCIL_REF",
        "STENCIL_TEST",
        "STENCIL_VALUE_MASK",
        "STENCIL_WRITEMASK",
        "STORAGE",
        "STORAGE_BINDING",
        "STREAM_COPY",
        "STREAM_DRAW",
        "STREAM_READ",
        "STRING_TYPE",
        "STYLE_RULE",
        "SUBPIXEL_BITS",
        "SUPPORTS_RULE",
        "SVGAElement",
        "SVGAltGlyphDefElement",
        "SVGAltGlyphElement",
        "SVGAltGlyphItemElement",
        "SVGAngle",
        "SVGAnimateColorElement",
        "SVGAnimateElement",
        "SVGAnimateMotionElement",
        "SVGAnimateTransformElement",
        "SVGAnimatedAngle",
        "SVGAnimatedBoolean",
        "SVGAnimatedEnumeration",
        "SVGAnimatedInteger",
        "SVGAnimatedLength",
        "SVGAnimatedLengthList",
        "SVGAnimatedNumber",
        "SVGAnimatedNumberList",
        "SVGAnimatedPreserveAspectRatio",
        "SVGAnimatedRect",
        "SVGAnimatedString",
        "SVGAnimatedTransformList",
        "SVGAnimationElement",
        "SVGCircleElement",
        "SVGClipPathElement",
        "SVGColor",
        "SVGComponentTransferFunctionElement",
        "SVGCursorElement",
        "SVGDefsElement",
        "SVGDescElement",
        "SVGDiscardElement",
        "SVGDocument",
        "SVGElement",
        "SVGElementInstance",
        "SVGElementInstanceList",
        "SVGEllipseElement",
        "SVGException",
        "SVGFEBlendElement",
        "SVGFEColorMatrixElement",
        "SVGFEComponentTransferElement",
        "SVGFECompositeElement",
        "SVGFEConvolveMatrixElement",
        "SVGFEDiffuseLightingElement",
        "SVGFEDisplacementMapElement",
        "SVGFEDistantLightElement",
        "SVGFEDropShadowElement",
        "SVGFEFloodElement",
        "SVGFEFuncAElement",
        "SVGFEFuncBElement",
        "SVGFEFuncGElement",
        "SVGFEFuncRElement",
        "SVGFEGaussianBlurElement",
        "SVGFEImageElement",
        "SVGFEMergeElement",
        "SVGFEMergeNodeElement",
        "SVGFEMorphologyElement",
        "SVGFEOffsetElement",
        "SVGFEPointLightElement",
        "SVGFESpecularLightingElement",
        "SVGFESpotLightElement",
        "SVGFETileElement",
        "SVGFETurbulenceElement",
        "SVGFilterElement",
        "SVGFontElement",
        "SVGFontFaceElement",
        "SVGFontFaceFormatElement",
        "SVGFontFaceNameElement",
        "SVGFontFaceSrcElement",
        "SVGFontFaceUriElement",
        "SVGForeignObjectElement",
        "SVGGElement",
        "SVGGeometryElement",
        "SVGGlyphElement",
        "SVGGlyphRefElement",
        "SVGGradientElement",
        "SVGGraphicsElement",
        "SVGHKernElement",
        "SVGImageElement",
        "SVGLength",
        "SVGLengthList",
        "SVGLineElement",
        "SVGLinearGradientElement",
        "SVGMPathElement",
        "SVGMarkerElement",
        "SVGMaskElement",
        "SVGMatrix",
        "SVGMetadataElement",
        "SVGMissingGlyphElement",
        "SVGNumber",
        "SVGNumberList",
        "SVGPaint",
        "SVGPathElement",
        "SVGPathSeg",
        "SVGPathSegArcAbs",
        "SVGPathSegArcRel",
        "SVGPathSegClosePath",
        "SVGPathSegCurvetoCubicAbs",
        "SVGPathSegCurvetoCubicRel",
        "SVGPathSegCurvetoCubicSmoothAbs",
        "SVGPathSegCurvetoCubicSmoothRel",
        "SVGPathSegCurvetoQuadraticAbs",
        "SVGPathSegCurvetoQuadraticRel",
        "SVGPathSegCurvetoQuadraticSmoothAbs",
        "SVGPathSegCurvetoQuadraticSmoothRel",
        "SVGPathSegLinetoAbs",
        "SVGPathSegLinetoHorizontalAbs",
        "SVGPathSegLinetoHorizontalRel",
        "SVGPathSegLinetoRel",
        "SVGPathSegLinetoVerticalAbs",
        "SVGPathSegLinetoVerticalRel",
        "SVGPathSegList",
        "SVGPathSegMovetoAbs",
        "SVGPathSegMovetoRel",
        "SVGPatternElement",
        "SVGPoint",
        "SVGPointList",
        "SVGPolygonElement",
        "SVGPolylineElement",
        "SVGPreserveAspectRatio",
        "SVGRadialGradientElement",
        "SVGRect",
        "SVGRectElement",
        "SVGRenderingIntent",
        "SVGSVGElement",
        "SVGScriptElement",
        "SVGSetElement",
        "SVGStopElement",
        "SVGStringList",
        "SVGStyleElement",
        "SVGSwitchElement",
        "SVGSymbolElement",
        "SVGTRefElement",
        "SVGTSpanElement",
        "SVGTextContentElement",
        "SVGTextElement",
        "SVGTextPathElement",
        "SVGTextPositioningElement",
        "SVGTitleElement",
        "SVGTransform",
        "SVGTransformList",
        "SVGUnitTypes",
        "SVGUseElement",
        "SVGVKernElement",
        "SVGViewElement",
        "SVGViewSpec",
        "SVGZoomAndPan",
        "SVGZoomEvent",
        "SVG_ANGLETYPE_DEG",
        "SVG_ANGLETYPE_GRAD",
        "SVG_ANGLETYPE_RAD",
        "SVG_ANGLETYPE_UNKNOWN",
        "SVG_ANGLETYPE_UNSPECIFIED",
        "SVG_CHANNEL_A",
        "SVG_CHANNEL_B",
        "SVG_CHANNEL_G",
        "SVG_CHANNEL_R",
        "SVG_CHANNEL_UNKNOWN",
        "SVG_COLORTYPE_CURRENTCOLOR",
        "SVG_COLORTYPE_RGBCOLOR",
        "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR",
        "SVG_COLORTYPE_UNKNOWN",
        "SVG_EDGEMODE_DUPLICATE",
        "SVG_EDGEMODE_NONE",
        "SVG_EDGEMODE_UNKNOWN",
        "SVG_EDGEMODE_WRAP",
        "SVG_FEBLEND_MODE_COLOR",
        "SVG_FEBLEND_MODE_COLOR_BURN",
        "SVG_FEBLEND_MODE_COLOR_DODGE",
        "SVG_FEBLEND_MODE_DARKEN",
        "SVG_FEBLEND_MODE_DIFFERENCE",
        "SVG_FEBLEND_MODE_EXCLUSION",
        "SVG_FEBLEND_MODE_HARD_LIGHT",
        "SVG_FEBLEND_MODE_HUE",
        "SVG_FEBLEND_MODE_LIGHTEN",
        "SVG_FEBLEND_MODE_LUMINOSITY",
        "SVG_FEBLEND_MODE_MULTIPLY",
        "SVG_FEBLEND_MODE_NORMAL",
        "SVG_FEBLEND_MODE_OVERLAY",
        "SVG_FEBLEND_MODE_SATURATION",
        "SVG_FEBLEND_MODE_SCREEN",
        "SVG_FEBLEND_MODE_SOFT_LIGHT",
        "SVG_FEBLEND_MODE_UNKNOWN",
        "SVG_FECOLORMATRIX_TYPE_HUEROTATE",
        "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA",
        "SVG_FECOLORMATRIX_TYPE_MATRIX",
        "SVG_FECOLORMATRIX_TYPE_SATURATE",
        "SVG_FECOLORMATRIX_TYPE_UNKNOWN",
        "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE",
        "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA",
        "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY",
        "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR",
        "SVG_FECOMPONENTTRANSFER_TYPE_TABLE",
        "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN",
        "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC",
        "SVG_FECOMPOSITE_OPERATOR_ATOP",
        "SVG_FECOMPOSITE_OPERATOR_IN",
        "SVG_FECOMPOSITE_OPERATOR_LIGHTER",
        "SVG_FECOMPOSITE_OPERATOR_OUT",
        "SVG_FECOMPOSITE_OPERATOR_OVER",
        "SVG_FECOMPOSITE_OPERATOR_UNKNOWN",
        "SVG_FECOMPOSITE_OPERATOR_XOR",
        "SVG_INVALID_VALUE_ERR",
        "SVG_LENGTHTYPE_CM",
        "SVG_LENGTHTYPE_EMS",
        "SVG_LENGTHTYPE_EXS",
        "SVG_LENGTHTYPE_IN",
        "SVG_LENGTHTYPE_MM",
        "SVG_LENGTHTYPE_NUMBER",
        "SVG_LENGTHTYPE_PC",
        "SVG_LENGTHTYPE_PERCENTAGE",
        "SVG_LENGTHTYPE_PT",
        "SVG_LENGTHTYPE_PX",
        "SVG_LENGTHTYPE_UNKNOWN",
        "SVG_MARKERUNITS_STROKEWIDTH",
        "SVG_MARKERUNITS_UNKNOWN",
        "SVG_MARKERUNITS_USERSPACEONUSE",
        "SVG_MARKER_ORIENT_ANGLE",
        "SVG_MARKER_ORIENT_AUTO",
        "SVG_MARKER_ORIENT_AUTO_START_REVERSE",
        "SVG_MARKER_ORIENT_UNKNOWN",
        "SVG_MASKTYPE_ALPHA",
        "SVG_MASKTYPE_LUMINANCE",
        "SVG_MATRIX_NOT_INVERTABLE",
        "SVG_MEETORSLICE_MEET",
        "SVG_MEETORSLICE_SLICE",
        "SVG_MEETORSLICE_UNKNOWN",
        "SVG_MORPHOLOGY_OPERATOR_DILATE",
        "SVG_MORPHOLOGY_OPERATOR_ERODE",
        "SVG_MORPHOLOGY_OPERATOR_UNKNOWN",
        "SVG_PAINTTYPE_CURRENTCOLOR",
        "SVG_PAINTTYPE_NONE",
        "SVG_PAINTTYPE_RGBCOLOR",
        "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR",
        "SVG_PAINTTYPE_UNKNOWN",
        "SVG_PAINTTYPE_URI",
        "SVG_PAINTTYPE_URI_CURRENTCOLOR",
        "SVG_PAINTTYPE_URI_NONE",
        "SVG_PAINTTYPE_URI_RGBCOLOR",
        "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR",
        "SVG_PRESERVEASPECTRATIO_NONE",
        "SVG_PRESERVEASPECTRATIO_UNKNOWN",
        "SVG_PRESERVEASPECTRATIO_XMAXYMAX",
        "SVG_PRESERVEASPECTRATIO_XMAXYMID",
        "SVG_PRESERVEASPECTRATIO_XMAXYMIN",
        "SVG_PRESERVEASPECTRATIO_XMIDYMAX",
        "SVG_PRESERVEASPECTRATIO_XMIDYMID",
        "SVG_PRESERVEASPECTRATIO_XMIDYMIN",
        "SVG_PRESERVEASPECTRATIO_XMINYMAX",
        "SVG_PRESERVEASPECTRATIO_XMINYMID",
        "SVG_PRESERVEASPECTRATIO_XMINYMIN",
        "SVG_SPREADMETHOD_PAD",
        "SVG_SPREADMETHOD_REFLECT",
        "SVG_SPREADMETHOD_REPEAT",
        "SVG_SPREADMETHOD_UNKNOWN",
        "SVG_STITCHTYPE_NOSTITCH",
        "SVG_STITCHTYPE_STITCH",
        "SVG_STITCHTYPE_UNKNOWN",
        "SVG_TRANSFORM_MATRIX",
        "SVG_TRANSFORM_ROTATE",
        "SVG_TRANSFORM_SCALE",
        "SVG_TRANSFORM_SKEWX",
        "SVG_TRANSFORM_SKEWY",
        "SVG_TRANSFORM_TRANSLATE",
        "SVG_TRANSFORM_UNKNOWN",
        "SVG_TURBULENCE_TYPE_FRACTALNOISE",
        "SVG_TURBULENCE_TYPE_TURBULENCE",
        "SVG_TURBULENCE_TYPE_UNKNOWN",
        "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX",
        "SVG_UNIT_TYPE_UNKNOWN",
        "SVG_UNIT_TYPE_USERSPACEONUSE",
        "SVG_WRONG_TYPE_ERR",
        "SVG_ZOOMANDPAN_DISABLE",
        "SVG_ZOOMANDPAN_MAGNIFY",
        "SVG_ZOOMANDPAN_UNKNOWN",
        "SYNC_CONDITION",
        "SYNC_FENCE",
        "SYNC_FLAGS",
        "SYNC_FLUSH_COMMANDS_BIT",
        "SYNC_GPU_COMMANDS_COMPLETE",
        "SYNC_STATUS",
        "SYNTAX_ERR",
        "SavedPages",
        "Scheduler",
        "Scheduling",
        "Screen",
        "ScreenDetailed",
        "ScreenDetails",
        "ScreenOrientation",
        "Script",
        "ScriptProcessorNode",
        "ScrollAreaEvent",
        "ScrollTimeline",
        "SecurityPolicyViolationEvent",
        "Segmenter",
        "Selection",
        "Sensor",
        "SensorErrorEvent",
        "Serial",
        "SerialPort",
        "ServiceWorker",
        "ServiceWorkerContainer",
        "ServiceWorkerRegistration",
        "SessionDescription",
        "Set",
        "ShadowRoot",
        "SharedArrayBuffer",
        "SharedStorage",
        "SharedStorageWorklet",
        "SharedWorker",
        "SharingState",
        "SimpleGestureEvent",
        "SnapEvent",
        "SourceBuffer",
        "SourceBufferList",
        "SpeechSynthesis",
        "SpeechSynthesisErrorEvent",
        "SpeechSynthesisEvent",
        "SpeechSynthesisUtterance",
        "SpeechSynthesisVoice",
        "StaticRange",
        "StereoPannerNode",
        "StopIteration",
        "Storage",
        "StorageBucket",
        "StorageBucketManager",
        "StorageEvent",
        "StorageManager",
        "String",
        "StructType",
        "StylePropertyMap",
        "StylePropertyMapReadOnly",
        "StyleSheet",
        "StyleSheetList",
        "SubmitEvent",
        "SubtleCrypto",
        "Symbol",
        "SyncManager",
        "SyntaxError",
        "TAB_ID_NONE",
        "TAB_INDEX_NONE",
        "TEMPORARY",
        "TEXTPATH_METHODTYPE_ALIGN",
        "TEXTPATH_METHODTYPE_STRETCH",
        "TEXTPATH_METHODTYPE_UNKNOWN",
        "TEXTPATH_SPACINGTYPE_AUTO",
        "TEXTPATH_SPACINGTYPE_EXACT",
        "TEXTPATH_SPACINGTYPE_UNKNOWN",
        "TEXTURE",
        "TEXTURE0",
        "TEXTURE1",
        "TEXTURE10",
        "TEXTURE11",
        "TEXTURE12",
        "TEXTURE13",
        "TEXTURE14",
        "TEXTURE15",
        "TEXTURE16",
        "TEXTURE17",
        "TEXTURE18",
        "TEXTURE19",
        "TEXTURE2",
        "TEXTURE20",
        "TEXTURE21",
        "TEXTURE22",
        "TEXTURE23",
        "TEXTURE24",
        "TEXTURE25",
        "TEXTURE26",
        "TEXTURE27",
        "TEXTURE28",
        "TEXTURE29",
        "TEXTURE3",
        "TEXTURE30",
        "TEXTURE31",
        "TEXTURE4",
        "TEXTURE5",
        "TEXTURE6",
        "TEXTURE7",
        "TEXTURE8",
        "TEXTURE9",
        "TEXTURE_2D",
        "TEXTURE_2D_ARRAY",
        "TEXTURE_3D",
        "TEXTURE_BASE_LEVEL",
        "TEXTURE_BINDING",
        "TEXTURE_BINDING_2D",
        "TEXTURE_BINDING_2D_ARRAY",
        "TEXTURE_BINDING_3D",
        "TEXTURE_BINDING_CUBE_MAP",
        "TEXTURE_COMPARE_FUNC",
        "TEXTURE_COMPARE_MODE",
        "TEXTURE_CUBE_MAP",
        "TEXTURE_CUBE_MAP_NEGATIVE_X",
        "TEXTURE_CUBE_MAP_NEGATIVE_Y",
        "TEXTURE_CUBE_MAP_NEGATIVE_Z",
        "TEXTURE_CUBE_MAP_POSITIVE_X",
        "TEXTURE_CUBE_MAP_POSITIVE_Y",
        "TEXTURE_CUBE_MAP_POSITIVE_Z",
        "TEXTURE_IMMUTABLE_FORMAT",
        "TEXTURE_IMMUTABLE_LEVELS",
        "TEXTURE_MAG_FILTER",
        "TEXTURE_MAX_ANISOTROPY_EXT",
        "TEXTURE_MAX_LEVEL",
        "TEXTURE_MAX_LOD",
        "TEXTURE_MIN_FILTER",
        "TEXTURE_MIN_LOD",
        "TEXTURE_WRAP_R",
        "TEXTURE_WRAP_S",
        "TEXTURE_WRAP_T",
        "TEXT_NODE",
        "TIMEOUT",
        "TIMEOUT_ERR",
        "TIMEOUT_EXPIRED",
        "TIMEOUT_IGNORED",
        "TOO_LARGE_ERR",
        "TRANSACTION_INACTIVE_ERR",
        "TRANSFORM_FEEDBACK",
        "TRANSFORM_FEEDBACK_ACTIVE",
        "TRANSFORM_FEEDBACK_BINDING",
        "TRANSFORM_FEEDBACK_BUFFER",
        "TRANSFORM_FEEDBACK_BUFFER_BINDING",
        "TRANSFORM_FEEDBACK_BUFFER_MODE",
        "TRANSFORM_FEEDBACK_BUFFER_SIZE",
        "TRANSFORM_FEEDBACK_BUFFER_START",
        "TRANSFORM_FEEDBACK_PAUSED",
        "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",
        "TRANSFORM_FEEDBACK_VARYINGS",
        "TRIANGLE",
        "TRIANGLES",
        "TRIANGLE_FAN",
        "TRIANGLE_STRIP",
        "TYPE_BACK_FORWARD",
        "TYPE_ERR",
        "TYPE_MISMATCH_ERR",
        "TYPE_NAVIGATE",
        "TYPE_RELOAD",
        "TYPE_RESERVED",
        "Tab",
        "TabStatus",
        "Table",
        "Tag",
        "TaskAttributionTiming",
        "TaskController",
        "TaskPriorityChangeEvent",
        "TaskSignal",
        "Text",
        "TextDecoder",
        "TextDecoderStream",
        "TextEncoder",
        "TextEncoderStream",
        "TextEvent",
        "TextFormat",
        "TextFormatUpdateEvent",
        "TextMetrics",
        "TextTrack",
        "TextTrackCue",
        "TextTrackCueList",
        "TextTrackList",
        "TextUpdateEvent",
        "TimeEvent",
        "TimeRanges",
        "ToggleEvent",
        "Touch",
        "TouchEvent",
        "TouchList",
        "TrackEvent",
        "TransformStream",
        "TransformStreamDefaultController",
        "TransitionEvent",
        "TreeWalker",
        "TrustedHTML",
        "TrustedScript",
        "TrustedScriptURL",
        "TrustedTypePolicy",
        "TrustedTypePolicyFactory",
        "TypeError",
        "TypedObject",
        "U2F",
        "UIEvent",
        "UNCACHED",
        "UNIFORM",
        "UNIFORM_ARRAY_STRIDE",
        "UNIFORM_BLOCK_ACTIVE_UNIFORMS",
        "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",
        "UNIFORM_BLOCK_BINDING",
        "UNIFORM_BLOCK_DATA_SIZE",
        "UNIFORM_BLOCK_INDEX",
        "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",
        "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",
        "UNIFORM_BUFFER",
        "UNIFORM_BUFFER_BINDING",
        "UNIFORM_BUFFER_OFFSET_ALIGNMENT",
        "UNIFORM_BUFFER_SIZE",
        "UNIFORM_BUFFER_START",
        "UNIFORM_IS_ROW_MAJOR",
        "UNIFORM_MATRIX_STRIDE",
        "UNIFORM_OFFSET",
        "UNIFORM_SIZE",
        "UNIFORM_TYPE",
        "UNKNOWN_ERR",
        "UNKNOWN_RULE",
        "UNMASKED_RENDERER_WEBGL",
        "UNMASKED_VENDOR_WEBGL",
        "UNORDERED_NODE_ITERATOR_TYPE",
        "UNORDERED_NODE_SNAPSHOT_TYPE",
        "UNPACK_ALIGNMENT",
        "UNPACK_COLORSPACE_CONVERSION_WEBGL",
        "UNPACK_FLIP_Y_WEBGL",
        "UNPACK_IMAGE_HEIGHT",
        "UNPACK_PREMULTIPLY_ALPHA_WEBGL",
        "UNPACK_ROW_LENGTH",
        "UNPACK_SKIP_IMAGES",
        "UNPACK_SKIP_PIXELS",
        "UNPACK_SKIP_ROWS",
        "UNSCHEDULED_STATE",
        "UNSENT",
        "UNSIGNALED",
        "UNSIGNED_BYTE",
        "UNSIGNED_INT",
        "UNSIGNED_INT_10F_11F_11F_REV",
        "UNSIGNED_INT_24_8",
        "UNSIGNED_INT_2_10_10_10_REV",
        "UNSIGNED_INT_5_9_9_9_REV",
        "UNSIGNED_INT_SAMPLER_2D",
        "UNSIGNED_INT_SAMPLER_2D_ARRAY",
        "UNSIGNED_INT_SAMPLER_3D",
        "UNSIGNED_INT_SAMPLER_CUBE",
        "UNSIGNED_INT_VEC2",
        "UNSIGNED_INT_VEC3",
        "UNSIGNED_INT_VEC4",
        "UNSIGNED_NORMALIZED",
        "UNSIGNED_SHORT",
        "UNSIGNED_SHORT_4_4_4_4",
        "UNSIGNED_SHORT_5_5_5_1",
        "UNSIGNED_SHORT_5_6_5",
        "UNSPECIFIED_EVENT_TYPE_ERR",
        "UPDATEREADY",
        "URIError",
        "URL",
        "URLPattern",
        "URLSearchParams",
        "URLUnencoded",
        "URL_MISMATCH_ERR",
        "USB",
        "USBAlternateInterface",
        "USBConfiguration",
        "USBConnectionEvent",
        "USBDevice",
        "USBEndpoint",
        "USBInTransferResult",
        "USBInterface",
        "USBIsochronousInTransferPacket",
        "USBIsochronousInTransferResult",
        "USBIsochronousOutTransferPacket",
        "USBIsochronousOutTransferResult",
        "USBOutTransferResult",
        "UTC",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "UpdateFilter",
        "UpdatePropertyName",
        "UserActivation",
        "UserMessageHandler",
        "UserMessageHandlersNamespace",
        "UserProximityEvent",
        "VALIDATE_STATUS",
        "VALIDATION_ERR",
        "VARIABLES_RULE",
        "VENDOR",
        "VERSION",
        "VERSION_CHANGE",
        "VERSION_ERR",
        "VERTEX",
        "VERTEX_ARRAY_BINDING",
        "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
        "VERTEX_ATTRIB_ARRAY_DIVISOR",
        "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
        "VERTEX_ATTRIB_ARRAY_ENABLED",
        "VERTEX_ATTRIB_ARRAY_INTEGER",
        "VERTEX_ATTRIB_ARRAY_NORMALIZED",
        "VERTEX_ATTRIB_ARRAY_POINTER",
        "VERTEX_ATTRIB_ARRAY_SIZE",
        "VERTEX_ATTRIB_ARRAY_STRIDE",
        "VERTEX_ATTRIB_ARRAY_TYPE",
        "VERTEX_SHADER",
        "VERTICAL",
        "VERTICAL_AXIS",
        "VER_ERR",
        "VIEWPORT",
        "VIEWPORT_RULE",
        "VRDisplay",
        "VRDisplayCapabilities",
        "VRDisplayEvent",
        "VREyeParameters",
        "VRFieldOfView",
        "VRFrameData",
        "VRPose",
        "VRStageParameters",
        "VTTCue",
        "VTTRegion",
        "ValidityState",
        "VideoColorSpace",
        "VideoDecoder",
        "VideoEncoder",
        "VideoFrame",
        "VideoPlaybackQuality",
        "VideoStreamTrack",
        "ViewTimeline",
        "ViewTransition",
        "ViewTransitionTypeSet",
        "ViewType",
        "VirtualKeyboard",
        "VirtualKeyboardGeometryChangeEvent",
        "VisibilityStateEntry",
        "VisualViewport",
        "WAIT_FAILED",
        "WEBKIT_FILTER_RULE",
        "WEBKIT_KEYFRAMES_RULE",
        "WEBKIT_KEYFRAME_RULE",
        "WEBKIT_REGION_RULE",
        "WGSLLanguageFeatures",
        "WINDOW_ID_CURRENT",
        "WINDOW_ID_NONE",
        "WRITE",
        "WRONG_DOCUMENT_ERR",
        "WakeLock",
        "WakeLockSentinel",
        "WasmAnyRef",
        "WaveShaperNode",
        "WeakMap",
        "WeakRef",
        "WeakSet",
        "WebAssembly",
        "WebGL2RenderingContext",
        "WebGLActiveInfo",
        "WebGLBuffer",
        "WebGLContextEvent",
        "WebGLFramebuffer",
        "WebGLObject",
        "WebGLProgram",
        "WebGLQuery",
        "WebGLRenderbuffer",
        "WebGLRenderingContext",
        "WebGLSampler",
        "WebGLShader",
        "WebGLShaderPrecisionFormat",
        "WebGLSync",
        "WebGLTexture",
        "WebGLTransformFeedback",
        "WebGLUniformLocation",
        "WebGLVertexArray",
        "WebGLVertexArrayObject",
        "WebKitAnimationEvent",
        "WebKitBlobBuilder",
        "WebKitCSSFilterRule",
        "WebKitCSSFilterValue",
        "WebKitCSSKeyframeRule",
        "WebKitCSSKeyframesRule",
        "WebKitCSSMatrix",
        "WebKitCSSRegionRule",
        "WebKitCSSTransformValue",
        "WebKitDataCue",
        "WebKitGamepad",
        "WebKitMediaKeyError",
        "WebKitMediaKeyMessageEvent",
        "WebKitMediaKeySession",
        "WebKitMediaKeys",
        "WebKitMediaSource",
        "WebKitMutationObserver",
        "WebKitNamespace",
        "WebKitPlaybackTargetAvailabilityEvent",
        "WebKitPoint",
        "WebKitShadowRoot",
        "WebKitSourceBuffer",
        "WebKitSourceBufferList",
        "WebKitTransitionEvent",
        "WebSocket",
        "WebSocketError",
        "WebSocketStream",
        "WebTransport",
        "WebTransportBidirectionalStream",
        "WebTransportDatagramDuplexStream",
        "WebTransportError",
        "WebTransportReceiveStream",
        "WebTransportSendStream",
        "WebkitAlignContent",
        "WebkitAlignItems",
        "WebkitAlignSelf",
        "WebkitAnimation",
        "WebkitAnimationDelay",
        "WebkitAnimationDirection",
        "WebkitAnimationDuration",
        "WebkitAnimationFillMode",
        "WebkitAnimationIterationCount",
        "WebkitAnimationName",
        "WebkitAnimationPlayState",
        "WebkitAnimationTimingFunction",
        "WebkitAppearance",
        "WebkitBackfaceVisibility",
        "WebkitBackgroundClip",
        "WebkitBackgroundOrigin",
        "WebkitBackgroundSize",
        "WebkitBorderBottomLeftRadius",
        "WebkitBorderBottomRightRadius",
        "WebkitBorderImage",
        "WebkitBorderRadius",
        "WebkitBorderTopLeftRadius",
        "WebkitBorderTopRightRadius",
        "WebkitBoxAlign",
        "WebkitBoxDirection",
        "WebkitBoxFlex",
        "WebkitBoxOrdinalGroup",
        "WebkitBoxOrient",
        "WebkitBoxPack",
        "WebkitBoxShadow",
        "WebkitBoxSizing",
        "WebkitClipPath",
        "WebkitFilter",
        "WebkitFlex",
        "WebkitFlexBasis",
        "WebkitFlexDirection",
        "WebkitFlexFlow",
        "WebkitFlexGrow",
        "WebkitFlexShrink",
        "WebkitFlexWrap",
        "WebkitFontFeatureSettings",
        "WebkitJustifyContent",
        "WebkitLineClamp",
        "WebkitMask",
        "WebkitMaskClip",
        "WebkitMaskComposite",
        "WebkitMaskImage",
        "WebkitMaskOrigin",
        "WebkitMaskPosition",
        "WebkitMaskPositionX",
        "WebkitMaskPositionY",
        "WebkitMaskRepeat",
        "WebkitMaskSize",
        "WebkitOrder",
        "WebkitPerspective",
        "WebkitPerspectiveOrigin",
        "WebkitTextFillColor",
        "WebkitTextSecurity",
        "WebkitTextSizeAdjust",
        "WebkitTextStroke",
        "WebkitTextStrokeColor",
        "WebkitTextStrokeWidth",
        "WebkitTransform",
        "WebkitTransformOrigin",
        "WebkitTransformStyle",
        "WebkitTransition",
        "WebkitTransitionDelay",
        "WebkitTransitionDuration",
        "WebkitTransitionProperty",
        "WebkitTransitionTimingFunction",
        "WebkitUserSelect",
        "WheelEvent",
        "Window",
        "WindowControlsOverlay",
        "WindowControlsOverlayGeometryChangeEvent",
        "WindowState",
        "WindowType",
        "Worker",
        "Worklet",
        "WritableStream",
        "WritableStreamDefaultController",
        "WritableStreamDefaultWriter",
        "XMLDocument",
        "XMLHttpRequest",
        "XMLHttpRequestEventTarget",
        "XMLHttpRequestException",
        "XMLHttpRequestProgressEvent",
        "XMLHttpRequestUpload",
        "XMLSerializer",
        "XMLStylesheetProcessingInstruction",
        "XPathEvaluator",
        "XPathException",
        "XPathExpression",
        "XPathNSResolver",
        "XPathResult",
        "XRAnchor",
        "XRAnchorSet",
        "XRBoundedReferenceSpace",
        "XRCPUDepthInformation",
        "XRCamera",
        "XRDOMOverlayState",
        "XRDepthInformation",
        "XRFrame",
        "XRHand",
        "XRHitTestResult",
        "XRHitTestSource",
        "XRInputSource",
        "XRInputSourceArray",
        "XRInputSourceEvent",
        "XRInputSourcesChangeEvent",
        "XRJointPose",
        "XRJointSpace",
        "XRLayer",
        "XRLightEstimate",
        "XRLightProbe",
        "XRPose",
        "XRRay",
        "XRReferenceSpace",
        "XRReferenceSpaceEvent",
        "XRRenderState",
        "XRRigidTransform",
        "XRSession",
        "XRSessionEvent",
        "XRSpace",
        "XRSystem",
        "XRTransientInputHitTestResult",
        "XRTransientInputHitTestSource",
        "XRView",
        "XRViewerPose",
        "XRViewport",
        "XRWebGLBinding",
        "XRWebGLDepthInformation",
        "XRWebGLLayer",
        "XSLTProcessor",
        "ZERO",
        "ZoomSettings",
        "ZoomSettingsMode",
        "ZoomSettingsScope",
        "_XD0M_",
        "_YD0M_",
        "__REACT_DEVTOOLS_GLOBAL_HOOK__",
        "__brand",
        "__defineGetter__",
        "__defineSetter__",
        "__lookupGetter__",
        "__lookupSetter__",
        "__opera",
        "__proto__",
        "_browserjsran",
        "a",
        "aLink",
        "abbr",
        "abort",
        "aborted",
        "aboutConfigPrefs",
        "abs",
        "absolute",
        "acceleration",
        "accelerationIncludingGravity",
        "accelerator",
        "accent-color",
        "accentColor",
        "accept",
        "acceptCharset",
        "acceptNode",
        "access",
        "accessKey",
        "accessKeyLabel",
        "accuracy",
        "acos",
        "acosh",
        "action",
        "actionURL",
        "actions",
        "activated",
        "activation",
        "activationStart",
        "active",
        "activeCues",
        "activeElement",
        "activeSourceBuffers",
        "activeSourceCount",
        "activeTexture",
        "activeVRDisplays",
        "activityLog",
        "actualBoundingBoxAscent",
        "actualBoundingBoxDescent",
        "actualBoundingBoxLeft",
        "actualBoundingBoxRight",
        "adAuctionComponents",
        "adAuctionHeaders",
        "add",
        "addAll",
        "addBehavior",
        "addCandidate",
        "addColorStop",
        "addCue",
        "addElement",
        "addEventListener",
        "addFilter",
        "addFromString",
        "addFromUri",
        "addIceCandidate",
        "addImport",
        "addListener",
        "addModule",
        "addNamed",
        "addPageRule",
        "addPath",
        "addPointer",
        "addRange",
        "addRegion",
        "addRule",
        "addSearchEngine",
        "addSourceBuffer",
        "addStream",
        "addTextTrack",
        "addTrack",
        "addTransceiver",
        "addWakeLockListener",
        "added",
        "addedNodes",
        "additionalName",
        "additiveSymbols",
        "addons",
        "address",
        "addressLine",
        "addressModeU",
        "addressModeV",
        "addressModeW",
        "adoptNode",
        "adoptedCallback",
        "adoptedStyleSheets",
        "adr",
        "advance",
        "after",
        "alarms",
        "album",
        "alert",
        "algorithm",
        "align",
        "align-content",
        "align-items",
        "align-self",
        "alignContent",
        "alignItems",
        "alignSelf",
        "alignmentBaseline",
        "alinkColor",
        "all",
        "allSettled",
        "allocationSize",
        "allow",
        "allowFullscreen",
        "allowPaymentRequest",
        "allowedDirections",
        "allowedFeatures",
        "allowedToPlay",
        "allowsFeature",
        "alpha",
        "alphaMode",
        "alphaToCoverageEnabled",
        "alphabeticBaseline",
        "alt",
        "altGraphKey",
        "altHtml",
        "altKey",
        "altLeft",
        "alternate",
        "alternateSetting",
        "alternates",
        "altitude",
        "altitudeAccuracy",
        "altitudeAngle",
        "amplitude",
        "ancestorOrigins",
        "anchor",
        "anchorNode",
        "anchorOffset",
        "anchorSpace",
        "anchors",
        "and",
        "angle",
        "angularAcceleration",
        "angularVelocity",
        "animVal",
        "animate",
        "animated",
        "animatedInstanceRoot",
        "animatedNormalizedPathSegList",
        "animatedPathSegList",
        "animatedPoints",
        "animation",
        "animation-composition",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "animationComposition",
        "animationDelay",
        "animationDirection",
        "animationDuration",
        "animationFillMode",
        "animationIterationCount",
        "animationName",
        "animationPlayState",
        "animationStartTime",
        "animationTimingFunction",
        "animationsPaused",
        "anniversary",
        "antialias",
        "anticipatedRemoval",
        "any",
        "app",
        "appCodeName",
        "appMinorVersion",
        "appName",
        "appNotifications",
        "appVersion",
        "appearance",
        "append",
        "appendBuffer",
        "appendChild",
        "appendData",
        "appendItem",
        "appendMedium",
        "appendNamed",
        "appendRule",
        "appendStream",
        "appendWindowEnd",
        "appendWindowStart",
        "applets",
        "applicationCache",
        "applicationServerKey",
        "apply",
        "applyConstraints",
        "applyElement",
        "arc",
        "arcTo",
        "arch",
        "architecture",
        "archive",
        "areas",
        "arguments",
        "ariaAtomic",
        "ariaAutoComplete",
        "ariaBrailleLabel",
        "ariaBrailleRoleDescription",
        "ariaBusy",
        "ariaChecked",
        "ariaColCount",
        "ariaColIndex",
        "ariaColIndexText",
        "ariaColSpan",
        "ariaCurrent",
        "ariaDescription",
        "ariaDisabled",
        "ariaExpanded",
        "ariaHasPopup",
        "ariaHidden",
        "ariaInvalid",
        "ariaKeyShortcuts",
        "ariaLabel",
        "ariaLevel",
        "ariaLive",
        "ariaModal",
        "ariaMultiLine",
        "ariaMultiSelectable",
        "ariaOrientation",
        "ariaPlaceholder",
        "ariaPosInSet",
        "ariaPressed",
        "ariaReadOnly",
        "ariaRelevant",
        "ariaRequired",
        "ariaRoleDescription",
        "ariaRowCount",
        "ariaRowIndex",
        "ariaRowIndexText",
        "ariaRowSpan",
        "ariaSelected",
        "ariaSetSize",
        "ariaSort",
        "ariaValueMax",
        "ariaValueMin",
        "ariaValueNow",
        "ariaValueText",
        "arrayBuffer",
        "arrayLayerCount",
        "arrayStride",
        "artist",
        "artwork",
        "as",
        "asIntN",
        "asUintN",
        "ascentOverride",
        "asin",
        "asinh",
        "aspect",
        "aspect-ratio",
        "aspectRatio",
        "assert",
        "assign",
        "assignedElements",
        "assignedNodes",
        "assignedSlot",
        "async",
        "asyncDispose",
        "asyncIterator",
        "at",
        "atEnd",
        "atan",
        "atan2",
        "atanh",
        "atob",
        "attachEvent",
        "attachInternals",
        "attachShader",
        "attachShadow",
        "attachedElements",
        "attachments",
        "attack",
        "attestationObject",
        "attrChange",
        "attrName",
        "attributeChangedCallback",
        "attributeFilter",
        "attributeName",
        "attributeNamespace",
        "attributeOldValue",
        "attributeStyleMap",
        "attributes",
        "attribution",
        "attributionSrc",
        "audioBitrateMode",
        "audioBitsPerSecond",
        "audioTracks",
        "audioWorklet",
        "authenticatedSignedWrites",
        "authenticatorAttachment",
        "authenticatorData",
        "autoIncrement",
        "autobuffer",
        "autocapitalize",
        "autocomplete",
        "autocorrect",
        "autofocus",
        "automationRate",
        "autoplay",
        "availHeight",
        "availLeft",
        "availTop",
        "availWidth",
        "availability",
        "available",
        "averageLatency",
        "aversion",
        "ax",
        "axes",
        "axis",
        "ay",
        "azimuth",
        "azimuthAngle",
        "b",
        "back",
        "backdrop-filter",
        "backdropFilter",
        "backends",
        "backface-visibility",
        "backfaceVisibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-position-x",
        "background-position-y",
        "background-repeat",
        "background-size",
        "backgroundAttachment",
        "backgroundBlendMode",
        "backgroundClip",
        "backgroundColor",
        "backgroundFetch",
        "backgroundImage",
        "backgroundOrigin",
        "backgroundPosition",
        "backgroundPositionX",
        "backgroundPositionY",
        "backgroundRepeat",
        "backgroundSize",
        "badInput",
        "badge",
        "balance",
        "baseArrayLayer",
        "baseFrequencyX",
        "baseFrequencyY",
        "baseLatency",
        "baseLayer",
        "baseMipLevel",
        "baseNode",
        "baseOffset",
        "basePalette",
        "baseURI",
        "baseVal",
        "baseline-source",
        "baselineShift",
        "baselineSource",
        "battery",
        "bday",
        "before",
        "beginComputePass",
        "beginElement",
        "beginElementAt",
        "beginOcclusionQuery",
        "beginPath",
        "beginQuery",
        "beginRenderPass",
        "beginTransformFeedback",
        "beginningOfPassWriteIndex",
        "behavior",
        "behaviorCookie",
        "behaviorPart",
        "behaviorUrns",
        "beta",
        "bezierCurveTo",
        "bgColor",
        "bgProperties",
        "bias",
        "big",
        "bigint64",
        "biguint64",
        "binaryType",
        "bind",
        "bindAttribLocation",
        "bindBuffer",
        "bindBufferBase",
        "bindBufferRange",
        "bindFramebuffer",
        "bindGroupLayouts",
        "bindRenderbuffer",
        "bindSampler",
        "bindTexture",
        "bindTransformFeedback",
        "bindVertexArray",
        "binding",
        "bitness",
        "blend",
        "blendColor",
        "blendEquation",
        "blendEquationSeparate",
        "blendFunc",
        "blendFuncSeparate",
        "blink",
        "blitFramebuffer",
        "blob",
        "block-size",
        "blockDirection",
        "blockSize",
        "blockedURI",
        "blocking",
        "blockingDuration",
        "blue",
        "bluetooth",
        "blur",
        "body",
        "bodyUsed",
        "bold",
        "bookmarks",
        "booleanValue",
        "border",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-end-end-radius",
        "border-end-start-radius",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-start-end-radius",
        "border-start-start-radius",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "borderBlock",
        "borderBlockColor",
        "borderBlockEnd",
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth",
        "borderBlockStart",
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth",
        "borderBlockStyle",
        "borderBlockWidth",
        "borderBottom",
        "borderBottomColor",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderBottomStyle",
        "borderBottomWidth",
        "borderBoxSize",
        "borderCollapse",
        "borderColor",
        "borderColorDark",
        "borderColorLight",
        "borderEndEndRadius",
        "borderEndStartRadius",
        "borderImage",
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth",
        "borderInline",
        "borderInlineColor",
        "borderInlineEnd",
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth",
        "borderInlineStart",
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth",
        "borderInlineStyle",
        "borderInlineWidth",
        "borderLeft",
        "borderLeftColor",
        "borderLeftStyle",
        "borderLeftWidth",
        "borderRadius",
        "borderRight",
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth",
        "borderSpacing",
        "borderStartEndRadius",
        "borderStartStartRadius",
        "borderStyle",
        "borderTop",
        "borderTopColor",
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderTopStyle",
        "borderTopWidth",
        "borderWidth",
        "bottom",
        "bottomMargin",
        "bound",
        "boundElements",
        "boundingClientRect",
        "boundingHeight",
        "boundingLeft",
        "boundingRect",
        "boundingTop",
        "boundingWidth",
        "bounds",
        "boundsGeometry",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "boxDecorationBreak",
        "boxShadow",
        "boxSizing",
        "brand",
        "brands",
        "break-after",
        "break-before",
        "break-inside",
        "breakAfter",
        "breakBefore",
        "breakInside",
        "broadcast",
        "browser",
        "browserLanguage",
        "browserSettings",
        "browsingData",
        "browsingTopics",
        "btoa",
        "bubbles",
        "buffer",
        "bufferData",
        "bufferDepth",
        "bufferSize",
        "bufferSubData",
        "buffered",
        "bufferedAmount",
        "bufferedAmountLowThreshold",
        "buffers",
        "buildID",
        "buildNumber",
        "button",
        "buttonID",
        "buttons",
        "byobRequest",
        "byteLength",
        "byteOffset",
        "bytes",
        "bytesPerRow",
        "bytesWritten",
        "c",
        "cache",
        "caches",
        "call",
        "caller",
        "camera",
        "canBeFormatted",
        "canBeMounted",
        "canBeShared",
        "canConstructInDedicatedWorker",
        "canGoBack",
        "canGoForward",
        "canHaveChildren",
        "canHaveHTML",
        "canInsertDTMF",
        "canIntercept",
        "canLoadAdAuctionFencedFrame",
        "canLoadOpaqueURL",
        "canMakePayment",
        "canParse",
        "canPlayType",
        "canPresent",
        "canShare",
        "canTransition",
        "canTrickleIceCandidates",
        "cancel",
        "cancelAndHoldAtTime",
        "cancelAnimationFrame",
        "cancelBubble",
        "cancelIdleCallback",
        "cancelScheduledValues",
        "cancelVideoFrameCallback",
        "cancelWatchAvailability",
        "cancelable",
        "candidate",
        "canonicalUUID",
        "canvas",
        "cap",
        "capabilities",
        "caption",
        "caption-side",
        "captionSide",
        "captivePortal",
        "capture",
        "captureEvents",
        "captureStackTrace",
        "captureStream",
        "captureTab",
        "captureVisibleTab",
        "caret-color",
        "caretBidiLevel",
        "caretColor",
        "caretPositionFromPoint",
        "caretRangeFromPoint",
        "cast",
        "catch",
        "category",
        "cbrt",
        "cd",
        "ceil",
        "cellIndex",
        "cellPadding",
        "cellSpacing",
        "cells",
        "ch",
        "chOff",
        "chain",
        "challenge",
        "changeType",
        "changed",
        "changedTouches",
        "channel",
        "channelCount",
        "channelCountMode",
        "channelInterpretation",
        "chapterInfo",
        "char",
        "charAt",
        "charCode",
        "charCodeAt",
        "charIndex",
        "charLength",
        "characterBounds",
        "characterBoundsRangeStart",
        "characterData",
        "characterDataOldValue",
        "characterSet",
        "characteristic",
        "charging",
        "chargingTime",
        "charset",
        "check",
        "checkDCE",
        "checkEnclosure",
        "checkFramebufferStatus",
        "checkIntersection",
        "checkValidity",
        "checkVisibility",
        "checked",
        "childElementCount",
        "childList",
        "childNodes",
        "children",
        "chrome",
        "ciphertext",
        "cite",
        "city",
        "claimInterface",
        "claimed",
        "classList",
        "className",
        "classid",
        "clear",
        "clearAppBadge",
        "clearAttributes",
        "clearBuffer",
        "clearBufferfi",
        "clearBufferfv",
        "clearBufferiv",
        "clearBufferuiv",
        "clearColor",
        "clearData",
        "clearDepth",
        "clearHalt",
        "clearImmediate",
        "clearInterval",
        "clearLiveSeekableRange",
        "clearMarks",
        "clearMaxGCPauseAccumulator",
        "clearMeasures",
        "clearOriginJoinedAdInterestGroups",
        "clearParameters",
        "clearRect",
        "clearResourceTimings",
        "clearShadow",
        "clearStencil",
        "clearTimeout",
        "clearValue",
        "clearWatch",
        "click",
        "clickCount",
        "clientDataJSON",
        "clientHeight",
        "clientInformation",
        "clientLeft",
        "clientRect",
        "clientRects",
        "clientTop",
        "clientWaitSync",
        "clientWidth",
        "clientX",
        "clientY",
        "clip",
        "clip-path",
        "clip-rule",
        "clipBottom",
        "clipLeft",
        "clipPath",
        "clipPathUnits",
        "clipRight",
        "clipRule",
        "clipTop",
        "clipboard",
        "clipboardData",
        "clonable",
        "clone",
        "cloneContents",
        "cloneNode",
        "cloneRange",
        "close",
        "closeCode",
        "closePath",
        "closed",
        "closest",
        "clz",
        "clz32",
        "cm",
        "cmp",
        "code",
        "codeBase",
        "codePointAt",
        "codeType",
        "codedHeight",
        "codedRect",
        "codedWidth",
        "colSpan",
        "collapse",
        "collapseToEnd",
        "collapseToStart",
        "collapsed",
        "collect",
        "collections",
        "colno",
        "color",
        "color-adjust",
        "color-interpolation",
        "color-interpolation-filters",
        "color-scheme",
        "colorAdjust",
        "colorAttachments",
        "colorDepth",
        "colorFormats",
        "colorInterpolation",
        "colorInterpolationFilters",
        "colorMask",
        "colorScheme",
        "colorSpace",
        "colorType",
        "cols",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columnCount",
        "columnFill",
        "columnGap",
        "columnNumber",
        "columnRule",
        "columnRuleColor",
        "columnRuleStyle",
        "columnRuleWidth",
        "columnSpan",
        "columnWidth",
        "columns",
        "command",
        "commands",
        "commit",
        "commitLoadTime",
        "commitPreferences",
        "commitStyles",
        "commonAncestorContainer",
        "compact",
        "compare",
        "compareBoundaryPoints",
        "compareDocumentPosition",
        "compareEndPoints",
        "compareExchange",
        "compareNode",
        "comparePoint",
        "compatMode",
        "compatible",
        "compile",
        "compileShader",
        "compileStreaming",
        "complete",
        "completed",
        "component",
        "componentFromPoint",
        "composed",
        "composedPath",
        "composite",
        "compositionEndOffset",
        "compositionStartOffset",
        "compressedTexImage2D",
        "compressedTexImage3D",
        "compressedTexSubImage2D",
        "compressedTexSubImage3D",
        "compute",
        "computedStyleMap",
        "concat",
        "conditionText",
        "coneInnerAngle",
        "coneOuterAngle",
        "coneOuterGain",
        "config",
        "configurable",
        "configuration",
        "configurationName",
        "configurationValue",
        "configurations",
        "configure",
        "confirm",
        "confirmComposition",
        "confirmSiteSpecificTrackingException",
        "confirmWebWideTrackingException",
        "congestionControl",
        "connect",
        "connectEnd",
        "connectNative",
        "connectShark",
        "connectStart",
        "connected",
        "connectedCallback",
        "connection",
        "connectionInfo",
        "connectionList",
        "connectionSpeed",
        "connectionState",
        "connections",
        "console",
        "consolidate",
        "constants",
        "constraint",
        "constrictionActive",
        "construct",
        "constructor",
        "contactID",
        "contain",
        "contain-intrinsic-block-size",
        "contain-intrinsic-height",
        "contain-intrinsic-inline-size",
        "contain-intrinsic-size",
        "contain-intrinsic-width",
        "containIntrinsicBlockSize",
        "containIntrinsicHeight",
        "containIntrinsicInlineSize",
        "containIntrinsicSize",
        "containIntrinsicWidth",
        "container",
        "container-name",
        "container-type",
        "containerId",
        "containerName",
        "containerQuery",
        "containerSrc",
        "containerType",
        "contains",
        "containsNode",
        "content",
        "content-visibility",
        "contentBoxSize",
        "contentDocument",
        "contentEditable",
        "contentHint",
        "contentOverflow",
        "contentRect",
        "contentScriptType",
        "contentStyleType",
        "contentType",
        "contentVisibility",
        "contentWindow",
        "context",
        "contextId",
        "contextIds",
        "contextMenu",
        "contextMenus",
        "contextType",
        "contextTypes",
        "contextmenu",
        "contextualIdentities",
        "continue",
        "continuePrimaryKey",
        "continuous",
        "control",
        "controlTransferIn",
        "controlTransferOut",
        "controller",
        "controls",
        "controlsList",
        "convertPointFromNode",
        "convertQuadFromNode",
        "convertRectFromNode",
        "convertToBlob",
        "convertToSpecifiedUnits",
        "cookie",
        "cookieEnabled",
        "cookieStore",
        "cookies",
        "coords",
        "copyBufferSubData",
        "copyBufferToBuffer",
        "copyBufferToTexture",
        "copyExternalImageToTexture",
        "copyFromChannel",
        "copyTexImage2D",
        "copyTexSubImage2D",
        "copyTexSubImage3D",
        "copyTextureToBuffer",
        "copyTextureToTexture",
        "copyTo",
        "copyToChannel",
        "copyWithin",
        "correspondingElement",
        "correspondingUseElement",
        "corruptedVideoFrames",
        "cos",
        "cosh",
        "count",
        "countReset",
        "counter-increment",
        "counter-reset",
        "counter-set",
        "counterIncrement",
        "counterReset",
        "counterSet",
        "country",
        "cpuClass",
        "cpuSleepAllowed",
        "cqb",
        "cqh",
        "cqi",
        "cqmax",
        "cqmin",
        "cqw",
        "create",
        "createAnalyser",
        "createAnchor",
        "createAnswer",
        "createAttribute",
        "createAttributeNS",
        "createAuctionNonce",
        "createBidirectionalStream",
        "createBindGroup",
        "createBindGroupLayout",
        "createBiquadFilter",
        "createBuffer",
        "createBufferSource",
        "createCDATASection",
        "createCSSStyleSheet",
        "createCaption",
        "createChannelMerger",
        "createChannelSplitter",
        "createCommandEncoder",
        "createComment",
        "createComputePipeline",
        "createComputePipelineAsync",
        "createConicGradient",
        "createConstantSource",
        "createContextualFragment",
        "createControlRange",
        "createConvolver",
        "createDTMFSender",
        "createDataChannel",
        "createDelay",
        "createDelayNode",
        "createDocument",
        "createDocumentFragment",
        "createDocumentType",
        "createDynamicsCompressor",
        "createElement",
        "createElementNS",
        "createEncodedStreams",
        "createEntityReference",
        "createEvent",
        "createEventObject",
        "createExpression",
        "createFramebuffer",
        "createFunction",
        "createGain",
        "createGainNode",
        "createHTML",
        "createHTMLDocument",
        "createIIRFilter",
        "createImageBitmap",
        "createImageData",
        "createIndex",
        "createJavaScriptNode",
        "createLinearGradient",
        "createMediaElementSource",
        "createMediaKeys",
        "createMediaStreamDestination",
        "createMediaStreamSource",
        "createMediaStreamTrackSource",
        "createMutableFile",
        "createNSResolver",
        "createNodeIterator",
        "createNotification",
        "createObjectStore",
        "createObjectURL",
        "createOffer",
        "createOscillator",
        "createPanner",
        "createPattern",
        "createPeriodicWave",
        "createPipelineLayout",
        "createPolicy",
        "createPopup",
        "createProcessingInstruction",
        "createProgram",
        "createQuery",
        "createQuerySet",
        "createRadialGradient",
        "createRange",
        "createRangeCollection",
        "createReader",
        "createRenderBundleEncoder",
        "createRenderPipeline",
        "createRenderPipelineAsync",
        "createRenderbuffer",
        "createSVGAngle",
        "createSVGLength",
        "createSVGMatrix",
        "createSVGNumber",
        "createSVGPathSegArcAbs",
        "createSVGPathSegArcRel",
        "createSVGPathSegClosePath",
        "createSVGPathSegCurvetoCubicAbs",
        "createSVGPathSegCurvetoCubicRel",
        "createSVGPathSegCurvetoCubicSmoothAbs",
        "createSVGPathSegCurvetoCubicSmoothRel",
        "createSVGPathSegCurvetoQuadraticAbs",
        "createSVGPathSegCurvetoQuadraticRel",
        "createSVGPathSegCurvetoQuadraticSmoothAbs",
        "createSVGPathSegCurvetoQuadraticSmoothRel",
        "createSVGPathSegLinetoAbs",
        "createSVGPathSegLinetoHorizontalAbs",
        "createSVGPathSegLinetoHorizontalRel",
        "createSVGPathSegLinetoRel",
        "createSVGPathSegLinetoVerticalAbs",
        "createSVGPathSegLinetoVerticalRel",
        "createSVGPathSegMovetoAbs",
        "createSVGPathSegMovetoRel",
        "createSVGPoint",
        "createSVGRect",
        "createSVGTransform",
        "createSVGTransformFromMatrix",
        "createSampler",
        "createScript",
        "createScriptProcessor",
        "createScriptURL",
        "createSession",
        "createShader",
        "createShaderModule",
        "createShadowRoot",
        "createStereoPanner",
        "createStyleSheet",
        "createTBody",
        "createTFoot",
        "createTHead",
        "createTask",
        "createTextNode",
        "createTextRange",
        "createTexture",
        "createTouch",
        "createTouchList",
        "createTransformFeedback",
        "createTreeWalker",
        "createUnidirectionalStream",
        "createVertexArray",
        "createView",
        "createWaveShaper",
        "createWorklet",
        "createWritable",
        "creationTime",
        "credentialless",
        "credentials",
        "criticalCHRestart",
        "cropTo",
        "crossOrigin",
        "crossOriginIsolated",
        "crypto",
        "csi",
        "csp",
        "cssFloat",
        "cssRules",
        "cssText",
        "cssValueType",
        "ctrlKey",
        "ctrlLeft",
        "cues",
        "cullFace",
        "cullMode",
        "currentCSSZoom",
        "currentDirection",
        "currentEntry",
        "currentLocalDescription",
        "currentNode",
        "currentPage",
        "currentRect",
        "currentRemoteDescription",
        "currentScale",
        "currentScreen",
        "currentScript",
        "currentSrc",
        "currentState",
        "currentStyle",
        "currentTarget",
        "currentTime",
        "currentTranslate",
        "currentView",
        "cursor",
        "curve",
        "customElements",
        "customError",
        "cx",
        "cy",
        "d",
        "data",
        "dataFld",
        "dataFormatAs",
        "dataLoss",
        "dataLossMessage",
        "dataPageSize",
        "dataSrc",
        "dataTransfer",
        "database",
        "databases",
        "datagrams",
        "dataset",
        "dateTime",
        "db",
        "debug",
        "debuggerEnabled",
        "declarativeNetRequest",
        "declare",
        "decode",
        "decodeAudioData",
        "decodeQueueSize",
        "decodeURI",
        "decodeURIComponent",
        "decodedBodySize",
        "decoding",
        "decodingInfo",
        "decrypt",
        "default",
        "defaultCharset",
        "defaultChecked",
        "defaultMuted",
        "defaultPlaybackRate",
        "defaultPolicy",
        "defaultPrevented",
        "defaultQueue",
        "defaultRequest",
        "defaultSelected",
        "defaultStatus",
        "defaultURL",
        "defaultValue",
        "defaultView",
        "defaultstatus",
        "defer",
        "define",
        "defineMagicFunction",
        "defineMagicVariable",
        "defineProperties",
        "defineProperty",
        "deg",
        "delay",
        "delayTime",
        "delegatesFocus",
        "delete",
        "deleteBuffer",
        "deleteCaption",
        "deleteCell",
        "deleteContents",
        "deleteData",
        "deleteDatabase",
        "deleteFramebuffer",
        "deleteFromDocument",
        "deleteIndex",
        "deleteMedium",
        "deleteObjectStore",
        "deleteProgram",
        "deleteProperty",
        "deleteQuery",
        "deleteRenderbuffer",
        "deleteRow",
        "deleteRule",
        "deleteSampler",
        "deleteShader",
        "deleteSync",
        "deleteTFoot",
        "deleteTHead",
        "deleteTexture",
        "deleteTransformFeedback",
        "deleteVertexArray",
        "deleted",
        "deliverChangeRecords",
        "deliveredFrames",
        "deliveredFramesDuration",
        "delivery",
        "deliveryInfo",
        "deliveryStatus",
        "deliveryTimestamp",
        "deliveryType",
        "delta",
        "deltaMode",
        "deltaX",
        "deltaY",
        "deltaZ",
        "dependentLocality",
        "deprecatedReplaceInURN",
        "deprecatedRunAdAuctionEnforcesKAnonymity",
        "deprecatedURNToURL",
        "depthBias",
        "depthBiasClamp",
        "depthBiasSlopeScale",
        "depthClearValue",
        "depthCompare",
        "depthDataFormat",
        "depthFailOp",
        "depthFar",
        "depthFunc",
        "depthLoadOp",
        "depthMask",
        "depthNear",
        "depthOrArrayLayers",
        "depthRange",
        "depthReadOnly",
        "depthStencil",
        "depthStencilAttachment",
        "depthStencilFormat",
        "depthStoreOp",
        "depthUsage",
        "depthWriteEnabled",
        "deref",
        "deriveBits",
        "deriveKey",
        "descentOverride",
        "description",
        "deselectAll",
        "designMode",
        "desiredSize",
        "destination",
        "destinationURL",
        "destroy",
        "detach",
        "detachEvent",
        "detachShader",
        "detached",
        "detail",
        "details",
        "detect",
        "detectLanguage",
        "detune",
        "device",
        "deviceClass",
        "deviceId",
        "deviceMemory",
        "devicePixelContentBoxSize",
        "devicePixelRatio",
        "deviceProtocol",
        "deviceSubclass",
        "deviceVersionMajor",
        "deviceVersionMinor",
        "deviceVersionSubminor",
        "deviceXDPI",
        "deviceYDPI",
        "devtools",
        "devtools_panels",
        "didTimeout",
        "difference",
        "diffuseConstant",
        "digest",
        "dimension",
        "dimensions",
        "dir",
        "dirName",
        "direction",
        "dirxml",
        "disable",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "disableVertexAttribArray",
        "disabled",
        "discard",
        "discardedFrames",
        "dischargingTime",
        "disconnect",
        "disconnectShark",
        "disconnectedCallback",
        "dispatchEvent",
        "dispatchWorkgroups",
        "dispatchWorkgroupsIndirect",
        "display",
        "displayHeight",
        "displayId",
        "displayName",
        "displayWidth",
        "dispose",
        "disposition",
        "distanceModel",
        "div",
        "divisor",
        "djsapi",
        "djsproxy",
        "dns",
        "doImport",
        "doNotTrack",
        "doScroll",
        "doctype",
        "document",
        "documentElement",
        "documentId",
        "documentIds",
        "documentLifecycle",
        "documentMode",
        "documentOrigin",
        "documentOrigins",
        "documentPictureInPicture",
        "documentURI",
        "documentUrl",
        "documentUrls",
        "dolphin",
        "dolphinGameCenter",
        "dolphininfo",
        "dolphinmeta",
        "dom",
        "domComplete",
        "domContentLoadedEventEnd",
        "domContentLoadedEventStart",
        "domInteractive",
        "domLoading",
        "domOverlayState",
        "domain",
        "domainLookupEnd",
        "domainLookupStart",
        "dominant-baseline",
        "dominantBaseline",
        "done",
        "dopplerFactor",
        "dotAll",
        "downDegrees",
        "downlink",
        "download",
        "downloadRequest",
        "downloadTotal",
        "downloaded",
        "downloads",
        "dpcm",
        "dpi",
        "dppx",
        "dragDrop",
        "draggable",
        "draw",
        "drawArrays",
        "drawArraysInstanced",
        "drawArraysInstancedANGLE",
        "drawBuffers",
        "drawCustomFocusRing",
        "drawElements",
        "drawElementsInstanced",
        "drawElementsInstancedANGLE",
        "drawFocusIfNeeded",
        "drawImage",
        "drawImageFromRect",
        "drawIndexed",
        "drawIndexedIndirect",
        "drawIndirect",
        "drawRangeElements",
        "drawSystemFocusRing",
        "drawingBufferColorSpace",
        "drawingBufferFormat",
        "drawingBufferHeight",
        "drawingBufferStorage",
        "drawingBufferWidth",
        "drop",
        "dropEffect",
        "droppedVideoFrames",
        "dropzone",
        "dstFactor",
        "dtmf",
        "dump",
        "dumpProfile",
        "duplex",
        "duplicate",
        "durability",
        "duration",
        "dvb",
        "dvh",
        "dvi",
        "dvmax",
        "dvmin",
        "dvname",
        "dvnum",
        "dvw",
        "dx",
        "dy",
        "dynamicId",
        "dynsrc",
        "e",
        "edgeMode",
        "editContext",
        "effect",
        "effectAllowed",
        "effectiveDirective",
        "effectiveType",
        "effects",
        "elapsedTime",
        "element",
        "elementFromPoint",
        "elementTiming",
        "elements",
        "elementsFromPoint",
        "elevation",
        "ellipse",
        "em",
        "emHeightAscent",
        "emHeightDescent",
        "email",
        "embeds",
        "emit",
        "emma",
        "empty",
        "empty-cells",
        "emptyCells",
        "emptyHTML",
        "emptyScript",
        "emulatedPosition",
        "enable",
        "enableBackground",
        "enableDelegations",
        "enableStyleSheetsForSet",
        "enableVertexAttribArray",
        "enabled",
        "enabledFeatures",
        "enabledPlugin",
        "encode",
        "encodeInto",
        "encodeQueueSize",
        "encodeURI",
        "encodeURIComponent",
        "encodedBodySize",
        "encoding",
        "encodingInfo",
        "encrypt",
        "enctype",
        "end",
        "endContainer",
        "endElement",
        "endElementAt",
        "endOcclusionQuery",
        "endOfPassWriteIndex",
        "endOfStream",
        "endOffset",
        "endQuery",
        "endTime",
        "endTransformFeedback",
        "ended",
        "endpoint",
        "endpointNumber",
        "endpoints",
        "endsWith",
        "enqueue",
        "enterKeyHint",
        "entities",
        "entries",
        "entry",
        "entryPoint",
        "entryType",
        "enumerable",
        "enumerate",
        "enumerateDevices",
        "enumerateEditable",
        "environmentBlendMode",
        "equals",
        "error",
        "errorCode",
        "errorDetail",
        "errorText",
        "escape",
        "estimate",
        "eval",
        "evaluate",
        "event",
        "eventCounts",
        "eventPhase",
        "events",
        "every",
        "ex",
        "exception",
        "exchange",
        "exec",
        "execCommand",
        "execCommandShowHelp",
        "execScript",
        "executeBundles",
        "executionStart",
        "exitFullscreen",
        "exitPictureInPicture",
        "exitPointerLock",
        "exitPresent",
        "exp",
        "expand",
        "expandEntityReferences",
        "expando",
        "expansion",
        "expectedImprovement",
        "experiments",
        "expiration",
        "expirationTime",
        "expires",
        "expiryDate",
        "explicitOriginalTarget",
        "expm1",
        "exponent",
        "exponentialRampToValueAtTime",
        "exportKey",
        "exports",
        "extend",
        "extension",
        "extensionTypes",
        "extensions",
        "extentNode",
        "extentOffset",
        "external",
        "externalResourcesRequired",
        "externalTexture",
        "extractContents",
        "extractable",
        "eye",
        "f",
        "f16round",
        "face",
        "factoryReset",
        "failOp",
        "failureReason",
        "fallback",
        "family",
        "familyName",
        "farthestViewportElement",
        "fastSeek",
        "fatal",
        "featureId",
        "featurePolicy",
        "featureSettings",
        "features",
        "fence",
        "fenceSync",
        "fetch",
        "fetchPriority",
        "fetchStart",
        "fftSize",
        "fgColor",
        "fieldOfView",
        "file",
        "fileCreatedDate",
        "fileHandle",
        "fileModifiedDate",
        "fileName",
        "fileSize",
        "fileUpdatedDate",
        "filename",
        "files",
        "filesystem",
        "fill",
        "fill-opacity",
        "fill-rule",
        "fillJointRadii",
        "fillLightMode",
        "fillOpacity",
        "fillPoses",
        "fillRect",
        "fillRule",
        "fillStyle",
        "fillText",
        "filter",
        "filterResX",
        "filterResY",
        "filterUnits",
        "filters",
        "finally",
        "find",
        "findIndex",
        "findLast",
        "findLastIndex",
        "findRule",
        "findText",
        "finish",
        "finishDocumentLoadTime",
        "finishLoadTime",
        "finished",
        "fireEvent",
        "firesTouchEvents",
        "firstChild",
        "firstElementChild",
        "firstInterimResponseStart",
        "firstPage",
        "firstPaintAfterLoadTime",
        "firstPaintTime",
        "firstUIEventTimestamp",
        "fixed",
        "flags",
        "flat",
        "flatMap",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "flexBasis",
        "flexDirection",
        "flexFlow",
        "flexGrow",
        "flexShrink",
        "flexWrap",
        "flipX",
        "flipY",
        "float",
        "float32",
        "float64",
        "flood-color",
        "flood-opacity",
        "floodColor",
        "floodOpacity",
        "floor",
        "flush",
        "focus",
        "focusNode",
        "focusOffset",
        "font",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-optical-sizing",
        "font-palette",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-synthesis-position",
        "font-synthesis-small-caps",
        "font-synthesis-style",
        "font-synthesis-weight",
        "font-variant",
        "font-variant-alternates",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "fontBoundingBoxAscent",
        "fontBoundingBoxDescent",
        "fontFamily",
        "fontFeatureSettings",
        "fontKerning",
        "fontLanguageOverride",
        "fontOpticalSizing",
        "fontPalette",
        "fontSize",
        "fontSizeAdjust",
        "fontSmoothingEnabled",
        "fontStretch",
        "fontStyle",
        "fontSynthesis",
        "fontSynthesisPosition",
        "fontSynthesisSmallCaps",
        "fontSynthesisStyle",
        "fontSynthesisWeight",
        "fontVariant",
        "fontVariantAlternates",
        "fontVariantCaps",
        "fontVariantEastAsian",
        "fontVariantLigatures",
        "fontVariantNumeric",
        "fontVariantPosition",
        "fontVariationSettings",
        "fontWeight",
        "fontcolor",
        "fontfaces",
        "fonts",
        "fontsize",
        "for",
        "forEach",
        "force",
        "forceFallbackAdapter",
        "forceRedraw",
        "forced-color-adjust",
        "forcedColorAdjust",
        "forcedStyleAndLayoutDuration",
        "forget",
        "form",
        "formAction",
        "formData",
        "formEnctype",
        "formMethod",
        "formNoValidate",
        "formTarget",
        "format",
        "formatToParts",
        "forms",
        "forward",
        "forwardX",
        "forwardY",
        "forwardZ",
        "foundation",
        "fr",
        "fragment",
        "fragmentDirective",
        "frame",
        "frameBorder",
        "frameCount",
        "frameElement",
        "frameId",
        "frameIds",
        "frameSpacing",
        "framebuffer",
        "framebufferHeight",
        "framebufferRenderbuffer",
        "framebufferTexture2D",
        "framebufferTextureLayer",
        "framebufferWidth",
        "frames",
        "freeSpace",
        "freeze",
        "frequency",
        "frequencyBinCount",
        "from",
        "fromAsync",
        "fromBase64",
        "fromCharCode",
        "fromCodePoint",
        "fromElement",
        "fromEntries",
        "fromFloat32Array",
        "fromFloat64Array",
        "fromHex",
        "fromMatrix",
        "fromPoint",
        "fromQuad",
        "fromRect",
        "frontFace",
        "fround",
        "fullName",
        "fullPath",
        "fullRange",
        "fullScreen",
        "fullVersionList",
        "fullscreen",
        "fullscreenElement",
        "fullscreenEnabled",
        "fx",
        "fy",
        "g",
        "gain",
        "gamepad",
        "gamma",
        "gap",
        "gatheringState",
        "gatt",
        "geckoProfiler",
        "genderIdentity",
        "generateCertificate",
        "generateKey",
        "generateMipmap",
        "generateRequest",
        "geolocation",
        "gestureObject",
        "get",
        "getAcceptLanguages",
        "getActiveAttrib",
        "getActiveUniform",
        "getActiveUniformBlockName",
        "getActiveUniformBlockParameter",
        "getActiveUniforms",
        "getAdjacentText",
        "getAll",
        "getAllKeys",
        "getAllResponseHeaders",
        "getAllowlistForFeature",
        "getAnimations",
        "getAsFile",
        "getAsFileSystemHandle",
        "getAsString",
        "getAttachedShaders",
        "getAttribLocation",
        "getAttribute",
        "getAttributeNS",
        "getAttributeNames",
        "getAttributeNode",
        "getAttributeNodeNS",
        "getAttributeType",
        "getAudioTracks",
        "getAuthenticatorData",
        "getAutoplayPolicy",
        "getAvailability",
        "getBBox",
        "getBackgroundPage",
        "getBadgeBackgroundColor",
        "getBadgeText",
        "getBadgeTextColor",
        "getBattery",
        "getBigInt64",
        "getBigUint64",
        "getBindGroupLayout",
        "getBlob",
        "getBookmark",
        "getBoundingClientRect",
        "getBounds",
        "getBoxQuads",
        "getBrowserInfo",
        "getBufferParameter",
        "getBufferSubData",
        "getByteFrequencyData",
        "getByteTimeDomainData",
        "getCSSCanvasContext",
        "getCTM",
        "getCameraImage",
        "getCandidateWindowClientRect",
        "getCanonicalLocales",
        "getCapabilities",
        "getCaptureHandle",
        "getChannelData",
        "getCharNumAtPosition",
        "getCharacteristic",
        "getCharacteristics",
        "getClientExtensionResults",
        "getClientRect",
        "getClientRects",
        "getCoalescedEvents",
        "getCompilationInfo",
        "getCompositionAlternatives",
        "getComputedStyle",
        "getComputedTextLength",
        "getComputedTiming",
        "getConfiguration",
        "getConstraints",
        "getContext",
        "getContextAttributes",
        "getContexts",
        "getContributingSources",
        "getCounterValue",
        "getCueAsHTML",
        "getCueById",
        "getCurrent",
        "getCurrentPosition",
        "getCurrentTexture",
        "getCurrentTime",
        "getData",
        "getDatabaseNames",
        "getDate",
        "getDay",
        "getDefaultComputedStyle",
        "getDepthInMeters",
        "getDepthInformation",
        "getDescriptor",
        "getDescriptors",
        "getDestinationInsertionPoints",
        "getDevices",
        "getDirectory",
        "getDirectoryHandle",
        "getDisplayMedia",
        "getDistributedNodes",
        "getEditable",
        "getElementById",
        "getElementsByClassName",
        "getElementsByName",
        "getElementsByTagName",
        "getElementsByTagNameNS",
        "getEnclosureList",
        "getEndPositionOfChar",
        "getEntries",
        "getEntriesByName",
        "getEntriesByType",
        "getError",
        "getExtension",
        "getExtentOfChar",
        "getEyeParameters",
        "getFeature",
        "getFiberRoots",
        "getFile",
        "getFileHandle",
        "getFiles",
        "getFilesAndDirectories",
        "getFingerprints",
        "getFloat16",
        "getFloat32",
        "getFloat64",
        "getFloatFrequencyData",
        "getFloatTimeDomainData",
        "getFloatValue",
        "getFragDataLocation",
        "getFrameData",
        "getFrameId",
        "getFramebufferAttachmentParameter",
        "getFrequencyResponse",
        "getFullYear",
        "getGamepads",
        "getHTML",
        "getHeaderExtensionsToNegotiate",
        "getHighEntropyValues",
        "getHitTestResults",
        "getHitTestResultsForTransientInput",
        "getHours",
        "getIdentityAssertion",
        "getIds",
        "getImageData",
        "getIndexedParameter",
        "getInfo",
        "getInnerHTML",
        "getInstalledRelatedApps",
        "getInt16",
        "getInt32",
        "getInt8",
        "getInterestGroupAdAuctionData",
        "getInternalModuleRanges",
        "getInternalformatParameter",
        "getIntersectionList",
        "getItem",
        "getItems",
        "getJointPose",
        "getKey",
        "getKeyframes",
        "getLastFocused",
        "getLayers",
        "getLayoutMap",
        "getLightEstimate",
        "getLineDash",
        "getLocalCandidates",
        "getLocalParameters",
        "getLocalStreams",
        "getManagedConfiguration",
        "getManifest",
        "getMappedRange",
        "getMarks",
        "getMatchedCSSRules",
        "getMaxGCPauseSinceClear",
        "getMeasures",
        "getMessage",
        "getMetadata",
        "getMilliseconds",
        "getMinutes",
        "getModifierState",
        "getMonth",
        "getName",
        "getNamedItem",
        "getNamedItemNS",
        "getNativeFramebufferScaleFactor",
        "getNegotiatedHeaderExtensions",
        "getNestedConfigs",
        "getNotifications",
        "getNotifier",
        "getNumberOfChars",
        "getOffsetReferenceSpace",
        "getOutputTimestamp",
        "getOverrideHistoryNavigationMode",
        "getOverrideStyle",
        "getOwnPropertyDescriptor",
        "getOwnPropertyDescriptors",
        "getOwnPropertyNames",
        "getOwnPropertySymbols",
        "getPackageDirectoryEntry",
        "getParameter",
        "getParameters",
        "getParent",
        "getPathSegAtLength",
        "getPermissionWarningsByManifest",
        "getPhotoCapabilities",
        "getPhotoSettings",
        "getPlatformInfo",
        "getPointAtLength",
        "getPopup",
        "getPorts",
        "getPose",
        "getPredictedEvents",
        "getPreference",
        "getPreferenceDefault",
        "getPreferredCanvasFormat",
        "getPresentationAttribute",
        "getPreventDefault",
        "getPrimaryService",
        "getPrimaryServices",
        "getProgramInfoLog",
        "getProgramParameter",
        "getPropertyCSSValue",
        "getPropertyPriority",
        "getPropertyShorthand",
        "getPropertyType",
        "getPropertyValue",
        "getPrototypeOf",
        "getPublicKey",
        "getPublicKeyAlgorithm",
        "getQuery",
        "getQueryParameter",
        "getRGBColorValue",
        "getRandomValues",
        "getRangeAt",
        "getReader",
        "getReceivers",
        "getRectValue",
        "getReflectionCubeMap",
        "getRegistration",
        "getRegistrations",
        "getRemoteCandidates",
        "getRemoteCertificates",
        "getRemoteParameters",
        "getRemoteStreams",
        "getRenderbufferParameter",
        "getResponseHeader",
        "getRoot",
        "getRootNode",
        "getRotationOfChar",
        "getSVGDocument",
        "getSamplerParameter",
        "getScreenCTM",
        "getScreenDetails",
        "getSeconds",
        "getSelectedCandidatePair",
        "getSelection",
        "getSelf",
        "getSenders",
        "getService",
        "getSetCookie",
        "getSettings",
        "getShaderInfoLog",
        "getShaderParameter",
        "getShaderPrecisionFormat",
        "getShaderSource",
        "getSignals",
        "getSimpleDuration",
        "getSiteIcons",
        "getSources",
        "getSpeculativeParserUrls",
        "getStartPositionOfChar",
        "getStartTime",
        "getState",
        "getStats",
        "getStatusForPolicy",
        "getStorageUpdates",
        "getStreamById",
        "getStringValue",
        "getSubStringLength",
        "getSubscription",
        "getSubscriptions",
        "getSupportedConstraints",
        "getSupportedExtensions",
        "getSupportedFormats",
        "getSyncParameter",
        "getSynchronizationSources",
        "getTags",
        "getTargetRanges",
        "getTexParameter",
        "getTextFormats",
        "getTime",
        "getTimezoneOffset",
        "getTiming",
        "getTitle",
        "getTitlebarAreaRect",
        "getTotalLength",
        "getTrackById",
        "getTracks",
        "getTransceivers",
        "getTransform",
        "getTransformFeedbackVarying",
        "getTransformToElement",
        "getTransports",
        "getType",
        "getTypeMapping",
        "getUILanguage",
        "getURL",
        "getUTCDate",
        "getUTCDay",
        "getUTCFullYear",
        "getUTCHours",
        "getUTCMilliseconds",
        "getUTCMinutes",
        "getUTCMonth",
        "getUTCSeconds",
        "getUint16",
        "getUint32",
        "getUint8",
        "getUniform",
        "getUniformBlockIndex",
        "getUniformIndices",
        "getUniformLocation",
        "getUserInfo",
        "getUserMedia",
        "getUserSettings",
        "getVRDisplays",
        "getValues",
        "getVarDate",
        "getVariableValue",
        "getVertexAttrib",
        "getVertexAttribOffset",
        "getVideoPlaybackQuality",
        "getVideoTracks",
        "getViewerPose",
        "getViewport",
        "getViews",
        "getVoices",
        "getWakeLockState",
        "getWriter",
        "getYear",
        "getZoom",
        "getZoomSettings",
        "givenName",
        "global",
        "globalAlpha",
        "globalCompositeOperation",
        "globalPrivacyControl",
        "globalThis",
        "glyphOrientationHorizontal",
        "glyphOrientationVertical",
        "glyphRef",
        "go",
        "goBack",
        "goForward",
        "gpu",
        "grabFrame",
        "grad",
        "gradientTransform",
        "gradientUnits",
        "grammars",
        "green",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-gap",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-gap",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "gridArea",
        "gridAutoColumns",
        "gridAutoFlow",
        "gridAutoRows",
        "gridColumn",
        "gridColumnEnd",
        "gridColumnGap",
        "gridColumnStart",
        "gridGap",
        "gridRow",
        "gridRowEnd",
        "gridRowGap",
        "gridRowStart",
        "gridTemplate",
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows",
        "gripSpace",
        "group",
        "groupBy",
        "groupCollapsed",
        "groupEnd",
        "groupId",
        "groups",
        "grow",
        "growable",
        "guestProcessId",
        "guestRenderFrameRoutingId",
        "hadRecentInput",
        "hand",
        "handedness",
        "hangingBaseline",
        "hapticActuators",
        "hardwareConcurrency",
        "has",
        "hasAttribute",
        "hasAttributeNS",
        "hasAttributes",
        "hasBeenActive",
        "hasChildNodes",
        "hasComposition",
        "hasDynamicOffset",
        "hasEnrolledInstrument",
        "hasExtension",
        "hasExternalDisplay",
        "hasFeature",
        "hasFocus",
        "hasIndices",
        "hasInstance",
        "hasLayout",
        "hasOrientation",
        "hasOwn",
        "hasOwnProperty",
        "hasPointerCapture",
        "hasPosition",
        "hasPrivateToken",
        "hasReading",
        "hasRedemptionRecord",
        "hasRegExpGroups",
        "hasStorageAccess",
        "hasUAVisualTransition",
        "hasUnpartitionedCookieAccess",
        "hash",
        "hashChange",
        "head",
        "headers",
        "heading",
        "height",
        "hid",
        "hidden",
        "hide",
        "hideFocus",
        "hidePopover",
        "high",
        "highWaterMark",
        "highlight",
        "highlights",
        "hint",
        "hints",
        "history",
        "honorificPrefix",
        "honorificSuffix",
        "horizontalOverflow",
        "host",
        "hostCandidate",
        "hostname",
        "href",
        "hrefTranslate",
        "hreflang",
        "hspace",
        "html5TagCheckInerface",
        "htmlFor",
        "htmlText",
        "httpEquiv",
        "httpRequestStatusCode",
        "hwTimestamp",
        "hyphenate-character",
        "hyphenateCharacter",
        "hyphens",
        "hypot",
        "i18n",
        "ic",
        "iccId",
        "iceConnectionState",
        "iceGatheringState",
        "iceTransport",
        "icon",
        "iconURL",
        "id",
        "identifier",
        "identity",
        "ideographicBaseline",
        "idle",
        "idpLoginUrl",
        "ignoreBOM",
        "ignoreCase",
        "ignoreDepthValues",
        "image",
        "image-orientation",
        "image-rendering",
        "imageHeight",
        "imageOrientation",
        "imageRendering",
        "imageSizes",
        "imageSmoothingEnabled",
        "imageSmoothingQuality",
        "imageSrcset",
        "imageWidth",
        "images",
        "ime-mode",
        "imeMode",
        "implementation",
        "importExternalTexture",
        "importKey",
        "importNode",
        "importStylesheet",
        "imports",
        "impp",
        "imul",
        "in",
        "in1",
        "in2",
        "inBandMetadataTrackDispatchType",
        "inIncognitoContext",
        "inRange",
        "includes",
        "incognito",
        "incomingBidirectionalStreams",
        "incomingHighWaterMark",
        "incomingMaxAge",
        "incomingUnidirectionalStreams",
        "incremental",
        "indeterminate",
        "index",
        "indexNames",
        "indexOf",
        "indexedDB",
        "indicate",
        "indices",
        "inert",
        "inertiaDestinationX",
        "inertiaDestinationY",
        "info",
        "inherits",
        "init",
        "initAnimationEvent",
        "initBeforeLoadEvent",
        "initClipboardEvent",
        "initCloseEvent",
        "initCommandEvent",
        "initCompositionEvent",
        "initCustomEvent",
        "initData",
        "initDataType",
        "initDeviceMotionEvent",
        "initDeviceOrientationEvent",
        "initDragEvent",
        "initErrorEvent",
        "initEvent",
        "initFocusEvent",
        "initGestureEvent",
        "initHashChangeEvent",
        "initKeyEvent",
        "initKeyboardEvent",
        "initMSManipulationEvent",
        "initMessageEvent",
        "initMouseEvent",
        "initMouseScrollEvent",
        "initMouseWheelEvent",
        "initMutationEvent",
        "initNSMouseEvent",
        "initOverflowEvent",
        "initPageEvent",
        "initPageTransitionEvent",
        "initPointerEvent",
        "initPopStateEvent",
        "initProgressEvent",
        "initScrollAreaEvent",
        "initSimpleGestureEvent",
        "initStorageEvent",
        "initTextEvent",
        "initTimeEvent",
        "initTouchEvent",
        "initTransitionEvent",
        "initUIEvent",
        "initWebKitAnimationEvent",
        "initWebKitTransitionEvent",
        "initWebKitWheelEvent",
        "initWheelEvent",
        "initialTime",
        "initialValue",
        "initialize",
        "initiatorType",
        "inject",
        "ink",
        "inline-size",
        "inlineSize",
        "inlineVerticalFieldOfView",
        "inner",
        "innerHTML",
        "innerHeight",
        "innerText",
        "innerWidth",
        "input",
        "inputBuffer",
        "inputEncoding",
        "inputMethod",
        "inputMode",
        "inputSource",
        "inputSources",
        "inputType",
        "inputs",
        "insertAdjacentElement",
        "insertAdjacentHTML",
        "insertAdjacentText",
        "insertBefore",
        "insertCell",
        "insertDTMF",
        "insertData",
        "insertDebugMarker",
        "insertItemBefore",
        "insertNode",
        "insertRow",
        "insertRule",
        "inset",
        "inset-block",
        "inset-block-end",
        "inset-block-start",
        "inset-inline",
        "inset-inline-end",
        "inset-inline-start",
        "insetBlock",
        "insetBlockEnd",
        "insetBlockStart",
        "insetInline",
        "insetInlineEnd",
        "insetInlineStart",
        "install",
        "installing",
        "instanceRoot",
        "instantiate",
        "instantiateStreaming",
        "instruments",
        "int16",
        "int32",
        "int8",
        "integrity",
        "interactionId",
        "interactionMode",
        "intercept",
        "interfaceClass",
        "interfaceName",
        "interfaceNumber",
        "interfaceProtocol",
        "interfaceSubclass",
        "interfaces",
        "interimResults",
        "internalSubset",
        "interpretation",
        "intersection",
        "intersectionRatio",
        "intersectionRect",
        "intersectsNode",
        "interval",
        "invalidIteratorState",
        "invalidateFramebuffer",
        "invalidateSubFramebuffer",
        "inverse",
        "invertSelf",
        "invoker",
        "invokerType",
        "is",
        "is2D",
        "isActive",
        "isAllowedFileSchemeAccess",
        "isAllowedIncognitoAccess",
        "isAlternate",
        "isArray",
        "isAutoSelected",
        "isBingCurrentSearchDefault",
        "isBuffer",
        "isCandidateWindowVisible",
        "isChar",
        "isCollapsed",
        "isComposing",
        "isConcatSpreadable",
        "isConditionalMediationAvailable",
        "isConfigSupported",
        "isConnected",
        "isContentEditable",
        "isContentHandlerRegistered",
        "isContextLost",
        "isDefaultNamespace",
        "isDirectory",
        "isDisabled",
        "isDisjointFrom",
        "isEnabled",
        "isEqual",
        "isEqualNode",
        "isExtended",
        "isExtensible",
        "isExternalCTAP2SecurityKeySupported",
        "isFallbackAdapter",
        "isFile",
        "isFinite",
        "isFirstPersonObserver",
        "isFramebuffer",
        "isFrozen",
        "isGenerator",
        "isHTML",
        "isHistoryNavigation",
        "isId",
        "isIdentity",
        "isInjected",
        "isInputPending",
        "isInteger",
        "isInternal",
        "isIntersecting",
        "isLockFree",
        "isMap",
        "isMultiLine",
        "isNaN",
        "isOpen",
        "isPointInFill",
        "isPointInPath",
        "isPointInRange",
        "isPointInStroke",
        "isPrefAlternate",
        "isPresenting",
        "isPrimary",
        "isProgram",
        "isPropertyImplicit",
        "isProtocolHandlerRegistered",
        "isPrototypeOf",
        "isQuery",
        "isRawJSON",
        "isRenderbuffer",
        "isSafeInteger",
        "isSameEntry",
        "isSameNode",
        "isSampler",
        "isScript",
        "isScriptURL",
        "isSealed",
        "isSecureContext",
        "isSessionSupported",
        "isShader",
        "isSubsetOf",
        "isSupersetOf",
        "isSupported",
        "isSync",
        "isTextEdit",
        "isTexture",
        "isTransformFeedback",
        "isTrusted",
        "isTypeSupported",
        "isUserVerifyingPlatformAuthenticatorAvailable",
        "isVertexArray",
        "isView",
        "isVisible",
        "isWellFormed",
        "isochronousTransferIn",
        "isochronousTransferOut",
        "isolation",
        "italics",
        "item",
        "itemId",
        "itemProp",
        "itemRef",
        "itemScope",
        "itemType",
        "itemValue",
        "items",
        "iterateNext",
        "iterationComposite",
        "iterator",
        "javaEnabled",
        "jitterBufferTarget",
        "jobTitle",
        "join",
        "joinAdInterestGroup",
        "jointName",
        "json",
        "justify-content",
        "justify-items",
        "justify-self",
        "justifyContent",
        "justifyItems",
        "justifySelf",
        "k1",
        "k2",
        "k3",
        "k4",
        "kHz",
        "keepalive",
        "kernelMatrix",
        "kernelUnitLengthX",
        "kernelUnitLengthY",
        "kerning",
        "key",
        "keyCode",
        "keyFor",
        "keyIdentifier",
        "keyLightEnabled",
        "keyLocation",
        "keyPath",
        "keyStatuses",
        "keySystem",
        "keyText",
        "keyUsage",
        "keyboard",
        "keys",
        "keytype",
        "kind",
        "knee",
        "knownSources",
        "label",
        "labels",
        "lang",
        "language",
        "languages",
        "largeArcFlag",
        "lastChild",
        "lastElementChild",
        "lastError",
        "lastEventId",
        "lastIndex",
        "lastIndexOf",
        "lastInputTime",
        "lastMatch",
        "lastMessageSubject",
        "lastMessageType",
        "lastModified",
        "lastModifiedDate",
        "lastPage",
        "lastParen",
        "lastState",
        "lastStyleSheetSet",
        "latency",
        "latitude",
        "launchQueue",
        "layerName",
        "layerX",
        "layerY",
        "layout",
        "layoutFlow",
        "layoutGrid",
        "layoutGridChar",
        "layoutGridLine",
        "layoutGridMode",
        "layoutGridType",
        "lbound",
        "leaveAdInterestGroup",
        "left",
        "leftContext",
        "leftDegrees",
        "leftMargin",
        "leftProjectionMatrix",
        "leftViewMatrix",
        "length",
        "lengthAdjust",
        "lengthComputable",
        "letter-spacing",
        "letterSpacing",
        "level",
        "lh",
        "lighting-color",
        "lightingColor",
        "limitingConeAngle",
        "limits",
        "line",
        "line-break",
        "line-height",
        "lineAlign",
        "lineBreak",
        "lineCap",
        "lineDashOffset",
        "lineGapOverride",
        "lineHeight",
        "lineJoin",
        "lineNum",
        "lineNumber",
        "linePos",
        "lineTo",
        "lineWidth",
        "linearAcceleration",
        "linearRampToValueAtTime",
        "linearVelocity",
        "lineno",
        "lines",
        "link",
        "linkColor",
        "linkProgram",
        "links",
        "list",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "listStyle",
        "listStyleImage",
        "listStylePosition",
        "listStyleType",
        "listener",
        "listeners",
        "load",
        "loadEventEnd",
        "loadEventStart",
        "loadOp",
        "loadTime",
        "loadTimes",
        "loaded",
        "loading",
        "localDescription",
        "localName",
        "localService",
        "localStorage",
        "locale",
        "localeCompare",
        "location",
        "locationbar",
        "lock",
        "locked",
        "lockedFile",
        "locks",
        "lodMaxClamp",
        "lodMinClamp",
        "log",
        "log10",
        "log1p",
        "log2",
        "logicalXDPI",
        "logicalYDPI",
        "login",
        "loglevel",
        "longDesc",
        "longitude",
        "lookupNamespaceURI",
        "lookupPrefix",
        "loop",
        "loopEnd",
        "loopStart",
        "looping",
        "lost",
        "low",
        "lower",
        "lowerBound",
        "lowerOpen",
        "lowsrc",
        "lvb",
        "lvh",
        "lvi",
        "lvmax",
        "lvmin",
        "lvw",
        "m11",
        "m12",
        "m13",
        "m14",
        "m21",
        "m22",
        "m23",
        "m24",
        "m31",
        "m32",
        "m33",
        "m34",
        "m41",
        "m42",
        "m43",
        "m44",
        "magFilter",
        "makeXRCompatible",
        "managed",
        "management",
        "manifest",
        "manufacturer",
        "manufacturerName",
        "map",
        "mapAsync",
        "mapState",
        "mappedAtCreation",
        "mapping",
        "margin",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-bottom",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "margin-left",
        "margin-right",
        "margin-top",
        "marginBlock",
        "marginBlockEnd",
        "marginBlockStart",
        "marginBottom",
        "marginHeight",
        "marginInline",
        "marginInlineEnd",
        "marginInlineStart",
        "marginLeft",
        "marginRight",
        "marginTop",
        "marginWidth",
        "mark",
        "marker",
        "marker-end",
        "marker-mid",
        "marker-offset",
        "marker-start",
        "markerEnd",
        "markerHeight",
        "markerMid",
        "markerOffset",
        "markerStart",
        "markerUnits",
        "markerWidth",
        "marks",
        "mask",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-position-x",
        "mask-position-y",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "maskClip",
        "maskComposite",
        "maskContentUnits",
        "maskImage",
        "maskMode",
        "maskOrigin",
        "maskPosition",
        "maskPositionX",
        "maskPositionY",
        "maskRepeat",
        "maskSize",
        "maskType",
        "maskUnits",
        "match",
        "matchAll",
        "matchMedia",
        "matchMedium",
        "matchPatterns",
        "matches",
        "math-depth",
        "math-style",
        "mathDepth",
        "mathStyle",
        "matrix",
        "matrixTransform",
        "max",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "maxActions",
        "maxAlternatives",
        "maxAnisotropy",
        "maxBindGroups",
        "maxBindGroupsPlusVertexBuffers",
        "maxBindingsPerBindGroup",
        "maxBlockSize",
        "maxBufferSize",
        "maxByteLength",
        "maxChannelCount",
        "maxChannels",
        "maxColorAttachmentBytesPerSample",
        "maxColorAttachments",
        "maxComputeInvocationsPerWorkgroup",
        "maxComputeWorkgroupSizeX",
        "maxComputeWorkgroupSizeY",
        "maxComputeWorkgroupSizeZ",
        "maxComputeWorkgroupStorageSize",
        "maxComputeWorkgroupsPerDimension",
        "maxConnectionsPerServer",
        "maxDatagramSize",
        "maxDecibels",
        "maxDistance",
        "maxDrawCount",
        "maxDynamicStorageBuffersPerPipelineLayout",
        "maxDynamicUniformBuffersPerPipelineLayout",
        "maxHeight",
        "maxInlineSize",
        "maxInterStageShaderComponents",
        "maxInterStageShaderVariables",
        "maxLayers",
        "maxLength",
        "maxMessageSize",
        "maxPacketLifeTime",
        "maxRetransmits",
        "maxSampledTexturesPerShaderStage",
        "maxSamplersPerShaderStage",
        "maxStorageBufferBindingSize",
        "maxStorageBuffersPerShaderStage",
        "maxStorageTexturesPerShaderStage",
        "maxTextureArrayLayers",
        "maxTextureDimension1D",
        "maxTextureDimension2D",
        "maxTextureDimension3D",
        "maxTouchPoints",
        "maxUniformBufferBindingSize",
        "maxUniformBuffersPerShaderStage",
        "maxValue",
        "maxVertexAttributes",
        "maxVertexBufferArrayStride",
        "maxVertexBuffers",
        "maxWidth",
        "maximumLatency",
        "measure",
        "measureText",
        "media",
        "mediaCapabilities",
        "mediaDevices",
        "mediaElement",
        "mediaGroup",
        "mediaKeys",
        "mediaSession",
        "mediaStream",
        "mediaText",
        "meetOrSlice",
        "memory",
        "menubar",
        "menus",
        "menusChild",
        "menusInternal",
        "mergeAttributes",
        "message",
        "messageClass",
        "messageHandlers",
        "messageType",
        "messages",
        "metaKey",
        "metadata",
        "method",
        "methodDetails",
        "methodName",
        "mid",
        "mimeType",
        "mimeTypes",
        "min",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "minBindingSize",
        "minBlockSize",
        "minDecibels",
        "minFilter",
        "minHeight",
        "minInlineSize",
        "minLength",
        "minStorageBufferOffsetAlignment",
        "minUniformBufferOffsetAlignment",
        "minValue",
        "minWidth",
        "minimumLatency",
        "mipLevel",
        "mipLevelCount",
        "mipmapFilter",
        "miterLimit",
        "mix-blend-mode",
        "mixBlendMode",
        "mm",
        "mobile",
        "mode",
        "model",
        "modify",
        "module",
        "mount",
        "move",
        "moveBy",
        "moveEnd",
        "moveFirst",
        "moveFocusDown",
        "moveFocusLeft",
        "moveFocusRight",
        "moveFocusUp",
        "moveInSuccession",
        "moveNext",
        "moveRow",
        "moveStart",
        "moveTo",
        "moveToBookmark",
        "moveToElementText",
        "moveToPoint",
        "movementX",
        "movementY",
        "mozAdd",
        "mozAnimationStartTime",
        "mozAnon",
        "mozApps",
        "mozAudioCaptured",
        "mozAudioChannelType",
        "mozAutoplayEnabled",
        "mozCancelAnimationFrame",
        "mozCancelFullScreen",
        "mozCancelRequestAnimationFrame",
        "mozCaptureStream",
        "mozCaptureStreamUntilEnded",
        "mozClearDataAt",
        "mozContact",
        "mozContacts",
        "mozCreateFileHandle",
        "mozCurrentTransform",
        "mozCurrentTransformInverse",
        "mozCursor",
        "mozDash",
        "mozDashOffset",
        "mozDecodedFrames",
        "mozExitPointerLock",
        "mozFillRule",
        "mozFragmentEnd",
        "mozFrameDelay",
        "mozFullScreen",
        "mozFullScreenElement",
        "mozFullScreenEnabled",
        "mozGetAll",
        "mozGetAllKeys",
        "mozGetAsFile",
        "mozGetDataAt",
        "mozGetMetadata",
        "mozGetUserMedia",
        "mozHasAudio",
        "mozHasItem",
        "mozHidden",
        "mozImageSmoothingEnabled",
        "mozIndexedDB",
        "mozInnerScreenX",
        "mozInnerScreenY",
        "mozInputSource",
        "mozIsTextField",
        "mozItem",
        "mozItemCount",
        "mozItems",
        "mozLength",
        "mozLockOrientation",
        "mozMatchesSelector",
        "mozMovementX",
        "mozMovementY",
        "mozOpaque",
        "mozOrientation",
        "mozPaintCount",
        "mozPaintedFrames",
        "mozParsedFrames",
        "mozPay",
        "mozPointerLockElement",
        "mozPresentedFrames",
        "mozPreservesPitch",
        "mozPressure",
        "mozPrintCallback",
        "mozRTCIceCandidate",
        "mozRTCPeerConnection",
        "mozRTCSessionDescription",
        "mozRemove",
        "mozRequestAnimationFrame",
        "mozRequestFullScreen",
        "mozRequestPointerLock",
        "mozSetDataAt",
        "mozSetImageElement",
        "mozSourceNode",
        "mozSrcObject",
        "mozSystem",
        "mozTCPSocket",
        "mozTextStyle",
        "mozTypesAt",
        "mozUnlockOrientation",
        "mozUserCancelled",
        "mozVisibilityState",
        "ms",
        "msAnimation",
        "msAnimationDelay",
        "msAnimationDirection",
        "msAnimationDuration",
        "msAnimationFillMode",
        "msAnimationIterationCount",
        "msAnimationName",
        "msAnimationPlayState",
        "msAnimationStartTime",
        "msAnimationTimingFunction",
        "msBackfaceVisibility",
        "msBlockProgression",
        "msCSSOMElementFloatMetrics",
        "msCaching",
        "msCachingEnabled",
        "msCancelRequestAnimationFrame",
        "msCapsLockWarningOff",
        "msClearImmediate",
        "msClose",
        "msContentZoomChaining",
        "msContentZoomFactor",
        "msContentZoomLimit",
        "msContentZoomLimitMax",
        "msContentZoomLimitMin",
        "msContentZoomSnap",
        "msContentZoomSnapPoints",
        "msContentZoomSnapType",
        "msContentZooming",
        "msConvertURL",
        "msCrypto",
        "msDoNotTrack",
        "msElementsFromPoint",
        "msElementsFromRect",
        "msExitFullscreen",
        "msExtendedCode",
        "msFillRule",
        "msFirstPaint",
        "msFlex",
        "msFlexAlign",
        "msFlexDirection",
        "msFlexFlow",
        "msFlexItemAlign",
        "msFlexLinePack",
        "msFlexNegative",
        "msFlexOrder",
        "msFlexPack",
        "msFlexPositive",
        "msFlexPreferredSize",
        "msFlexWrap",
        "msFlowFrom",
        "msFlowInto",
        "msFontFeatureSettings",
        "msFullscreenElement",
        "msFullscreenEnabled",
        "msGetInputContext",
        "msGetRegionContent",
        "msGetUntransformedBounds",
        "msGraphicsTrustStatus",
        "msGridColumn",
        "msGridColumnAlign",
        "msGridColumnSpan",
        "msGridColumns",
        "msGridRow",
        "msGridRowAlign",
        "msGridRowSpan",
        "msGridRows",
        "msHidden",
        "msHighContrastAdjust",
        "msHyphenateLimitChars",
        "msHyphenateLimitLines",
        "msHyphenateLimitZone",
        "msHyphens",
        "msImageSmoothingEnabled",
        "msImeAlign",
        "msIndexedDB",
        "msInterpolationMode",
        "msIsStaticHTML",
        "msKeySystem",
        "msKeys",
        "msLaunchUri",
        "msLockOrientation",
        "msManipulationViewsEnabled",
        "msMatchMedia",
        "msMatchesSelector",
        "msMaxTouchPoints",
        "msOrientation",
        "msOverflowStyle",
        "msPerspective",
        "msPerspectiveOrigin",
        "msPlayToDisabled",
        "msPlayToPreferredSourceUri",
        "msPlayToPrimary",
        "msPointerEnabled",
        "msRegionOverflow",
        "msReleasePointerCapture",
        "msRequestAnimationFrame",
        "msRequestFullscreen",
        "msSaveBlob",
        "msSaveOrOpenBlob",
        "msScrollChaining",
        "msScrollLimit",
        "msScrollLimitXMax",
        "msScrollLimitXMin",
        "msScrollLimitYMax",
        "msScrollLimitYMin",
        "msScrollRails",
        "msScrollSnapPointsX",
        "msScrollSnapPointsY",
        "msScrollSnapType",
        "msScrollSnapX",
        "msScrollSnapY",
        "msScrollTranslation",
        "msSetImmediate",
        "msSetMediaKeys",
        "msSetPointerCapture",
        "msTextCombineHorizontal",
        "msTextSizeAdjust",
        "msToBlob",
        "msTouchAction",
        "msTouchSelect",
        "msTraceAsyncCallbackCompleted",
        "msTraceAsyncCallbackStarting",
        "msTraceAsyncOperationCompleted",
        "msTraceAsyncOperationStarting",
        "msTransform",
        "msTransformOrigin",
        "msTransformStyle",
        "msTransition",
        "msTransitionDelay",
        "msTransitionDuration",
        "msTransitionProperty",
        "msTransitionTimingFunction",
        "msUnlockOrientation",
        "msUpdateAsyncCallbackRelation",
        "msUserSelect",
        "msVisibilityState",
        "msWrapFlow",
        "msWrapMargin",
        "msWrapThrough",
        "msWriteProfilerMark",
        "msZoom",
        "msZoomTo",
        "mt",
        "mul",
        "multiEntry",
        "multiSelectionObj",
        "multiline",
        "multiple",
        "multiply",
        "multiplySelf",
        "multisample",
        "multisampled",
        "mutableFile",
        "muted",
        "n",
        "nacl_arch",
        "name",
        "nameList",
        "nameProp",
        "namedItem",
        "namedRecordset",
        "names",
        "namespaceURI",
        "namespaces",
        "nativeApplication",
        "nativeMap",
        "nativeObjectCreate",
        "nativeSet",
        "nativeWeakMap",
        "naturalHeight",
        "naturalWidth",
        "navigate",
        "navigation",
        "navigationMode",
        "navigationPreload",
        "navigationStart",
        "navigationType",
        "navigator",
        "near",
        "nearestViewportElement",
        "negative",
        "negotiated",
        "netscape",
        "networkState",
        "networkStatus",
        "newScale",
        "newState",
        "newTranslate",
        "newURL",
        "newValue",
        "newValueSpecifiedUnits",
        "newVersion",
        "newhome",
        "next",
        "nextElementSibling",
        "nextHopProtocol",
        "nextNode",
        "nextPage",
        "nextSibling",
        "nickname",
        "noHref",
        "noModule",
        "noResize",
        "noShade",
        "noValidate",
        "noWrap",
        "node",
        "nodeName",
        "nodeType",
        "nodeValue",
        "nonce",
        "normDepthBufferFromNormView",
        "normalize",
        "normalizedPathSegList",
        "normandyAddonStudy",
        "notRestoredReasons",
        "notationName",
        "notations",
        "note",
        "noteGrainOn",
        "noteOff",
        "noteOn",
        "notifications",
        "notify",
        "now",
        "npnNegotiatedProtocol",
        "numOctaves",
        "number",
        "numberOfChannels",
        "numberOfFrames",
        "numberOfInputs",
        "numberOfItems",
        "numberOfOutputs",
        "numberValue",
        "oMatchesSelector",
        "object",
        "object-fit",
        "object-position",
        "objectFit",
        "objectPosition",
        "objectStore",
        "objectStoreNames",
        "objectType",
        "observe",
        "occlusionQuerySet",
        "of",
        "off",
        "offscreenBuffering",
        "offset",
        "offset-anchor",
        "offset-distance",
        "offset-path",
        "offset-position",
        "offset-rotate",
        "offsetAnchor",
        "offsetDistance",
        "offsetHeight",
        "offsetLeft",
        "offsetNode",
        "offsetParent",
        "offsetPath",
        "offsetPosition",
        "offsetRotate",
        "offsetTop",
        "offsetWidth",
        "offsetX",
        "offsetY",
        "ok",
        "oldState",
        "oldURL",
        "oldValue",
        "oldVersion",
        "olderShadowRoot",
        "omnibox",
        "on",
        "onActivated",
        "onAdded",
        "onAttached",
        "onBoundsChanged",
        "onBrowserUpdateAvailable",
        "onClicked",
        "onCommitFiberRoot",
        "onCommitFiberUnmount",
        "onConnect",
        "onConnectExternal",
        "onConnectNative",
        "onCreated",
        "onDetached",
        "onDisabled",
        "onEnabled",
        "onFocusChanged",
        "onHighlighted",
        "onInstalled",
        "onLine",
        "onMessage",
        "onMessageExternal",
        "onMoved",
        "onPerformanceWarning",
        "onPostCommitFiberRoot",
        "onRemoved",
        "onReplaced",
        "onRestartRequired",
        "onStartup",
        "onSubmittedWorkDone",
        "onSuspend",
        "onSuspendCanceled",
        "onUninstalled",
        "onUpdateAvailable",
        "onUpdated",
        "onUserScriptConnect",
        "onUserScriptMessage",
        "onUserSettingsChanged",
        "onZoomChange",
        "onabort",
        "onabsolutedeviceorientation",
        "onactivate",
        "onactive",
        "onaddsourcebuffer",
        "onaddstream",
        "onaddtrack",
        "onafterprint",
        "onafterscriptexecute",
        "onafterupdate",
        "onanimationcancel",
        "onanimationend",
        "onanimationiteration",
        "onanimationstart",
        "onappinstalled",
        "onaudioend",
        "onaudioprocess",
        "onaudiostart",
        "onautocomplete",
        "onautocompleteerror",
        "onauxclick",
        "onbeforeactivate",
        "onbeforecopy",
        "onbeforecut",
        "onbeforedeactivate",
        "onbeforeeditfocus",
        "onbeforeinput",
        "onbeforeinstallprompt",
        "onbeforematch",
        "onbeforepaste",
        "onbeforeprint",
        "onbeforescriptexecute",
        "onbeforetoggle",
        "onbeforeunload",
        "onbeforeupdate",
        "onbeforexrselect",
        "onbegin",
        "onblocked",
        "onblur",
        "onbounce",
        "onboundary",
        "onbufferedamountlow",
        "oncached",
        "oncancel",
        "oncandidatewindowhide",
        "oncandidatewindowshow",
        "oncandidatewindowupdate",
        "oncanplay",
        "oncanplaythrough",
        "oncapturehandlechange",
        "once",
        "oncellchange",
        "onchange",
        "oncharacterboundsupdate",
        "oncharacteristicvaluechanged",
        "onchargingchange",
        "onchargingtimechange",
        "onchecking",
        "onclick",
        "onclose",
        "onclosing",
        "oncompassneedscalibration",
        "oncomplete",
        "oncompositionend",
        "oncompositionstart",
        "onconnect",
        "onconnecting",
        "onconnectionavailable",
        "onconnectionstatechange",
        "oncontentvisibilityautostatechange",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncontrollerchange",
        "oncontrolselect",
        "oncopy",
        "oncuechange",
        "oncurrententrychange",
        "oncurrentscreenchange",
        "oncut",
        "ondataavailable",
        "ondatachannel",
        "ondatasetchanged",
        "ondatasetcomplete",
        "ondblclick",
        "ondeactivate",
        "ondequeue",
        "ondevicechange",
        "ondevicelight",
        "ondevicemotion",
        "ondeviceorientation",
        "ondeviceorientationabsolute",
        "ondeviceproximity",
        "ondischargingtimechange",
        "ondisconnect",
        "ondisplay",
        "ondispose",
        "ondownloading",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragexit",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onencrypted",
        "onend",
        "onended",
        "onenter",
        "onenterpictureinpicture",
        "onerror",
        "onerrorupdate",
        "onexit",
        "onfencedtreeclick",
        "onfilterchange",
        "onfinish",
        "onfocus",
        "onfocusin",
        "onfocusout",
        "onformdata",
        "onfreeze",
        "onfullscreenchange",
        "onfullscreenerror",
        "ongamepadconnected",
        "ongamepaddisconnected",
        "ongatheringstatechange",
        "ongattserverdisconnected",
        "ongeometrychange",
        "ongesturechange",
        "ongestureend",
        "ongesturestart",
        "ongotpointercapture",
        "onhashchange",
        "onhelp",
        "onicecandidate",
        "onicecandidateerror",
        "oniceconnectionstatechange",
        "onicegatheringstatechange",
        "oninactive",
        "oninput",
        "oninputreport",
        "oninputsourceschange",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeystatuseschange",
        "onkeyup",
        "onlanguagechange",
        "onlayoutcomplete",
        "onleavepictureinpicture",
        "onlevelchange",
        "onload",
        "onloadT",
        "onloadeddata",
        "onloadedmetadata",
        "onloadend",
        "onloading",
        "onloadingdone",
        "onloadingerror",
        "onloadstart",
        "onlosecapture",
        "onlostpointercapture",
        "only",
        "onmanagedconfigurationchange",
        "onmark",
        "onmessage",
        "onmessageerror",
        "onmidimessage",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onmousewheel",
        "onmove",
        "onmoveend",
        "onmovestart",
        "onmozfullscreenchange",
        "onmozfullscreenerror",
        "onmozorientationchange",
        "onmozpointerlockchange",
        "onmozpointerlockerror",
        "onmscontentzoom",
        "onmsfullscreenchange",
        "onmsfullscreenerror",
        "onmsgesturechange",
        "onmsgesturedoubletap",
        "onmsgestureend",
        "onmsgesturehold",
        "onmsgesturestart",
        "onmsgesturetap",
        "onmsgotpointercapture",
        "onmsinertiastart",
        "onmslostpointercapture",
        "onmsmanipulationstatechanged",
        "onmsneedkey",
        "onmsorientationchange",
        "onmspointercancel",
        "onmspointerdown",
        "onmspointerenter",
        "onmspointerhover",
        "onmspointerleave",
        "onmspointermove",
        "onmspointerout",
        "onmspointerover",
        "onmspointerup",
        "onmssitemodejumplistitemremoved",
        "onmsthumbnailclick",
        "onmute",
        "onnavigate",
        "onnavigateerror",
        "onnavigatesuccess",
        "onnegotiationneeded",
        "onnomatch",
        "onnoupdate",
        "onobsolete",
        "onoffline",
        "ononline",
        "onopen",
        "onorientationchange",
        "onpagechange",
        "onpagehide",
        "onpagereveal",
        "onpageshow",
        "onpageswap",
        "onpaste",
        "onpause",
        "onpayerdetailchange",
        "onpaymentmethodchange",
        "onplay",
        "onplaying",
        "onpluginstreamstart",
        "onpointercancel",
        "onpointerdown",
        "onpointerenter",
        "onpointerleave",
        "onpointerlockchange",
        "onpointerlockerror",
        "onpointermove",
        "onpointerout",
        "onpointerover",
        "onpointerrawupdate",
        "onpointerup",
        "onpopstate",
        "onprerenderingchange",
        "onprioritychange",
        "onprocessorerror",
        "onprogress",
        "onpropertychange",
        "onratechange",
        "onreading",
        "onreadystatechange",
        "onreflectionchange",
        "onrejectionhandled",
        "onrelease",
        "onremove",
        "onremovesourcebuffer",
        "onremovestream",
        "onremovetrack",
        "onrepeat",
        "onreset",
        "onresize",
        "onresizeend",
        "onresizestart",
        "onresourcetimingbufferfull",
        "onresult",
        "onresume",
        "onrowenter",
        "onrowexit",
        "onrowsdelete",
        "onrowsinserted",
        "onscreenschange",
        "onscroll",
        "onscrollend",
        "onscrollsnapchange",
        "onscrollsnapchanging",
        "onsearch",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onselectedcandidatepairchange",
        "onselectend",
        "onselectionchange",
        "onselectstart",
        "onshippingaddresschange",
        "onshippingoptionchange",
        "onshow",
        "onsignalingstatechange",
        "onsinkchange",
        "onslotchange",
        "onsoundend",
        "onsoundstart",
        "onsourceclose",
        "onsourceclosed",
        "onsourceended",
        "onsourceopen",
        "onspeechend",
        "onspeechstart",
        "onsqueeze",
        "onsqueezeend",
        "onsqueezestart",
        "onstalled",
        "onstart",
        "onstatechange",
        "onstop",
        "onstorage",
        "onstoragecommit",
        "onsubmit",
        "onsuccess",
        "onsuspend",
        "onterminate",
        "ontextformatupdate",
        "ontextinput",
        "ontextupdate",
        "ontimeout",
        "ontimeupdate",
        "ontoggle",
        "ontonechange",
        "ontouchcancel",
        "ontouchend",
        "ontouchmove",
        "ontouchstart",
        "ontrack",
        "ontransitioncancel",
        "ontransitionend",
        "ontransitionrun",
        "ontransitionstart",
        "onuncapturederror",
        "onunhandledrejection",
        "onunload",
        "onunmute",
        "onupdate",
        "onupdateend",
        "onupdatefound",
        "onupdateready",
        "onupdatestart",
        "onupgradeneeded",
        "onuserproximity",
        "onversionchange",
        "onvisibilitychange",
        "onvoiceschanged",
        "onvolumechange",
        "onvrdisplayactivate",
        "onvrdisplayconnect",
        "onvrdisplaydeactivate",
        "onvrdisplaydisconnect",
        "onvrdisplaypresentchange",
        "onwaiting",
        "onwaitingforkey",
        "onwarning",
        "onwebkitanimationend",
        "onwebkitanimationiteration",
        "onwebkitanimationstart",
        "onwebkitcurrentplaybacktargetiswirelesschanged",
        "onwebkitfullscreenchange",
        "onwebkitfullscreenerror",
        "onwebkitkeyadded",
        "onwebkitkeyerror",
        "onwebkitkeymessage",
        "onwebkitneedkey",
        "onwebkitorientationchange",
        "onwebkitplaybacktargetavailabilitychanged",
        "onwebkitpointerlockchange",
        "onwebkitpointerlockerror",
        "onwebkitresourcetimingbufferfull",
        "onwebkittransitionend",
        "onwheel",
        "onzoom",
        "opacity",
        "open",
        "openCursor",
        "openDatabase",
        "openKeyCursor",
        "openOptionsPage",
        "openOrClosedShadowRoot",
        "openPopup",
        "opened",
        "opener",
        "opera",
        "operation",
        "operationType",
        "operator",
        "opr",
        "optimum",
        "options",
        "or",
        "order",
        "orderX",
        "orderY",
        "ordered",
        "org",
        "organization",
        "orient",
        "orientAngle",
        "orientType",
        "orientation",
        "orientationX",
        "orientationY",
        "orientationZ",
        "origin",
        "originAgentCluster",
        "originalPolicy",
        "originalTarget",
        "orphans",
        "os",
        "oscpu",
        "outerHTML",
        "outerHeight",
        "outerText",
        "outerWidth",
        "outgoingHighWaterMark",
        "outgoingMaxAge",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "outlineColor",
        "outlineOffset",
        "outlineStyle",
        "outlineWidth",
        "outputBuffer",
        "outputChannelCount",
        "outputLatency",
        "outputs",
        "overflow",
        "overflow-anchor",
        "overflow-block",
        "overflow-clip-margin",
        "overflow-inline",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "overflowAnchor",
        "overflowBlock",
        "overflowClipMargin",
        "overflowInline",
        "overflowWrap",
        "overflowX",
        "overflowY",
        "overlaysContent",
        "overrideColors",
        "overrideMimeType",
        "oversample",
        "overscroll-behavior",
        "overscroll-behavior-block",
        "overscroll-behavior-inline",
        "overscroll-behavior-x",
        "overscroll-behavior-y",
        "overscrollBehavior",
        "overscrollBehaviorBlock",
        "overscrollBehaviorInline",
        "overscrollBehaviorX",
        "overscrollBehaviorY",
        "ownKeys",
        "ownerDocument",
        "ownerElement",
        "ownerNode",
        "ownerRule",
        "ownerSVGElement",
        "owningElement",
        "p1",
        "p2",
        "p3",
        "p4",
        "packetSize",
        "packets",
        "pad",
        "padEnd",
        "padStart",
        "padding",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-bottom",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "padding-left",
        "padding-right",
        "padding-top",
        "paddingBlock",
        "paddingBlockEnd",
        "paddingBlockStart",
        "paddingBottom",
        "paddingInline",
        "paddingInlineEnd",
        "paddingInlineStart",
        "paddingLeft",
        "paddingRight",
        "paddingTop",
        "page",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "page-orientation",
        "pageAction",
        "pageBreakAfter",
        "pageBreakBefore",
        "pageBreakInside",
        "pageCount",
        "pageLeft",
        "pageOrientation",
        "pageT",
        "pageTop",
        "pageX",
        "pageXOffset",
        "pageY",
        "pageYOffset",
        "pages",
        "paint-order",
        "paintOrder",
        "paintRequests",
        "paintType",
        "paintWorklet",
        "palette",
        "pan",
        "panningModel",
        "parameterData",
        "parameters",
        "parent",
        "parentElement",
        "parentNode",
        "parentRule",
        "parentStyleSheet",
        "parentTextEdit",
        "parentWindow",
        "parse",
        "parseAll",
        "parseCreationOptionsFromJSON",
        "parseFloat",
        "parseFromString",
        "parseHTMLUnsafe",
        "parseInt",
        "parseRequestOptionsFromJSON",
        "part",
        "participants",
        "passOp",
        "passive",
        "password",
        "pasteHTML",
        "path",
        "pathLength",
        "pathSegList",
        "pathSegType",
        "pathSegTypeAsLetter",
        "pathname",
        "pattern",
        "patternContentUnits",
        "patternMismatch",
        "patternTransform",
        "patternUnits",
        "pause",
        "pauseAnimations",
        "pauseDuration",
        "pauseOnExit",
        "pauseProfilers",
        "pauseTransformFeedback",
        "paused",
        "payerEmail",
        "payerName",
        "payerPhone",
        "paymentManager",
        "pc",
        "pdfViewerEnabled",
        "peerIdentity",
        "pending",
        "pendingLocalDescription",
        "pendingRemoteDescription",
        "percent",
        "performance",
        "periodicSync",
        "permission",
        "permissionState",
        "permissions",
        "persist",
        "persisted",
        "persistentDeviceId",
        "personalbar",
        "perspective",
        "perspective-origin",
        "perspectiveOrigin",
        "phone",
        "phoneticFamilyName",
        "phoneticGivenName",
        "photo",
        "pictureInPictureChild",
        "pictureInPictureElement",
        "pictureInPictureEnabled",
        "pictureInPictureWindow",
        "ping",
        "pipeThrough",
        "pipeTo",
        "pitch",
        "pixelBottom",
        "pixelDepth",
        "pixelHeight",
        "pixelLeft",
        "pixelRight",
        "pixelStorei",
        "pixelTop",
        "pixelUnitToMillimeterX",
        "pixelUnitToMillimeterY",
        "pixelWidth",
        "pkcs11",
        "place-content",
        "place-items",
        "place-self",
        "placeContent",
        "placeItems",
        "placeSelf",
        "placeholder",
        "platform",
        "platformVersion",
        "platforms",
        "play",
        "playEffect",
        "playState",
        "playbackRate",
        "playbackState",
        "playbackTime",
        "played",
        "playoutDelayHint",
        "playsInline",
        "plugins",
        "pluginspage",
        "pname",
        "pointer-events",
        "pointerBeforeReferenceNode",
        "pointerEnabled",
        "pointerEvents",
        "pointerId",
        "pointerLockElement",
        "pointerType",
        "points",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "polygonOffset",
        "pop",
        "popDebugGroup",
        "popErrorScope",
        "popover",
        "popoverTargetAction",
        "popoverTargetElement",
        "populateMatrix",
        "popupWindowFeatures",
        "popupWindowName",
        "popupWindowURI",
        "port",
        "port1",
        "port2",
        "ports",
        "posBottom",
        "posHeight",
        "posLeft",
        "posRight",
        "posTop",
        "posWidth",
        "pose",
        "position",
        "position-anchor",
        "position-area",
        "positionAlign",
        "positionAnchor",
        "positionArea",
        "positionX",
        "positionY",
        "positionZ",
        "postError",
        "postMessage",
        "postTask",
        "postalCode",
        "poster",
        "postscriptName",
        "pow",
        "powerEfficient",
        "powerOff",
        "powerPreference",
        "preMultiplySelf",
        "precision",
        "preferredReflectionFormat",
        "preferredStyleSheetSet",
        "preferredStylesheetSet",
        "prefix",
        "preload",
        "premultipliedAlpha",
        "prepend",
        "prerendering",
        "presentation",
        "presentationArea",
        "presentationStyle",
        "preserveAlpha",
        "preserveAspectRatio",
        "preserveAspectRatioString",
        "preservesPitch",
        "pressed",
        "pressure",
        "prevValue",
        "preventDefault",
        "preventExtensions",
        "preventSilentAccess",
        "previousElementSibling",
        "previousNode",
        "previousPage",
        "previousPriority",
        "previousRect",
        "previousScale",
        "previousSibling",
        "previousTranslate",
        "primaries",
        "primaryKey",
        "primaryLightDirection",
        "primaryLightIntensity",
        "primitive",
        "primitiveType",
        "primitiveUnits",
        "principals",
        "print",
        "print-color-adjust",
        "printColorAdjust",
        "printPreview",
        "priority",
        "privacy",
        "privateKey",
        "privateToken",
        "probablySupportsContext",
        "probeSpace",
        "process",
        "processIceMessage",
        "processingEnd",
        "processingStart",
        "processorOptions",
        "product",
        "productId",
        "productName",
        "productSub",
        "profile",
        "profileEnd",
        "profiles",
        "projectionMatrix",
        "promise",
        "prompt",
        "properties",
        "propertyIsEnumerable",
        "propertyName",
        "protectedAudience",
        "protocol",
        "protocolLong",
        "prototype",
        "provider",
        "proxy",
        "pseudoClass",
        "pseudoElement",
        "pt",
        "publicId",
        "publicKey",
        "published",
        "pulse",
        "push",
        "pushDebugGroup",
        "pushErrorScope",
        "pushManager",
        "pushNotification",
        "pushState",
        "put",
        "putImageData",
        "px",
        "quadraticCurveTo",
        "qualifier",
        "quaternion",
        "query",
        "queryCommandEnabled",
        "queryCommandIndeterm",
        "queryCommandState",
        "queryCommandSupported",
        "queryCommandText",
        "queryCommandValue",
        "queryFeatureSupport",
        "queryLocalFonts",
        "queryPermission",
        "querySelector",
        "querySelectorAll",
        "querySet",
        "queue",
        "queueMicrotask",
        "quote",
        "quotes",
        "r",
        "r1",
        "r2",
        "race",
        "rad",
        "radiogroup",
        "radius",
        "radiusX",
        "radiusY",
        "random",
        "randomUUID",
        "range",
        "rangeCount",
        "rangeEnd",
        "rangeMax",
        "rangeMin",
        "rangeOffset",
        "rangeOverflow",
        "rangeParent",
        "rangeStart",
        "rangeUnderflow",
        "rate",
        "ratio",
        "raw",
        "rawId",
        "rawJSON",
        "rawValueToMeters",
        "rcap",
        "rch",
        "read",
        "readAsArrayBuffer",
        "readAsBinaryString",
        "readAsBlob",
        "readAsDataURL",
        "readAsText",
        "readBuffer",
        "readEntries",
        "readOnly",
        "readPixels",
        "readReportRequested",
        "readText",
        "readValue",
        "readable",
        "ready",
        "readyState",
        "reason",
        "reasons",
        "reboot",
        "receiveFeatureReport",
        "receivedAlert",
        "receiver",
        "receivers",
        "recipient",
        "recommendedViewportScale",
        "reconnect",
        "recordNumber",
        "recordsAvailable",
        "recordset",
        "rect",
        "red",
        "redEyeReduction",
        "redirect",
        "redirectCount",
        "redirectEnd",
        "redirectStart",
        "redirected",
        "reduce",
        "reduceRight",
        "reduction",
        "refDistance",
        "refX",
        "refY",
        "referenceNode",
        "referenceSpace",
        "referrer",
        "referrerPolicy",
        "refresh",
        "region",
        "regionAnchorX",
        "regionAnchorY",
        "regionId",
        "regions",
        "register",
        "registerContentHandler",
        "registerElement",
        "registerInternalModuleStart",
        "registerInternalModuleStop",
        "registerProperty",
        "registerProtocolHandler",
        "reject",
        "rel",
        "relList",
        "relatedAddress",
        "relatedNode",
        "relatedPort",
        "relatedTarget",
        "relayProtocol",
        "release",
        "releaseCapture",
        "releaseEvents",
        "releaseInterface",
        "releaseLock",
        "releasePointerCapture",
        "releaseShaderCompiler",
        "released",
        "reliability",
        "reliable",
        "reliableWrite",
        "reload",
        "rem",
        "remainingSpace",
        "remote",
        "remoteDescription",
        "remove",
        "removeAllRanges",
        "removeAttribute",
        "removeAttributeNS",
        "removeAttributeNode",
        "removeBehavior",
        "removeChild",
        "removeCue",
        "removeEntry",
        "removeEventListener",
        "removeFilter",
        "removeImport",
        "removeItem",
        "removeListener",
        "removeNamedItem",
        "removeNamedItemNS",
        "removeNode",
        "removeParameter",
        "removeProperty",
        "removeRange",
        "removeRegion",
        "removeRule",
        "removeSiteSpecificTrackingException",
        "removeSourceBuffer",
        "removeStream",
        "removeTrack",
        "removeVariable",
        "removeWakeLockListener",
        "removeWebWideTrackingException",
        "removed",
        "removedNodes",
        "renderBlockingStatus",
        "renderHeight",
        "renderStart",
        "renderState",
        "renderTime",
        "renderWidth",
        "renderbufferStorage",
        "renderbufferStorageMultisample",
        "renderedBuffer",
        "rendererInterfaces",
        "renderers",
        "renderingMode",
        "renotify",
        "repeat",
        "repetitionCount",
        "replace",
        "replaceAdjacentText",
        "replaceAll",
        "replaceChild",
        "replaceChildren",
        "replaceData",
        "replaceId",
        "replaceItem",
        "replaceNode",
        "replaceState",
        "replaceSync",
        "replaceTrack",
        "replaceWholeText",
        "replaceWith",
        "reportError",
        "reportEvent",
        "reportId",
        "reportValidity",
        "request",
        "requestAdapter",
        "requestAdapterInfo",
        "requestAnimationFrame",
        "requestAutocomplete",
        "requestClose",
        "requestData",
        "requestDevice",
        "requestFrame",
        "requestFullscreen",
        "requestHitTestSource",
        "requestHitTestSourceForTransientInput",
        "requestId",
        "requestIdleCallback",
        "requestLightProbe",
        "requestMIDIAccess",
        "requestMediaKeySystemAccess",
        "requestPermission",
        "requestPictureInPicture",
        "requestPointerLock",
        "requestPort",
        "requestPresent",
        "requestPresenter",
        "requestReferenceSpace",
        "requestSession",
        "requestStart",
        "requestStorageAccess",
        "requestStorageAccessFor",
        "requestSubmit",
        "requestTime",
        "requestUpdateCheck",
        "requestVideoFrameCallback",
        "requestViewportScale",
        "requestWindow",
        "requestingWindow",
        "requireInteraction",
        "required",
        "requiredExtensions",
        "requiredFeatures",
        "requiredLimits",
        "reset",
        "resetLatency",
        "resetPose",
        "resetTransform",
        "resizable",
        "resize",
        "resizeBy",
        "resizeTo",
        "resolve",
        "resolveQuerySet",
        "resolveTarget",
        "resource",
        "respond",
        "respondWithNewView",
        "response",
        "responseBody",
        "responseEnd",
        "responseReady",
        "responseStart",
        "responseStatus",
        "responseText",
        "responseType",
        "responseURL",
        "responseXML",
        "restart",
        "restartAfterDelay",
        "restartIce",
        "restore",
        "result",
        "resultIndex",
        "resultType",
        "results",
        "resume",
        "resumeProfilers",
        "resumeTransformFeedback",
        "retry",
        "returnValue",
        "rev",
        "reverse",
        "reversed",
        "revocable",
        "revokeObjectURL",
        "rex",
        "rgbColor",
        "ric",
        "right",
        "rightContext",
        "rightDegrees",
        "rightMargin",
        "rightProjectionMatrix",
        "rightViewMatrix",
        "rlh",
        "role",
        "rolloffFactor",
        "root",
        "rootBounds",
        "rootElement",
        "rootMargin",
        "rotate",
        "rotateAxisAngle",
        "rotateAxisAngleSelf",
        "rotateFromVector",
        "rotateFromVectorSelf",
        "rotateSelf",
        "rotation",
        "rotationAngle",
        "rotationRate",
        "round",
        "roundRect",
        "row-gap",
        "rowGap",
        "rowIndex",
        "rowSpan",
        "rows",
        "rowsPerImage",
        "rtcpTransport",
        "rtt",
        "ruby-align",
        "ruby-position",
        "rubyAlign",
        "rubyOverhang",
        "rubyPosition",
        "rules",
        "run",
        "runAdAuction",
        "runtime",
        "runtimeStyle",
        "rx",
        "ry",
        "s",
        "safari",
        "sameDocument",
        "sample",
        "sampleCount",
        "sampleCoverage",
        "sampleInterval",
        "sampleRate",
        "sampleType",
        "sampler",
        "samplerParameterf",
        "samplerParameteri",
        "sandbox",
        "save",
        "saveAsPDF",
        "saveData",
        "scale",
        "scale3d",
        "scale3dSelf",
        "scaleNonUniform",
        "scaleNonUniformSelf",
        "scaleSelf",
        "scheduler",
        "scheduling",
        "scheme",
        "scissor",
        "scope",
        "scopeName",
        "scoped",
        "screen",
        "screenBrightness",
        "screenEnabled",
        "screenLeft",
        "screenPixelToMillimeterX",
        "screenPixelToMillimeterY",
        "screenState",
        "screenTop",
        "screenX",
        "screenY",
        "screens",
        "scriptURL",
        "scripting",
        "scripts",
        "scroll",
        "scroll-behavior",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-stop",
        "scroll-snap-type",
        "scrollAmount",
        "scrollBehavior",
        "scrollBy",
        "scrollByLines",
        "scrollByPages",
        "scrollDelay",
        "scrollHeight",
        "scrollIntoView",
        "scrollIntoViewIfNeeded",
        "scrollLeft",
        "scrollLeftMax",
        "scrollMargin",
        "scrollMarginBlock",
        "scrollMarginBlockEnd",
        "scrollMarginBlockStart",
        "scrollMarginBottom",
        "scrollMarginInline",
        "scrollMarginInlineEnd",
        "scrollMarginInlineStart",
        "scrollMarginLeft",
        "scrollMarginRight",
        "scrollMarginTop",
        "scrollMaxX",
        "scrollMaxY",
        "scrollPadding",
        "scrollPaddingBlock",
        "scrollPaddingBlockEnd",
        "scrollPaddingBlockStart",
        "scrollPaddingBottom",
        "scrollPaddingInline",
        "scrollPaddingInlineEnd",
        "scrollPaddingInlineStart",
        "scrollPaddingLeft",
        "scrollPaddingRight",
        "scrollPaddingTop",
        "scrollRestoration",
        "scrollSnapAlign",
        "scrollSnapStop",
        "scrollSnapType",
        "scrollTo",
        "scrollTop",
        "scrollTopMax",
        "scrollWidth",
        "scrollX",
        "scrollY",
        "scrollbar-color",
        "scrollbar-gutter",
        "scrollbar-width",
        "scrollbar3dLightColor",
        "scrollbarArrowColor",
        "scrollbarBaseColor",
        "scrollbarColor",
        "scrollbarDarkShadowColor",
        "scrollbarFaceColor",
        "scrollbarGutter",
        "scrollbarHighlightColor",
        "scrollbarShadowColor",
        "scrollbarTrackColor",
        "scrollbarWidth",
        "scrollbars",
        "scrolling",
        "scrollingElement",
        "sctp",
        "sctpCauseCode",
        "sdp",
        "sdpLineNumber",
        "sdpMLineIndex",
        "sdpMid",
        "seal",
        "search",
        "searchBox",
        "searchBoxJavaBridge_",
        "searchParams",
        "sectionRowIndex",
        "secureConnectionStart",
        "security",
        "seed",
        "seek",
        "seekToNextFrame",
        "seekable",
        "seeking",
        "select",
        "selectAllChildren",
        "selectAlternateInterface",
        "selectAudioOutput",
        "selectConfiguration",
        "selectNode",
        "selectNodeContents",
        "selectNodes",
        "selectSingleNode",
        "selectSubString",
        "selectURL",
        "selected",
        "selectedIndex",
        "selectedOptions",
        "selectedStyleSheetSet",
        "selectedStylesheetSet",
        "selectedTrack",
        "selection",
        "selectionDirection",
        "selectionEnd",
        "selectionStart",
        "selector",
        "selectorText",
        "self",
        "send",
        "sendAsBinary",
        "sendBeacon",
        "sendFeatureReport",
        "sendMessage",
        "sendNativeMessage",
        "sendOrder",
        "sendReport",
        "sender",
        "sentAlert",
        "sentTimestamp",
        "separator",
        "serial",
        "serialNumber",
        "serializable",
        "serializeToString",
        "serverTiming",
        "service",
        "serviceWorker",
        "session",
        "sessionId",
        "sessionStorage",
        "sessions",
        "set",
        "setActionHandler",
        "setActive",
        "setAlpha",
        "setAppBadge",
        "setAttribute",
        "setAttributeNS",
        "setAttributeNode",
        "setAttributeNodeNS",
        "setAttributionReporting",
        "setBadgeBackgroundColor",
        "setBadgeText",
        "setBadgeTextColor",
        "setBaseAndExtent",
        "setBigInt64",
        "setBigUint64",
        "setBindGroup",
        "setBingCurrentSearchDefault",
        "setBlendConstant",
        "setCameraActive",
        "setCapture",
        "setCaptureHandleConfig",
        "setCodecPreferences",
        "setColor",
        "setCompositeOperation",
        "setConfiguration",
        "setConsumer",
        "setCurrentTime",
        "setCustomValidity",
        "setData",
        "setDate",
        "setDragImage",
        "setEnabled",
        "setEnd",
        "setEndAfter",
        "setEndBefore",
        "setEndPoint",
        "setExpires",
        "setFillColor",
        "setFilterRes",
        "setFloat16",
        "setFloat32",
        "setFloat64",
        "setFloatValue",
        "setFocusBehavior",
        "setFormValue",
        "setFromBase64",
        "setFromHex",
        "setFullYear",
        "setHTMLUnsafe",
        "setHeaderExtensionsToNegotiate",
        "setHeaderValue",
        "setHours",
        "setIcon",
        "setIdentityProvider",
        "setImmediate",
        "setIndexBuffer",
        "setInt16",
        "setInt32",
        "setInt8",
        "setInterval",
        "setItem",
        "setKeyframes",
        "setLineCap",
        "setLineDash",
        "setLineJoin",
        "setLineWidth",
        "setLiveSeekableRange",
        "setLocalDescription",
        "setMatrix",
        "setMatrixValue",
        "setMediaKeys",
        "setMicrophoneActive",
        "setMilliseconds",
        "setMinutes",
        "setMiterLimit",
        "setMonth",
        "setNamedItem",
        "setNamedItemNS",
        "setNonUserCodeExceptions",
        "setOrientToAngle",
        "setOrientToAuto",
        "setOrientation",
        "setOverrideHistoryNavigationMode",
        "setPaint",
        "setParameter",
        "setParameters",
        "setPeriodicWave",
        "setPipeline",
        "setPointerCapture",
        "setPopup",
        "setPosition",
        "setPositionState",
        "setPreference",
        "setPriority",
        "setPrivateToken",
        "setProperty",
        "setPrototypeOf",
        "setRGBColor",
        "setRGBColorICCColor",
        "setRadius",
        "setRangeText",
        "setRemoteDescription",
        "setReportEventDataForAutomaticBeacons",
        "setRequestHeader",
        "setResizable",
        "setResourceTimingBufferSize",
        "setRotate",
        "setScale",
        "setScissorRect",
        "setSeconds",
        "setSelectionRange",
        "setServerCertificate",
        "setShadow",
        "setSharedStorageContext",
        "setSignals",
        "setSinkId",
        "setSkewX",
        "setSkewY",
        "setStart",
        "setStartAfter",
        "setStartBefore",
        "setStatus",
        "setStdDeviation",
        "setStencilReference",
        "setStreams",
        "setStrictMode",
        "setStringValue",
        "setStrokeColor",
        "setSuggestResult",
        "setTargetAtTime",
        "setTargetValueAtTime",
        "setTime",
        "setTimeout",
        "setTitle",
        "setTransform",
        "setTranslate",
        "setUTCDate",
        "setUTCFullYear",
        "setUTCHours",
        "setUTCMilliseconds",
        "setUTCMinutes",
        "setUTCMonth",
        "setUTCSeconds",
        "setUint16",
        "setUint32",
        "setUint8",
        "setUninstallURL",
        "setUpdateUrlData",
        "setUri",
        "setValidity",
        "setValueAtTime",
        "setValueCurveAtTime",
        "setVariable",
        "setVelocity",
        "setVersion",
        "setVertexBuffer",
        "setViewport",
        "setYear",
        "setZoom",
        "setZoomSettings",
        "settingName",
        "settingValue",
        "sex",
        "shaderLocation",
        "shaderSource",
        "shadowBlur",
        "shadowColor",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowRoot",
        "shadowRootClonable",
        "shadowRootDelegatesFocus",
        "shadowRootMode",
        "shadowRootSerializable",
        "shape",
        "shape-image-threshold",
        "shape-margin",
        "shape-outside",
        "shape-rendering",
        "shapeImageThreshold",
        "shapeMargin",
        "shapeOutside",
        "shapeRendering",
        "share",
        "sharedStorage",
        "sharedStorageWritable",
        "sheet",
        "shift",
        "shiftKey",
        "shiftLeft",
        "shippingAddress",
        "shippingOption",
        "shippingType",
        "show",
        "showDirectoryPicker",
        "showHelp",
        "showModal",
        "showModalDialog",
        "showModelessDialog",
        "showNotification",
        "showOpenFilePicker",
        "showPicker",
        "showPopover",
        "showSaveFilePicker",
        "sidebar",
        "sidebarAction",
        "sign",
        "signal",
        "signalingState",
        "signature",
        "silent",
        "sin",
        "singleNodeValue",
        "sinh",
        "sinkId",
        "sittingToStandingTransform",
        "size",
        "sizeAdjust",
        "sizeToContent",
        "sizeX",
        "sizeZ",
        "sizes",
        "skewX",
        "skewXSelf",
        "skewY",
        "skewYSelf",
        "skipTransition",
        "skipped",
        "slice",
        "slope",
        "slot",
        "slotAssignment",
        "small",
        "smil",
        "smooth",
        "smoothingTimeConstant",
        "snapTargetBlock",
        "snapTargetInline",
        "snapToLines",
        "snapshotItem",
        "snapshotLength",
        "some",
        "sort",
        "sortingCode",
        "source",
        "sourceBuffer",
        "sourceBuffers",
        "sourceCapabilities",
        "sourceCharPosition",
        "sourceFile",
        "sourceFunctionName",
        "sourceIndex",
        "sourceMap",
        "sourceURL",
        "sources",
        "spacing",
        "span",
        "speak",
        "speakAs",
        "speaking",
        "species",
        "specified",
        "specularConstant",
        "specularExponent",
        "speechSynthesis",
        "speed",
        "speedOfSound",
        "spellcheck",
        "sphericalHarmonicsCoefficients",
        "splice",
        "split",
        "splitText",
        "spreadMethod",
        "sqrt",
        "src",
        "srcElement",
        "srcFactor",
        "srcFilter",
        "srcObject",
        "srcUrn",
        "srcdoc",
        "srclang",
        "srcset",
        "stack",
        "stackTraceLimit",
        "stacktrace",
        "stageParameters",
        "standalone",
        "standby",
        "start",
        "startContainer",
        "startE",
        "startIce",
        "startLoadTime",
        "startMessages",
        "startNotifications",
        "startOffset",
        "startProfiling",
        "startRendering",
        "startShark",
        "startTime",
        "startViewTransition",
        "startsWith",
        "state",
        "states",
        "stats",
        "status",
        "statusCode",
        "statusMessage",
        "statusText",
        "statusbar",
        "stdDeviationX",
        "stdDeviationY",
        "stencilBack",
        "stencilClearValue",
        "stencilFront",
        "stencilFunc",
        "stencilFuncSeparate",
        "stencilLoadOp",
        "stencilMask",
        "stencilMaskSeparate",
        "stencilOp",
        "stencilOpSeparate",
        "stencilReadMask",
        "stencilReadOnly",
        "stencilStoreOp",
        "stencilWriteMask",
        "step",
        "stepDown",
        "stepMismatch",
        "stepMode",
        "stepUp",
        "sticky",
        "stitchTiles",
        "stop",
        "stop-color",
        "stop-opacity",
        "stopColor",
        "stopImmediatePropagation",
        "stopNotifications",
        "stopOpacity",
        "stopProfiling",
        "stopPropagation",
        "stopShark",
        "stopped",
        "storage",
        "storageArea",
        "storageBuckets",
        "storageName",
        "storageStatus",
        "storageTexture",
        "store",
        "storeOp",
        "storeSiteSpecificTrackingException",
        "storeWebWideTrackingException",
        "stpVersion",
        "stream",
        "streamErrorCode",
        "streams",
        "stretch",
        "strike",
        "string",
        "stringValue",
        "stringify",
        "stripIndexFormat",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "strokeDasharray",
        "strokeDashoffset",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeMiterlimit",
        "strokeOpacity",
        "strokeRect",
        "strokeStyle",
        "strokeText",
        "strokeWidth",
        "structuredClone",
        "style",
        "styleAndLayoutStart",
        "styleFloat",
        "styleMap",
        "styleMedia",
        "styleSheet",
        "styleSheetSets",
        "styleSheets",
        "sub",
        "subarray",
        "subject",
        "submit",
        "submitFrame",
        "submitter",
        "subscribe",
        "substr",
        "substring",
        "substringData",
        "subtle",
        "subtree",
        "suffix",
        "suffixes",
        "summary",
        "sup",
        "supported",
        "supportedContentEncodings",
        "supportedEntryTypes",
        "supportedValuesOf",
        "supports",
        "supportsFiber",
        "supportsSession",
        "supportsText",
        "surfaceScale",
        "surroundContents",
        "suspend",
        "suspendRedraw",
        "svb",
        "svh",
        "svi",
        "svmax",
        "svmin",
        "svw",
        "swapCache",
        "swapNode",
        "sweepFlag",
        "symbols",
        "symmetricDifference",
        "sync",
        "syntax",
        "sysexEnabled",
        "system",
        "systemCode",
        "systemId",
        "systemLanguage",
        "systemXDPI",
        "systemYDPI",
        "tBodies",
        "tFoot",
        "tHead",
        "tab",
        "tab-size",
        "tabId",
        "tabIds",
        "tabIndex",
        "tabSize",
        "table",
        "table-layout",
        "tableLayout",
        "tableValues",
        "tabs",
        "tag",
        "tagName",
        "tagUrn",
        "tags",
        "taintEnabled",
        "take",
        "takePhoto",
        "takeRecords",
        "tan",
        "tangentialPressure",
        "tanh",
        "target",
        "targetAddressSpace",
        "targetElement",
        "targetRayMode",
        "targetRaySpace",
        "targetTouches",
        "targetURL",
        "targetX",
        "targetY",
        "targets",
        "tcpType",
        "tee",
        "tel",
        "telemetry",
        "terminate",
        "test",
        "texImage2D",
        "texImage3D",
        "texParameterf",
        "texParameteri",
        "texStorage2D",
        "texStorage3D",
        "texSubImage2D",
        "texSubImage3D",
        "text",
        "text-align",
        "text-align-last",
        "text-anchor",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-skip-ink",
        "text-decoration-style",
        "text-decoration-thickness",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-transform",
        "text-underline-offset",
        "text-underline-position",
        "text-wrap",
        "text-wrap-mode",
        "text-wrap-style",
        "textAlign",
        "textAlignLast",
        "textAnchor",
        "textAutospace",
        "textBaseline",
        "textCombineUpright",
        "textContent",
        "textDecoration",
        "textDecorationBlink",
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationLineThrough",
        "textDecorationNone",
        "textDecorationOverline",
        "textDecorationSkipInk",
        "textDecorationStyle",
        "textDecorationThickness",
        "textDecorationUnderline",
        "textEmphasis",
        "textEmphasisColor",
        "textEmphasisPosition",
        "textEmphasisStyle",
        "textIndent",
        "textJustify",
        "textJustifyTrim",
        "textKashida",
        "textKashidaSpace",
        "textLength",
        "textOrientation",
        "textOverflow",
        "textRendering",
        "textShadow",
        "textTracks",
        "textTransform",
        "textUnderlineOffset",
        "textUnderlinePosition",
        "textWrap",
        "textWrapMode",
        "textWrapStyle",
        "texture",
        "theme",
        "then",
        "threadId",
        "threshold",
        "thresholds",
        "throwIfAborted",
        "tiltX",
        "tiltY",
        "time",
        "timeEnd",
        "timeLog",
        "timeOrigin",
        "timeRemaining",
        "timeStamp",
        "timecode",
        "timeline",
        "timelineTime",
        "timeout",
        "timestamp",
        "timestampOffset",
        "timestampWrites",
        "timing",
        "title",
        "titlebarAreaRect",
        "tlsChannelId",
        "to",
        "toArray",
        "toBase64",
        "toBlob",
        "toDataURL",
        "toDateString",
        "toElement",
        "toExponential",
        "toFixed",
        "toFloat32Array",
        "toFloat64Array",
        "toGMTString",
        "toHex",
        "toISOString",
        "toJSON",
        "toLocaleDateString",
        "toLocaleFormat",
        "toLocaleLowerCase",
        "toLocaleString",
        "toLocaleTimeString",
        "toLocaleUpperCase",
        "toLowerCase",
        "toMatrix",
        "toMethod",
        "toPrecision",
        "toPrimitive",
        "toReversed",
        "toSdp",
        "toSorted",
        "toSource",
        "toSpliced",
        "toStaticHTML",
        "toString",
        "toStringTag",
        "toSum",
        "toTimeString",
        "toUTCString",
        "toUpperCase",
        "toWellFormed",
        "toggle",
        "toggleAttribute",
        "toggleLongPressEnabled",
        "togglePopover",
        "toggleReaderMode",
        "token",
        "tone",
        "toneBuffer",
        "tooLong",
        "tooShort",
        "toolbar",
        "top",
        "topMargin",
        "topSites",
        "topology",
        "total",
        "totalFrameDelay",
        "totalFrames",
        "totalFramesDuration",
        "totalVideoFrames",
        "touch-action",
        "touchAction",
        "touched",
        "touches",
        "trace",
        "track",
        "trackVisibility",
        "trackedAnchors",
        "tracks",
        "tran",
        "transaction",
        "transactions",
        "transceiver",
        "transfer",
        "transferControlToOffscreen",
        "transferFromImageBitmap",
        "transferImageBitmap",
        "transferIn",
        "transferOut",
        "transferSize",
        "transferToFixedLength",
        "transferToImageBitmap",
        "transform",
        "transform-box",
        "transform-origin",
        "transform-style",
        "transformBox",
        "transformFeedbackVaryings",
        "transformOrigin",
        "transformPoint",
        "transformString",
        "transformStyle",
        "transformToDocument",
        "transformToFragment",
        "transition",
        "transition-behavior",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "transitionBehavior",
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction",
        "translate",
        "translateSelf",
        "translationX",
        "translationY",
        "transport",
        "traverseTo",
        "trim",
        "trimEnd",
        "trimLeft",
        "trimRight",
        "trimStart",
        "trueSpeed",
        "trunc",
        "truncate",
        "trustedTypes",
        "try",
        "turn",
        "twist",
        "type",
        "typeDetail",
        "typeMismatch",
        "typeMustMatch",
        "types",
        "u2f",
        "ubound",
        "uint16",
        "uint32",
        "uint8",
        "uint8Clamped",
        "unadjustedMovement",
        "unclippedDepth",
        "unconfigure",
        "undefined",
        "underlineStyle",
        "underlineThickness",
        "unescape",
        "uneval",
        "ungroup",
        "unicode",
        "unicode-bidi",
        "unicodeBidi",
        "unicodeRange",
        "unicodeSets",
        "uniform1f",
        "uniform1fv",
        "uniform1i",
        "uniform1iv",
        "uniform1ui",
        "uniform1uiv",
        "uniform2f",
        "uniform2fv",
        "uniform2i",
        "uniform2iv",
        "uniform2ui",
        "uniform2uiv",
        "uniform3f",
        "uniform3fv",
        "uniform3i",
        "uniform3iv",
        "uniform3ui",
        "uniform3uiv",
        "uniform4f",
        "uniform4fv",
        "uniform4i",
        "uniform4iv",
        "uniform4ui",
        "uniform4uiv",
        "uniformBlockBinding",
        "uniformMatrix2fv",
        "uniformMatrix2x3fv",
        "uniformMatrix2x4fv",
        "uniformMatrix3fv",
        "uniformMatrix3x2fv",
        "uniformMatrix3x4fv",
        "uniformMatrix4fv",
        "uniformMatrix4x2fv",
        "uniformMatrix4x3fv",
        "uninstallSelf",
        "union",
        "unique",
        "uniqueID",
        "uniqueNumber",
        "unit",
        "unitType",
        "units",
        "unloadEventEnd",
        "unloadEventStart",
        "unlock",
        "unmap",
        "unmount",
        "unobserve",
        "unpackColorSpace",
        "unpause",
        "unpauseAnimations",
        "unreadCount",
        "unregister",
        "unregisterContentHandler",
        "unregisterProtocolHandler",
        "unscopables",
        "unselectable",
        "unshift",
        "unsubscribe",
        "unsuspendRedraw",
        "unsuspendRedrawAll",
        "unwatch",
        "unwrapKey",
        "upDegrees",
        "upX",
        "upY",
        "upZ",
        "update",
        "updateAdInterestGroups",
        "updateCallbackDone",
        "updateCharacterBounds",
        "updateCommands",
        "updateControlBounds",
        "updateCurrentEntry",
        "updateIce",
        "updateInkTrailStartPoint",
        "updateInterval",
        "updatePlaybackRate",
        "updateRangeEnd",
        "updateRangeStart",
        "updateRenderState",
        "updateSelection",
        "updateSelectionBounds",
        "updateSettings",
        "updateText",
        "updateTiming",
        "updateViaCache",
        "updateWith",
        "updated",
        "updating",
        "upgrade",
        "upload",
        "uploadTotal",
        "uploaded",
        "upper",
        "upperBound",
        "upperOpen",
        "uri",
        "url",
        "urn",
        "urns",
        "usage",
        "usages",
        "usb",
        "usbVersionMajor",
        "usbVersionMinor",
        "usbVersionSubminor",
        "useCurrentView",
        "useMap",
        "useProgram",
        "usedSpace",
        "user-select",
        "userActivation",
        "userAgent",
        "userAgentData",
        "userChoice",
        "userHandle",
        "userHint",
        "userInitiated",
        "userLanguage",
        "userSelect",
        "userState",
        "userVisibleOnly",
        "username",
        "usernameFragment",
        "utterance",
        "uuid",
        "v8BreakIterator",
        "vAlign",
        "vLink",
        "valid",
        "validate",
        "validateProgram",
        "validationMessage",
        "validity",
        "value",
        "valueAsDate",
        "valueAsNumber",
        "valueAsString",
        "valueInSpecifiedUnits",
        "valueMissing",
        "valueOf",
        "valueText",
        "valueType",
        "values",
        "variable",
        "variant",
        "variationSettings",
        "vb",
        "vector-effect",
        "vectorEffect",
        "velocityAngular",
        "velocityExpansion",
        "velocityX",
        "velocityY",
        "vendor",
        "vendorId",
        "vendorSub",
        "verify",
        "version",
        "vertex",
        "vertexAttrib1f",
        "vertexAttrib1fv",
        "vertexAttrib2f",
        "vertexAttrib2fv",
        "vertexAttrib3f",
        "vertexAttrib3fv",
        "vertexAttrib4f",
        "vertexAttrib4fv",
        "vertexAttribDivisor",
        "vertexAttribDivisorANGLE",
        "vertexAttribI4i",
        "vertexAttribI4iv",
        "vertexAttribI4ui",
        "vertexAttribI4uiv",
        "vertexAttribIPointer",
        "vertexAttribPointer",
        "vertical",
        "vertical-align",
        "verticalAlign",
        "verticalOverflow",
        "vh",
        "vi",
        "vibrate",
        "vibrationActuator",
        "videoBitsPerSecond",
        "videoHeight",
        "videoTracks",
        "videoWidth",
        "view",
        "viewBox",
        "viewBoxString",
        "viewDimension",
        "viewFormats",
        "viewTarget",
        "viewTargetString",
        "viewTransition",
        "viewport",
        "viewportAnchorX",
        "viewportAnchorY",
        "viewportElement",
        "views",
        "violatedDirective",
        "virtualKeyboard",
        "virtualKeyboardPolicy",
        "visibility",
        "visibilityState",
        "visible",
        "visibleRect",
        "visualViewport",
        "vlinkColor",
        "vmax",
        "vmin",
        "voice",
        "voiceURI",
        "volume",
        "vrml",
        "vspace",
        "vw",
        "w",
        "wait",
        "waitAsync",
        "waitSync",
        "waiting",
        "wake",
        "wakeLock",
        "wand",
        "warmup",
        "warn",
        "wasAlternateProtocolAvailable",
        "wasClean",
        "wasDiscarded",
        "wasFetchedViaSpdy",
        "wasNpnNegotiated",
        "watch",
        "watchAvailability",
        "watchPosition",
        "webNavigation",
        "webRequest",
        "webdriver",
        "webkitAddKey",
        "webkitAlignContent",
        "webkitAlignItems",
        "webkitAlignSelf",
        "webkitAnimation",
        "webkitAnimationDelay",
        "webkitAnimationDirection",
        "webkitAnimationDuration",
        "webkitAnimationFillMode",
        "webkitAnimationIterationCount",
        "webkitAnimationName",
        "webkitAnimationPlayState",
        "webkitAnimationTimingFunction",
        "webkitAppearance",
        "webkitAudioContext",
        "webkitAudioDecodedByteCount",
        "webkitAudioPannerNode",
        "webkitBackfaceVisibility",
        "webkitBackground",
        "webkitBackgroundAttachment",
        "webkitBackgroundClip",
        "webkitBackgroundColor",
        "webkitBackgroundImage",
        "webkitBackgroundOrigin",
        "webkitBackgroundPosition",
        "webkitBackgroundPositionX",
        "webkitBackgroundPositionY",
        "webkitBackgroundRepeat",
        "webkitBackgroundSize",
        "webkitBackingStorePixelRatio",
        "webkitBorderBottomLeftRadius",
        "webkitBorderBottomRightRadius",
        "webkitBorderImage",
        "webkitBorderImageOutset",
        "webkitBorderImageRepeat",
        "webkitBorderImageSlice",
        "webkitBorderImageSource",
        "webkitBorderImageWidth",
        "webkitBorderRadius",
        "webkitBorderTopLeftRadius",
        "webkitBorderTopRightRadius",
        "webkitBoxAlign",
        "webkitBoxDirection",
        "webkitBoxFlex",
        "webkitBoxOrdinalGroup",
        "webkitBoxOrient",
        "webkitBoxPack",
        "webkitBoxShadow",
        "webkitBoxSizing",
        "webkitCancelAnimationFrame",
        "webkitCancelFullScreen",
        "webkitCancelKeyRequest",
        "webkitCancelRequestAnimationFrame",
        "webkitClearResourceTimings",
        "webkitClipPath",
        "webkitClosedCaptionsVisible",
        "webkitConvertPointFromNodeToPage",
        "webkitConvertPointFromPageToNode",
        "webkitCreateShadowRoot",
        "webkitCurrentFullScreenElement",
        "webkitCurrentPlaybackTargetIsWireless",
        "webkitDecodedFrameCount",
        "webkitDirectionInvertedFromDevice",
        "webkitDisplayingFullscreen",
        "webkitDroppedFrameCount",
        "webkitEnterFullScreen",
        "webkitEnterFullscreen",
        "webkitEntries",
        "webkitExitFullScreen",
        "webkitExitFullscreen",
        "webkitExitPointerLock",
        "webkitFilter",
        "webkitFlex",
        "webkitFlexBasis",
        "webkitFlexDirection",
        "webkitFlexFlow",
        "webkitFlexGrow",
        "webkitFlexShrink",
        "webkitFlexWrap",
        "webkitFontFeatureSettings",
        "webkitFullScreenKeyboardInputAllowed",
        "webkitFullscreenElement",
        "webkitFullscreenEnabled",
        "webkitGenerateKeyRequest",
        "webkitGetAsEntry",
        "webkitGetDatabaseNames",
        "webkitGetEntries",
        "webkitGetEntriesByName",
        "webkitGetEntriesByType",
        "webkitGetFlowByName",
        "webkitGetGamepads",
        "webkitGetImageDataHD",
        "webkitGetNamedFlows",
        "webkitGetRegionFlowRanges",
        "webkitGetUserMedia",
        "webkitHasClosedCaptions",
        "webkitHidden",
        "webkitIDBCursor",
        "webkitIDBDatabase",
        "webkitIDBDatabaseError",
        "webkitIDBDatabaseException",
        "webkitIDBFactory",
        "webkitIDBIndex",
        "webkitIDBKeyRange",
        "webkitIDBObjectStore",
        "webkitIDBRequest",
        "webkitIDBTransaction",
        "webkitImageSmoothingEnabled",
        "webkitIndexedDB",
        "webkitInitMessageEvent",
        "webkitIsFullScreen",
        "webkitJustifyContent",
        "webkitKeys",
        "webkitLineClamp",
        "webkitLineDashOffset",
        "webkitLockOrientation",
        "webkitMask",
        "webkitMaskClip",
        "webkitMaskComposite",
        "webkitMaskImage",
        "webkitMaskOrigin",
        "webkitMaskPosition",
        "webkitMaskPositionX",
        "webkitMaskPositionY",
        "webkitMaskRepeat",
        "webkitMaskSize",
        "webkitMatchesSelector",
        "webkitMediaStream",
        "webkitNotifications",
        "webkitOfflineAudioContext",
        "webkitOrder",
        "webkitOrientation",
        "webkitPeerConnection00",
        "webkitPersistentStorage",
        "webkitPerspective",
        "webkitPerspectiveOrigin",
        "webkitPointerLockElement",
        "webkitPostMessage",
        "webkitPreservesPitch",
        "webkitPutImageDataHD",
        "webkitRTCPeerConnection",
        "webkitRegionOverset",
        "webkitRelativePath",
        "webkitRequestAnimationFrame",
        "webkitRequestFileSystem",
        "webkitRequestFullScreen",
        "webkitRequestFullscreen",
        "webkitRequestPointerLock",
        "webkitResolveLocalFileSystemURL",
        "webkitSetMediaKeys",
        "webkitSetResourceTimingBufferSize",
        "webkitShadowRoot",
        "webkitShowPlaybackTargetPicker",
        "webkitSlice",
        "webkitSpeechGrammar",
        "webkitSpeechGrammarList",
        "webkitSpeechRecognition",
        "webkitSpeechRecognitionError",
        "webkitSpeechRecognitionEvent",
        "webkitStorageInfo",
        "webkitSupportsFullscreen",
        "webkitTemporaryStorage",
        "webkitTextFillColor",
        "webkitTextSecurity",
        "webkitTextSizeAdjust",
        "webkitTextStroke",
        "webkitTextStrokeColor",
        "webkitTextStrokeWidth",
        "webkitTransform",
        "webkitTransformOrigin",
        "webkitTransformStyle",
        "webkitTransition",
        "webkitTransitionDelay",
        "webkitTransitionDuration",
        "webkitTransitionProperty",
        "webkitTransitionTimingFunction",
        "webkitURL",
        "webkitUnlockOrientation",
        "webkitUserSelect",
        "webkitVideoDecodedByteCount",
        "webkitVisibilityState",
        "webkitWirelessVideoPlaybackDisabled",
        "webkitdirectory",
        "webkitdropzone",
        "webstore",
        "weight",
        "wgslLanguageFeatures",
        "whatToShow",
        "wheelDelta",
        "wheelDeltaX",
        "wheelDeltaY",
        "whenDefined",
        "which",
        "white-space",
        "white-space-collapse",
        "whiteSpace",
        "whiteSpaceCollapse",
        "wholeText",
        "widows",
        "width",
        "will-change",
        "willChange",
        "willValidate",
        "window",
        "windowAttribution",
        "windowControlsOverlay",
        "windowId",
        "windowIds",
        "windows",
        "with",
        "withCredentials",
        "withResolvers",
        "word-break",
        "word-spacing",
        "word-wrap",
        "wordBreak",
        "wordSpacing",
        "wordWrap",
        "workerStart",
        "worklet",
        "wow64",
        "wrap",
        "wrapKey",
        "writable",
        "writableAuxiliaries",
        "write",
        "writeBuffer",
        "writeMask",
        "writeText",
        "writeTexture",
        "writeTimestamp",
        "writeValue",
        "writeValueWithResponse",
        "writeValueWithoutResponse",
        "writeWithoutResponse",
        "writeln",
        "writing-mode",
        "writingMode",
        "writingSuggestions",
        "x",
        "x1",
        "x2",
        "xChannelSelector",
        "xmlEncoding",
        "xmlStandalone",
        "xmlVersion",
        "xmlbase",
        "xmllang",
        "xmlspace",
        "xor",
        "xr",
        "y",
        "y1",
        "y2",
        "yChannelSelector",
        "yandex",
        "yield",
        "z",
        "z-index",
        "zIndex",
        "zoom",
        "zoomAndPan",
        "zoomRectScreen"
      ];
      function find_builtins(reserved) {
        domprops.forEach(add);
        var new_globals = ["Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"];
        var objects = {};
        var global_ref = typeof global === "object" ? global : self;
        new_globals.forEach(function(new_global) {
          objects[new_global] = global_ref[new_global] || function() {
          };
        });
        [
          "null",
          "true",
          "false",
          "NaN",
          "Infinity",
          "-Infinity",
          "undefined"
        ].forEach(add);
        [
          Object,
          Array,
          Function,
          Number,
          String,
          Boolean,
          Error,
          Math,
          Date,
          RegExp,
          objects.Symbol,
          ArrayBuffer,
          DataView,
          decodeURI,
          decodeURIComponent,
          encodeURI,
          encodeURIComponent,
          eval,
          EvalError,
          Float32Array,
          Float64Array,
          Int8Array,
          Int16Array,
          Int32Array,
          isFinite,
          isNaN,
          JSON,
          objects.Map,
          parseFloat,
          parseInt,
          objects.Promise,
          objects.Proxy,
          RangeError,
          ReferenceError,
          objects.Reflect,
          objects.Set,
          SyntaxError,
          TypeError,
          Uint8Array,
          Uint8ClampedArray,
          Uint16Array,
          Uint32Array,
          URIError,
          objects.WeakMap,
          objects.WeakSet
        ].forEach(function(ctor) {
          Object.getOwnPropertyNames(ctor).map(add);
          if (ctor.prototype) {
            Object.getOwnPropertyNames(ctor.prototype).map(add);
          }
        });
        function add(name) {
          reserved.add(name);
        }
      }
      function reserve_quoted_keys(ast, reserved) {
        function add(name) {
          push_uniq(reserved, name);
        }
        ast.walk(new TreeWalker(function(node) {
          if (node instanceof AST_ObjectKeyVal && node.quote) {
            add(node.key);
          } else if (node instanceof AST_ObjectProperty && node.quote) {
            add(node.key.name);
          } else if (node instanceof AST_Sub) {
            addStrings(node.property, add);
          }
        }));
      }
      function addStrings(node, add) {
        node.walk(new TreeWalker(function(node2) {
          if (node2 instanceof AST_Sequence) {
            addStrings(node2.tail_node(), add);
          } else if (node2 instanceof AST_String) {
            add(node2.value);
          } else if (node2 instanceof AST_Conditional) {
            addStrings(node2.consequent, add);
            addStrings(node2.alternative, add);
          }
          return true;
        }));
      }
      function mangle_private_properties(ast, options) {
        var cprivate = -1;
        var private_cache = /* @__PURE__ */ new Map();
        var nth_identifier = options.nth_identifier || base54;
        ast = ast.transform(new TreeTransformer(function(node) {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_PrivateIn) {
            node.key.name = mangle_private(node.key.name);
          } else if (node instanceof AST_DotHash) {
            node.property = mangle_private(node.property);
          }
        }));
        return ast;
        function mangle_private(name) {
          let mangled = private_cache.get(name);
          if (!mangled) {
            mangled = nth_identifier.get(++cprivate);
            private_cache.set(name, mangled);
          }
          return mangled;
        }
      }
      function find_annotated_props(ast) {
        var annotated_props = /* @__PURE__ */ new Set();
        walk(ast, (node) => {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash)
            ;
          else if (node instanceof AST_ObjectKeyVal) {
            if (typeof node.key == "string" && has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.key);
            }
          } else if (node instanceof AST_ObjectProperty) {
            if (has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.key.name);
            }
          } else if (node instanceof AST_Dot) {
            if (has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.property);
            }
          } else if (node instanceof AST_Sub) {
            if (node.property instanceof AST_String && has_annotation(node, _MANGLEPROP)) {
              annotated_props.add(node.property.value);
            }
          }
        });
        return annotated_props;
      }
      function mangle_properties(ast, options, annotated_props = find_annotated_props(ast)) {
        options = defaults(options, {
          builtins: false,
          cache: null,
          debug: false,
          keep_quoted: false,
          nth_identifier: base54,
          only_cache: false,
          regex: null,
          reserved: null,
          undeclared: false,
          only_annotated: false
        }, true);
        var nth_identifier = options.nth_identifier;
        var reserved_option = options.reserved;
        if (!Array.isArray(reserved_option))
          reserved_option = [reserved_option];
        var reserved = new Set(reserved_option);
        if (!options.builtins)
          find_builtins(reserved);
        var cname = -1;
        var cache;
        if (options.cache) {
          cache = options.cache.props;
        } else {
          cache = /* @__PURE__ */ new Map();
        }
        var only_annotated = options.only_annotated;
        var regex = options.regex && new RegExp(options.regex);
        var debug = options.debug !== false;
        var debug_name_suffix;
        if (debug) {
          debug_name_suffix = options.debug === true ? "" : options.debug;
        }
        var names_to_mangle = /* @__PURE__ */ new Set();
        var unmangleable = /* @__PURE__ */ new Set();
        cache.forEach((mangled_name) => unmangleable.add(mangled_name));
        var keep_quoted = !!options.keep_quoted;
        ast.walk(new TreeWalker(function(node) {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash)
            ;
          else if (node instanceof AST_ObjectKeyVal) {
            if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
              add(node.key);
            }
          } else if (node instanceof AST_ObjectProperty) {
            if (!keep_quoted || !node.quote) {
              add(node.key.name);
            }
          } else if (node instanceof AST_Dot) {
            var declared = !!options.undeclared;
            if (!declared) {
              var root = node;
              while (root.expression) {
                root = root.expression;
              }
              declared = !(root.thedef && root.thedef.undeclared);
            }
            if (declared && (!keep_quoted || !node.quote)) {
              add(node.property);
            }
          } else if (node instanceof AST_Sub) {
            if (!keep_quoted) {
              addStrings(node.property, add);
            }
          } else if (node instanceof AST_Call && node.expression.print_to_string() == "Object.defineProperty") {
            addStrings(node.args[1], add);
          } else if (node instanceof AST_Binary && node.operator === "in") {
            addStrings(node.left, add);
          } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
            add(node.value);
          }
        }));
        return ast.transform(new TreeTransformer(function(node) {
          if (node instanceof AST_ClassPrivateProperty || node instanceof AST_PrivateMethod || node instanceof AST_PrivateGetter || node instanceof AST_PrivateSetter || node instanceof AST_DotHash)
            ;
          else if (node instanceof AST_ObjectKeyVal) {
            if (typeof node.key == "string" && (!keep_quoted || !node.quote)) {
              node.key = mangle(node.key);
            }
          } else if (node instanceof AST_ObjectProperty) {
            if (!keep_quoted || !node.quote) {
              if (!node.computed_key()) {
                node.key.name = mangle(node.key.name);
              }
            }
          } else if (node instanceof AST_Dot) {
            if (!keep_quoted || !node.quote) {
              node.property = mangle(node.property);
            }
          } else if (!keep_quoted && node instanceof AST_Sub) {
            node.property = mangleStrings(node.property);
          } else if (node instanceof AST_Call && node.expression.print_to_string() == "Object.defineProperty") {
            node.args[1] = mangleStrings(node.args[1]);
          } else if (node instanceof AST_Binary && node.operator === "in") {
            node.left = mangleStrings(node.left);
          } else if (node instanceof AST_String && has_annotation(node, _KEY)) {
            clear_annotation(node, _KEY);
            node.value = mangle(node.value);
          }
        }));
        function can_mangle(name) {
          if (unmangleable.has(name))
            return false;
          if (reserved.has(name))
            return false;
          if (options.only_cache) {
            return cache.has(name);
          }
          if (/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(name))
            return false;
          return true;
        }
        function should_mangle(name) {
          if (only_annotated && !annotated_props.has(name))
            return false;
          if (regex && !regex.test(name)) {
            return annotated_props.has(name);
          }
          if (reserved.has(name))
            return false;
          return cache.has(name) || names_to_mangle.has(name);
        }
        function add(name) {
          if (can_mangle(name)) {
            names_to_mangle.add(name);
          }
          if (!should_mangle(name)) {
            unmangleable.add(name);
          }
        }
        function mangle(name) {
          if (!should_mangle(name)) {
            return name;
          }
          var mangled = cache.get(name);
          if (!mangled) {
            if (debug) {
              var debug_mangled = "_$" + name + "$" + debug_name_suffix + "_";
              if (can_mangle(debug_mangled)) {
                mangled = debug_mangled;
              }
            }
            if (!mangled) {
              do {
                mangled = nth_identifier.get(++cname);
              } while (!can_mangle(mangled));
            }
            cache.set(name, mangled);
          }
          return mangled;
        }
        function mangleStrings(node) {
          return node.transform(new TreeTransformer(function(node2) {
            if (node2 instanceof AST_Sequence) {
              var last = node2.expressions.length - 1;
              node2.expressions[last] = mangleStrings(node2.expressions[last]);
            } else if (node2 instanceof AST_String) {
              clear_annotation(node2, _KEY);
              node2.value = mangle(node2.value);
            } else if (node2 instanceof AST_Conditional) {
              node2.consequent = mangleStrings(node2.consequent);
              node2.alternative = mangleStrings(node2.alternative);
            }
            return node2;
          }));
        }
      }
      var to_ascii = typeof Buffer !== "undefined" ? (b64) => Buffer.from(b64, "base64").toString() : (b64) => decodeURIComponent(escape(atob(b64)));
      var to_base64 = typeof Buffer !== "undefined" ? (str) => Buffer.from(str).toString("base64") : (str) => btoa(unescape(encodeURIComponent(str)));
      function read_source_map(code) {
        var match = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(code);
        if (!match) {
          console.warn("inline source map not found");
          return null;
        }
        return to_ascii(match[2]);
      }
      function set_shorthand(name, options, keys) {
        if (options[name]) {
          keys.forEach(function(key2) {
            if (options[key2]) {
              if (typeof options[key2] != "object")
                options[key2] = {};
              if (!(name in options[key2]))
                options[key2][name] = options[name];
            }
          });
        }
      }
      function init_cache(cache) {
        if (!cache)
          return;
        if (!("props" in cache)) {
          cache.props = /* @__PURE__ */ new Map();
        } else if (!(cache.props instanceof Map)) {
          cache.props = map_from_object(cache.props);
        }
      }
      function cache_to_json(cache) {
        return {
          props: map_to_object(cache.props)
        };
      }
      function log_input(files, options, fs7, debug_folder) {
        if (!(fs7 && fs7.writeFileSync && fs7.mkdirSync)) {
          return;
        }
        try {
          fs7.mkdirSync(debug_folder);
        } catch (e) {
          if (e.code !== "EEXIST")
            throw e;
        }
        const log_path = `${debug_folder}/terser-debug-${Math.random() * 9999999 | 0}.log`;
        options = options || {};
        const options_str = JSON.stringify(options, (_key, thing) => {
          if (typeof thing === "function")
            return "[Function " + thing.toString() + "]";
          if (thing instanceof RegExp)
            return "[RegExp " + thing.toString() + "]";
          return thing;
        }, 4);
        const files_str = (file) => {
          if (typeof file === "object" && options.parse && options.parse.spidermonkey) {
            return JSON.stringify(file, null, 2);
          } else if (typeof file === "object") {
            return Object.keys(file).map((key2) => key2 + ": " + files_str(file[key2])).join("\n\n");
          } else if (typeof file === "string") {
            return "```\n" + file + "\n```";
          } else {
            return file;
          }
        };
        fs7.writeFileSync(log_path, "Options: \n" + options_str + "\n\nInput files:\n\n" + files_str(files) + "\n");
      }
      function* minify_sync_or_async(files, options, _fs_module) {
        if (_fs_module && typeof process === "object" && process.env && typeof process.env.TERSER_DEBUG_DIR === "string") {
          log_input(files, options, _fs_module, process.env.TERSER_DEBUG_DIR);
        }
        options = defaults(options, {
          compress: {},
          ecma: void 0,
          enclose: false,
          ie8: false,
          keep_classnames: void 0,
          keep_fnames: false,
          mangle: {},
          module: false,
          nameCache: null,
          output: null,
          format: null,
          parse: {},
          rename: void 0,
          safari10: false,
          sourceMap: false,
          spidermonkey: false,
          timings: false,
          toplevel: false,
          warnings: false,
          wrap: false
        }, true);
        var timings = options.timings && {
          start: Date.now()
        };
        if (options.keep_classnames === void 0) {
          options.keep_classnames = options.keep_fnames;
        }
        if (options.rename === void 0) {
          options.rename = options.compress && options.mangle;
        }
        if (options.output && options.format) {
          throw new Error("Please only specify either output or format option, preferrably format.");
        }
        options.format = options.format || options.output || {};
        set_shorthand("ecma", options, ["parse", "compress", "format"]);
        set_shorthand("ie8", options, ["compress", "mangle", "format"]);
        set_shorthand("keep_classnames", options, ["compress", "mangle"]);
        set_shorthand("keep_fnames", options, ["compress", "mangle"]);
        set_shorthand("module", options, ["parse", "compress", "mangle"]);
        set_shorthand("safari10", options, ["mangle", "format"]);
        set_shorthand("toplevel", options, ["compress", "mangle"]);
        set_shorthand("warnings", options, ["compress"]);
        var quoted_props;
        if (options.mangle) {
          options.mangle = defaults(options.mangle, {
            cache: options.nameCache && (options.nameCache.vars || {}),
            eval: false,
            ie8: false,
            keep_classnames: false,
            keep_fnames: false,
            module: false,
            nth_identifier: base54,
            properties: false,
            reserved: [],
            safari10: false,
            toplevel: false
          }, true);
          if (options.mangle.properties) {
            if (typeof options.mangle.properties != "object") {
              options.mangle.properties = {};
            }
            if (options.mangle.properties.keep_quoted) {
              quoted_props = options.mangle.properties.reserved;
              if (!Array.isArray(quoted_props))
                quoted_props = [];
              options.mangle.properties.reserved = quoted_props;
            }
            if (options.nameCache && !("cache" in options.mangle.properties)) {
              options.mangle.properties.cache = options.nameCache.props || {};
            }
          }
          init_cache(options.mangle.cache);
          init_cache(options.mangle.properties.cache);
        }
        if (options.sourceMap) {
          options.sourceMap = defaults(options.sourceMap, {
            asObject: false,
            content: null,
            filename: null,
            includeSources: false,
            root: null,
            url: null
          }, true);
        }
        if (timings)
          timings.parse = Date.now();
        var toplevel;
        if (files instanceof AST_Toplevel) {
          toplevel = files;
        } else {
          if (typeof files == "string" || options.parse.spidermonkey && !Array.isArray(files)) {
            files = [files];
          }
          options.parse = options.parse || {};
          options.parse.toplevel = null;
          if (options.parse.spidermonkey) {
            options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(function(toplevel2, name2) {
              if (!toplevel2)
                return files[name2];
              toplevel2.body = toplevel2.body.concat(files[name2].body);
              return toplevel2;
            }, null));
          } else {
            delete options.parse.spidermonkey;
            for (var name in files)
              if (HOP(files, name)) {
                options.parse.filename = name;
                options.parse.toplevel = parse2(files[name], options.parse);
                if (options.sourceMap && options.sourceMap.content == "inline") {
                  if (Object.keys(files).length > 1)
                    throw new Error("inline source map only works with singular input");
                  options.sourceMap.content = read_source_map(files[name]);
                }
              }
          }
          if (options.parse.toplevel === null) {
            throw new Error("no source file given");
          }
          toplevel = options.parse.toplevel;
        }
        if (quoted_props && options.mangle.properties.keep_quoted !== "strict") {
          reserve_quoted_keys(toplevel, quoted_props);
        }
        var annotated_props;
        if (options.mangle && options.mangle.properties) {
          annotated_props = find_annotated_props(toplevel);
        }
        if (options.wrap) {
          toplevel = toplevel.wrap_commonjs(options.wrap);
        }
        if (options.enclose) {
          toplevel = toplevel.wrap_enclose(options.enclose);
        }
        if (timings)
          timings.rename = Date.now();
        if (timings)
          timings.compress = Date.now();
        if (options.compress) {
          toplevel = new Compressor(options.compress, {
            mangle_options: options.mangle
          }).compress(toplevel);
        }
        if (timings)
          timings.scope = Date.now();
        if (options.mangle)
          toplevel.figure_out_scope(options.mangle);
        if (timings)
          timings.mangle = Date.now();
        if (options.mangle) {
          toplevel.compute_char_frequency(options.mangle);
          toplevel.mangle_names(options.mangle);
          toplevel = mangle_private_properties(toplevel, options.mangle);
        }
        if (timings)
          timings.properties = Date.now();
        if (options.mangle && options.mangle.properties) {
          toplevel = mangle_properties(toplevel, options.mangle.properties, annotated_props);
        }
        if (timings)
          timings.format = Date.now();
        var result = {};
        if (options.format.ast) {
          result.ast = toplevel;
        }
        if (options.format.spidermonkey) {
          result.ast = toplevel.to_mozilla_ast();
        }
        let format_options;
        if (!HOP(options.format, "code") || options.format.code) {
          format_options = { ...options.format };
          if (!format_options.ast) {
            format_options._destroy_ast = true;
            walk(toplevel, (node) => {
              if (node instanceof AST_Scope) {
                node.variables = void 0;
                node.enclosed = void 0;
                node.parent_scope = void 0;
              }
              if (node.block_scope) {
                node.block_scope.variables = void 0;
                node.block_scope.enclosed = void 0;
                node.block_scope.parent_scope = void 0;
              }
            });
          }
          if (options.sourceMap) {
            if (options.sourceMap.includeSources && files instanceof AST_Toplevel) {
              throw new Error("original source content unavailable");
            }
            format_options.source_map = yield* SourceMap({
              file: options.sourceMap.filename,
              orig: options.sourceMap.content,
              root: options.sourceMap.root,
              files: options.sourceMap.includeSources ? files : null
            });
          }
          delete format_options.ast;
          delete format_options.code;
          delete format_options.spidermonkey;
          var stream = OutputStream(format_options);
          toplevel.print(stream);
          result.code = stream.get();
          if (options.sourceMap) {
            Object.defineProperty(result, "map", {
              configurable: true,
              enumerable: true,
              get() {
                const map = format_options.source_map.getEncoded();
                return result.map = options.sourceMap.asObject ? map : JSON.stringify(map);
              },
              set(value2) {
                Object.defineProperty(result, "map", {
                  value: value2,
                  writable: true
                });
              }
            });
            result.decoded_map = format_options.source_map.getDecoded();
            if (options.sourceMap.url == "inline") {
              var sourceMap2 = typeof result.map === "object" ? JSON.stringify(result.map) : result.map;
              result.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + to_base64(sourceMap2);
            } else if (options.sourceMap.url) {
              result.code += "\n//# sourceMappingURL=" + options.sourceMap.url;
            }
          }
        }
        if (options.nameCache && options.mangle) {
          if (options.mangle.cache)
            options.nameCache.vars = cache_to_json(options.mangle.cache);
          if (options.mangle.properties && options.mangle.properties.cache) {
            options.nameCache.props = cache_to_json(options.mangle.properties.cache);
          }
        }
        if (format_options && format_options.source_map) {
          format_options.source_map.destroy();
        }
        if (timings) {
          timings.end = Date.now();
          result.timings = {
            parse: 1e-3 * (timings.rename - timings.parse),
            rename: 1e-3 * (timings.compress - timings.rename),
            compress: 1e-3 * (timings.scope - timings.compress),
            scope: 1e-3 * (timings.mangle - timings.scope),
            mangle: 1e-3 * (timings.properties - timings.mangle),
            properties: 1e-3 * (timings.format - timings.properties),
            format: 1e-3 * (timings.end - timings.format),
            total: 1e-3 * (timings.end - timings.start)
          };
        }
        return result;
      }
      async function minify(files, options, _fs_module) {
        const gen = minify_sync_or_async(files, options, _fs_module);
        let yielded;
        let val;
        do {
          val = gen.next(await yielded);
          yielded = val.value;
        } while (!val.done);
        return val.value;
      }
      function minify_sync(files, options, _fs_module) {
        const gen = minify_sync_or_async(files, options, _fs_module);
        let yielded;
        let val;
        do {
          if (yielded && typeof yielded.then === "function") {
            throw new Error("minify_sync cannot be used with the legacy source-map module");
          }
          val = gen.next(yielded);
          yielded = val.value;
        } while (!val.done);
        return val.value;
      }
      async function run_cli({ program, packageJson, fs: fs7, path: path8 }) {
        const skip_keys = /* @__PURE__ */ new Set(["cname", "parent_scope", "scope", "uses_eval", "uses_with"]);
        var files = {};
        var options = {
          compress: false,
          mangle: false
        };
        const default_options = await _default_options();
        program.version(packageJson.name + " " + packageJson.version);
        program.parseArgv = program.parse;
        program.parse = void 0;
        if (process.argv.includes("ast"))
          program.helpInformation = describe_ast;
        else if (process.argv.includes("options"))
          program.helpInformation = function() {
            var text3 = [];
            for (var option in default_options) {
              text3.push("--" + (option === "sourceMap" ? "source-map" : option) + " options:");
              text3.push(format_object(default_options[option]));
              text3.push("");
            }
            return text3.join("\n");
          };
        program.option("-p, --parse <options>", "Specify parser options.", parse_js());
        program.option("-c, --compress [options]", "Enable compressor/specify compressor options.", parse_js());
        program.option("-m, --mangle [options]", "Mangle names/specify mangler options.", parse_js());
        program.option("--mangle-props [options]", "Mangle properties/specify mangler options.", parse_js());
        program.option("-f, --format [options]", "Format options.", parse_js());
        program.option("-b, --beautify [options]", "Alias for --format.", parse_js());
        program.option("-o, --output <file>", "Output file (default STDOUT).");
        program.option("--comments [filter]", "Preserve copyright comments in the output.");
        program.option("--config-file <file>", "Read minify() options from JSON file.");
        program.option("-d, --define <expr>[=value]", "Global definitions.", parse_js("define"));
        program.option("--ecma <version>", "Specify ECMAScript release: 5, 2015, 2016 or 2017...");
        program.option("-e, --enclose [arg[,...][:value[,...]]]", "Embed output in a big function with configurable arguments and values.");
        program.option("--ie8", "Support non-standard Internet Explorer 8.");
        program.option("--keep-classnames", "Do not mangle/drop class names.");
        program.option("--keep-fnames", "Do not mangle/drop function names. Useful for code relying on Function.prototype.name.");
        program.option("--module", "Input is an ES6 module");
        program.option("--name-cache <file>", "File to hold mangled name mappings.");
        program.option("--rename", "Force symbol expansion.");
        program.option("--no-rename", "Disable symbol expansion.");
        program.option("--safari10", "Support non-standard Safari 10.");
        program.option("--source-map [options]", "Enable source map/specify source map options.", parse_js());
        program.option("--timings", "Display operations run time on STDERR.");
        program.option("--toplevel", "Compress and/or mangle variables in toplevel scope.");
        program.option("--wrap <name>", "Embed everything as a function with \u201Cexports\u201D corresponding to \u201Cname\u201D globally.");
        program.arguments("[files...]").parseArgv(process.argv);
        if (program.configFile) {
          options = JSON.parse(read_file(program.configFile));
        }
        if (!program.output && program.sourceMap && program.sourceMap.url != "inline") {
          fatal("ERROR: cannot write source map to STDOUT");
        }
        [
          "compress",
          "enclose",
          "ie8",
          "mangle",
          "module",
          "safari10",
          "sourceMap",
          "toplevel",
          "wrap"
        ].forEach(function(name) {
          if (name in program) {
            options[name] = program[name];
          }
        });
        if ("ecma" in program) {
          if (program.ecma != (program.ecma | 0))
            fatal("ERROR: ecma must be an integer");
          const ecma = program.ecma | 0;
          if (ecma > 5 && ecma < 2015)
            options.ecma = ecma + 2009;
          else
            options.ecma = ecma;
        }
        if (program.format || program.beautify) {
          const chosenOption = program.format || program.beautify;
          options.format = typeof chosenOption === "object" ? chosenOption : {};
        }
        if (program.comments) {
          if (typeof options.format != "object")
            options.format = {};
          options.format.comments = typeof program.comments == "string" ? program.comments == "false" ? false : program.comments : "some";
        }
        if (program.define) {
          if (typeof options.compress != "object")
            options.compress = {};
          if (typeof options.compress.global_defs != "object")
            options.compress.global_defs = {};
          for (var expr in program.define) {
            options.compress.global_defs[expr] = program.define[expr];
          }
        }
        if (program.keepClassnames) {
          options.keep_classnames = true;
        }
        if (program.keepFnames) {
          options.keep_fnames = true;
        }
        if (program.mangleProps) {
          if (program.mangleProps.domprops) {
            delete program.mangleProps.domprops;
          } else {
            if (typeof program.mangleProps != "object")
              program.mangleProps = {};
            if (!Array.isArray(program.mangleProps.reserved))
              program.mangleProps.reserved = [];
          }
          if (typeof options.mangle != "object")
            options.mangle = {};
          options.mangle.properties = program.mangleProps;
        }
        if (program.nameCache) {
          options.nameCache = JSON.parse(read_file(program.nameCache, "{}"));
        }
        if (program.output == "ast") {
          options.format = {
            ast: true,
            code: false
          };
        }
        if (program.parse) {
          if (!program.parse.acorn && !program.parse.spidermonkey) {
            options.parse = program.parse;
          } else if (program.sourceMap && program.sourceMap.content == "inline") {
            fatal("ERROR: inline source map only works with built-in parser");
          }
        }
        if (~program.rawArgs.indexOf("--rename")) {
          options.rename = true;
        } else if (!program.rename) {
          options.rename = false;
        }
        let convert_path = (name) => name;
        if (typeof program.sourceMap == "object" && "base" in program.sourceMap) {
          convert_path = function() {
            var base = program.sourceMap.base;
            delete options.sourceMap.base;
            return function(name) {
              return path8.relative(base, name);
            };
          }();
        }
        let filesList;
        if (options.files && options.files.length) {
          filesList = options.files;
          delete options.files;
        } else if (program.args.length) {
          filesList = program.args;
        }
        if (filesList) {
          simple_glob(filesList).forEach(function(name) {
            files[convert_path(name)] = read_file(name);
          });
        } else {
          await new Promise((resolve) => {
            var chunks = [];
            process.stdin.setEncoding("utf8");
            process.stdin.on("data", function(chunk) {
              chunks.push(chunk);
            }).on("end", function() {
              files = [chunks.join("")];
              resolve();
            });
            process.stdin.resume();
          });
        }
        await run_cli2();
        function convert_ast(fn) {
          return AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
        }
        async function run_cli2() {
          var content = program.sourceMap && program.sourceMap.content;
          if (content && content !== "inline") {
            options.sourceMap.content = read_file(content, content);
          }
          if (program.timings)
            options.timings = true;
          try {
            if (program.parse) {
              if (program.parse.acorn) {
                files = convert_ast(function(toplevel, name) {
                  return require_acorn().parse(files[name], {
                    ecmaVersion: 2024,
                    locations: true,
                    program: toplevel,
                    sourceFile: name,
                    sourceType: options.module || program.parse.module ? "module" : "script"
                  });
                });
              } else if (program.parse.spidermonkey) {
                files = convert_ast(function(toplevel, name) {
                  var obj = JSON.parse(files[name]);
                  if (!toplevel)
                    return obj;
                  toplevel.body = toplevel.body.concat(obj.body);
                  return toplevel;
                });
              }
            }
          } catch (ex) {
            fatal(ex);
          }
          let result;
          try {
            result = await minify(files, options, fs7);
          } catch (ex) {
            if (ex.name == "SyntaxError") {
              print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
              var col = ex.col;
              var lines = files[ex.filename].split(/\r?\n/);
              var line = lines[ex.line - 1];
              if (!line && !col) {
                line = lines[ex.line - 2];
                col = line.length;
              }
              if (line) {
                var limit = 70;
                if (col > limit) {
                  line = line.slice(col - limit);
                  col = limit;
                }
                print_error(line.slice(0, 80));
                print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
              }
            }
            if (ex.defs) {
              print_error("Supported options:");
              print_error(format_object(ex.defs));
            }
            fatal(ex);
            return;
          }
          if (program.output == "ast") {
            if (!options.compress && !options.mangle) {
              result.ast.figure_out_scope({});
            }
            console.log(JSON.stringify(result.ast, function(key2, value2) {
              if (value2)
                switch (key2) {
                  case "thedef":
                    return symdef(value2);
                  case "enclosed":
                    return value2.length ? value2.map(symdef) : void 0;
                  case "variables":
                  case "globals":
                    return value2.size ? collect_from_map(value2, symdef) : void 0;
                }
              if (skip_keys.has(key2))
                return;
              if (value2 instanceof AST_Token)
                return;
              if (value2 instanceof Map)
                return;
              if (value2 instanceof AST_Node) {
                var result2 = {
                  _class: "AST_" + value2.TYPE
                };
                if (value2.block_scope) {
                  result2.variables = value2.block_scope.variables;
                  result2.enclosed = value2.block_scope.enclosed;
                }
                value2.CTOR.PROPS.forEach(function(prop) {
                  if (prop !== "block_scope") {
                    result2[prop] = value2[prop];
                  }
                });
                return result2;
              }
              return value2;
            }, 2));
          } else if (program.output == "spidermonkey") {
            try {
              const minified = await minify(result.code, {
                compress: false,
                mangle: false,
                format: {
                  ast: true,
                  code: false
                }
              }, fs7);
              console.log(JSON.stringify(minified.ast.to_mozilla_ast(), null, 2));
            } catch (ex) {
              fatal(ex);
              return;
            }
          } else if (program.output) {
            fs7.mkdirSync(path8.dirname(program.output), { recursive: true });
            fs7.writeFileSync(program.output, result.code);
            if (options.sourceMap && options.sourceMap.url !== "inline" && result.map) {
              fs7.writeFileSync(program.output + ".map", result.map);
            }
          } else {
            console.log(result.code);
          }
          if (program.nameCache) {
            fs7.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));
          }
          if (result.timings)
            for (var phase in result.timings) {
              print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
            }
        }
        function fatal(message) {
          if (message instanceof Error)
            message = message.stack.replace(/^\S*?Error:/, "ERROR:");
          print_error(message);
          process.exit(1);
        }
        function simple_glob(glob) {
          if (Array.isArray(glob)) {
            return [].concat.apply([], glob.map(simple_glob));
          }
          if (glob && glob.match(/[*?]/)) {
            var dir = path8.dirname(glob);
            try {
              var entries = fs7.readdirSync(dir);
            } catch (ex) {
            }
            if (entries) {
              var pattern = "^" + path8.basename(glob).replace(/[.+^$[\]\\(){}]/g, "\\$&").replace(/\*/g, "[^/\\\\]*").replace(/\?/g, "[^/\\\\]") + "$";
              var mod = process.platform === "win32" ? "i" : "";
              var rx = new RegExp(pattern, mod);
              var results = entries.filter(function(name) {
                return rx.test(name);
              }).map(function(name) {
                return path8.join(dir, name);
              });
              if (results.length)
                return results;
            }
          }
          return [glob];
        }
        function read_file(path9, default_value) {
          try {
            return fs7.readFileSync(path9, "utf8");
          } catch (ex) {
            if ((ex.code == "ENOENT" || ex.code == "ENAMETOOLONG") && default_value != null)
              return default_value;
            fatal(ex);
          }
        }
        function parse_js(flag) {
          return function(value2, options2) {
            options2 = options2 || {};
            try {
              walk(parse2(value2, { expression: true }), (node) => {
                if (node instanceof AST_Assign) {
                  var name = node.left.print_to_string();
                  var value3 = node.right;
                  if (flag) {
                    options2[name] = value3;
                  } else if (value3 instanceof AST_Array) {
                    options2[name] = value3.elements.map(to_string);
                  } else if (value3 instanceof AST_RegExp) {
                    value3 = value3.value;
                    options2[name] = new RegExp(value3.source, value3.flags);
                  } else {
                    options2[name] = to_string(value3);
                  }
                  return true;
                }
                if (node instanceof AST_Symbol || node instanceof AST_PropAccess) {
                  var name = node.print_to_string();
                  options2[name] = true;
                  return true;
                }
                if (!(node instanceof AST_Sequence))
                  throw node;
                function to_string(value4) {
                  return value4 instanceof AST_Constant ? value4.getValue() : value4.print_to_string({
                    quote_keys: true
                  });
                }
              });
            } catch (ex) {
              if (flag) {
                fatal("Error parsing arguments for '" + flag + "': " + value2);
              } else {
                options2[value2] = null;
              }
            }
            return options2;
          };
        }
        function symdef(def) {
          var ret = 1e6 + def.id + " " + def.name;
          if (def.mangled_name)
            ret += " " + def.mangled_name;
          return ret;
        }
        function collect_from_map(map, callback) {
          var result = [];
          map.forEach(function(def) {
            result.push(callback(def));
          });
          return result;
        }
        function format_object(obj) {
          var lines = [];
          var padding = "";
          Object.keys(obj).map(function(name) {
            if (padding.length < name.length)
              padding = Array(name.length + 1).join(" ");
            return [name, JSON.stringify(obj[name])];
          }).forEach(function(tokens) {
            lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
          });
          return lines.join("\n");
        }
        function print_error(msg) {
          process.stderr.write(msg);
          process.stderr.write("\n");
        }
        function describe_ast() {
          var out = OutputStream({ beautify: true });
          function doitem(ctor) {
            out.print("AST_" + ctor.TYPE);
            const props = ctor.SELF_PROPS.filter((prop) => !/^\$/.test(prop));
            if (props.length > 0) {
              out.space();
              out.with_parens(function() {
                props.forEach(function(prop, i) {
                  if (i)
                    out.space();
                  out.print(prop);
                });
              });
            }
            if (ctor.documentation) {
              out.space();
              out.print_string(ctor.documentation);
            }
            if (ctor.SUBCLASSES.length > 0) {
              out.space();
              out.with_block(function() {
                ctor.SUBCLASSES.forEach(function(ctor2) {
                  out.indent();
                  doitem(ctor2);
                  out.newline();
                });
              });
            }
          }
          doitem(AST_Node);
          return out + "\n";
        }
      }
      async function _default_options() {
        const defs = {};
        Object.keys(infer_options({ 0: 0 })).forEach((component) => {
          const options = infer_options({
            [component]: { 0: 0 }
          });
          if (options)
            defs[component] = options;
        });
        return defs;
      }
      async function infer_options(options) {
        try {
          await minify("", options);
        } catch (error) {
          return error.defs;
        }
      }
      exports3._default_options = _default_options;
      exports3._run_cli = run_cli;
      exports3.minify = minify;
      exports3.minify_sync = minify_sync;
    });
  }
});

// node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/readdirp/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdirpPromise = exports2.readdirp = exports2.ReaddirpStream = void 0;
    var promises_1 = require("fs/promises");
    var stream_1 = require("stream");
    var path_1 = require("path");
    function defaultOptions() {
      return {
        root: ".",
        fileFilter: (_path) => true,
        directoryFilter: (_path) => true,
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false,
        highWaterMark: 4096
      };
    }
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var DIR_TYPES = /* @__PURE__ */ new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);
    var FILE_TYPES = /* @__PURE__ */ new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);
    var isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    var wantBigintFsStats = process.platform === "win32";
    var emptyFn = (_path) => true;
    var normalizeFilter = (filter) => {
      if (filter === void 0)
        return emptyFn;
      if (typeof filter === "function")
        return filter;
      if (typeof filter === "string") {
        const fl = filter.trim();
        return (entry) => entry.basename === fl;
      }
      if (Array.isArray(filter)) {
        const trItems = filter.map((item) => item.trim());
        return (entry) => trItems.some((f) => entry.basename === f);
      }
      return emptyFn;
    };
    var ReaddirpStream = class extends stream_1.Readable {
      constructor(options = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options.highWaterMark
        });
        const opts = { ...defaultOptions(), ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? promises_1.lstat : promises_1.stat;
        if (wantBigintFsStats) {
          this._stat = (path8) => statMethod(path8, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = DIR_TYPES.has(type);
        this._wantsFile = FILE_TYPES.has(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = (0, path_1.resolve)(root);
        this._isDirent = !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const par = this.parent;
            const fil = par && par.files;
            if (fil && fil.length > 0) {
              const { path: path8, depth } = par;
              const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path8));
              const awaited = await Promise.all(slice);
              for (const entry of awaited) {
                if (!entry) {
                  batch--;
                  return;
                }
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry);
                if (entryType === "directory" && this._directoryFilter(entry)) {
                  if (depth <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                  if (this._wantsFile) {
                    this.push(entry);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path8, depth) {
        let files;
        try {
          files = await (0, promises_1.readdir)(path8, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth, path: path8 };
      }
      async _formatEntry(dirent, path8) {
        let entry;
        const basename2 = this._isDirent ? dirent.name : dirent;
        try {
          const fullPath = (0, path_1.resolve)((0, path_1.join)(path8, basename2));
          entry = { path: (0, path_1.relative)(this._root, fullPath), fullPath, basename: basename2 };
          entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
          return;
        }
        return entry;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry) {
        if (!entry && this._statsProp in entry) {
          return "";
        }
        const stats = entry[this._statsProp];
        if (stats.isFile())
          return "file";
        if (stats.isDirectory())
          return "directory";
        if (stats && stats.isSymbolicLink()) {
          const full = entry.fullPath;
          try {
            const entryRealPath = await (0, promises_1.realpath)(full);
            const entryRealPathStats = await (0, promises_1.lstat)(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === path_1.sep) {
                const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
            return "";
          }
        }
      }
      _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    exports2.ReaddirpStream = ReaddirpStream;
    var readdirp = (root, options = {}) => {
      let type = options.entryType || options.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options.root = root;
      return new ReaddirpStream(options);
    };
    exports2.readdirp = readdirp;
    var readdirpPromise = (root, options = {}) => {
      return new Promise((resolve, reject) => {
        const files = [];
        (0, exports2.readdirp)(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve(files)).on("error", (error) => reject(error));
      });
    };
    exports2.readdirpPromise = readdirpPromise;
    exports2.default = exports2.readdirp;
  }
});

// node_modules/chokidar/handler.js
var require_handler = __commonJS({
  "node_modules/chokidar/handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NodeFsHandler = exports2.EVENTS = exports2.isIBMi = exports2.isFreeBSD = exports2.isLinux = exports2.isMacos = exports2.isWindows = exports2.IDENTITY_FN = exports2.EMPTY_FN = exports2.STR_CLOSE = exports2.STR_END = exports2.STR_DATA = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var sysPath = require("path");
    var os_1 = require("os");
    exports2.STR_DATA = "data";
    exports2.STR_END = "end";
    exports2.STR_CLOSE = "close";
    var EMPTY_FN = () => {
    };
    exports2.EMPTY_FN = EMPTY_FN;
    var IDENTITY_FN = (val) => val;
    exports2.IDENTITY_FN = IDENTITY_FN;
    var pl = process.platform;
    exports2.isWindows = pl === "win32";
    exports2.isMacos = pl === "darwin";
    exports2.isLinux = pl === "linux";
    exports2.isFreeBSD = pl === "freebsd";
    exports2.isIBMi = (0, os_1.type)() === "OS400";
    exports2.EVENTS = {
      ALL: "all",
      READY: "ready",
      ADD: "add",
      CHANGE: "change",
      ADD_DIR: "addDir",
      UNLINK: "unlink",
      UNLINK_DIR: "unlinkDir",
      RAW: "raw",
      ERROR: "error"
    };
    var EV = exports2.EVENTS;
    var THROTTLE_MODE_WATCH = "watch";
    var statMethods = { lstat: promises_1.lstat, stat: promises_1.stat };
    var KEY_LISTENERS = "listeners";
    var KEY_ERR = "errHandlers";
    var KEY_RAW = "rawEmitters";
    var HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];
    var binaryExtensions = /* @__PURE__ */ new Set([
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "afdesign",
      "afphoto",
      "afpub",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ]);
    var isBinaryPath = (filePath) => binaryExtensions.has(sysPath.extname(filePath).slice(1).toLowerCase());
    var foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert = (main, prop, item) => {
      let container = main[prop];
      if (!(container instanceof Set)) {
        main[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key2) => {
      const set = cont[key2];
      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key2];
      }
    };
    var delFromSet = (main, prop, item) => {
      const container = main[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = /* @__PURE__ */ new Map();
    function createFsWatchInstance(path8, options, listener, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener(path8);
        emitRaw(rawEvent, evPath, { watchedPath: path8 });
        if (evPath && path8 !== evPath) {
          fsWatchBroadcast(sysPath.resolve(path8, evPath), KEY_LISTENERS, sysPath.join(path8, evPath));
        }
      };
      try {
        return (0, fs_1.watch)(path8, {
          persistent: options.persistent
        }, handleEvent);
      } catch (error) {
        errHandler(error);
        return void 0;
      }
    }
    var fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[listenerType], (listener) => {
        listener(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path8, fullPath, options, handlers) => {
      const { listener, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options.persistent) {
        watcher = createFsWatchInstance(path8, options, listener, errHandler, rawEmitter);
        if (!watcher)
          return;
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(path8, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
          return;
        watcher.on(EV.ERROR, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          if (cont)
            cont.watcherUnusable = true;
          if (exports2.isWindows && error.code === "EPERM") {
            try {
              const fd = await (0, promises_1.open)(path8, "r");
              await fd.close();
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = /* @__PURE__ */ new Map();
    var setFsWatchFileListener = (path8, fullPath, options, handlers) => {
      const { listener, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
        (0, fs_1.unwatchFile)(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener,
          rawEmitters: rawEmitter,
          options,
          watcher: (0, fs_1.watchFile)(fullPath, options, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV.CHANGE, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener2) => listener2(path8, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          (0, fs_1.unwatchFile)(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler = class {
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      _watchWithNodeFs(path8, listener) {
        const opts = this.fsw.options;
        const directory = sysPath.dirname(path8);
        const basename2 = sysPath.basename(path8);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename2);
        const absolutePath = sysPath.resolve(path8);
        const options = {
          persistent: opts.persistent
        };
        if (!listener)
          listener = exports2.EMPTY_FN;
        let closer;
        if (opts.usePolling) {
          const enableBin = opts.interval !== opts.binaryInterval;
          options.interval = enableBin && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path8, absolutePath, options, {
            listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path8, absolutePath, options, {
            listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname5 = sysPath.dirname(file);
        const basename2 = sysPath.basename(file);
        const parent = this.fsw._getWatchedDir(dirname5);
        let prevStats = stats;
        if (parent.has(basename2))
          return;
        const listener = async (path8, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await (0, promises_1.stat)(file);
              if (this.fsw.closed)
                return;
              const at = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV.CHANGE, file, newStats2);
              }
              if ((exports2.isMacos || exports2.isLinux || exports2.isFreeBSD) && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path8);
                prevStats = newStats2;
                const closer2 = this._watchWithNodeFs(file, listener);
                if (closer2)
                  this.fsw._addPathCloser(path8, closer2);
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname5, basename2);
            }
          } else if (parent.has(basename2)) {
            const at = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at || at <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV.CHANGE, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV.ADD, file, 0))
            return;
          this.fsw._emit(EV.ADD, file, stats);
        }
        return closer;
      }
      async _handleSymlink(entry, directory, path8, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await (0, promises_1.realpath)(path8);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV.CHANGE, path8, entry.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV.ADD, path8, entry.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        directory = sysPath.join(directory, "");
        throttler = this.fsw._throttle("readdir", directory, 1e3);
        if (!throttler)
          return;
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream = this.fsw._readdirp(directory, {
          fileFilter: (entry) => wh.filterPath(entry),
          directoryFilter: (entry) => wh.filterDir(entry)
        });
        if (!stream)
          return;
        stream.on(exports2.STR_DATA, async (entry) => {
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          const item = entry.path;
          let path8 = sysPath.join(directory, item);
          current.add(item);
          if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path8, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path8 = sysPath.join(dir, sysPath.relative(dir, path8));
            this._addToNodeFs(path8, initialAdd, wh, depth + 1);
          }
        }).on(EV.ERROR, this._boundHandleError);
        return new Promise((resolve, reject) => {
          if (!stream)
            return reject();
          stream.once(exports2.STR_END, () => {
            if (this.fsw.closed) {
              stream = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve(void 0);
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item);
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth, throttler);
          });
        });
      }
      async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
        const tracked = parentDir.has(sysPath.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          this.fsw._emit(EV.ADD_DIR, dir, stats);
        }
        parentDir.add(sysPath.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
          });
        }
        return closer;
      }
      async _addToNodeFs(path8, initialAdd, priorWh, depth, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path8) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path8);
        if (priorWh) {
          wh.filterPath = (entry) => priorWh.filterPath(entry);
          wh.filterDir = (entry) => priorWh.filterDir(entry);
        }
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks;
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath.resolve(path8);
            const targetPath = follow ? await (0, promises_1.realpath)(path8) : path8;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await (0, promises_1.realpath)(path8) : path8;
            if (this.fsw.closed)
              return;
            const parent = sysPath.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV.ADD, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth, path8, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath.resolve(path8), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          if (closer)
            this.fsw._addPathCloser(path8, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path8;
          }
        }
      }
    };
    exports2.NodeFsHandler = NodeFsHandler;
  }
});

// node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/chokidar/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FSWatcher = exports2.WatchHelper = void 0;
    exports2.watch = watch;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var events_1 = require("events");
    var sysPath = require("path");
    var readdirp_1 = require_readdirp();
    var handler_js_1 = require_handler();
    var SLASH = "/";
    var SLASH_SLASH = "//";
    var ONE_DOT = ".";
    var TWO_DOTS = "..";
    var STRING_TYPE = "string";
    var BACK_SLASH_RE = /\\/g;
    var DOUBLE_SLASH_RE = /\/\//;
    var DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    var REPLACER_RE = /^\.[/\\]/;
    function arrify(item) {
      return Array.isArray(item) ? item : [item];
    }
    var isMatcherObject = (matcher) => typeof matcher === "object" && matcher !== null && !(matcher instanceof RegExp);
    function createPattern(matcher) {
      if (typeof matcher === "function")
        return matcher;
      if (typeof matcher === "string")
        return (string) => matcher === string;
      if (matcher instanceof RegExp)
        return (string) => matcher.test(string);
      if (typeof matcher === "object" && matcher !== null) {
        return (string) => {
          if (matcher.path === string)
            return true;
          if (matcher.recursive) {
            const relative = sysPath.relative(matcher.path, string);
            if (!relative) {
              return false;
            }
            return !relative.startsWith("..") && !sysPath.isAbsolute(relative);
          }
          return false;
        };
      }
      return () => false;
    }
    function normalizePath(path8) {
      if (typeof path8 !== "string")
        throw new Error("string expected");
      path8 = sysPath.normalize(path8);
      path8 = path8.replace(/\\/g, "/");
      let prepend = false;
      if (path8.startsWith("//"))
        prepend = true;
      const DOUBLE_SLASH_RE2 = /\/\//;
      while (path8.match(DOUBLE_SLASH_RE2))
        path8 = path8.replace(DOUBLE_SLASH_RE2, "/");
      if (prepend)
        path8 = "/" + path8;
      return path8;
    }
    function matchPatterns(patterns, testString, stats) {
      const path8 = normalizePath(testString);
      for (let index = 0; index < patterns.length; index++) {
        const pattern = patterns[index];
        if (pattern(path8, stats)) {
          return true;
        }
      }
      return false;
    }
    function anymatch(matchers, testString) {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const matchersArray = arrify(matchers);
      const patterns = matchersArray.map((matcher) => createPattern(matcher));
      if (testString == null) {
        return (testString2, stats) => {
          return matchPatterns(patterns, testString2, stats);
        };
      }
      return matchPatterns(patterns, testString);
    }
    var unifyPaths = (paths_) => {
      const paths = arrify(paths_).flat();
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string) => {
      let str = string.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path8) => toUnix(sysPath.normalize(toUnix(path8)));
    var normalizeIgnored = (cwd = "") => (path8) => {
      if (typeof path8 === "string") {
        return normalizePathToUnix(sysPath.isAbsolute(path8) ? path8 : sysPath.join(cwd, path8));
      } else {
        return path8;
      }
    };
    var getAbsolutePath = (path8, cwd) => {
      if (sysPath.isAbsolute(path8)) {
        return path8;
      }
      return sysPath.join(cwd, path8);
    };
    var EMPTY_SET = Object.freeze(/* @__PURE__ */ new Set());
    var DirEntry = class {
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await (0, promises_1.readdir)(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      getChildren() {
        const { items } = this;
        if (!items)
          return [];
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        this.path = "";
        this._removeWatcher = handler_js_1.EMPTY_FN;
        this.items = EMPTY_SET;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path8, follow, fsw) {
        this.fsw = fsw;
        const watchPath = path8;
        this.path = path8 = path8.replace(REPLACER_RE, "");
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.dirParts = [];
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, entry.fullPath));
      }
      filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      filterDir(entry) {
        return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    };
    exports2.WatchHelper = WatchHelper;
    var FSWatcher = class extends events_1.EventEmitter {
      constructor(_opts = {}) {
        super();
        this.closed = false;
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._watched = /* @__PURE__ */ new Map();
        this._pendingWrites = /* @__PURE__ */ new Map();
        this._pendingUnlinks = /* @__PURE__ */ new Map();
        this._readyCount = 0;
        this._readyEmitted = false;
        const awf = _opts.awaitWriteFinish;
        const DEF_AWF = { stabilityThreshold: 2e3, pollInterval: 100 };
        const opts = {
          persistent: true,
          ignoreInitial: false,
          ignorePermissionErrors: false,
          interval: 100,
          binaryInterval: 300,
          followSymlinks: true,
          usePolling: false,
          atomic: true,
          ..._opts,
          ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
          awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === "object" ? { ...DEF_AWF, ...awf } : false
        };
        if (handler_js_1.isIBMi)
          opts.usePolling = true;
        if (opts.atomic === void 0)
          opts.atomic = !opts.usePolling;
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0")
            opts.usePolling = false;
          else if (envLower === "true" || envLower === "1")
            opts.usePolling = true;
          else
            opts.usePolling = !!envLower;
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval)
          opts.interval = Number.parseInt(envInterval, 10);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = handler_js_1.EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(handler_js_1.EVENTS.READY));
          }
        };
        this._emitRaw = (...args) => this.emit(handler_js_1.EVENTS.RAW, ...args);
        this._boundRemove = this._remove.bind(this);
        this.options = opts;
        this._nodeFsHandler = new handler_js_1.NodeFsHandler(this);
        Object.freeze(opts);
      }
      _addIgnoredPath(matcher) {
        if (isMatcherObject(matcher)) {
          for (const ignored of this._ignoredPaths) {
            if (isMatcherObject(ignored) && ignored.path === matcher.path && ignored.recursive === matcher.recursive) {
              return;
            }
          }
        }
        this._ignoredPaths.add(matcher);
      }
      _removeIgnoredPath(matcher) {
        this._ignoredPaths.delete(matcher);
        if (typeof matcher === "string") {
          for (const ignored of this._ignoredPaths) {
            if (isMatcherObject(ignored) && ignored.path === matcher) {
              this._ignoredPaths.delete(ignored);
            }
          }
        }
      }
      add(paths_, _origAdd, _internal) {
        const { cwd } = this.options;
        this.closed = false;
        this._closePromise = void 0;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path8) => {
            const absPath = getAbsolutePath(path8, cwd);
            return absPath;
          });
        }
        paths.forEach((path8) => {
          this._removeIgnoredPath(path8);
        });
        this._userIgnored = void 0;
        if (!this._readyCount)
          this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(async (path8) => {
          const res = await this._nodeFsHandler._addToNodeFs(path8, !_internal, void 0, 0, _origAdd);
          if (res)
            this._emitReady();
          return res;
        })).then((results) => {
          if (this.closed)
            return;
          results.forEach((item) => {
            if (item)
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          });
        });
        return this;
      }
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path8) => {
          if (!sysPath.isAbsolute(path8) && !this._closers.has(path8)) {
            if (cwd)
              path8 = sysPath.join(cwd, path8);
            path8 = sysPath.resolve(path8);
          }
          this._closePath(path8);
          this._addIgnoredPath(path8);
          if (this._watched.has(path8)) {
            this._addIgnoredPath({
              path: path8,
              recursive: true
            });
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      close() {
        if (this._closePromise) {
          return this._closePromise;
        }
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise = closer();
          if (promise instanceof Promise)
            closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        this._closers.clear();
        this._watched.clear();
        this._streams.clear();
        this._symlinkPaths.clear();
        this._throttled.clear();
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
          const key2 = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          const index = key2 || ONE_DOT;
          watchList[index] = entry.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(event, ...args);
        if (event !== handler_js_1.EVENTS.ERROR)
          this.emit(handler_js_1.EVENTS.ALL, event, ...args);
      }
      async _emit(event, path8, stats) {
        if (this.closed)
          return;
        const opts = this.options;
        if (handler_js_1.isWindows)
          path8 = sysPath.normalize(path8);
        if (opts.cwd)
          path8 = sysPath.relative(opts.cwd, path8);
        const args = [path8];
        if (stats != null)
          args.push(stats);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path8))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === handler_js_1.EVENTS.UNLINK) {
            this._pendingUnlinks.set(path8, [event, ...args]);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry, path9) => {
                this.emit(...entry);
                this.emit(handler_js_1.EVENTS.ALL, ...entry);
                this._pendingUnlinks.delete(path9);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === handler_js_1.EVENTS.ADD && this._pendingUnlinks.has(path8)) {
            event = handler_js_1.EVENTS.CHANGE;
            this._pendingUnlinks.delete(path8);
          }
        }
        if (awf && (event === handler_js_1.EVENTS.ADD || event === handler_js_1.EVENTS.CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats2) => {
            if (err) {
              event = handler_js_1.EVENTS.ERROR;
              args[0] = err;
              this.emitWithAll(event, args);
            } else if (stats2) {
              if (args.length > 1) {
                args[1] = stats2;
              } else {
                args.push(stats2);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path8, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === handler_js_1.EVENTS.CHANGE) {
          const isThrottled = !this._throttle(handler_js_1.EVENTS.CHANGE, path8, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && stats === void 0 && (event === handler_js_1.EVENTS.ADD || event === handler_js_1.EVENTS.ADD_DIR || event === handler_js_1.EVENTS.CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path8) : path8;
          let stats2;
          try {
            stats2 = await (0, promises_1.stat)(fullPath);
          } catch (err) {
          }
          if (!stats2 || this.closed)
            return;
          args.push(stats2);
        }
        this.emitWithAll(event, args);
        return this;
      }
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(handler_js_1.EVENTS.ERROR, error);
        }
        return error || this.closed;
      }
      _throttle(actionType, path8, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        if (!action)
          throw new Error("invalid throttle");
        const actionPath = action.get(path8);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path8);
          const count = item ? item.count : 0;
          action.delete(path8);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path8, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      _awaitWriteFinish(path8, threshold, event, awfEmit) {
        const awf = this.options.awaitWriteFinish;
        if (typeof awf !== "object")
          return;
        const pollInterval = awf.pollInterval;
        let timeoutHandler;
        let fullPath = path8;
        if (this.options.cwd && !sysPath.isAbsolute(path8)) {
          fullPath = sysPath.join(this.options.cwd, path8);
        }
        const now = new Date();
        const writes = this._pendingWrites;
        function awaitWriteFinishFn(prevStat) {
          (0, fs_1.stat)(fullPath, (err, curStat) => {
            if (err || !writes.has(path8)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              writes.get(path8).lastChange = now2;
            }
            const pw = writes.get(path8);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              writes.delete(path8);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
            }
          });
        }
        if (!writes.has(path8)) {
          writes.set(path8, {
            lastChange: now,
            cancelWait: () => {
              writes.delete(path8);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
        }
      }
      _isIgnored(path8, stats) {
        if (this.options.atomic && DOT_RE.test(path8))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = (ign || []).map(normalizeIgnored(cwd));
          const ignoredPaths = [...this._ignoredPaths];
          const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];
          this._userIgnored = anymatch(list, void 0);
        }
        return this._userIgnored(path8, stats);
      }
      _isntIgnored(path8, stat) {
        return !this._isIgnored(path8, stat);
      }
      _getWatchHelpers(path8) {
        return new WatchHelper(path8, this.options.followSymlinks, this);
      }
      _getWatchedDir(directory) {
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        return Boolean(Number(stats.mode) & 256);
      }
      _remove(directory, item, isDirectory) {
        const path8 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path8);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path8) || this._watched.has(fullPath);
        if (!this._throttle("remove", path8, 100))
          return;
        if (!isDirectory && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path8);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path8, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path8;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path8);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === handler_js_1.EVENTS.ADD)
            return;
        }
        this._watched.delete(path8);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? handler_js_1.EVENTS.UNLINK_DIR : handler_js_1.EVENTS.UNLINK;
        if (wasTracked && !this._isIgnored(path8))
          this._emit(eventName, path8);
        this._closePath(path8);
      }
      _closePath(path8) {
        this._closeFile(path8);
        const dir = sysPath.dirname(path8);
        this._getWatchedDir(dir).remove(sysPath.basename(path8));
      }
      _closeFile(path8) {
        const closers = this._closers.get(path8);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path8);
      }
      _addPathCloser(path8, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path8);
        if (!list) {
          list = [];
          this._closers.set(path8, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options = { type: handler_js_1.EVENTS.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };
        let stream = (0, readdirp_1.readdirp)(root, options);
        this._streams.add(stream);
        stream.once(handler_js_1.STR_CLOSE, () => {
          stream = void 0;
        });
        stream.once(handler_js_1.STR_END, () => {
          if (stream) {
            this._streams.delete(stream);
            stream = void 0;
          }
        });
        return stream;
      }
    };
    exports2.FSWatcher = FSWatcher;
    function watch(paths, options = {}) {
      const watcher = new FSWatcher(options);
      watcher.add(paths);
      return watcher;
    }
    exports2.default = { watch, FSWatcher };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
    };
  }
});

// node_modules/@mdfriday/foundry/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@mdfriday/foundry/dist/index.js"(exports2, module2) {
    var t;
    var e;
    var r;
    var s;
    var n2;
    var i;
    var a;
    var o = Object.create;
    var h = Object.defineProperty;
    var c = Object.getOwnPropertyDescriptor;
    var u = Object.getOwnPropertyNames;
    var l = Object.getPrototypeOf;
    var f = Object.prototype.hasOwnProperty;
    var w = (t2, e2) => function() {
      return t2 && (e2 = (0, t2[u(t2)[0]])(t2 = 0)), e2;
    };
    var d = (t2, e2) => {
      for (var r2 in e2)
        h(t2, r2, { get: e2[r2], enumerable: true });
    };
    var g = (t2, e2, r2, s2) => {
      if (e2 && typeof e2 == "object" || typeof e2 == "function")
        for (let n3 of u(e2))
          f.call(t2, n3) || n3 === r2 || h(t2, n3, { get: () => e2[n3], enumerable: !(s2 = c(e2, n3)) || s2.enumerable });
      return t2;
    };
    var p = (t2, e2, r2) => (r2 = t2 != null ? o(l(t2)) : {}, g(!e2 && t2 && t2.t ? r2 : h(r2, "default", { value: t2, enumerable: true }), t2));
    var m = (t2) => g(h({}, "__esModule", { value: true }), t2);
    var y = w({ "pkg/lang/data.ts"() {
      t = [{ code: "en", name: "English", direction: "ltr", englishName: "English" }, { code: "zh", name: "\u4E2D\u6587", direction: "ltr", englishName: "Chinese" }, { code: "ja", name: "\u65E5\u672C\u8A9E", direction: "ltr", englishName: "Japanese" }, { code: "ko", name: "\uD55C\uAD6D\uC5B4", direction: "ltr", englishName: "Korean" }, { code: "fr", name: "Fran\xE7ais", direction: "ltr", englishName: "French" }, { code: "de", name: "Deutsch", direction: "ltr", englishName: "German" }, { code: "es", name: "Espa\xF1ol", direction: "ltr", englishName: "Spanish" }, { code: "pt", name: "Portugu\xEAs", direction: "ltr", englishName: "Portuguese" }, { code: "ru", name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439", direction: "ltr", englishName: "Russian" }, { code: "hi", name: "\u0939\u093F\u0902\u0926\u0940", direction: "ltr", englishName: "Hindi" }, { code: "it", name: "Italiano", direction: "ltr", englishName: "Italian" }, { code: "nl", name: "Nederlands", direction: "ltr", englishName: "Dutch" }, { code: "tr", name: "T\xFCrk\xE7e", direction: "ltr", englishName: "Turkish" }, { code: "vi", name: "Ti\u1EBFng Vi\u1EC7t", direction: "ltr", englishName: "Vietnamese" }, { code: "th", name: "\u0E44\u0E17\u0E22", direction: "ltr", englishName: "Thai" }], e = [], r = [...t, ...e], s = r.reduce((t2, e2) => (t2[e2.code] = e2, t2), {}), n2 = r.reduce((t2, e2) => (t2[e2.code] = e2.name, t2), {});
    } });
    function b() {
      return a || (a = new i()), a;
    }
    function E() {
      return new i();
    }
    var S;
    var v;
    var T = w({ "pkg/lang/service.ts"() {
      y(), i = class {
        getAllCodes() {
          return r.map((t2) => t2.code);
        }
        getAllNames() {
          return r.map((t2) => t2.name);
        }
        getCodesByDirection(r2) {
          return (r2 === "ltr" ? t : e).map((t2) => t2.code);
        }
        getNamesByDirection(r2) {
          return (r2 === "ltr" ? t : e).map((t2) => t2.name);
        }
        getCodeNameMap() {
          return { ...n2 };
        }
        getCodeNameMapByDirection(r2) {
          return (r2 === "ltr" ? t : e).reduce((t2, e2) => (t2[e2.code] = e2.name, t2), {});
        }
        getNameByCode(t2) {
          return s[t2]?.name;
        }
        getLanguageInfo(t2) {
          const e2 = s[t2];
          return e2 ? { ...e2 } : void 0;
        }
        isSupported(t2) {
          return t2 in s;
        }
        getDirection(t2) {
          return s[t2]?.direction;
        }
        isLTR(t2) {
          return s[t2]?.direction === "ltr";
        }
        isRTL(t2) {
          return s[t2]?.direction === "rtl";
        }
      }, a = null;
    } });
    var x = {};
    d(x, { ALL_LANGUAGES: () => r, CODE_NAME_MAP: () => n2, DefaultLanguageService: () => i, LANGUAGE_MAP: () => s, LTR_LANGUAGES: () => t, RTL_LANGUAGES: () => e, createLanguageService: () => E, getLanguageService: () => b, lang: () => S, languages: () => v });
    var P;
    var $;
    var R;
    var L = w({ "pkg/lang/index.ts"() {
      y(), T(), T(), S = b(), v = { getAllCodes: () => S.getAllCodes(), getAllNames: () => S.getAllNames(), getCodesByDirection: (t2) => S.getCodesByDirection(t2), getNamesByDirection: (t2) => S.getNamesByDirection(t2), getCodeNameMap: () => S.getCodeNameMap(), getCodeNameMapByDirection: (t2) => S.getCodeNameMapByDirection(t2), getNameByCode: (t2) => S.getNameByCode(t2), getLanguageInfo: (t2) => S.getLanguageInfo(t2), isSupported: (t2) => S.isSupported(t2), getDirection: (t2) => S.getDirection(t2), isLTR: (t2) => S.isLTR(t2), isRTL: (t2) => S.isRTL(t2) };
    } });
    var N = w({ "pkg/log/types.ts"() {
    } });
    var F = w({ "pkg/log/logger.ts"() {
      P = p(require("util")), N(), $ = class t2 {
        constructor(t3) {
          __publicField(this, "config");
          __publicField(this, "fields");
          this.config = { enableCaller: true, jsonFormat: true, ...t3 }, this.fields = {};
        }
        shouldLog(t3) {
          const e2 = ["debug", "info", "warn", "error", "fatal"], r2 = e2.indexOf(this.config.level);
          return e2.indexOf(t3) >= r2;
        }
        getCaller() {
          if (!this.config.enableCaller)
            return;
          const t3 = new Error().stack;
          if (!t3)
            return;
          const e2 = t3.split("\n")[4];
          if (!e2)
            return;
          const r2 = e2.match(/at .* \((.+):(\d+):(\d+)\)/);
          if (r2) {
            const [, t4, e3] = r2;
            return `${t4.split("/").pop()}:${e3}`;
          }
          const s2 = e2.match(/at (.+):(\d+):(\d+)/);
          if (s2) {
            const [, t4, e3] = s2;
            return `${t4.split("/").pop()}:${e3}`;
          }
        }
        formatMessage(t3, e2) {
          return e2.length === 0 ? t3 : P.format(t3, ...e2);
        }
        writeLog(t3, e2) {
          if (!this.shouldLog(t3))
            return;
          const r2 = { level: t3, timestamp: new Date().toISOString(), message: e2, ...this.fields }, s2 = this.getCaller();
          s2 && (r2.caller = s2);
          const n3 = this.config.jsonFormat ? JSON.stringify(r2) : this.formatPlainText(r2);
          t3 === "error" || t3 === "fatal" ? process.stderr.write(n3 + "\n") : process.stdout.write(n3 + "\n"), t3 === "fatal" && process.exit(1);
        }
        formatPlainText(t3) {
          const e2 = [t3.timestamp, t3.level.toUpperCase()];
          t3.caller && e2.push(`[${t3.caller}]`), e2.push(t3.message);
          const r2 = Object.keys(t3).filter((t4) => !["level", "timestamp", "message", "caller"].includes(t4)).map((e3) => `${e3}=${JSON.stringify(t3[e3])}`).join(" ");
          return r2 && e2.push(r2), e2.join(" ");
        }
        debug(t3, ...e2) {
          this.writeLog("debug", this.formatMessage(t3, e2));
        }
        info(t3, ...e2) {
          this.writeLog("info", this.formatMessage(t3, e2));
        }
        warn(t3, ...e2) {
          this.writeLog("warn", this.formatMessage(t3, e2));
        }
        error(t3, ...e2) {
          this.writeLog("error", this.formatMessage(t3, e2));
        }
        fatal(t3, ...e2) {
          this.writeLog("fatal", this.formatMessage(t3, e2));
        }
        debugf(t3, ...e2) {
          this.writeLog("debug", this.formatMessage(t3, e2));
        }
        infof(t3, ...e2) {
          this.writeLog("info", this.formatMessage(t3, e2));
        }
        warnf(t3, ...e2) {
          this.writeLog("warn", this.formatMessage(t3, e2));
        }
        errorf(t3, ...e2) {
          this.writeLog("error", this.formatMessage(t3, e2));
        }
        fatalf(t3, ...e2) {
          this.writeLog("fatal", this.formatMessage(t3, e2));
        }
        with(e2) {
          const r2 = new t2(this.config);
          return r2.fields = { ...this.fields, ...e2 }, r2;
        }
      };
    } });
    var D = w({ "pkg/log/http.ts"() {
    } });
    function A(t2, e2) {
      return R.getLogger(t2, e2);
    }
    var k;
    var I;
    var C;
    var O;
    var _;
    var M;
    var U;
    var j;
    var B = w({ "pkg/log/manager.ts"() {
      var _a3;
      F(), N(), R = (_a3 = class {
        constructor() {
          __publicField(this, "globalConfig");
          __publicField(this, "loggers");
          this.globalConfig = { level: "debug", enableCaller: true, jsonFormat: true }, this.loggers = /* @__PURE__ */ new Map();
        }
        static getInstance() {
          return _a3.instance || (_a3.instance = new _a3()), _a3.instance;
        }
        setGlobalConfig(t2) {
          this.globalConfig = { ...this.globalConfig, ...t2 }, this.loggers.clear();
        }
        getGlobalConfig() {
          return { ...this.globalConfig };
        }
        getLogger(t2, e2) {
          const r2 = t2 + (e2 ? JSON.stringify(e2) : "");
          if (!this.loggers.has(r2)) {
            const n3 = (s2 = this.globalConfig, new $(s2)), i2 = { domain: t2, ...e2 }, a2 = n3.with(i2);
            this.loggers.set(r2, a2);
          }
          var s2;
          return this.loggers.get(r2);
        }
        getComponentLogger(t2, e2, r2) {
          const s2 = { component: e2, ...r2 };
          return this.getLogger(t2, s2);
        }
        clearCache() {
          this.loggers.clear();
        }
        getCachedDomains() {
          return Array.from(this.loggers.keys());
        }
        setLogLevel(t2) {
          this.setGlobalConfig({ level: t2 });
        }
        setCallerEnabled(t2) {
          this.setGlobalConfig({ enableCaller: t2 });
        }
        setJsonFormat(t2) {
          this.setGlobalConfig({ jsonFormat: t2 });
        }
      }, __publicField(_a3, "instance"), _a3).getInstance();
    } });
    var q = w({ "pkg/log/index.ts"() {
      N(), F(), D(), B(), F(), N(), function(t2 = "info") {
        new $({ level: t2 });
      }("info");
    } });
    var W = {};
    d(W, { OrderedTaxonomy: () => M, OrderedTaxonomyEntry: () => _, TaxonomiesBuilder: () => j, Taxonomy: () => O, TaxonomyList: () => U, WeightedPage: () => I, WeightedPages: () => C });
    var z = w({ "internal/domain/site/entity/taxonomies-builder.ts"() {
      q(), k = A("site", { component: "taxonomies-builder" }), I = class {
        constructor(t2, e2) {
          __publicField(this, "page");
          __publicField(this, "ordinalWeightPage");
          this.page = t2, this.ordinalWeightPage = e2;
        }
        get Page() {
          return this.page;
        }
        weight() {
          return this.ordinalWeightPage.weight();
        }
        ordinal() {
          return this.ordinalWeightPage.ordinal();
        }
        owner() {
          return this.ordinalWeightPage.owner();
        }
        get Permalink() {
          return this.page.Permalink;
        }
        get RelPermalink() {
          return this.page.RelPermalink;
        }
        get Title() {
          return this.page.Title;
        }
      }, C = class extends Array {
        page() {
          return this.length === 0 ? (k.error("Page called on empty WeightedPages"), null) : this[0];
        }
        get Page() {
          return this.page();
        }
        pages() {
          return Array.from(this);
        }
        sortByWeight() {
          this.stableSort((t2, e2) => t2.weight() - e2.weight());
        }
        count() {
          return this.length;
        }
        get Count() {
          return this.count();
        }
        stableSort(t2) {
          const e2 = this.map((t3, e3) => ({ item: t3, index: e3 }));
          e2.sort((e3, r2) => {
            const s2 = t2(e3.item, r2.item);
            return s2 !== 0 ? s2 : e3.index - r2.index;
          }), this.splice(0, this.length, ...e2.map((t3) => t3.item));
        }
      }, O = class {
        constructor() {
          __publicField(this, "terms", /* @__PURE__ */ new Map());
        }
        get(t2) {
          return this.terms.get(t2);
        }
        set(t2, e2) {
          this.terms.set(t2, e2);
        }
        has(t2) {
          return this.terms.has(t2);
        }
        keys() {
          return Array.from(this.terms.keys());
        }
        values() {
          return Array.from(this.terms.values());
        }
        get Values() {
          return this.terms;
        }
        entries() {
          return Array.from(this.terms.entries());
        }
        size() {
          return this.terms.size;
        }
        byCount() {
          const t2 = this.taxonomyArray();
          return t2.sort((t3, e2) => {
            const r2 = t3.weightedPages.length, s2 = e2.weightedPages.length;
            return r2 === s2 ? t3.name.localeCompare(e2.name) : s2 - r2;
          }), new M(t2);
        }
        taxonomyArray() {
          const t2 = [];
          for (const [e2, r2] of this.terms.entries())
            t2.push(new _(e2, r2));
          return t2;
        }
      }, _ = class {
        constructor(t2, e2) {
          __publicField(this, "name");
          __publicField(this, "weightedPages");
          this.name = t2, this.weightedPages = e2;
        }
        count() {
          return this.weightedPages.count();
        }
        term() {
          return this.name;
        }
      }, M = class extends Array {
        constructor(t2) {
          super(), t2 && this.push(...t2);
        }
        getOneOPage() {
          return this.length === 0 ? null : this[0].weightedPages.page();
        }
      }, U = class {
        constructor() {
          __publicField(this, "taxonomies", /* @__PURE__ */ new Map());
        }
        get(t2) {
          return this.taxonomies.get(t2);
        }
        set(t2, e2) {
          this.taxonomies.set(t2, e2);
        }
        has(t2) {
          return this.taxonomies.has(t2);
        }
        keys() {
          return Array.from(this.taxonomies.keys());
        }
        values() {
          return Array.from(this.taxonomies.values());
        }
        get Values() {
          return this.taxonomies;
        }
        entries() {
          return Array.from(this.taxonomies.entries());
        }
        size() {
          return this.taxonomies.size;
        }
      }, j = class {
        constructor(t2) {
          __publicField(this, "contentService");
          this.contentService = t2;
        }
        async buildTaxonomiesForLanguage(t2, e2) {
          const r2 = new U();
          try {
            return await this.contentService.walkTaxonomies(t2, async (t3, s2, n3) => {
              r2.has(t3) || r2.set(t3, new O());
              const i2 = r2.get(t3);
              i2.has(s2) || i2.set(s2, new C());
              const a2 = await e2.siteWeightedPage(n3);
              i2.get(s2).push(a2);
            }), r2;
          } catch (t3) {
            throw k.error(`Failed to create taxonomies: ${t3}`), t3;
          }
        }
      };
    } });
    var H = {};
    d(H, { AutoIDGenerator: () => Qe, IncrementalBuildCoordinator: () => So, processSSG: () => eo, processSSGWithProgress: () => so, startIncrementalBuild: () => vo }), module2.exports = m(H);
    var G = class extends Error {
      constructor(t2, e2) {
        super(t2), this.code = e2, this.name = "ConfigError";
      }
    };
    var V = (new G("configuration not found", "CONFIG_NOT_FOUND"), new G("invalid configuration", "INVALID_CONFIG"), new G("workspace not found", "WORKSPACE_NOT_FOUND"), new G("configuration file not found", "CONFIG_FILE_NOT_FOUND"), new G("invalid configuration format", "INVALID_CONFIG_FORMAT"), class {
      constructor(t2, e2, r2, s2, n3, i2, a2, o2, h2) {
        __publicField(this, "configSourceFs");
        __publicField(this, "provider");
        __publicField(this, "root");
        __publicField(this, "dir");
        __publicField(this, "module");
        __publicField(this, "service");
        __publicField(this, "social");
        __publicField(this, "language");
        __publicField(this, "taxonomy");
        this.configSourceFs = t2, this.provider = e2, this.root = r2, this.dir = s2, this.module = n3, this.service = i2, this.social = a2, this.language = o2, this.taxonomy = h2;
      }
      fs() {
        return this.configSourceFs;
      }
      getProvider() {
        return this.provider;
      }
      theme() {
        return this.root.defaultTheme();
      }
      getDir() {
        return this.dir;
      }
      getRoot() {
        return this.root;
      }
      getModule() {
        return this.module;
      }
      getService() {
        return this.service;
      }
      getSocial() {
        return this.social;
      }
      getLanguage() {
        return this.language;
      }
      getTaxonomy() {
        return this.taxonomy;
      }
      setLanguage(t2) {
        this.language = t2;
      }
      setTaxonomy(t2) {
        this.taxonomy = t2;
      }
      validate() {
        let t2 = true;
        return this.language && (t2 = t2 && this.language.validate()), t2;
      }
    });
    var K = { baseURL: "", title: "", theme: [], timeout: "30s", contentDir: "content", dataDir: "data", layoutDir: "layouts", staticDir: "static", archetypeDir: "archetypes", assetDir: "assets", publishDir: "public", buildDrafts: false, buildExpired: false, buildFuture: false, copyright: "", defaultContentLanguage: "en", defaultContentLanguageInSubdir: false, disableAliases: false, disablePathToLower: false, disableKinds: [], disableLanguages: [], renderSegments: [], disableHugoGeneratorInject: false, disableLiveReload: false, enableEmoji: false };
    var J = class {
      constructor(t2, e2 = {}) {
        __publicField(this, "rootConfig");
        __publicField(this, "rootParams");
        this.rootConfig = t2, this.rootParams = e2;
      }
      defaultTheme() {
        return this.rootConfig.theme.length > 0 ? this.rootConfig.theme[0] : "";
      }
      compiledTimeout() {
        const t2 = this.rootConfig.timeout;
        if (/^\d+$/.test(t2))
          return 1e3 * parseInt(t2, 10);
        const e2 = t2.match(/^(\d+)([smh])$/);
        if (e2) {
          const t3 = parseInt(e2[1], 10);
          switch (e2[2]) {
            case "s":
              return 1e3 * t3;
            case "m":
              return 60 * t3 * 1e3;
            case "h":
              return 60 * t3 * 60 * 1e3;
          }
        }
        return 3e4;
      }
      baseUrl() {
        return this.rootConfig.baseURL;
      }
      configParams() {
        return this.rootParams;
      }
      siteTitle() {
        return this.rootConfig.title;
      }
      getRootConfig() {
        return this.rootConfig;
      }
      getThemes() {
        return this.rootConfig.theme;
      }
      getDefaultContentLanguage() {
        return this.rootConfig.defaultContentLanguage;
      }
      shouldBuildDrafts() {
        return this.rootConfig.buildDrafts;
      }
      shouldBuildFuture() {
        return this.rootConfig.buildFuture;
      }
      shouldBuildExpired() {
        return this.rootConfig.buildExpired;
      }
    };
    var Y = class {
      constructor(t2) {
        __publicField(this, "moduleConfig");
        this.moduleConfig = t2;
      }
      importPaths() {
        return this.moduleConfig.imports.map((t2) => t2.path);
      }
      getModuleConfig() {
        return this.moduleConfig;
      }
      getImports() {
        return this.moduleConfig.imports;
      }
      getMounts() {
        return this.moduleConfig.mounts;
      }
      importCount() {
        return this.moduleConfig.imports.length;
      }
      mountCount() {
        return this.moduleConfig.mounts.length;
      }
      hasImports() {
        return this.moduleConfig.imports.length > 0;
      }
      hasMounts() {
        return this.moduleConfig.mounts.length > 0;
      }
      findImport(t2) {
        return this.moduleConfig.imports.find((e2) => e2.path === t2);
      }
      findMount(t2) {
        return this.moduleConfig.mounts.find((e2) => e2.source === t2);
      }
    };
    var Z = { disqus: { disable: false, shortname: "" }, googleAnalytics: { disable: false, respectDoNotTrack: false, id: "" }, rss: { limit: 0 }, x: { respectDoNotTrack: false, disableInlineCSS: false } };
    var X = class {
      constructor(t2) {
        __publicField(this, "serviceConfig");
        this.serviceConfig = t2;
      }
      isGoogleAnalyticsEnabled() {
        return !this.serviceConfig.googleAnalytics.disable;
      }
      googleAnalyticsID() {
        return this.serviceConfig.googleAnalytics.id;
      }
      isGoogleAnalyticsRespectDoNotTrack() {
        return this.serviceConfig.googleAnalytics.respectDoNotTrack;
      }
      isDisqusEnabled() {
        return !this.serviceConfig.disqus.disable;
      }
      disqusShortname() {
        return this.serviceConfig.disqus.shortname;
      }
      isXRespectDoNotTrack() {
        return this.serviceConfig.x.respectDoNotTrack;
      }
      isXDisableInlineCSS() {
        return this.serviceConfig.x.disableInlineCSS;
      }
      rssLimit() {
        return this.serviceConfig.rss.limit;
      }
      getServiceConfig() {
        return this.serviceConfig;
      }
      getGoogleAnalytics() {
        return this.serviceConfig.googleAnalytics;
      }
      getDisqus() {
        return this.serviceConfig.disqus;
      }
      getRSS() {
        return this.serviceConfig.rss;
      }
      hasEnabledServices() {
        return this.isGoogleAnalyticsEnabled() || this.isDisqusEnabled();
      }
    };
    L();
    var Q = { languageCode: "en", languageName: "English", title: "", weight: 0, contentDir: "content", disabled: false, params: {} };
    var tt = class {
      constructor(t2) {
        __publicField(this, "defaultLang");
        __publicField(this, "configs");
        __publicField(this, "indices");
        this.configs = t2, this.defaultLang = this.calculateDefaultLanguage(), this.indices = [], this.setIndices();
      }
      calculateDefaultLanguage() {
        if (Object.keys(this.configs).length === 0)
          return "en";
        let t2 = "", e2 = Number.MAX_SAFE_INTEGER;
        for (const [r2, s2] of Object.entries(this.configs))
          s2.weight < e2 && (e2 = s2.weight, t2 = r2);
        return t2 || Object.keys(this.configs)[0];
      }
      languages() {
        return Object.values(this.configs);
      }
      defaultLanguage() {
        return this.defaultLang;
      }
      isLanguageValid(t2) {
        return Object.prototype.hasOwnProperty.call(this.configs, t2);
      }
      otherLanguageKeys() {
        return Object.keys(this.configs).filter((t2) => t2 !== this.defaultLang);
      }
      getRelDir(t2, e2) {
        const r2 = this.configs[e2];
        if (!r2)
          throw new Error(`Language "${e2}" not found`);
        return r2.contentDir || "content";
      }
      validate() {
        return t2 = this.configs, e2 = this.defaultLang, Object.prototype.hasOwnProperty.call(t2, e2);
        var t2, e2;
      }
      setIndices() {
        const t2 = [];
        this.configs[this.defaultLang] && t2.push(this.defaultLang);
        for (const e2 of Object.keys(this.configs))
          e2 !== this.defaultLang && t2.push(e2);
        this.indices = t2;
      }
      languageKeys() {
        return [...this.indices];
      }
      languageIndexes() {
        return this.indices.map((t2, e2) => e2);
      }
      getLanguageIndex(t2) {
        const e2 = this.indices.indexOf(t2);
        if (e2 === -1)
          throw new Error("Language not found in indices");
        return e2;
      }
      getLanguageByIndex(t2) {
        if (t2 < 0 || t2 >= this.indices.length)
          throw new Error("Language index out of range");
        return this.indices[t2];
      }
      getLanguageName(t2) {
        const e2 = this.configs[t2];
        return e2 ? e2.languageName : "";
      }
      getLanguageConfig(t2) {
        return this.configs[t2];
      }
      getConfigs() {
        return this.configs;
      }
    };
    var et = { tag: "tags", category: "categories" };
    function rt(...t2) {
      let e2 = "";
      return t2.length > 0 && (e2 = t2[0], t2.length > 1 && (e2 = t2.join("/"))), e2 = e2.replace(/^[.\s/]+|[.\s/]+$/g, ""), e2 = e2.toLowerCase(), e2 = e2.replace(/\\/g, "/"), e2 === "" || e2 === "/" ? "" : (e2.startsWith("/") || (e2 = "/" + e2), e2);
    }
    var st = class {
      constructor(t2) {
        __publicField(this, "taxonomies");
        __publicField(this, "views");
        __publicField(this, "viewsByTreeKey");
        this.taxonomies = t2, this.views = [], this.viewsByTreeKey = {}, this.setupViews();
      }
      getViews() {
        return [...this.views];
      }
      getTaxonomies() {
        return { ...this.taxonomies };
      }
      getViewByTreeKey(t2) {
        return this.viewsByTreeKey[t2];
      }
      hasTaxonomy(t2) {
        return Object.prototype.hasOwnProperty.call(this.taxonomies, t2);
      }
      getPluralForm(t2) {
        return this.taxonomies[t2];
      }
      getSingularForm(t2) {
        for (const [e2, r2] of Object.entries(this.taxonomies))
          if (r2 === t2)
            return e2;
      }
      getSingularForms() {
        return Object.keys(this.taxonomies);
      }
      getPluralForms() {
        return Object.values(this.taxonomies);
      }
      setupViews() {
        this.views = function(t2) {
          const e2 = [];
          for (const [r2, s2] of Object.entries(t2))
            e2.push({ singular: r2, plural: s2, pluralTreeKey: rt(s2) });
          return e2.sort((t3, e3) => t3.plural.localeCompare(e3.plural)), e2;
        }(this.taxonomies), this.viewsByTreeKey = {};
        for (const t2 of this.views)
          this.viewsByTreeKey[t2.pluralTreeKey] = t2;
      }
      getViewCount() {
        return this.views.length;
      }
      isEmpty() {
        return Object.keys(this.taxonomies).length === 0;
      }
    };
    function nt(t2) {
      const e2 = function(t3) {
        if (t3.taxonomies && typeof t3.taxonomies == "object") {
          const e3 = {};
          for (const [r2, s2] of Object.entries(t3.taxonomies))
            typeof s2 == "string" && (e3[r2] = s2);
          return e3;
        }
        return { ...et };
      }(t2);
      return new st(e2);
    }
    var it = [{ id: "email", title: "Email me" }, { id: "facebook", title: "Facebook" }, { id: "github", title: "GitHub" }, { id: "gitlab", title: "GitLab" }, { id: "bitbucket", title: "Bitbucket" }, { id: "twitter", title: "Twitter" }, { id: "slack", title: "Slack" }, { id: "reddit", title: "Reddit" }, { id: "linkedin", title: "LinkedIn" }, { id: "xing", title: "Xing" }, { id: "stackoverflow", title: "StackOverflow" }, { id: "snapchat", title: "Snapchat" }, { id: "instagram", title: "Instagram" }, { id: "youtube", title: "Youtube" }, { id: "soundcloud", title: "SoundCloud" }, { id: "spotify", title: "Spotify" }, { id: "bandcamp", title: "Bandcamp" }, { id: "itchio", title: "Itch.io" }, { id: "keybase", title: "Keybase" }, { id: "vk", title: "VK" }, { id: "paypal", title: "PayPal" }, { id: "telegram", title: "Telegram" }, { id: "500px", title: "500px" }, { id: "codepen", title: "CodePen" }, { id: "kaggle", title: "kaggle" }, { id: "mastodon", title: "Mastodon" }, { id: "weibo", title: "Weibo" }, { id: "medium", title: "Medium" }, { id: "discord", title: "Discord" }, { id: "strava", title: "Strava" }, { id: "steam", title: "Steam" }, { id: "quora", title: "Quora" }, { id: "amazonwishlist", title: "Amazon Wishlist" }, { id: "slideshare", title: "Slideshare" }, { id: "angellist", title: "AngelList" }, { id: "about", title: "About" }, { id: "lastfm", title: "Last.fm" }, { id: "bluesky", title: "Bluesky" }, { id: "goodreads", title: "Goodreads" }];
    var at = class {
      constructor(t2) {
        __publicField(this, "socialConfig");
        this.socialConfig = t2;
      }
      getUserConfig() {
        return this.socialConfig.userConfig;
      }
      getPlatformTemplates() {
        return this.socialConfig.platformTemplates;
      }
      getPlatformTemplate(t2) {
        return e2 = t2, it.find((t3) => t3.id === e2);
        var e2;
      }
      isPlatformConfigured(t2) {
        return t2 in this.socialConfig.userConfig;
      }
      getConfiguredPlatforms() {
        return Object.keys(this.socialConfig.userConfig);
      }
      getProcessedSocialLinks() {
        const t2 = [];
        for (const [e2, r2] of Object.entries(this.socialConfig.userConfig)) {
          const s2 = this.getPlatformTemplate(e2);
          s2 ? t2.push({ id: e2, title: s2.title, url: r2.link }) : t2.push({ id: e2, title: e2.charAt(0).toUpperCase() + e2.slice(1), url: r2.link });
        }
        return t2;
      }
      getSocialLink(t2) {
        const e2 = this.socialConfig.userConfig[t2];
        if (!e2)
          return;
        const r2 = this.getPlatformTemplate(t2);
        return r2 ? { id: t2, title: r2.title, url: e2.link } : { id: t2, title: t2.charAt(0).toUpperCase() + t2.slice(1), url: e2.link };
      }
      hasSocialLinks() {
        return Object.keys(this.socialConfig.userConfig).length > 0;
      }
      getSocialLinkCount() {
        return Object.keys(this.socialConfig.userConfig).length;
      }
      getAvailablePlatforms() {
        return this.socialConfig.platformTemplates.map((t2) => t2.id);
      }
      getSocialConfig() {
        return this.socialConfig;
      }
    };
    var ot = p(require("path"));
    var ht = "public";
    var ct = class {
      constructor(t2, e2, r2 = ht) {
        __publicField(this, "workingDir");
        __publicField(this, "themesDir");
        __publicField(this, "publishDir");
        this.workingDir = t2, this.themesDir = e2, this.publishDir = r2;
      }
      getWorkingDir() {
        return ot.default.resolve(this.workingDir);
      }
      getThemesDir() {
        return ot.default.resolve(this.themesDir);
      }
      getThemesCacheDir() {
        return ot.default.resolve(this.themesDir, ".cache");
      }
      getPublishDir() {
        return ot.default.resolve(this.publishDir);
      }
    };
    var ut = class {
      constructor(t2 = {}) {
        __publicField(this, "root");
        __publicField(this, "keyCache");
        this.root = this.prepareParams(t2), this.keyCache = /* @__PURE__ */ new Map();
      }
      prepareParams(t2) {
        const e2 = {};
        for (const [r2, s2] of Object.entries(t2))
          e2[r2.toLowerCase()] = s2;
        return e2;
      }
      getNestedKeyAndMap(t2, e2) {
        let r2;
        this.keyCache.has(t2) ? r2 = this.keyCache.get(t2) : (r2 = t2.split("."), this.keyCache.set(t2, r2));
        let s2 = this.root;
        for (let t3 = 0; t3 < r2.length - 1; t3++) {
          const n3 = r2[t3];
          if (!(n3 in s2)) {
            if (!e2)
              return ["", null];
            s2[n3] = {};
          }
          const i2 = s2[n3];
          if (typeof i2 != "object" || i2 === null)
            return ["", null];
          s2 = i2;
        }
        return [r2[r2.length - 1], s2];
      }
      getString(t2) {
        const e2 = this.get(t2);
        return String(e2 || "");
      }
      getInt(t2) {
        const e2 = this.get(t2), r2 = Number(e2);
        return isNaN(r2) ? 0 : Math.floor(r2);
      }
      getBool(t2) {
        const e2 = this.get(t2);
        return typeof e2 == "boolean" ? e2 : typeof e2 == "string" ? e2.toLowerCase() === "true" : Boolean(e2);
      }
      getParams(t2) {
        const e2 = this.get(t2);
        return e2 && typeof e2 == "object" ? e2 : {};
      }
      getStringMap(t2) {
        const e2 = this.get(t2);
        return e2 && typeof e2 == "object" ? e2 : {};
      }
      getStringMapString(t2) {
        const e2 = this.get(t2);
        if (e2 && typeof e2 == "object") {
          const t3 = {};
          for (const [r2, s2] of Object.entries(e2))
            t3[r2] = String(s2);
          return t3;
        }
        return {};
      }
      getStringSlice(t2) {
        const e2 = this.get(t2);
        return Array.isArray(e2) ? e2.map((t3) => String(t3)) : [];
      }
      get(t2) {
        if (t2 === "")
          return this.root;
        const [e2, r2] = this.getNestedKeyAndMap(t2.toLowerCase(), false);
        return r2 !== null ? r2[e2] : void 0;
      }
      set(t2, e2) {
        const r2 = t2.toLowerCase();
        if (r2 === "")
          return void (e2 && typeof e2 == "object" ? Object.assign(this.root, this.prepareParams(e2)) : this.root[r2] = e2);
        const [s2, n3] = this.getNestedKeyAndMap(r2, true);
        n3 !== null && (s2 in n3 && typeof n3[s2] == "object" && typeof e2 == "object" && e2 !== null ? Object.assign(n3[s2], e2) : n3[s2] = e2);
      }
      keys() {
        return Object.keys(this.root);
      }
      merge(t2, e2) {
        const r2 = t2.toLowerCase();
        if (r2 === "")
          return void (e2 && typeof e2 == "object" && Object.assign(this.root, this.prepareParams(e2)));
        const [s2, n3] = this.getNestedKeyAndMap(r2, true);
        n3 !== null && (s2 in n3 && typeof n3[s2] == "object" && typeof e2 == "object" && e2 !== null ? Object.assign(n3[s2], e2) : n3[s2] = e2);
      }
      setDefaults(t2) {
        const e2 = this.prepareParams(t2);
        for (const [t3, r2] of Object.entries(e2))
          t3 in this.root || (this.root[t3] = r2);
      }
      setDefaultMergeStrategy() {
      }
      walkParams(t2) {
        const e2 = (r2) => {
          if (r2 && typeof r2 == "object" && !Array.isArray(r2)) {
            if (t2(r2))
              return true;
            for (const t3 of Object.values(r2))
              if (e2(t3))
                return true;
          }
          return false;
        };
        e2(this.root);
      }
      isSet(t2) {
        const [e2, r2] = this.getNestedKeyAndMap(t2.toLowerCase(), false);
        return r2 !== null && e2 in r2;
      }
    };
    var lt = p(require("path"));
    var ft = class {
      constructor(t2, e2) {
        __publicField(this, "cfg");
        __publicField(this, "sourceDescriptor");
        __publicField(this, "baseDirs");
        this.cfg = new ut(), this.sourceDescriptor = t2, this.baseDirs = e2;
      }
      async loadConfigByDefault() {
        const t2 = this.sourceDescriptor.filename();
        if (await this.loadProvider(t2), this.applyDefaultConfig(), this.cfg.setDefaultMergeStrategy(), !this.cfg.isSet("languages")) {
          const t3 = this.cfg.getString("defaultContentLanguage");
          this.cfg.set("languages", { [t3]: {} });
        }
        return this.cfg;
      }
      deleteMergeStrategies() {
        this.cfg.walkParams((t2) => false);
      }
      async loadProvider(t2) {
        const e2 = this.baseDirs.workingDir;
        let r2;
        r2 = lt.isAbsolute(t2) ? t2 : lt.join(e2, t2);
        let s2 = "";
        if (lt.extname(t2) !== "" && await this.fileExists(r2) && (s2 = r2), s2 === "")
          throw new Error("Unable to locate config file or config directory.");
        const n3 = await this.loadConfigFromFile(s2);
        this.cfg.set("", n3);
      }
      applyDefaultConfig() {
        this.cfg.setDefaults({ baseURL: "", cleanDestinationDir: false, watch: false, contentDir: "content", resourceDir: "resources", publishDir: "public", publishDirOrig: "public", themesDir: "themes", assetDir: "assets", layoutDir: "layouts", i18nDir: "i18n", dataDir: "data", archetypeDir: "archetypes", configDir: "config", staticDir: "static", buildDrafts: false, buildFuture: false, buildExpired: false, params: {}, environment: "production", uglyURLs: false, verbose: false, ignoreCache: false, canonifyURLs: false, relativeURLs: false, removePathAccents: false, titleCaseStyle: "AP", taxonomies: { tag: "tags", category: "categories" }, permalinks: {}, sitemap: { priority: -1, filename: "sitemap.xml" }, menus: {}, disableLiveReload: false, pluralizeListTitles: true, capitalizeListTitles: true, forceSyncStatic: false, footnoteAnchorPrefix: "", footnoteReturnLinkContents: "", newContentEditor: "", paginate: 10, paginatePath: "page", summaryLength: 70, rssLimit: -1, sectionPagesMenu: "", disablePathToLower: false, hasCJKLanguage: false, enableEmoji: false, defaultContentLanguage: "en", defaultContentLanguageInSubdir: false, enableMissingTranslationPlaceholders: false, enableGitInfo: false, ignoreFiles: [], disableAliases: false, debug: false, disableFastRender: false, timeout: "30s", timeZone: "", enableInlineShortcodes: false });
      }
      async fileExists(t2) {
        try {
          const e2 = this.sourceDescriptor.fs();
          return !(await e2.stat(t2)).isDir();
        } catch {
          return false;
        }
      }
      async loadConfigFromFile(t2) {
        const e2 = this.sourceDescriptor.fs(), r2 = await e2.open(t2);
        try {
          const t3 = new Uint8Array(1048576), { bytesRead: e3 } = await r2.read(t3), s2 = new TextDecoder().decode(t3.slice(0, e3));
          try {
            return JSON.parse(s2);
          } catch {
            return {};
          }
        } finally {
          await r2.close();
        }
      }
    };
    var wt = class {
      constructor(t2, e2) {
        __publicField(this, "fileSystem");
        __publicField(this, "configFilename");
        this.fileSystem = t2, this.configFilename = e2;
      }
      fs() {
        return this.fileSystem;
      }
      filename() {
        return this.configFilename;
      }
    };
    var dt = p(require("path"));
    var gt = "content";
    var pt = ["workflows", "prompts", gt, "layouts", "static", "assets", "i18n"];
    var mt = class extends Error {
      constructor(t2, e2) {
        super(t2), this.code = e2, this.name = "ModuleError";
      }
    };
    var yt = (new mt("module not found", "MODULE_NOT_FOUND"), new mt("download failed", "DOWNLOAD_FAILED"), new mt("invalid zip file", "INVALID_ZIP"), new mt("mount failed", "MOUNT_FAILED"), p(require("path")));
    var bt = class t2 {
      constructor(t3, e2, r2 = "") {
        this.sourcePath = t3, this.targetPath = e2, this.language = r2;
      }
      source() {
        return this.sourcePath;
      }
      target() {
        return this.targetPath;
      }
      lang() {
        return this.language;
      }
      setLanguage(t3) {
        this.language = t3;
      }
      component() {
        return this.targetPath.split(yt.sep)[0] || "";
      }
      componentAndName() {
        const t3 = this.targetPath.split(yt.sep);
        return { component: t3[0] || "", name: t3.slice(1).join(yt.sep) };
      }
      copy() {
        return new t2(this.sourcePath, this.targetPath, this.language);
      }
      equals(t3) {
        return this.sourcePath === t3.sourcePath && this.targetPath === t3.targetPath && this.language === t3.language;
      }
      toConfig() {
        const t3 = { sourcePath: this.sourcePath, targetPath: this.targetPath };
        return this.language && (t3.language = this.language), t3;
      }
      toString() {
        return `${this.sourcePath} -> ${this.targetPath} (${this.language})`;
      }
    };
    var Et = p(require("path"));
    var St = p(require("http"));
    var vt = p(require("https"));
    q();
    var Tt = A("module", { component: "httpclient" });
    var xt = class {
      constructor(t2, e2 = 3e4, r2 = {}) {
        __publicField(this, "defaultTimeout", 3e4);
        __publicField(this, "defaultHeaders", { "User-Agent": "MDFriday-CLI/1.0.0" });
        this.fs = t2, this.timeout = e2, this.headers = r2;
      }
      async download(t2, e2, r2) {
        return new Promise((s2, n3) => {
          try {
            const i2 = new URL(t2), a2 = i2.protocol === "https:", o2 = a2 ? vt : St, h2 = { ...this.defaultHeaders, ...this.headers, ...r2?.headers }, c2 = { hostname: i2.hostname, port: i2.port || (a2 ? 443 : 80), path: i2.pathname + i2.search, method: "GET", headers: h2, timeout: r2?.timeout || this.timeout }, u2 = o2.request(c2, async (t3) => {
              if (!t3.statusCode || t3.statusCode < 200 || t3.statusCode >= 300)
                return void n3(new mt(`HTTP ${t3.statusCode}: ${t3.statusMessage}`, "HTTP_ERROR"));
              const i3 = parseInt(t3.headers["content-length"] || "0", 10);
              let a3 = 0, o3 = Date.now(), h3 = -1;
              try {
                const c3 = Et.dirname(e2);
                await this.fs.mkdirAll(c3, 493);
                const u3 = await this.fs.create(e2), l2 = [];
                t3.on("data", (t4) => {
                  if (l2.push(t4), a3 += t4.length, r2?.onProgress && i3 > 0) {
                    const t5 = Date.now(), e3 = Math.round(a3 / i3 * 100);
                    if (t5 - o3 >= 100 && e3 !== h3 || e3 - h3 >= 5) {
                      const s3 = { loaded: a3, total: i3, percentage: e3 };
                      try {
                        r2.onProgress(s3), h3 = e3;
                      } catch (t6) {
                        Tt.error(`Progress callback error: ${t6}`);
                      }
                      o3 = t5;
                    }
                  }
                }), t3.on("end", async () => {
                  try {
                    const t4 = Buffer.concat(l2), e3 = new Uint8Array(t4);
                    if (await u3.write(e3), await u3.sync(), await u3.close(), r2?.onProgress && i3 > 0) {
                      const t5 = { loaded: i3, total: i3, percentage: 100 };
                      try {
                        r2.onProgress(t5);
                      } catch (t6) {
                        Tt.warn(`Progress callback error: ${t6}`);
                      }
                    }
                    s2();
                  } catch (t4) {
                    const e3 = t4 instanceof Error ? t4.message : String(t4);
                    n3(new mt(`File write failed: ${e3}`, "WRITE_FAILED"));
                  }
                }), t3.on("error", (t4) => {
                  Tt.error(`Response error: ${t4.message}`), n3(new mt(`Download failed: ${t4.message}`, "DOWNLOAD_FAILED"));
                });
              } catch (t4) {
                const e3 = t4 instanceof Error ? t4.message : String(t4);
                n3(new mt(`File system error: ${e3}`, "FS_ERROR"));
              }
            });
            u2.on("error", (t3) => {
              Tt.error("Request error:", t3), n3(new mt(`Request failed: ${t3.message}`, "REQUEST_FAILED"));
            }), u2.on("timeout", () => {
              u2.destroy(), Tt.error(`Request timeout for ${t2}`), n3(new mt("Request timeout", "TIMEOUT"));
            }), u2.end();
          } catch (t3) {
            const e3 = t3 instanceof Error ? t3.message : String(t3);
            n3(new mt(`Download failed: ${e3}`, "DOWNLOAD_FAILED"));
          }
        });
      }
      async get(t2, e2) {
        return new Promise((r2, s2) => {
          try {
            const n3 = new URL(t2), i2 = n3.protocol === "https:", a2 = i2 ? vt : St, o2 = { ...this.defaultHeaders, ...this.headers, ...e2?.headers }, h2 = { hostname: n3.hostname, port: n3.port || (i2 ? 443 : 80), path: n3.pathname + n3.search, method: "GET", headers: o2, timeout: e2?.timeout || this.timeout }, c2 = a2.request(h2, (t3) => {
              const e3 = [], n4 = {};
              Object.entries(t3.headers).forEach(([t4, e4]) => {
                n4[t4] = Array.isArray(e4) ? e4.join(", ") : e4 || "";
              }), t3.on("data", (t4) => {
                e3.push(t4);
              }), t3.on("end", () => {
                const s3 = Buffer.concat(e3), i3 = s3.buffer.slice(s3.byteOffset, s3.byteOffset + s3.byteLength);
                r2({ data: i3, headers: n4, status: t3.statusCode || 0 });
              }), t3.on("error", (t4) => {
                s2(new mt(`Response error: ${t4.message}`, "RESPONSE_ERROR"));
              });
            });
            c2.on("error", (t3) => {
              s2(new mt(`GET request failed: ${t3.message}`, "REQUEST_FAILED"));
            }), c2.on("timeout", () => {
              c2.destroy(), s2(new mt("GET request timeout", "TIMEOUT"));
            }), c2.end();
          } catch (t3) {
            const e3 = t3 instanceof Error ? t3.message : String(t3);
            s2(new mt(`GET request failed: ${e3}`, "REQUEST_FAILED"));
          }
        });
      }
    };
    function Pt(t2, e2, r2, s2) {
      return s2 || new xt(t2, e2, r2);
    }
    q();
    var $t = p(require_jszip_min());
    var Rt = p(require("path"));
    var Lt = A("module", { component: "zipextractor" });
    var Nt = class {
      constructor(t2) {
        this.fs = t2;
      }
      async extract(t2, e2) {
        try {
          const r2 = await this.fs.open(t2), s2 = (await r2.stat()).size(), n3 = new Uint8Array(s2), i2 = await r2.read(n3);
          await r2.close(), await this.extractZipData(i2.buffer, e2);
        } catch (e3) {
          const r2 = e3 instanceof Error ? e3.message : String(e3);
          throw Lt.error(`ZIP extraction failed for ${t2}: ${r2}`), new mt(`ZIP extraction failed: ${r2}`, "EXTRACTION_FAILED");
        }
      }
      async list(t2) {
        try {
          const e2 = await this.fs.open(t2), r2 = await e2.stat(), s2 = new Uint8Array(r2.size()), n3 = await e2.read(s2);
          return await e2.close(), await this.listZipContents(n3.buffer);
        } catch (t3) {
          const e2 = t3 instanceof Error ? t3.message : String(t3);
          throw new mt(`ZIP listing failed: ${e2}`, "LIST_FAILED");
        }
      }
      async extractZipData(t2, e2) {
        try {
          await this.fs.mkdirAll(e2, 493);
          const r2 = new $t.default(), s2 = await r2.loadAsync(t2), n3 = [];
          s2.forEach((t3, e3) => {
            e3.dir || n3.push(t3);
          });
          const i2 = [];
          let a2 = 0;
          s2.forEach((t3, r3) => {
            i2.push(this.extractSingleEntry(t3, r3, e2).then(() => {
              a2++;
            }));
          }), await Promise.all(i2);
        } catch (t3) {
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw Lt.error(`Failed to extract ZIP data: ${e3}`), new mt(`Failed to extract ZIP data: ${e3}`, "EXTRACTION_FAILED");
        }
      }
      async extractSingleEntry(t2, e2, r2) {
        const s2 = Rt.join(r2, t2);
        if (e2.dir)
          await this.fs.mkdirAll(s2, 493);
        else {
          const t3 = Rt.dirname(s2);
          t3 !== r2 && await this.fs.mkdirAll(t3, 493);
          const n3 = await e2.async("uint8array"), i2 = await this.fs.create(s2);
          await i2.write(n3), await i2.close();
        }
      }
      async listZipContents(t2) {
        try {
          const e2 = new $t.default(), r2 = await e2.loadAsync(t2), s2 = [];
          return r2.forEach((t3) => {
            s2.push(t3);
          }), s2;
        } catch (t3) {
          const e2 = t3 instanceof Error ? t3.message : String(t3);
          throw new mt(`Failed to list ZIP contents: ${e2}`, "LIST_FAILED");
        }
      }
    };
    var Ft = class {
      constructor(t2) {
        this.fs = t2;
      }
      async extract(t2, e2) {
        try {
          throw new mt("Web ZIP extraction not implemented", "NOT_IMPLEMENTED");
        } catch (t3) {
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new mt(`Web ZIP extraction failed: ${e3}`, "WEB_EXTRACTION_FAILED");
        }
      }
      async list(t2) {
        try {
          throw new mt("Web ZIP listing not implemented", "NOT_IMPLEMENTED");
        } catch (t3) {
          const e2 = t3 instanceof Error ? t3.message : String(t3);
          throw new mt(`Web ZIP listing failed: ${e2}`, "WEB_LIST_FAILED");
        }
      }
    };
    function Dt(t2, e2 = "node") {
      switch (e2) {
        case "node":
          return new Nt(t2);
        case "browser":
          return new Ft(t2);
        default:
          throw new Error(`Unsupported environment: ${e2}`);
      }
    }
    q();
    var At = p(require("path"));
    var kt = A("module", { component: "cache" });
    var It = class {
      constructor(t2, e2 = "./module/cache") {
        __publicField(this, "cacheDir");
        this.fs = t2, this.cacheDir = e2;
      }
      async get(t2) {
        try {
          const e2 = this.getCacheFilePath(t2), r2 = await this.fs.open(e2), s2 = await r2.stat(), n3 = new Uint8Array(s2.size());
          await r2.read(n3), await r2.close();
          const i2 = new TextDecoder().decode(n3);
          return JSON.parse(i2);
        } catch (e2) {
          if (e2.message?.includes("ENOENT") || e2.message?.includes("no such file"))
            return kt.error(`Cache miss: ${t2}`, e2), null;
          const r2 = e2 instanceof Error ? e2.message : String(e2);
          throw kt.error(`Cache read error for ${t2}: ${r2}`), new mt(`Failed to read cache: ${r2}`, "CACHE_READ_FAILED");
        }
      }
      async set(t2, e2) {
        try {
          await this.fs.mkdirAll(this.cacheDir, 493);
          const r2 = this.getCacheFilePath(t2), s2 = JSON.stringify(e2, null, 2), n3 = new TextEncoder().encode(s2), i2 = await this.fs.create(r2);
          await i2.write(n3), await i2.sync(), await i2.close();
        } catch (e3) {
          const r2 = e3 instanceof Error ? e3.message : String(e3);
          throw kt.error(`Cache write error for ${t2}: ${r2}`), new mt(`Failed to write cache: ${r2}`, "CACHE_WRITE_FAILED");
        }
      }
      async has(t2) {
        try {
          const e2 = this.getCacheFilePath(t2);
          return await this.fs.stat(e2), true;
        } catch (t3) {
          return false;
        }
      }
      async delete(t2) {
        try {
          const e2 = this.getCacheFilePath(t2);
          await this.fs.remove(e2);
        } catch (e2) {
          if (!e2.message?.includes("ENOENT") && !e2.message?.includes("no such file")) {
            const r2 = e2 instanceof Error ? e2.message : String(e2);
            throw kt.error(`Cache delete error for ${t2}: ${r2}`), new mt(`Failed to delete cache: ${r2}`, "CACHE_DELETE_FAILED");
          }
        }
      }
      async clear() {
        try {
          await this.fs.removeAll(this.cacheDir);
        } catch (t2) {
          if (!t2.message?.includes("ENOENT") && !t2.message?.includes("no such file")) {
            const e2 = t2 instanceof Error ? t2.message : String(t2);
            throw kt.error(`Cache clear error: ${e2}`), new mt(`Failed to clear cache: ${e2}`, "CACHE_CLEAR_FAILED");
          }
        }
      }
      getCacheFilePath(t2) {
        const e2 = t2.replace(/[/\\:*?"<>|]/g, "_").replace(/^_+|_+$/g, "") + ".json";
        return At.join(this.cacheDir, e2);
      }
      getCacheDir() {
        return this.cacheDir;
      }
      async getStats() {
        try {
          const t2 = await this.listCacheFiles();
          let e2 = 0;
          for (const r2 of t2)
            try {
              const t3 = At.join(this.cacheDir, r2);
              e2 += (await this.fs.stat(t3)).size();
            } catch (t3) {
            }
          return { totalEntries: t2.length, totalSize: e2 };
        } catch (t2) {
          return { totalEntries: 0, totalSize: 0 };
        }
      }
      async listCached() {
        try {
          return (await this.listCacheFiles()).map((t2) => At.basename(t2, ".json").replace(/_/g, "/"));
        } catch (t2) {
          return [];
        }
      }
      async listCacheFiles() {
        try {
          const t2 = await this.fs.open(this.cacheDir), e2 = await t2.readdirnames(-1);
          return await t2.close(), e2.filter((t3) => t3.endsWith(".json"));
        } catch (t2) {
          return [];
        }
      }
    };
    function Ct(t2, e2) {
      return new It(t2, e2);
    }
    var Ot = p(require("path"));
    var _t = class t2 {
      constructor(t3, e2, r2, s2 = null, n3 = false) {
        __publicField(this, "absoluteDir");
        __publicField(this, "modulePath");
        __publicField(this, "parentModule");
        __publicField(this, "mountDirs");
        __publicField(this, "metadata");
        __publicField(this, "isProject", false);
        this.fs = t3, this.absoluteDir = e2, this.modulePath = r2, this.parentModule = s2, this.mountDirs = [], this.metadata = null, this.isProject = n3;
      }
      isProjectModule() {
        return this.isProject;
      }
      owner() {
        return this.parentModule;
      }
      mounts() {
        return this.mountDirs.map((t3) => t3);
      }
      dir() {
        return this.absoluteDir;
      }
      path() {
        return this.modulePath;
      }
      setMetadata(t3) {
        this.metadata = t3;
      }
      getMetadata() {
        return this.metadata;
      }
      async applyMounts(t3) {
        try {
          let e2 = t3.mounts || [];
          if (e2.length === 0)
            for (const t4 of pt) {
              const r2 = Ot.join(this.absoluteDir, t4);
              try {
                (await this.fs.stat(r2)).isDir() && e2.push({ sourcePath: t4, targetPath: t4 });
              } catch (t5) {
              }
            }
          this.mountDirs = e2.map((t4) => {
            return e3 = t4.sourcePath, r2 = t4.targetPath, new bt(e3, r2);
            var e3, r2;
          });
        } catch (t4) {
          const e2 = t4 instanceof Error ? t4.message : String(t4);
          throw new mt(`Failed to apply mounts: ${e2}`, "MOUNT_FAILED");
        }
      }
      appendMount(t3) {
        this.mountDirs.push(t3);
      }
      removeMount(t3) {
        const e2 = this.mountDirs.findIndex((e3) => e3.equals(t3));
        return e2 >= 0 && (this.mountDirs.splice(e2, 1), true);
      }
      getMountByTarget(t3) {
        return this.mountDirs.find((e2) => e2.target() === t3) || null;
      }
      getMountsByComponent(t3) {
        return this.mountDirs.filter((e2) => e2.component() === t3);
      }
      isDownloaded() {
        return this.metadata?.downloadStatus === "completed";
      }
      isDownloading() {
        return this.metadata?.downloadStatus === "downloading";
      }
      isDownloadFailed() {
        return this.metadata?.downloadStatus === "failed";
      }
      async exists() {
        try {
          return (await this.fs.stat(this.absoluteDir)).isDir();
        } catch (t3) {
          return false;
        }
      }
      copy() {
        const e2 = new t2(this.fs, this.absoluteDir, this.modulePath, this.parentModule, this.isProject);
        return e2.mountDirs = this.mountDirs.map((t3) => t3.copy()), e2.metadata = this.metadata ? { ...this.metadata } : null, e2;
      }
      toString() {
        return `Module{path: ${this.modulePath}, dir: ${this.absoluteDir}, mounts: ${this.mountDirs.length}}`;
      }
    };
    var Mt = class {
      constructor(t2) {
        this.module = t2;
      }
      getModule() {
        return this.module;
      }
      appendMount(t2) {
        this.module.appendMount(t2);
      }
      setDefaultLanguage(t2) {
        const e2 = this.module.mounts();
        for (const r2 of e2)
          r2 instanceof bt && r2.setLanguage(t2);
      }
      applyDefaultMounts() {
        const t2 = pt.map((t3) => new bt(t3, t3));
        for (const e2 of t2)
          this.module.appendMount(e2);
      }
      owner() {
        return this.module.owner();
      }
      mounts() {
        return this.module.mounts();
      }
      dir() {
        return this.module.dir();
      }
      path() {
        return this.module.path();
      }
    };
    function Ut(t2, e2, r2, s2) {
      return new _t(t2, e2, r2, s2 || null, false);
    }
    var jt = p(require("path"));
    var Bt = class {
      constructor(t2) {
        __publicField(this, "sourceLangMap");
        this.sourceLangMap = /* @__PURE__ */ new Map();
        for (const e2 of t2)
          for (const t3 of e2.mounts())
            this.sourceLangMap.set(t3.source(), t3.lang());
      }
      getSourceLang(t2) {
        const e2 = this.sourceLangMap.get(jt.default.basename(t2));
        return e2 !== void 0 ? [e2, true] : ["", false];
      }
    };
    var qt = class t2 {
      constructor(t3) {
        __publicField(this, "themes");
        this.themes = t3;
      }
      static fromJson(e2) {
        return new t2(e2);
      }
      findThemeByUrl(t3) {
        const e2 = this.extractBaseUrl(t3);
        for (const t4 of this.themes)
          if (e2 === this.extractBaseUrl(t4.download_url))
            return t4;
        return null;
      }
      resolveLatestVersion(t3) {
        const e2 = this.findThemeByUrl(t3);
        return e2 ? e2.download_url : t3;
      }
      extractBaseUrl(t3) {
        try {
          const e2 = new URL(t3);
          return e2.searchParams.delete("version"), e2.toString();
        } catch (e2) {
          const r2 = t3.indexOf("?");
          if (r2 === -1)
            return t3;
          const s2 = t3.substring(0, r2), n3 = new URLSearchParams(t3.substring(r2 + 1));
          n3.delete("version");
          const i2 = n3.toString();
          return i2 ? `${s2}?${i2}` : s2;
        }
      }
      getAllThemes() {
        return [...this.themes];
      }
      getThemeByName(t3) {
        return this.themes.find((e2) => e2.name.toLowerCase() === t3.toLowerCase()) || null;
      }
      getThemesByTag(t3) {
        return this.themes.filter((e2) => e2.tags.some((e3) => e3.toLowerCase() === t3.toLowerCase()));
      }
    };
    q();
    var Wt = require_dist();
    var zt = p(require("path"));
    var Ht = A("module", { component: "modules" });
    var Gt = class {
      constructor(t2, e2, r2, s2) {
        __publicField(this, "projectModule");
        __publicField(this, "modules", []);
        __publicField(this, "downloadedModules", /* @__PURE__ */ new Set());
        __publicField(this, "lang");
        __publicField(this, "themesCache", /* @__PURE__ */ new Map());
        var n3;
        this.info = t2, this.httpClient = e2, this.zipExtractor = r2, this.moduleCache = s2, this.projectModule = function(t3) {
          const e3 = t3.osFs(), r3 = t3.projDir(), s3 = t3.defaultLanguageKey(), n4 = new _t(e3, r3, "project-root", null, true), i2 = new Mt(n4);
          i2.applyDefaultMounts(), s3 && i2.setDefaultLanguage(s3);
          const a2 = t3.otherLanguageKeys();
          for (const e4 of a2)
            try {
              const r4 = t3.getRelDir(gt, e4);
              if (r4 && r4 !== "") {
                const t4 = new bt(r4, gt, e4);
                i2.appendMount(t4);
              }
            } catch (t4) {
              console.warn(`Failed to get relative directory for language ${e4}:`, t4);
            }
          return i2;
        }(this.info), this.lang = (n3 = this.all(), new Bt(n3));
      }
      proj() {
        return this.projectModule.getModule();
      }
      all() {
        const t2 = [this.projectModule.getModule()];
        return t2.push(...this.modules), t2;
      }
      isProjMod(t2) {
        return t2 === this.projectModule.getModule();
      }
      async load(t2) {
        const e2 = this.info.importPaths();
        if (e2.length !== 0)
          for (let r2 = 0; r2 < e2.length; r2++) {
            const s2 = e2[r2], { cleanUrl: n3, version: i2 } = this.parseVersionFromImportPath(s2);
            let a2 = s2;
            i2 === "latest" && (a2 = await this.resolveLatestVersion(s2)), this.downloadedModules.has(a2) ? Ht.info(`Module already downloaded: ${a2}`) : await this.addModule(this.projectModule.getModule(), a2, (e3) => {
              t2?.({ modulePath: a2, downloadPercentage: e3.percentage });
            });
          }
        else
          Ht.warn("No import paths configured - no modules will be downloaded");
      }
      parseVersionFromImportPath(t2) {
        try {
          const e2 = new URL(t2), r2 = e2.searchParams.get("version") || "latest";
          return e2.searchParams.delete("version"), { cleanUrl: e2.toString(), version: r2 };
        } catch (e2) {
          return Ht.warn(`Failed to parse import path ${t2}:`, e2), { cleanUrl: t2, version: "latest" };
        }
      }
      getThemeRegistryUrl(t2) {
        try {
          const e2 = new URL(t2).hostname;
          return e2 === "sunwei.xyz" || e2 === "www.sunwei.xyz" ? "https://sunwei.xyz/mdf/themes-zh.json" : "https://gohugo.net/themes.json";
        } catch (e2) {
          return Ht.warn(`Failed to parse import path ${t2}, using default theme registry`), "https://gohugo.net/themes.json";
        }
      }
      async resolveLatestVersion(t2) {
        const { version: e2 } = this.parseVersionFromImportPath(t2);
        if (e2 !== "latest")
          return t2;
        try {
          const e3 = this.getThemeRegistryUrl(t2);
          Ht.info(`Fetching latest theme versions from ${e3}...`);
          let r2 = this.themesCache.get(e3);
          if (!r2) {
            const t3 = await this.httpClient.get(e3), s3 = new TextDecoder().decode(t3.data), n3 = JSON.parse(s3);
            r2 = qt.fromJson(n3), this.themesCache.set(e3, r2);
          }
          const s2 = r2.resolveLatestVersion(t2);
          return s2 !== t2 ? Ht.info(`Resolved latest version: ${t2} -> ${s2}`) : Ht.warn(`Could not resolve latest version for ${t2}, using original path`), s2;
        } catch (e3) {
          return Ht.error(`Failed to resolve latest version for ${t2}:`, e3), t2;
        }
      }
      async downloadModule(t2, e2) {
        try {
          let r2 = t2.version;
          if (t2.version === "latest") {
            const e3 = await this.resolveLatestVersion(t2.path), { version: s3 } = this.parseVersionFromImportPath(e3);
            r2 = s3;
          }
          const s2 = await this.moduleCache.get(t2.path);
          if (s2 && s2.downloadStatus === "completed" && this.isCacheValidForVersion(s2.version, r2)) {
            const e3 = await this.createModuleFromCache(t2, s2);
            if (await e3.exists())
              return Ht.info(`Using cached module ${t2.path} version ${s2.version}`), e3;
          }
          s2 && s2.downloadStatus === "completed" && !this.isCacheValidForVersion(s2.version, r2) && Ht.info(`Cache version mismatch for ${t2.path}: cached=${s2.version}, requested=${r2 || "latest"}`);
          const n3 = this.getModuleDir(t2.path), i2 = zt.join(n3, "module.zip"), a2 = { path: t2.path, version: t2.version || "latest", url: t2.url, dir: n3, downloadStatus: "downloading", downloadedAt: new Date() };
          await this.moduleCache.set(t2.path, a2);
          try {
            const r3 = this.addTimestampToUrl(t2.url);
            await this.httpClient.download(r3, i2, { onProgress: (t3) => {
              e2?.({ percentage: t3.percentage });
            } }), await this.zipExtractor.extract(i2, n3), a2.downloadStatus = "completed", a2.downloadedAt = new Date();
            try {
              const t3 = await this.info.osFs().stat(i2);
              a2.size = t3.size();
            } catch (t3) {
            }
            try {
              await this.info.osFs().remove(i2);
            } catch (t3) {
            }
            await this.moduleCache.set(t2.path, a2);
            const s3 = Ut(this.info.osFs(), n3, t2.path);
            return s3.setMetadata(a2), await s3.applyMounts(t2), s3;
          } catch (e3) {
            a2.downloadStatus = "failed", await this.moduleCache.set(t2.path, a2);
            const r3 = e3 instanceof Error ? e3.message : String(e3);
            throw new mt(`Failed to download module ${t2.path}: ${r3}`, "DOWNLOAD_FAILED");
          }
        } catch (t3) {
          if (t3 instanceof mt)
            throw t3;
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new mt(`Module download failed: ${e3}`, "DOWNLOAD_FAILED");
        }
      }
      async addModule(t2, e2, r2) {
        try {
          if (this.downloadedModules.has(e2))
            return;
          const { cleanUrl: t3, version: s2 } = this.parseVersionFromImportPath(e2), n3 = { path: e2, url: this.getDownloadUrl(t3), ...s2 && { version: s2 } }, i2 = await this.downloadModule(n3, r2);
          this.modules.push(i2), this.downloadedModules.add(e2);
          try {
            const t4 = await this.parseThemeToml(i2);
            for (const e3 of t4) {
              if (this.downloadedModules.has(e3)) {
                Ht.info(`Module ${e3} already downloaded, skipping`);
                continue;
              }
              Ht.info(`Recursively downloading module dependency: ${e3}`);
              const t5 = e3, { cleanUrl: s3, version: n4 } = this.parseVersionFromImportPath(t5);
              let a2 = t5;
              n4 === "latest" && (a2 = await this.resolveLatestVersion(t5)), await this.addModule(i2, a2, (t6) => {
                r2?.({ percentage: 0.5 * t6.percentage });
              });
            }
          } catch (t4) {
            const r3 = t4 instanceof Error ? t4.message : String(t4);
            Ht.warn(`Failed to process recursive imports for module ${e2}: ${r3}`);
          }
        } catch (t3) {
          const r3 = t3 instanceof Error ? t3.message : String(t3);
          throw new mt(`Failed to add module ${e2}: ${r3}`, "ADD_MODULE_FAILED");
        }
      }
      async createModuleFromCache(t2, e2) {
        const r2 = Ut(this.info.osFs(), e2.dir, t2.path);
        return r2.setMetadata(e2), await r2.applyMounts(t2), r2;
      }
      getModuleDir(t2) {
        const e2 = t2.replace(/[/\\:*?"<>|]/g, "_").replace(/^_+|_+$/g, "");
        return zt.join(this.info.moduleDir(), e2);
      }
      getDownloadUrl(t2) {
        return t2;
      }
      isCacheValidForVersion(t2, e2) {
        return !e2 || t2 === e2;
      }
      addTimestampToUrl(t2) {
        try {
          const e2 = new URL(t2), r2 = Date.now().toString();
          return e2.searchParams.set("_t", r2), e2.toString();
        } catch (e2) {
          const r2 = t2.includes("?") ? "&" : "?";
          return `${t2}${r2}_t=${Date.now()}`;
        }
      }
      getModuleByPath(t2) {
        return this.modules.find((e2) => e2.path() === t2) || null;
      }
      isModuleDownloaded(t2) {
        return this.downloadedModules.has(t2);
      }
      async getModuleStatus(t2) {
        const e2 = await this.moduleCache.get(t2);
        return e2?.downloadStatus || "pending";
      }
      async removeModule(t2) {
        try {
          const e2 = this.modules.findIndex((e3) => e3.path() === t2);
          if (e2 >= 0) {
            const r2 = this.modules[e2];
            try {
              await this.info.osFs().removeAll(r2.dir());
            } catch (t3) {
            }
            this.modules.splice(e2, 1), this.downloadedModules.delete(t2), await this.moduleCache.delete(t2);
          }
        } catch (e2) {
          const r2 = e2 instanceof Error ? e2.message : String(e2);
          throw new mt(`Failed to remove module ${t2}: ${r2}`, "REMOVE_MODULE_FAILED");
        }
      }
      async clearAll() {
        try {
          for (const t2 of this.modules)
            try {
              await this.info.osFs().removeAll(t2.dir());
            } catch (t3) {
            }
          this.modules = [], this.downloadedModules.clear(), await this.moduleCache.clear();
        } catch (t2) {
          const e2 = t2 instanceof Error ? t2.message : String(t2);
          throw new mt(`Failed to clear modules: ${e2}`, "CLEAR_MODULES_FAILED");
        }
      }
      getSourceLang(t2) {
        return this.lang.getSourceLang(t2);
      }
      async parseThemeToml(t2) {
        try {
          const e2 = zt.join(t2.dir(), "theme.toml");
          try {
            if ((await this.info.osFs().stat(e2)).isDir())
              return [];
          } catch (t3) {
            return [];
          }
          let r2;
          try {
            const t3 = await this.info.osFs().open(e2);
            try {
              const e3 = [], s3 = new Uint8Array(4096);
              for (; ; ) {
                const r3 = await t3.read(s3);
                if (r3.bytesRead === 0)
                  break;
                e3.push(s3.slice(0, r3.bytesRead));
              }
              const n3 = e3.reduce((t4, e4) => t4 + e4.length, 0), i2 = new Uint8Array(n3);
              let a2 = 0;
              for (const t4 of e3)
                i2.set(t4, a2), a2 += t4.length;
              r2 = new TextDecoder("utf-8").decode(i2);
            } finally {
              await t3.close();
            }
          } catch (e3) {
            const r3 = e3 instanceof Error ? e3.message : String(e3);
            return Ht.warn(`Failed to read theme.toml for module ${t2.path()}: ${r3}`), [];
          }
          const s2 = (0, Wt.parse)(r2);
          return s2.module?.imports ? (Ht.info(`Found ${s2.module.imports.length} module imports in ${t2.path()}/theme.toml`), s2.module.imports.map((t3) => t3.path)) : [];
        } catch (e2) {
          const r2 = e2 instanceof Error ? e2.message : String(e2);
          return Ht.warn(`Failed to parse theme.toml for module ${t2.path()}: ${r2}`), [];
        }
      }
    };
    function Vt(t2, e2, r2, s2) {
      return new Gt(t2, e2, r2, s2);
    }
    q();
    var Kt = A("module", { component: "factory" });
    var Jt = class extends Error {
      constructor(t2, e2) {
        super(t2), this.code = e2, this.name = "FsError";
      }
    };
    var Yt = new Jt("File is closed", "FILE_CLOSED");
    var Zt = (new Jt("out of range", "OUT_OF_RANGE"), new Jt("too large", "TOO_LARGE"), new Jt("file not found", "FILE_NOT_FOUND"));
    var Xt = (new Jt("file exists", "FILE_EXISTS"), new Jt("destination exists", "DESTINATION_EXISTS"), new Error("skip directory"));
    var Qt = (new Jt("walkway already walked", "ALREADY_WALKED"), class extends Jt {
      constructor(t2, e2) {
        super(t2, e2), this.name = "OverlayFsError";
      }
    });
    var te = new Qt("no filesystems to write to", "NO_FILESYSTEMS");
    var ee = (new Qt("operation not supported", "OPERATION_NOT_SUPPORTED"), class {
      constructor(t2, e2, r2) {
        __publicField(this, "source");
        __publicField(this, "origin");
        __publicField(this, "publishDir");
        this.source = t2, this.origin = e2, this.publishDir = r2;
      }
      getSource() {
        return this.source;
      }
      getOrigin() {
        return this.origin;
      }
      publish() {
        return this.publishDir;
      }
    });
    q(), A("fs", { component: "filemeta" });
    var re = class {
      constructor(t2 = "", e2 = null) {
        __publicField(this, "filename");
        __publicField(this, "componentRoot");
        __publicField(this, "componentDir");
        __publicField(this, "openFunc");
        this.filename = t2, this.componentRoot = "", this.componentDir = "", this.openFunc = e2;
      }
      fileName() {
        return this.filename;
      }
      relativeFilename() {
        if (this.componentRoot === "")
          return this.filename;
        const t2 = this.filename.indexOf(this.componentRoot);
        if (t2 === -1)
          throw new Error(`filename ${this.filename} has no root ${this.componentRoot}`);
        let e2 = this.filename.substring(t2 + this.componentRoot.length);
        return e2.startsWith("/") || (e2 = "/" + e2), e2;
      }
      component() {
        return this.componentDir;
      }
      root() {
        return this.componentRoot;
      }
      async open() {
        if (this.openFunc === null)
          throw new Error("OpenFunc not set");
        return await this.openFunc();
      }
      setFileName(t2) {
        this.filename = t2;
      }
      setComponentRoot(t2) {
        this.componentRoot = t2;
      }
      setComponentDir(t2) {
        this.componentDir = t2;
      }
      setOpenFunc(t2) {
        this.openFunc = t2;
      }
      merge(t2) {
        t2 && (t2.filename && !this.filename && (this.filename = t2.filename), t2.componentRoot && !this.componentRoot && (this.componentRoot = t2.componentRoot), t2.componentDir && !this.componentDir && (this.componentDir = t2.componentDir), t2.openFunc && !this.openFunc && (this.openFunc = t2.openFunc));
      }
    };
    function se(t2, e2) {
      return new re(t2, e2);
    }
    var ne = class {
      constructor(t2, e2) {
        __publicField(this, "fileInfo");
        __publicField(this, "i");
        this.fileInfo = t2, this.i = e2;
      }
      meta() {
        return this.i;
      }
      type() {
        return this.fileInfo.mode();
      }
      info() {
        return this.fileInfo;
      }
      setMeta(t2) {
        this.i = t2;
      }
      name() {
        return this.fileInfo.name();
      }
      size() {
        return this.fileInfo.size();
      }
      mode() {
        return this.fileInfo.mode();
      }
      modTime() {
        return this.fileInfo.modTime();
      }
      isDir() {
        return this.fileInfo.isDir();
      }
      sys() {
        return this.fileInfo.sys();
      }
      fileName() {
        return this.i.fileName();
      }
      relativeFilename() {
        return this.i.relativeFilename();
      }
      component() {
        return this.i.component();
      }
      root() {
        return this.i.root();
      }
      async open() {
        return await this.i.open();
      }
    };
    function ie(t2, e2) {
      const r2 = se(e2), s2 = new ne(t2, r2);
      return oe(t2) && s2.meta().merge(t2.meta()), s2;
    }
    function ae(t2, e2) {
      const r2 = new ne(t2, e2);
      return oe(t2) && r2.meta().merge(t2.meta()), r2;
    }
    function oe(t2) {
      return t2 && typeof t2.meta == "function";
    }
    var he = p(require("path"));
    var ce = class {
      constructor(t2, e2, r2, s2 = false) {
        __publicField(this, "file");
        __publicField(this, "fileMeta");
        __publicField(this, "fs");
        __publicField(this, "o");
        this.file = t2, this.fileMeta = e2, this.fs = r2, this.o = s2;
      }
      isNop() {
        return this.file === null;
      }
      async close() {
        if (this.file !== null)
          return await this.file.close();
      }
      async readDir(t2) {
        const e2 = [];
        if (this.o && this.file) {
          const r2 = await this.file.readdir(t2);
          for (const t3 of r2) {
            const r3 = this.joinPath(this.fileMeta.fileName(), t3.name()), s2 = se(r3, async () => await this.fs.open(r3));
            s2.merge(this.fileMeta);
            const n3 = ie(t3, r3);
            n3.setMeta(s2), e2.push(n3);
          }
        }
        return e2;
      }
      meta() {
        return this.fileMeta;
      }
      joinPath(t2, e2) {
        return t2.endsWith("/") ? t2 + e2 : t2 + "/" + e2;
      }
      async read(t2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.read(t2);
      }
      async readAt(t2, e2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.readAt(t2, e2);
      }
      async seek(t2, e2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.seek(t2, e2);
      }
      async write(t2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.write(t2);
      }
      async writeAt(t2, e2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.writeAt(t2, e2);
      }
      name() {
        return he.basename(this.fileMeta.fileName());
      }
      async readdir(t2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.readDir(t2);
      }
      async readdirnames(t2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.readdirnames(t2);
      }
      async stat() {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.stat();
      }
      async sync() {
        if (this.file !== null)
          return await this.file.sync();
      }
      async truncate(t2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.truncate(t2);
      }
      async writeString(t2) {
        if (this.file === null)
          throw new Error("File is null");
        return await this.file.writeString(t2);
      }
    };
    var ue = class extends ce {
      constructor(t2, e2 = null, r2 = null) {
        super(t2.isNop() ? null : t2, t2.meta(), t2.fs, true);
        __publicField(this, "virtualOpener");
        __publicField(this, "filter");
        this.virtualOpener = e2, this.filter = r2;
      }
      async readDir(t2) {
        if (!this.isNop()) {
          let e2 = await super.readDir(t2);
          return this.filter !== null && (e2 = await this.filter(e2)), e2;
        }
        return await this.readVirtualDir();
      }
      async readVirtualDir() {
        if (this.virtualOpener !== null)
          return await this.virtualOpener();
        throw new Error("virtual dir opener not found");
      }
      setFilter(t2) {
        this.filter = t2;
      }
      setVirtualOpener(t2) {
        this.virtualOpener = t2;
      }
      getFilter() {
        return this.filter;
      }
      getVirtualOpener() {
        return this.virtualOpener;
      }
    };
    var le = p(require("path"));
    q(), A("fs", { component: "basefs" });
    var fe = class {
      constructor(t2, e2) {
        __publicField(this, "fs");
        __publicField(this, "roots");
        this.fs = t2, this.roots = e2;
      }
      toAbsolutePath(t2) {
        if (this.roots.length === 0)
          return t2;
        const e2 = this.roots[0];
        return t2 === "" ? e2 : le.isAbsolute(t2) ? t2.startsWith(e2) ? t2 : le.join(e2, t2.substring(1)) : le.join(e2, t2);
      }
      isSameRootedPath(t2) {
        const e2 = this.roots[0];
        return t2.startsWith(le.join(e2, le.sep)) || t2 === e2;
      }
      async stat(t2) {
        const e2 = this.toAbsolutePath(t2);
        if (!this.isSameRootedPath(e2))
          throw new Error(`path ${t2} is outside of the BaseFs root`);
        try {
          const r2 = await this.fs.stat(e2);
          if (r2.isDir()) {
            const s3 = ie(r2, e2);
            return s3.meta().setOpenFunc(async () => await this.openDir(t2)), s3;
          }
          const s2 = ie(r2, e2), n3 = this.getRoot(e2);
          return s2.meta().setComponentRoot(n3), s2.meta().setOpenFunc(async () => await this.openInternal(t2)), s2;
        } catch (t3) {
          throw t3;
        }
      }
      async open(t2) {
        const e2 = this.toAbsolutePath(t2);
        return (await this.fs.stat(e2)).isDir() ? await this.openDir(t2) : await this.openInternal(t2);
      }
      async openInternal(t2, e2 = false) {
        const r2 = this.toAbsolutePath(t2), s2 = await this.fs.open(r2), n3 = this.getRoot(r2), i2 = se(r2);
        return i2.setComponentRoot(n3), e2 ? function(t3, e3, r3) {
          return new ce(t3, e3, r3, true);
        }(s2, i2, this.fs) : function(t3, e3, r3) {
          return new ce(t3, e3, r3);
        }(s2, i2, this.fs);
      }
      getRoot(t2) {
        for (const e2 of this.roots)
          if (t2.startsWith(e2))
            return e2;
        return "";
      }
      async openDir(t2) {
        const e2 = await this.openInternal(t2, true), r2 = this.toAbsolutePath(t2), s2 = this.getRoot(r2), n3 = se(r2);
        return n3.setComponentRoot(s2), function(t3, e3, r3) {
          const s3 = new ce(t3, e3, r3, true);
          return new ue(s3);
        }(e2, n3, this.fs);
      }
      async create(t2) {
        const e2 = this.toAbsolutePath(t2);
        return await this.fs.create(e2);
      }
      async mkdir(t2, e2) {
        const r2 = this.toAbsolutePath(t2);
        return await this.fs.mkdir(r2, e2);
      }
      async mkdirAll(t2, e2) {
        const r2 = this.toAbsolutePath(t2);
        return await this.fs.mkdirAll(r2, e2);
      }
      async openFile(t2, e2, r2) {
        const s2 = this.toAbsolutePath(t2);
        return await this.fs.openFile(s2, e2, r2);
      }
      async remove(t2) {
        const e2 = this.toAbsolutePath(t2);
        return await this.fs.remove(e2);
      }
      async removeAll(t2) {
        const e2 = this.toAbsolutePath(t2);
        return await this.fs.removeAll(e2);
      }
      async rename(t2, e2) {
        const r2 = this.toAbsolutePath(t2), s2 = this.toAbsolutePath(e2);
        return await this.fs.rename(r2, s2);
      }
      name() {
        return `BaseFs(${this.fs.name()})`;
      }
      async chmod(t2, e2) {
        const r2 = this.toAbsolutePath(t2);
        return await this.fs.chmod(r2, e2);
      }
      async chown(t2, e2, r2) {
        const s2 = this.toAbsolutePath(t2);
        return await this.fs.chown(s2, e2, r2);
      }
      async chtimes(t2, e2, r2) {
        const s2 = this.toAbsolutePath(t2);
        return await this.fs.chtimes(s2, e2, r2);
      }
    };
    function we(t2, e2) {
      return new fe(t2, e2);
    }
    var de = p(require("path"));
    q();
    var ge = A("fs", { component: "walkway" });
    var pe = class {
      constructor(t2, e2) {
        __publicField(this, "fs");
        __publicField(this, "root");
        __publicField(this, "cb");
        __publicField(this, "cfg");
        __publicField(this, "walked", false);
        if (!t2)
          throw new Error("fs must be set");
        if (!e2.walkFn)
          throw new Error("walkFn must be set");
        this.fs = t2, this.cb = e2, this.root = "", this.cfg = {};
      }
      async walkWith(t2, e2) {
        return this.cfg = e2, this.root = t2, await this.walk();
      }
      async walk() {
        if (this.walked)
          throw new Error("this walkway is already walked");
        return this.walked = true, await this.walkRecursive(this.root, this.cfg.info, this.cfg.dirEntries);
      }
      checkErr(t2, e2) {
        return !(!this.isNotExistError(e2) || this.cfg.failOnNotExist || (ge.warn(`File "${t2}" not found, skipping.`), 0));
      }
      isNotExistError(t2) {
        return t2.message.includes("ENOENT") || t2.message.includes("no such file") || t2.code === "ENOENT";
      }
      async walkRecursive(t2, e2, r2) {
        if (!e2)
          try {
            const r3 = await this.fs.stat(t2), s2 = se(t2);
            s2.setOpenFunc(async () => await this.fs.open(t2)), e2 = ae(r3, s2);
          } catch (e3) {
            if (t2 === this.root && this.isNotExistError(e3)) {
              if (this.cfg.failOnNotExist)
                throw new Jt(`walk: root not found: ${e3.message}`, "WALK_ROOT_NOT_FOUND");
              return;
            }
            if (this.checkErr(t2, e3))
              return;
            throw new Jt(`walk: stat: ${e3.message}`, "WALK_STAT_FAILED");
          }
        try {
          const r3 = await this.cb.walkFn(t2, e2);
          if (r3 instanceof Error)
            throw r3;
        } catch (t3) {
          if (e2.isDir() && t3 === Xt)
            return;
          throw t3;
        }
        if (e2.isDir()) {
          if (!r2)
            try {
              const e3 = await this.fs.open(t2), s2 = await e3.readdir(-1);
              await e3.close(), r2 = s2.map((t3) => t3), this.cfg.sortDirEntries && r2.sort((t3, e4) => t3.name().localeCompare(e4.name()));
            } catch (e3) {
              if (this.checkErr(t2, e3))
                return;
              throw new Jt(`walk: readdir: ${e3.message}`, "WALK_READDIR_FAILED");
            }
          if (this.cfg.ignoreFile && (r2 = r2.filter((t3) => !this.cfg.ignoreFile(t3.fileName()))), this.cb.hookPre)
            try {
              r2 = await this.cb.hookPre(e2, t2, r2);
            } catch (t3) {
              if (t3 === Xt)
                return;
              throw t3;
            }
          for (const e3 of r2) {
            const r3 = de.join(t2, e3.name());
            try {
              await this.walkRecursive(r3, e3);
            } catch (t3) {
              if (!e3.isDir() || t3 !== Xt)
                throw t3;
            }
          }
          if (this.cb.hookPost)
            try {
              await this.cb.hookPost(e2, t2, r2);
            } catch (t3) {
              if (t3 === Xt)
                return;
              throw t3;
            }
        }
      }
    };
    q();
    var me = A("fs", { component: "static-copier" });
    var ye = class {
      constructor(t2, e2) {
        __publicField(this, "fromFss");
        __publicField(this, "toFs");
        this.fromFss = t2, this.toFs = e2;
      }
      async copy() {
        this.fromFss && this.fromFss.length !== 0 ? this.toFs ? await this.doWithPublishDirs(this.toFs, async (t2) => {
          for (const e2 of this.fromFss)
            await this.copyStaticTo(e2, t2);
        }) : me.error("No publish filesystem found") : me.error("No static filesystems found");
      }
      async doWithPublishDirs(t2, e2) {
        try {
          await e2("/");
        } catch (t3) {
          throw me.error("Error in doWithPublishDirs:", t3), t3;
        }
      }
      async copyStaticTo(t2, e2) {
        try {
          return await this.walkSourceFiles(t2, e2);
        } catch (t3) {
          throw me.error(`Error copying static files to ${e2}:`, t3), t3;
        }
      }
      async walkSourceFiles(t2, e2) {
        let r2 = 0;
        try {
          await this.walkFileSystem(t2, "/", async (s2, n3) => {
            n3 || (await this.copyFile(t2, s2, this.toFs, e2), r2++);
          });
        } catch (t3) {
          throw me.error("Error walking source files:", t3), t3;
        }
        return r2;
      }
      async walkFileSystem(t2, e2, r2) {
        try {
          const s2 = await t2.open(e2);
          if (!(await s2.stat()).isDir())
            return await s2.close(), void await r2(e2, false);
          const n3 = await s2.readdir(-1);
          await s2.close();
          for (const s3 of n3) {
            const n4 = this.joinPath(e2, s3.name());
            s3.isDir() ? (await r2(n4, true), await this.walkFileSystem(t2, n4, r2)) : await r2(n4, false);
          }
        } catch (t3) {
          me.error(`Could not read directory ${e2}:`, t3);
        }
      }
      async copyFile(t2, e2, r2, s2) {
        let n3 = null, i2 = null;
        try {
          const a2 = e2.startsWith("/") ? e2.slice(1) : e2, o2 = this.joinPath(s2, a2), h2 = this.dirname(o2);
          h2 !== "/" && await r2.mkdirAll(h2, 493), n3 = await t2.open(e2);
          const c2 = await n3.stat(), u2 = new Uint8Array(c2.size());
          await n3.read(u2), i2 = await r2.create(o2), await i2.write(u2);
        } catch (t3) {
          me.warn(`Failed to copy static file ${e2}:`, t3);
        } finally {
          if (i2)
            try {
              await i2.close();
            } catch (t3) {
              me.warn(`Failed to close target file: ${t3}`);
            }
          if (n3)
            try {
              await n3.close();
            } catch (t3) {
              me.warn(`Failed to close source file: ${t3}`);
            }
        }
      }
      joinPath(...t2) {
        return t2.map((t3) => t3.replace(/^\/+|\/+$/g, "")).filter((t3) => t3.length > 0).join("/").replace(/^/, "/");
      }
      dirname(t2) {
        const e2 = t2.split("/").filter((t3) => t3.length > 0);
        return e2.length <= 1 ? "/" : "/" + e2.slice(0, -1).join("/");
      }
    };
    q();
    var be = A("fs", { component: "incremental-file-collector" });
    async function Ee(t2, e2) {
      try {
        const r2 = await e2.stat(t2), s2 = se(t2);
        return s2.setOpenFunc(async () => await e2.open(t2)), ae(r2, s2);
      } catch (e3) {
        throw new Error(`Failed to stat file ${t2}: ${e3.message}`);
      }
    }
    var Se = class {
      constructor(t2, e2, r2, s2, n3, i2, a2, o2, h2) {
        __publicField(this, "originFs");
        __publicField(this, "prompts");
        __publicField(this, "workflows");
        __publicField(this, "content");
        __publicField(this, "layouts");
        __publicField(this, "statics");
        __publicField(this, "assets");
        __publicField(this, "i18n");
        __publicField(this, "work");
        __publicField(this, "service");
        this.originFs = t2, this.prompts = e2, this.workflows = r2, this.content = s2, this.layouts = n3, this.statics = i2, this.assets = a2, this.i18n = o2, this.work = h2, this.service = new ke();
      }
      os() {
        return this.originFs.getOrigin();
      }
      workFs() {
        return this.work;
      }
      workflowFs() {
        return this.workflows;
      }
      promptFs() {
        return this.prompts;
      }
      contentFs() {
        return this.content;
      }
      layoutsFs() {
        return this.layouts;
      }
      staticFs() {
        return this.statics;
      }
      assetsFs() {
        return this.assets;
      }
      publishFs() {
        return this.originFs.publish();
      }
      copyStatic(t2, e2) {
        return new ye(t2, e2).copy();
      }
      newFileMetaInfo(t2) {
        return this.service.newFileMetaInfo(t2);
      }
      newFileMetaInfoWithContent(t2) {
        return this.service.newFileMetaInfoWithContent(t2);
      }
      async getFileMetaInfos(t2) {
        return async function(t3, e2) {
          const r2 = /* @__PURE__ */ new Map();
          let s2 = false;
          for (const n3 of t3)
            for (const t4 of e2)
              try {
                const e3 = await Ee(n3, t4);
                if (r2.set(n3, e3), s2 = true, s2)
                  break;
              } catch (e3) {
                be.error(`Failed to create FileMetaInfo for ${n3} with fs=${t4}:`, e3);
              }
          return r2;
        }(t2, this.content);
      }
      newBasePathFs(t2, e2) {
        return we(t2, [e2]);
      }
      async walkPrompts(t2, e2, r2) {
        return await this.walk(this.prompts, t2, e2, r2);
      }
      async walkWorkflows(t2, e2, r2) {
        return await this.walk(this.workflows, t2, e2, r2);
      }
      async walkLayouts(t2, e2, r2) {
        return await this.walk(this.layouts, t2, e2, r2);
      }
      async walkContent(t2, e2, r2, s2) {
        await this.walk(t2, e2, r2, s2);
      }
      async walkStatics(t2, e2, r2) {
        return await this.walk(this.statics, t2, e2, r2);
      }
      async walkI18n(t2, e2, r2) {
        return await this.walk(this.i18n, t2, e2, r2);
      }
      async walk(t2, e2, r2, s2) {
        const n3 = function(t3, e3) {
          return new pe(t3, e3);
        }(t2, r2);
        return e2 === "" && (e2 = "/"), await n3.walkWith(e2, s2);
      }
    };
    var ve = (t2, e2) => {
      const r2 = [...t2];
      for (const s2 of e2) {
        let e3 = false;
        for (const r3 of t2)
          if (s2.name() === r3.name()) {
            e3 = true;
            break;
          }
        e3 || r2.push(s2);
      }
      return r2;
    };
    var Te = class t2 {
      constructor(t3) {
        __publicField(this, "fss");
        __publicField(this, "firstWritable");
        __publicField(this, "dirsMerger");
        this.fss = [...t3.fss], this.firstWritable = t3.firstWritable ?? false, this.dirsMerger = t3.dirsMerger ?? ve;
      }
      withFilesystems(...e2) {
        return new t2({ fss: [...this.fss, ...e2], firstWritable: this.firstWritable, dirsMerger: this.dirsMerger });
      }
      withFirstWritable(e2) {
        return new t2({ fss: this.fss, firstWritable: e2, dirsMerger: this.dirsMerger });
      }
      withDirsMerger(e2) {
        return new t2({ fss: this.fss, firstWritable: this.firstWritable, dirsMerger: e2 });
      }
      getWritableFs() {
        return this.firstWritable && this.fss.length !== 0 ? this.fss[0] : null;
      }
      isValid() {
        return this.dirsMerger !== void 0;
      }
      getFilesystemCount() {
        return this.fss.length;
      }
      getFilesystem(t3) {
        return t3 < 0 || t3 >= this.fss.length ? null : this.fss[t3];
      }
      hasFilesystem(t3) {
        return this.fss.includes(t3);
      }
      getFilesystems() {
        return this.fss;
      }
    };
    function xe(t2, e2 = false, r2) {
      const s2 = { fss: t2, firstWritable: e2 };
      return r2 !== void 0 && (s2.dirsMerger = r2), new Te(s2);
    }
    function Pe(t2) {
      return xe(t2, false, ve);
    }
    var $e = class {
      constructor(t2 = {}) {
        __publicField(this, "u");
        __publicField(this, "fss");
        __publicField(this, "dirOpeners");
        __publicField(this, "info");
        __publicField(this, "merge");
        __publicField(this, "err");
        __publicField(this, "offset");
        __publicField(this, "fis");
        __publicField(this, "closed");
        this.u = t2.name || "", this.fss = t2.fss ? [...t2.fss] : [], this.dirOpeners = t2.dirOpeners ? [...t2.dirOpeners] : [], t2.info !== void 0 && (this.info = t2.info), this.merge = t2.merge || ve, this.offset = 0, this.fis = [], this.closed = false;
      }
      name() {
        return this.u;
      }
      isClosed() {
        return this.closed || this.fss.length === 0 && this.dirOpeners.length === 0;
      }
      async readdir(t2) {
        if (this.isClosed())
          throw Yt;
        if (this.err)
          throw this.err;
        this.offset === 0 && await this.loadDirectoryEntries();
        const e2 = this.fis.slice(this.offset);
        if (t2 <= 0) {
          if (this.err = new Error("EOF"), this.offset > 0 && e2.length === 0)
            throw this.err;
          return [...e2];
        }
        if (e2.length === 0)
          throw this.err = new Error("EOF"), this.err;
        const r2 = e2.slice(0, t2);
        return this.offset += r2.length, r2;
      }
      async readdirnames(t2) {
        if (this.isClosed())
          throw Yt;
        return (await this.readdir(t2)).map((t3) => t3.name());
      }
      async loadDirectoryEntries() {
        for (let t2 = 0; t2 < this.fss.length; t2++) {
          const e2 = this.fss[t2];
          await this.readFromFilesystem(e2, null);
        }
        for (let t2 = 0; t2 < this.dirOpeners.length; t2++) {
          const e2 = await this.dirOpeners[t2]();
          await this.readFromFilesystem(null, e2);
        }
      }
      async readFromFilesystem(t2, e2) {
        let r2 = e2;
        try {
          if (!r2 && t2) {
            const e4 = this.u === "/" ? "" : this.u;
            r2 = await t2.open(e4);
          }
          if (!r2)
            return;
          const e3 = await r2.readdir(-1);
          this.fis = this.merge(this.fis, e3);
        } catch (t3) {
        } finally {
          r2 && !e2 && await r2.close();
        }
      }
      async stat() {
        if (this.isClosed())
          throw Yt;
        if (this.info)
          return await this.info();
        if (this.fss.length > 0)
          return await this.fss[0].stat(this.u);
        throw new Qt("no filesystem available for stat", "NO_FILESYSTEM");
      }
      async close() {
        this.closed = true, this.fss = [], this.dirOpeners = [], this.fis = [], delete this.info, this.offset = 0, delete this.err;
      }
      notSupported(t2) {
        throw new Qt(`operation ${t2} not supported on directory "${this.u}"`, "OPERATION_NOT_SUPPORTED");
      }
      async read(t2) {
        this.notSupported("read");
      }
      async readAt(t2, e2) {
        this.notSupported("readAt");
      }
      async seek(t2, e2) {
        this.notSupported("seek");
      }
      async write(t2) {
        this.notSupported("write");
      }
      async writeAt(t2, e2) {
        this.notSupported("writeAt");
      }
      async sync() {
        this.notSupported("sync");
      }
      async truncate(t2) {
        this.notSupported("truncate");
      }
      async writeString(t2) {
        this.notSupported("writeString");
      }
    };
    var Re = new class {
      constructor() {
        __publicField(this, "pool", []);
      }
      get() {
        return this.pool.length > 0 ? this.pool.pop() : new $e();
      }
      release(t2) {
        t2.fss = [], t2.dirOpeners = [], t2.fis = [], delete t2.info, t2.offset = 0, t2.u = "", delete t2.err, t2.closed = false, this.pool.push(t2);
      }
    }();
    q(), A("fs", { component: "overlayfs" });
    var Le = class t2 {
      constructor(t3) {
        __publicField(this, "fss");
        __publicField(this, "mergeDirs");
        __publicField(this, "firstWritable");
        this.fss = [...t3.fss], this.mergeDirs = t3.dirsMerger, this.firstWritable = t3.firstWritable;
      }
      name() {
        return "overlayfs";
      }
      filesystem(t3) {
        return t3 < 0 || t3 >= this.fss.length ? null : this.fss[t3];
      }
      numFilesystems() {
        return this.fss.length;
      }
      append(...e2) {
        const r2 = new Te({ fss: [...this.fss, ...e2], firstWritable: this.firstWritable, dirsMerger: this.mergeDirs });
        return new t2(r2);
      }
      withDirsMerger(e2) {
        const r2 = new Te({ fss: this.fss, firstWritable: this.firstWritable, dirsMerger: e2 });
        return new t2(r2);
      }
      writeFs() {
        if (this.fss.length === 0)
          throw te;
        return this.fss[0];
      }
      async collectDirs(t3, e2) {
        for (const r2 of this.fss)
          await this.collectDirsRecursive(r2, t3, e2);
      }
      async collectDirsRecursive(t3, e2, r2) {
        try {
          (await t3.stat(e2)).isDir() && r2(t3);
        } catch (t4) {
        }
        const s2 = t3;
        if (s2.filesystem && s2.numFilesystems)
          for (let t4 = 0; t4 < s2.numFilesystems(); t4++) {
            const n3 = s2.filesystem(t4);
            n3 && await this.collectDirsRecursive(n3, e2, r2);
          }
      }
      async statInternal(t3, e2) {
        for (let r2 = 0; r2 < this.fss.length; r2++) {
          const s2 = this.fss[r2], [n3, i2, a2, o2] = await this.statRecursive(s2, t3, e2);
          if (o2 === null || !this.isNotExistError(o2))
            return [n3, i2, a2, o2];
        }
        return [null, null, false, Zt];
      }
      async statRecursive(t3, e2, r2) {
        try {
          const r3 = await t3.stat(e2);
          return [t3, r3, false, null];
        } catch (e3) {
          if (!this.isNotExistError(e3))
            return [t3, null, false, e3];
        }
        const s2 = t3;
        if (s2.filesystem && s2.numFilesystems)
          for (let t4 = 0; t4 < s2.numFilesystems(); t4++) {
            const n3 = s2.filesystem(t4);
            if (n3) {
              const [t5, s3, i2, a2] = await this.statRecursive(n3, e2, r2);
              if (a2 === null || !this.isNotExistError(a2))
                return [t5, s3, i2, a2];
            }
          }
        return [null, null, false, Zt];
      }
      isNotExistError(t3) {
        return t3.message.includes("ENOENT") || t3.message.includes("no such file") || t3 === Zt;
      }
      async create(t3) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().create(t3);
      }
      async mkdir(t3, e2) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().mkdir(t3, e2);
      }
      async mkdirAll(t3, e2) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().mkdirAll(t3, e2);
      }
      async open(t3) {
        if (this.fss.length === 0)
          throw Zt;
        const [e2, r2, , s2] = await this.statInternal(t3, false);
        if (s2)
          throw s2;
        if (r2.isDir()) {
          const e3 = [];
          if (await this.collectDirs(t3, (t4) => {
            e3.push(t4);
          }), e3.length === 0)
            throw Zt;
          return e3.length === 1 ? await e3[0].open(t3) : await async function(t4, e4, r3, s3) {
            if (!r3)
              throw new Qt("info function must not be null", "INFO_REQUIRED");
            const n3 = Re.get(), i2 = { name: t4, fss: [...s3], info: r3, merge: e4 || ve };
            return Object.assign(n3, new $e(i2)), n3;
          }(t3, this.mergeDirs, async () => r2, e3);
        }
        return await e2.open(t3);
      }
      async openFile(t3, e2, r2) {
        const s2 = !!(1 & e2) || !!(2 & e2);
        if (s2 && !this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return s2 ? await this.writeFs().openFile(t3, e2, r2) : await this.open(t3);
      }
      async remove(t3) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().remove(t3);
      }
      async removeAll(t3) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().removeAll(t3);
      }
      async rename(t3, e2) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().rename(t3, e2);
      }
      async stat(t3) {
        const e2 = t3 === "/" ? "" : t3, [, r2, , s2] = await this.statInternal(e2, false);
        if (s2)
          throw s2;
        return r2;
      }
      async chmod(t3, e2) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().chmod(t3, e2);
      }
      async chown(t3, e2, r2) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().chown(t3, e2, r2);
      }
      async chtimes(t3, e2, r2) {
        if (!this.firstWritable)
          throw new Qt("filesystem is read-only", "READ_ONLY");
        return await this.writeFs().chtimes(t3, e2, r2);
      }
    };
    function Ne(t2) {
      return new Le(t2);
    }
    var Fe = class {
      constructor(t2, e2 = "This is a virtual file.") {
        __publicField(this, "u");
        __publicField(this, "p");
        __publicField(this, "S");
        this.u = t2, this.p = e2, this.S = new Date();
      }
      name() {
        return this.u;
      }
      size() {
        return Buffer.byteLength(this.p, "utf8");
      }
      mode() {
        return 420;
      }
      modTime() {
        return this.S;
      }
      isDir() {
        return false;
      }
      sys() {
        return null;
      }
      getContent() {
        return this.p;
      }
    };
    var De = class {
      constructor(t2, e2) {
        __publicField(this, "T");
        __publicField(this, "P");
        __publicField(this, "$", null);
        this.T = t2, this.P = e2;
      }
      fullName() {
        return this.T;
      }
      async open() {
        return { name: () => this.T, close: async () => {
        }, read: async (t2) => {
          const e2 = Buffer.from(this.P, "utf8"), r2 = Math.min(t2.length, e2.length);
          return e2.copy(t2, 0, 0, r2), { bytesRead: r2, buffer: t2 };
        }, readAt: async (t2, e2) => {
          const r2 = Buffer.from(this.P, "utf8"), s2 = Math.min(e2, r2.length), n3 = Math.min(t2.length, r2.length - s2);
          return n3 > 0 && r2.copy(t2, 0, s2, s2 + n3), { bytesRead: n3, buffer: t2 };
        }, seek: async (t2, e2) => t2, write: async (t2) => ({ bytesWritten: t2.length, buffer: t2 }), writeAt: async (t2, e2) => ({ bytesWritten: t2.length, buffer: t2 }), readdir: async (t2) => [], readdirnames: async (t2) => [], stat: async () => this.getFileInfo(), sync: async () => {
        }, truncate: async (t2) => {
        }, writeString: async (t2) => ({ bytesWritten: Buffer.byteLength(t2, "utf8") }) };
      }
      getFileInfo() {
        return this.$ || (this.$ = new Fe(this.T, this.P)), this.$;
      }
    };
    var Ae = null;
    var ke = class {
      newFileMetaInfo(t2) {
        return function(t3) {
          const e2 = (Ae || (Ae = new De("/content/file.txt", "This is a virtual file.")), Ae.getFileInfo()), r2 = se(t3);
          return new ne(e2, r2);
        }(t2);
      }
      newFileMetaInfoWithContent(t2) {
        return function(t3) {
          const e2 = function(t4) {
            const e3 = Math.floor(1e6 * Math.random()).toString().padStart(6, "0");
            return new De(`/content/file_${e3}.md`, t4);
          }(t3), r2 = e2.getFileInfo(), s2 = se(e2.fullName(), () => e2.open());
          return s2.setComponentRoot("content"), s2.setComponentDir("content"), new ne(r2, s2);
        }(t2);
      }
    };
    var Ie = class {
      create(t2) {
        return Ne(Pe(t2));
      }
      createWithOptions(t2) {
        return function(t3) {
          const e2 = new Te(t3);
          return new Le(e2);
        }(t2);
      }
      createReadOnly(t2) {
        return Ne(Pe(t2));
      }
      createWritable(t2) {
        const e2 = function(t3) {
          return xe(t3, true, void 0);
        }(t2);
        return Ne(e2);
      }
      createWithMerger(t2, e2) {
        return Ne(Pe(t2).withDirsMerger(e2));
      }
    };
    function Ce(t2) {
      return new Ie().createReadOnly(t2);
    }
    var Oe = p(require("path"));
    q(), A("fs", { component: "filesystemscollector" });
    var _e = class {
      constructor(t2, e2, r2 = "") {
        __publicField(this, "from");
        __publicField(this, "to");
        __publicField(this, "toBase");
        this.from = t2, this.to = e2, this.toBase = r2;
      }
      fs(t2) {
        return we(t2, [this.to]);
      }
    };
    var Me = class {
      constructor(t2) {
        __publicField(this, "sourceProject");
        __publicField(this, "overlayMountsPrompt");
        __publicField(this, "overlayMountsWorkflow");
        __publicField(this, "overlayMountsContent");
        __publicField(this, "overlayMountsLayouts");
        __publicField(this, "overlayMountsStatics");
        __publicField(this, "overlayMountsAssets");
        __publicField(this, "overlayMountsI18n");
        this.sourceProject = t2, this.overlayMountsPrompt = Ce([]), this.overlayMountsWorkflow = Ce([]), this.overlayMountsContent = [], this.overlayMountsLayouts = Ce([]), this.overlayMountsStatics = Ce([]), this.overlayMountsAssets = Ce([]), this.overlayMountsI18n = Ce([]);
      }
      async collect(t2) {
        const e2 = t2.all();
        for (const t3 of e2) {
          const e3 = [], r2 = [], s2 = [], n3 = [], i2 = [], a2 = [], o2 = [], h2 = (e4) => Oe.isAbsolute(e4) ? ["", e4] : [t3.dir(), this.absPathify(t3.dir(), e4)], c2 = t3.mounts();
          for (const t4 of c2) {
            const [c3, u2] = h2(t4.source()), l2 = new _e(t4.target(), u2, c3).fs(this.sourceProject);
            this.isPrompts(t4.target()) ? r2.push(l2) : this.isWorkflows(t4.target()) ? e3.push(l2) : this.isContent(t4.target()) ? s2.push(l2) : this.isLayouts(t4.target()) ? n3.push(l2) : this.isStatics(t4.target()) ? i2.push(l2) : this.isAssets(t4.target()) ? a2.push(l2) : this.isI18n(t4.target()) && o2.push(l2);
          }
          if (e3.length > 0 && (this.overlayMountsWorkflow = this.overlayMountsWorkflow.append(...e3)), r2.length > 0 && (this.overlayMountsPrompt = this.overlayMountsPrompt.append(...r2)), t3.isProjectModule())
            for (const t4 of s2) {
              let e4 = Ce([]);
              e4 = e4.append(t4), this.overlayMountsContent.push(e4);
            }
          n3.length > 0 && (this.overlayMountsLayouts = this.overlayMountsLayouts.append(...n3)), i2.length > 0 && (this.overlayMountsStatics = this.overlayMountsStatics.append(...i2)), a2.length > 0 && (this.overlayMountsAssets = this.overlayMountsAssets.append(...a2)), o2.length > 0 && (this.overlayMountsI18n = this.overlayMountsI18n.append(...o2));
        }
      }
      isPrompts(t2) {
        return t2 === "prompts" || t2.startsWith("prompts/") || t2.startsWith("/prompts/");
      }
      isWorkflows(t2) {
        return t2 === "workflows" || t2.startsWith("workflows/") || t2.startsWith("/workflows/");
      }
      isContent(t2) {
        return t2 === "content" || t2.startsWith("content/") || t2.startsWith("/content/");
      }
      isLayouts(t2) {
        return t2 === "layouts" || t2.startsWith("layouts/") || t2.startsWith("/layouts/");
      }
      isStatics(t2) {
        return t2 === "static" || t2.startsWith("static/") || t2.startsWith("/static/");
      }
      isAssets(t2) {
        return t2 === "assets" || t2.startsWith("assets/") || t2.startsWith("/assets/");
      }
      isI18n(t2) {
        return t2 === "i18n" || t2.startsWith("i18n/") || t2.startsWith("/i18n/");
      }
      absPathify(t2, e2) {
        return Oe.resolve(t2, e2);
      }
    };
    var Ue = p(require("fs/promises"));
    var je = p(require("path"));
    q();
    var Be = A("fs", { component: "osfs" });
    var qe = class {
      constructor(t2, e2) {
        this.stats = t2, this.u = e2;
      }
      name() {
        return this.u;
      }
      size() {
        return this.stats.size;
      }
      mode() {
        return this.stats.mode;
      }
      modTime() {
        return this.stats.mtime;
      }
      isDir() {
        return this.stats.isDirectory();
      }
      sys() {
        return this.stats;
      }
    };
    var We = class {
      constructor(t2, e2 = "r") {
        __publicField(this, "handle", null);
        __publicField(this, "closed", false);
        __publicField(this, "position", 0);
        this.filePath = t2, this.flags = e2;
      }
      async ensureOpen() {
        this.handle || this.closed || (this.handle = await Ue.open(this.filePath, this.flags));
      }
      async close() {
        if (this.handle) {
          try {
            await this.handle.close();
          } catch (t2) {
            throw Be.error(`\u274C Error closing file handle for ${this.filePath}:`, t2), t2;
          }
          this.handle = null;
        }
        this.closed = true;
      }
      async read(t2) {
        if (this.closed)
          throw new Error("File is closed");
        if (await this.ensureOpen(), !this.handle)
          throw new Error("Failed to open file");
        const e2 = await this.handle.read(t2, 0, t2.length, this.position);
        return this.position += e2.bytesRead, { bytesRead: e2.bytesRead, buffer: t2 };
      }
      async readAt(t2, e2) {
        if (this.closed)
          throw new Error("File is closed");
        if (await this.ensureOpen(), !this.handle)
          throw new Error("Failed to open file");
        return { bytesRead: (await this.handle.read(t2, 0, t2.length, e2)).bytesRead, buffer: t2 };
      }
      async seek(t2, e2) {
        if (this.closed)
          throw new Error("File is closed");
        switch (e2) {
          case 0:
          default:
            this.position = t2;
            break;
          case 1:
            this.position += t2;
            break;
          case 2:
            if (await this.ensureOpen(), this.handle) {
              const e3 = await this.handle.stat();
              this.position = e3.size + t2;
            }
        }
        return this.position;
      }
      async write(t2) {
        if (this.closed)
          throw new Error("File is closed");
        if (await this.ensureOpen(), !this.handle)
          throw new Error("Failed to open file");
        const e2 = await this.handle.write(t2, 0, t2.length, this.position);
        return this.position += e2.bytesWritten, { bytesWritten: e2.bytesWritten, buffer: t2 };
      }
      async writeAt(t2, e2) {
        if (this.closed)
          throw new Error("File is closed");
        if (await this.ensureOpen(), !this.handle)
          throw new Error("Failed to open file");
        return { bytesWritten: (await this.handle.write(t2, 0, t2.length, e2)).bytesWritten, buffer: t2 };
      }
      name() {
        return this.filePath;
      }
      async readdir(t2) {
        if (this.closed)
          throw new Error("File is closed");
        const e2 = await Ue.readdir(this.filePath, { withFileTypes: true }), r2 = [], s2 = t2 > 0 ? Math.min(t2, e2.length) : e2.length;
        for (let t3 = 0; t3 < s2; t3++) {
          const s3 = e2[t3], n3 = je.join(this.filePath, s3.name), i2 = await Ue.stat(n3);
          r2.push(new qe(i2, s3.name));
        }
        return r2;
      }
      async readdirnames(t2) {
        if (this.closed)
          throw new Error("File is closed");
        const e2 = await Ue.readdir(this.filePath);
        return t2 > 0 ? e2.slice(0, t2) : e2;
      }
      async stat() {
        if (this.closed)
          throw new Error("File is closed");
        const t2 = await Ue.stat(this.filePath);
        return new qe(t2, je.basename(this.filePath));
      }
      async sync() {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen(), this.handle && await this.handle.sync();
      }
      async truncate(t2) {
        if (this.closed)
          throw new Error("File is closed");
        await this.ensureOpen(), this.handle && (await this.handle.truncate(t2), this.position > t2 && (this.position = t2));
      }
      async writeString(t2) {
        const e2 = Buffer.from(t2, "utf8");
        return { bytesWritten: (await this.write(e2)).bytesWritten };
      }
    };
    var ze = class {
      async create(t2) {
        return await Ue.writeFile(t2, ""), new We(t2, "w+");
      }
      async mkdir(t2, e2) {
        await Ue.mkdir(t2, { mode: e2 });
      }
      async mkdirAll(t2, e2) {
        await Ue.mkdir(t2, { mode: e2, recursive: true });
      }
      async open(t2) {
        return await Ue.access(t2), (await Ue.stat(t2)).isDirectory(), new We(t2, "r");
      }
      async openFile(t2, e2, r2) {
        let s2 = "r";
        return 1 & e2 && (s2 = "w"), 2 & e2 && (s2 = "r+"), 64 & e2 && (s2 = "w"), 512 & e2 && (s2 = "w"), 1024 & e2 && (s2 = "a"), new We(t2, s2);
      }
      async remove(t2) {
        (await Ue.stat(t2)).isDirectory() ? await Ue.rmdir(t2) : await Ue.unlink(t2);
      }
      async removeAll(t2) {
        await Ue.rm(t2, { recursive: true, force: true });
      }
      async rename(t2, e2) {
        await Ue.rename(t2, e2);
      }
      async stat(t2) {
        const e2 = await Ue.stat(t2);
        return new qe(e2, je.basename(t2));
      }
      name() {
        return "OsFs";
      }
      async chmod(t2, e2) {
        await Ue.chmod(t2, e2);
      }
      async chown(t2, e2, r2) {
        await Ue.chown(t2, e2, r2);
      }
      async chtimes(t2, e2, r2) {
        await Ue.utimes(t2, e2, r2);
      }
    };
    var He = "page";
    var Ge = "home";
    var Ve = "section";
    var Ke = "taxonomy";
    var Je = "term";
    var Ye = "sitemap";
    var Ze = "404";
    var Xe = class {
      constructor(t2 = 1024) {
        __publicField(this, "buffer");
        __publicField(this, "position");
        __publicField(this, "capacity");
        this.capacity = t2, this.buffer = new Uint8Array(this.capacity), this.position = 0;
      }
      async write(t2) {
        this.ensureCapacity(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
      }
      async writeString(t2) {
        const e2 = new TextEncoder().encode(t2);
        await this.write(e2);
      }
      async writeByte(t2) {
        this.ensureCapacity(1), this.buffer[this.position] = t2, this.position++;
      }
      bytes() {
        return this.buffer.slice(0, this.position);
      }
      length() {
        return this.position;
      }
      truncate(t2) {
        if (t2 < 0 || t2 > this.position)
          throw new Error("Invalid truncate size");
        this.position = t2;
      }
      ensureCapacity(t2) {
        const e2 = this.position + t2;
        if (e2 <= this.capacity)
          return;
        const r2 = Math.max(2 * this.capacity, e2), s2 = new Uint8Array(r2);
        s2.set(this.buffer), this.buffer = s2, this.capacity = r2;
      }
    };
    var Qe = class {
      constructor() {
        __publicField(this, "usedIds", /* @__PURE__ */ new Set());
      }
      generateID(t2, e2 = "github") {
        let r2;
        switch (e2) {
          case "github":
          default:
            r2 = this.githubStyle(t2);
            break;
          case "github-ascii":
            r2 = this.githubAsciiStyle(t2);
            break;
          case "blackfriday":
            r2 = this.blackfridayStyle(t2);
        }
        if (this.usedIds.has(r2)) {
          let t3 = 1, e3 = `${r2}-${t3}`;
          for (; this.usedIds.has(e3); )
            t3++, e3 = `${r2}-${t3}`;
          r2 = e3;
        }
        return this.usedIds.add(r2), r2;
      }
      githubStyle(t2) {
        return t2.toLowerCase().replace(/[^\w\u4e00-\u9fff\s-]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
      }
      githubAsciiStyle(t2) {
        return t2.toLowerCase().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
      }
      blackfridayStyle(t2) {
        return t2.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
      }
      reset() {
        this.usedIds.clear();
      }
    };
    var tr = class {
      constructor(t2, e2) {
        this.wrappedContent = t2, this.innerContent = e2;
      }
      wrapped() {
        return this.wrappedContent;
      }
      inner() {
        return this.innerContent;
      }
    };
    var er = class {
      constructor(t2) {
        this.config = t2;
      }
      async highlight(t2, e2, r2) {
        if (!e2 || e2 === "text" || e2 === "plain")
          return this.escapeHTML(t2);
        const s2 = this.escapeHTML(t2), n3 = `language-${e2}`;
        return this.config.lineNos ? this.addLineNumbers(s2, n3) : `<code class="${n3}">${s2}</code>`;
      }
      async highlightCodeBlock(t2, e2) {
        const r2 = t2.type(), s2 = t2.inner(), n3 = await this.highlight(s2, r2, e2);
        return new tr(`<pre>${n3}</pre>`, n3);
      }
      async renderCodeblock(t2, e2, r2) {
        const s2 = await this.highlightCodeBlock(r2);
        await e2.writeString(s2.wrapped());
      }
      isDefaultCodeBlockRenderer() {
        return true;
      }
      escapeHTML(t2) {
        return t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
      }
      addLineNumbers(t2, e2) {
        const r2 = t2.split("\n").map((t3, r3) => {
          const s2 = r3 + this.config.lineNoStart;
          return this.config.lineNumbersInTable ? `<tr><td class="line-number">${s2}</td><td class="line-code"><code class="${e2}">${t3}</code></td></tr>` : `<span class="line-number">${s2}</span><code class="${e2}">${t3}</code>`;
        });
        return this.config.lineNumbersInTable ? `<table class="code-table"><tbody>${r2.join("")}</tbody></table>` : r2.join("\n");
      }
    };
    q();
    var rr = class {
      constructor() {
        __publicField(this, "Type");
        __publicField(this, "Err");
        __publicField(this, "low");
        __publicField(this, "high");
        __publicField(this, "segments");
        __publicField(this, "firstByte");
        __publicField(this, "isString");
        __publicField(this, "content");
        __publicField(this, "bytes");
        this.Type = 0, this.Err = null, this.low = 0, this.high = 0, this.segments = [], this.firstByte = 0, this.isString = false, this.content = "", this.bytes = [];
      }
      Pos() {
        return this.segments.length > 0 ? this.segments[0].Low : this.low;
      }
      Val(t2) {
        if (this.segments.length === 0)
          return t2.slice(this.low, this.high);
        if (this.segments.length === 1)
          return t2.slice(this.segments[0].Low, this.segments[0].High);
        const e2 = [];
        for (const r3 of this.segments)
          e2.push(t2.slice(r3.Low, r3.High));
        const r2 = e2.reduce((t3, e3) => t3 + e3.length, 0), s2 = new Uint8Array(r2);
        let n3 = 0;
        for (const t3 of e2)
          s2.set(t3, n3), n3 += t3.length;
        return s2;
      }
      ValStr(t2) {
        return new TextDecoder().decode(this.Val(t2));
      }
      ValTyped(t2) {
        const e2 = this.ValStr(t2);
        if (this.isString)
          return e2;
        if (sr.test(e2))
          return e2 === "true";
        if (nr.test(e2)) {
          const t3 = parseInt(e2, 10);
          return isNaN(t3) ? e2 : t3;
        }
        if (ir.test(e2)) {
          const t3 = parseFloat(e2);
          return isNaN(t3) ? e2 : t3;
        }
        return e2;
      }
      IsText() {
        return this.Type === 18 || this.Type === 17;
      }
      IsIndentation() {
        return this.Type === 17;
      }
      IsNonWhitespace(t2) {
        return this.ValStr(t2).trim().length > 0;
      }
      IsShortcodeName() {
        return this.Type === 13;
      }
      IsInlineShortcodeName() {
        return this.Type === 14;
      }
      IsLeftShortcodeDelim() {
        return this.Type === 10 || this.Type === 8;
      }
      IsRightShortcodeDelim() {
        return this.Type === 11 || this.Type === 9;
      }
      IsShortcodeClose() {
        return this.Type === 12;
      }
      IsShortcodeParam() {
        return this.Type === 15;
      }
      IsShortcodeParamVal() {
        return this.Type === 16;
      }
      IsShortcodeMarkupDelimiter() {
        return this.Type === 10 || this.Type === 11;
      }
      IsFrontMatter() {
        return this.Type >= 3 && this.Type <= 6;
      }
      IsDone() {
        return this.Type === 0 || this.Type === 1;
      }
      IsEOF() {
        return this.Type === 1;
      }
      IsError() {
        return this.Type === 0;
      }
      ToString(t2) {
        const e2 = this.Val(t2), r2 = this.ValStr(t2), s2 = function(t3) {
          const e3 = t3;
          return e3 < 0 || e3 >= or.length - 1 ? `ItemType(${e3})` : ar.slice(or[e3], or[e3 + 1]);
        }(this.Type);
        switch (true) {
          case this.Type === 1:
            return "EOF";
          case this.Type === 0:
            return r2;
          case this.Type === 17:
            return `${s2}:[${n3 = r2, n3.replace(/ /g, "\u2423").replace(/\t/g, "\u2192")}]`;
          case this.Type > 19:
            return `<${r2}>`;
          case e2.length > 50:
            return `${s2}:${r2.substring(0, 20)}...`;
          default:
            return `${s2}:[${r2}]`;
        }
        var n3;
      }
    };
    var sr = /^(true|false)$/;
    var nr = /^[-+]?\d+$/;
    var ir = /^[-+]?\d*\.\d+$/;
    var ar = "tErrortEOFTypeLeadSummaryDividerTypeFrontMatterYAMLTypeFrontMatterTOMLTypeFrontMatterJSONTypeFrontMatterORGTypeIgnoretLeftDelimScNoMarkuptRightDelimScNoMarkuptLeftDelimScWithMarkuptRightDelimScWithMarkuptScClosetScNametScNameInlinetScParamtScParamValtIndentationtTexttKeywordMarker";
    var or = [0, 6, 10, 32, 51, 70, 89, 107, 117, 137, 158, 180, 203, 211, 218, 231, 239, 250, 262, 267, 281];
    var hr = -1;
    var cr = (new Uint8Array([239, 187, 191]), new TextEncoder().encode("<!--more-->"));
    var ur = new TextEncoder().encode("# more");
    var lr = new TextEncoder().encode("+++");
    var fr = new TextEncoder().encode("---");
    var wr = new TextEncoder().encode("#+");
    var dr = new TextEncoder().encode("{{");
    var gr = new TextEncoder().encode("{{<");
    var pr = new TextEncoder().encode(">}}");
    var mr = new TextEncoder().encode("{{%");
    var yr = new TextEncoder().encode("%}}");
    var br = new TextEncoder().encode("/*");
    var Er = new TextEncoder().encode("*/");
    var Sr = new TextEncoder().encode("inline ");
    var vr = class {
      constructor(t2) {
        __publicField(this, "l");
        __publicField(this, "skipAll");
        __publicField(this, "handlers");
        __publicField(this, "skipIndexes");
        this.l = t2, this.skipAll = false, this.handlers = [], this.skipIndexes = [];
      }
      skip() {
        if (this.skipAll)
          return -1;
        this.skipIndexes = [];
        let t2 = false;
        for (const e2 of this.handlers) {
          if (e2.skipAll)
            continue;
          const r2 = e2.skip();
          r2 !== -1 && (t2 = true, this.skipIndexes.push(r2));
        }
        return t2 ? function(...t3) {
          let e2 = -1;
          for (const r2 of t3)
            r2 < 0 || (e2 === -1 || r2 < e2) && (e2 = r2);
          return e2;
        }(...this.skipIndexes) : (this.skipAll = true, -1);
      }
      lex(t2) {
        if (this.skipAll)
          return null;
        this.l.pos > this.l.start && this.l.emit(18);
        for (const e2 of this.handlers) {
          if (e2.skipAll)
            continue;
          const [r2, s2] = e2.lexFunc(t2, e2.l);
          if (r2 === null || s2)
            return r2;
        }
        return this.l.pos++, t2;
      }
    };
    var Tr = class {
      constructor(t2, e2, r2) {
        __publicField(this, "l");
        __publicField(this, "skipAll");
        __publicField(this, "skipFunc");
        __publicField(this, "lexFunc");
        this.l = t2, this.skipAll = false, this.skipFunc = e2, this.lexFunc = r2;
      }
      skip() {
        if (this.skipAll)
          return -1;
        const t2 = this.skipFunc(this.l);
        return t2 === -1 && (this.skipAll = true), t2;
      }
    };
    function xr(t2) {
      return t2 === 32 || t2 === 9;
    }
    function Pr(t2) {
      return Rr(t2) || t2 === 45;
    }
    function $r(t2) {
      return t2 === 13 || t2 === 10;
    }
    function Rr(t2) {
      return t2 === 95 || t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122 || t2 >= 48 && t2 <= 57;
    }
    var Lr = class {
      constructor(t2) {
        __publicField(this, "items");
        __publicField(this, "lastPos");
        this.items = t2, this.lastPos = -1;
      }
      Next() {
        return this.lastPos++, this.Current();
      }
      Current() {
        if (this.lastPos >= this.items.length) {
          const t2 = new rr();
          return t2.Type = 0, t2.Err = new Error("no more tokens"), t2;
        }
        return this.items[this.lastPos];
      }
      Backup() {
        if (this.lastPos < 0)
          throw new Error("need to go forward before going back");
        this.lastPos--;
      }
      Pos() {
        return this.lastPos;
      }
      IsValueNext() {
        const t2 = this.Peek();
        return t2.Type !== 0 && t2.Type !== 1;
      }
      Peek() {
        return this.items[this.lastPos + 1];
      }
      PeekWalk(t2) {
        for (let e2 = this.lastPos + 1; e2 < this.items.length && t2(this.items[e2]); e2++)
          ;
      }
      Consume(t2) {
        for (let e2 = 0; e2 < t2; e2++) {
          const t3 = this.Next();
          if (t3.Type === 0 || t3.Type === 1) {
            this.Backup();
            break;
          }
        }
      }
      LineNumber(t2) {
        const e2 = new Uint8Array([10]), r2 = t2.slice(0, this.Current().low);
        let s2 = 0;
        for (let t3 = 0; t3 < r2.length; t3++)
          r2[t3] === e2[0] && s2++;
        return s2 + 1;
      }
    };
    var Nr = class {
      constructor(t2, e2, r2) {
        __publicField(this, "input");
        __publicField(this, "stateStart");
        __publicField(this, "state");
        __publicField(this, "pos");
        __publicField(this, "start");
        __publicField(this, "width");
        __publicField(this, "sectionHandlers");
        __publicField(this, "cfg");
        __publicField(this, "summaryDivider");
        __publicField(this, "summaryDividerChecked");
        __publicField(this, "lexerShortcodeState");
        __publicField(this, "items");
        __publicField(this, "err");
        __publicField(this, "inFrontMatter");
        __publicField(this, "parenDepth");
        this.input = t2, this.stateStart = e2, this.state = null, this.pos = 0, this.start = 0, this.width = 0, this.cfg = r2, this.summaryDivider = null, this.summaryDividerChecked = false, this.err = null, this.items = [], this.inFrontMatter = false, this.parenDepth = 0, this.lexerShortcodeState = { currLeftDelimItem: 8, currRightDelimItem: 9, isInline: false, currShortcodeName: "", closingState: 0, elementStepNum: 0, paramElements: 0, paramState: 0, openShortcodes: {} }, this.lexSummaryDivider = this.lexSummaryDivider.bind(this), this.lexMainSection = this.lexMainSection.bind(this), this.lexIdentifierInShortcode = this.lexIdentifierInShortcode.bind(this), this.lexEndOfShortcode = this.lexEndOfShortcode.bind(this), this.lexShortcodeLeftDelim = this.lexShortcodeLeftDelim.bind(this), this.lexShortcodeRightDelim = this.lexShortcodeRightDelim.bind(this), this.lexShortcodeParam = this.lexShortcodeParam.bind(this), this.lexShortcodeValue = this.lexShortcodeValue.bind(this), this.lexShortcodeValueQuoted = this.lexShortcodeValueQuoted.bind(this), this.lexShortcodeValueUnquoted = this.lexShortcodeValueUnquoted.bind(this), this.lexInsideShortcode = this.lexInsideShortcode.bind(this), this.lexDone = this.lexDone.bind(this), this.sectionHandlers = function(t3) {
          const e3 = new vr(t3), r3 = new Tr(t3, (t4) => t4.index(dr), (t4, e4) => {
            if (!e4.isShortCodeStart())
              return [t4, false];
            if (e4.lexerShortcodeState.isInline) {
              const t5 = e4.input.slice(e4.pos + 3), r4 = function(t6) {
                for (let e5 = 0; e5 < t6.length; e5++)
                  if (!xr(t6[e5])) {
                    if (t6[e5] === 47)
                      return e5;
                    break;
                  }
                return -1;
              }(t5);
              if (r4 !== e4.input.length - 1) {
                const s3 = new TextDecoder().decode(t5.slice(r4 + 1)).trim();
                if (r4 === -1 || !s3.startsWith(e4.lexerShortcodeState.currShortcodeName + " "))
                  return [e4.errorf("inline shortcodes do not support nesting"), true];
              }
            }
            return e4.hasPrefix(mr) ? (e4.lexerShortcodeState.currLeftDelimItem = 10, e4.lexerShortcodeState.currRightDelimItem = 11) : (e4.lexerShortcodeState.currLeftDelimItem = 8, e4.lexerShortcodeState.currRightDelimItem = 9), [e4.lexShortcodeLeftDelim, true];
          }), s2 = new Tr(t3, (t4) => t4.summaryDividerChecked || !t4.summaryDivider ? -1 : t4.index(t4.summaryDivider), (t4, e4) => e4.summaryDivider && e4.hasPrefix(e4.summaryDivider) ? (e4.summaryDividerChecked = true, e4.pos += e4.summaryDivider.length, e4.consumeSpace(), e4.emit(2), [t4, true]) : [t4, false]);
          return e3.handlers = [r3, s2], e3.skipIndexes = new Array(e3.handlers.length), e3;
        }(this);
      }
      Iterator() {
        return t2 = this.items, new Lr(t2);
        var t2;
      }
      Input() {
        return this.input;
      }
      run() {
        for (this.state = this.stateStart; this.state !== null; )
          this.state = this.state(this);
        return this;
      }
      next() {
        if (this.pos >= this.input.length)
          return this.width = 0, hr;
        const t2 = this.input[this.pos];
        return this.width = 1, this.pos += this.width, t2;
      }
      peek() {
        const t2 = this.next();
        return this.backup(), t2;
      }
      backup() {
        this.pos -= this.width;
      }
      append(t2) {
        t2.Pos() < this.input.length && (t2.Type === 7 && this.input[t2.Pos()] === 239 ? t2.firstByte = 239 : t2.firstByte = this.input[t2.Pos()]), this.items.push(t2);
      }
      emit(t2) {
        const e2 = () => {
          this.start = this.pos;
        };
        if (t2 === 18)
          for (let r3 = this.pos - 1; r3 >= this.start; r3--) {
            const s2 = this.input[r3];
            if (s2 !== 32 && s2 !== 9 && s2 !== 13 && s2 !== 10)
              break;
            if (r3 === this.start && s2 !== 10) {
              const t3 = new rr();
              return t3.Type = 17, t3.low = this.start, t3.high = this.pos, this.append(t3), void e2();
            }
            if (s2 === 10 && r3 < this.pos - 1) {
              const s3 = new rr();
              s3.Type = t2, s3.low = this.start, s3.high = r3 + 1, this.append(s3);
              const n3 = new rr();
              return n3.Type = 17, n3.low = r3 + 1, n3.high = this.pos, this.append(n3), void e2();
            }
            if (s2 === 10 && r3 === this.pos - 1)
              break;
          }
        const r2 = new rr();
        r2.Type = t2, r2.low = this.start, r2.high = this.pos, r2.low < this.input.length && (t2 === 7 && this.input[r2.low] === 239 ? r2.firstByte = 239 : r2.firstByte = this.input[r2.low]), this.append(r2), e2();
      }
      emitString(t2) {
        const e2 = new rr();
        e2.Type = t2, e2.low = this.start, e2.high = this.pos, e2.isString = true, this.pos > this.start && (e2.firstByte = this.input[this.start]), this.items.push(e2), this.start = this.pos;
      }
      isEOF() {
        return this.pos >= this.input.length;
      }
      ignoreEscapesAndEmit(t2, e2) {
        let r2 = this.start, s2 = r2;
        const n3 = [];
        for (; r2 < this.pos; ) {
          const t3 = 1;
          this.input[r2] === 92 && (r2 > s2 && n3.push({ Low: s2, High: r2 }), s2 = r2 + t3), r2 += t3;
        }
        if (s2 < this.pos && n3.push({ Low: s2, High: this.pos }), n3.length > 0) {
          const e3 = new rr();
          e3.Type = t2, e3.segments = n3, n3[0].High > n3[0].Low && (e3.firstByte = this.input[n3[0].Low]), this.items.push(e3), this.start = this.pos;
        }
        this.start = this.pos;
      }
      current() {
        return this.input.slice(this.start, this.pos);
      }
      ignore() {
        this.start = this.pos;
      }
      errorf(t2, ...e2) {
        const r2 = new Error(t2.replace(/%[a-z]/g, () => String(e2.shift()))), s2 = new rr();
        return s2.Type = 0, s2.Err = r2, s2.low = this.start, s2.high = this.pos, this.append(s2), null;
      }
      consumeCRLF() {
        let t2 = false;
        const e2 = this.peek();
        return e2 === 13 ? (this.next(), this.peek() === 10 && (this.next(), t2 = true)) : e2 === 10 && (this.next(), t2 = true), t2;
      }
      consumeToSpace() {
        for (; ; ) {
          const t2 = this.next();
          if (t2 === hr || xr(t2))
            return void this.backup();
        }
      }
      consumeSpace() {
        for (; ; ) {
          const t2 = this.next();
          if (t2 === hr || !this.isUnicodeSpace(t2))
            return void this.backup();
        }
      }
      isUnicodeSpace(t2) {
        return t2 === 32 || t2 === 9 || t2 === 10 || t2 === 12 || t2 === 13 || t2 === 133 || t2 === 160 || t2 === 8192 || t2 === 8193 || t2 === 8194 || t2 === 8195 || t2 === 8196 || t2 === 8197 || t2 === 8198 || t2 === 8199 || t2 === 8200 || t2 === 8201 || t2 === 8202 || t2 === 8232 || t2 === 8233 || t2 === 8239 || t2 === 8287 || t2 === 12288;
      }
      index(t2) {
        const e2 = this.input.slice(this.pos), r2 = t2.length, s2 = e2.length;
        if (r2 > s2)
          return -1;
        t:
          for (let n3 = 0; n3 <= s2 - r2; n3++) {
            for (let s3 = 0; s3 < r2; s3++)
              if (e2[n3 + s3] !== t2[s3])
                continue t;
            return n3;
          }
        return -1;
      }
      hasPrefix(t2) {
        if (this.pos + t2.length > this.input.length)
          return false;
        for (let e2 = 0; e2 < t2.length; e2++)
          if (this.input[this.pos + e2] !== t2[e2])
            return false;
        return true;
      }
      isShortCodeStart() {
        return this.hasPrefix(mr) || this.hasPrefix(gr);
      }
      lexFrontMatterSection(t2, e2, r2, s2) {
        for (let t3 = 0; t3 < 2; t3++)
          if (this.next() !== e2)
            return this.errorf(`invalid ${r2} delimiter`);
        let n3, i2 = this.consumeCRLF();
        for (this.ignore(); ; ) {
          if (!i2 && (n3 = this.next(), n3 === hr))
            return this.errorf(`EOF looking for end ${r2} front matter delimiter`);
          if ((i2 || $r(n3)) && this.hasPrefix(s2)) {
            this.emit(t2), this.pos += 3, this.consumeCRLF(), this.ignore();
            break;
          }
          i2 = false;
        }
        return () => this.lexMainSection();
      }
      currentLeftShortcodeDelimItem() {
        return this.lexerShortcodeState.currLeftDelimItem;
      }
      currentRightShortcodeDelimItem() {
        return this.lexerShortcodeState.currRightDelimItem;
      }
      currentLeftShortcodeDelim() {
        return this.lexerShortcodeState.currLeftDelimItem === 10 ? mr : gr;
      }
      currentRightShortcodeDelim() {
        return this.lexerShortcodeState.currRightDelimItem === 11 ? yr : pr;
      }
      lexIdentifier() {
        for (; ; )
          if (!Pr(this.next()))
            return this.backup(), new TextDecoder().decode(this.input.slice(this.start, this.pos)).length === 0 || this.emit(15), null;
      }
      lexMainSection() {
        if (this.isEOF())
          return () => this.lexDone();
        const t2 = this.sectionHandlers.skip();
        if (t2 === -1)
          return this.pos = this.input.length, () => this.lexDone();
        t2 > 0 && (this.pos += t2);
        const e2 = this.sectionHandlers.lex(this.lexMainSection);
        return e2 !== null ? e2 : (this.pos = this.input.length, this.lexDone);
      }
      lexInlineShortcodeContent() {
        for (; ; ) {
          if (this.pos >= this.input.length)
            return this.errorf("unclosed inline shortcode");
          if (this.hasPrefix(mr) || this.hasPrefix(gr))
            return this.errorf("inline shortcodes do not support nesting");
          if (this.hasPrefix(this.currentRightShortcodeDelim()))
            return this.backup(), this.pos > this.start && this.emit(18), () => this.lexShortcodeRightDelim();
          this.next();
        }
      }
      lexIdentifierInShortcode() {
        let t2 = false;
        for (; ; ) {
          const e2 = this.next();
          switch (true) {
            case Pr(e2):
            case e2 === 47:
              break;
            case e2 === 46:
              if (this.lexerShortcodeState.isInline = this.hasPrefix(Sr), !this.lexerShortcodeState.isInline)
                return this.errorf("period in shortcode name only allowed for inline identifiers");
              break;
            default:
              this.backup();
              const r2 = new TextDecoder().decode(this.input.slice(this.start, this.pos));
              return this.lexerShortcodeState.closingState > 0 && !this.lexerShortcodeState.openShortcodes[r2] ? this.errorf(`closing tag for shortcode '${r2}' does not match start tag`) : (this.lexerShortcodeState.closingState > 0 && (this.lexerShortcodeState.openShortcodes[r2] = false, t2 = true), this.lexerShortcodeState.closingState = 0, this.lexerShortcodeState.currShortcodeName = r2, this.lexerShortcodeState.openShortcodes[r2] = true, this.lexerShortcodeState.elementStepNum++, this.lexerShortcodeState.isInline ? this.emit(14) : this.emit(13), t2 ? () => this.lexEndOfShortcode() : this.lexInsideShortcode);
          }
        }
      }
      lexEndOfShortcode() {
        return this.lexerShortcodeState.isInline = false, this.hasPrefix(this.currentRightShortcodeDelim()) ? () => this.lexShortcodeRightDelim() : xr(this.next()) !== true ? this.errorf("unclosed shortcode") : (this.ignore(), () => this.lexEndOfShortcode());
      }
      lexShortcodeLeftDelim() {
        return this.pos += this.currentLeftShortcodeDelim().length, this.isComment() ? () => this.lexComment() : (this.emit(this.lexerShortcodeState.currLeftDelimItem), this.lexerShortcodeState.elementStepNum = 0, this.lexerShortcodeState.paramElements = 0, this.lexerShortcodeState.paramState = 0, this.start = this.pos, this.lexInsideShortcode);
      }
      peekString(t2) {
        const e2 = (Uint8Array, t2.length);
        if (this.pos + e2 > this.input.length)
          return null;
        const r2 = this.input.slice(this.pos, this.pos + e2);
        if (t2 instanceof Uint8Array) {
          for (let s2 = 0; s2 < e2; s2++)
            if (r2[s2] !== t2[s2])
              return null;
          return new TextDecoder().decode(r2);
        }
        {
          const e3 = new TextDecoder().decode(r2);
          return e3 === t2 ? e3 : null;
        }
      }
      lexSummaryDivider() {
        if (!this.hasPrefix(cr))
          return null;
        if (this.start < this.pos) {
          const t3 = new rr();
          t3.Type = 18, t3.low = this.start, t3.high = this.pos, t3.low < this.input.length && (t3.firstByte = this.input[t3.low]), this.append(t3);
        }
        const t2 = new rr();
        return t2.Type = 2, t2.low = this.pos, t2.high = this.pos + cr.length, t2.low < this.input.length && (t2.firstByte = this.input[t2.low]), this.append(t2), this.pos += cr.length, this.start = this.pos, () => this.lexMainSection();
      }
      handleBOM() {
        if (this.pos + 3 <= this.input.length) {
          const t2 = this.input.slice(this.pos, this.pos + 3);
          if (t2[0] === 239 && t2[1] === 187 && t2[2] === 191) {
            const t3 = new rr();
            return t3.Type = 7, t3.low = this.pos, t3.high = this.pos + 3, t3.firstByte = 239, this.append(t3), this.pos += 3, this.start = this.pos, true;
          }
        }
        return false;
      }
      lexIntroSection() {
        this.summaryDivider = cr, this.pos === 0 && this.handleBOM();
        t:
          for (; ; ) {
            const t2 = this.next();
            if (t2 === hr)
              break;
            switch (true) {
              case t2 === 43:
                if (this.hasPrefix(lr.slice(1)))
                  return () => this.lexFrontMatterSection(4, t2, "TOML", lr);
                this.backup();
                break t;
              case t2 === 45:
                if (this.hasPrefix(fr.slice(1)))
                  return () => this.lexFrontMatterSection(3, t2, "YAML", fr);
                this.backup();
                break t;
              case t2 === 123:
                return Fr;
              case t2 === 35:
                return Dr;
              case t2 === 65279:
                this.emit(7);
                break;
              case (!xr(t2) && !$r(t2)):
                break t;
            }
          }
        return () => this.lexMainSection();
      }
      lexInsideShortcode() {
        if (this.hasPrefix(this.currentRightShortcodeDelim()))
          return this.lexShortcodeRightDelim;
        const t2 = this.next();
        if (t2 === hr)
          return this.errorf("unclosed shortcode action");
        if (xr(t2) || $r(t2))
          this.ignore();
        else {
          if (t2 === 61) {
            this.consumeSpace(), this.ignore();
            const t3 = this.peek();
            return t3 === 34 || t3 === 92 ? this.lexShortcodeQuotedParamVal(t3 !== 92, 16) : t3 === 96 ? this.lexShortCodeParamRawStringVal(16) : this.lexShortcodeParamVal;
          }
          if (t2 === 47) {
            if (this.lexerShortcodeState.currShortcodeName === "")
              return this.errorf("got closing shortcode, but none is open");
            this.lexerShortcodeState.closingState++, this.lexerShortcodeState.isInline = false, this.emit(12);
          } else {
            if (t2 !== 92)
              return this.lexerShortcodeState.elementStepNum > 0 && (Pr(t2) || t2 === 34 || t2 === 96) ? (this.backup(), this.lexShortcodeParam(false)) : Rr(t2) ? (this.backup(), this.lexIdentifierInShortcode) : this.errorf(`unrecognized character in shortcode action: U+${t2.toString(16).toUpperCase()} '${String.fromCharCode(t2)}'. Note: Parameters with non-alphanumeric args must be quoted`);
            if (this.ignore(), this.peek() === 34 || this.peek() === 96)
              return this.lexShortcodeParam(true);
          }
        }
        return this.lexInsideShortcode;
      }
      lexShortcodeParam(t2) {
        let e2, r2 = true, s2 = false;
        for (; ; ) {
          if (e2 = this.next(), r2) {
            if (e2 === 34 || e2 === 96 && !t2)
              return this.lexerShortcodeState.paramElements === 2 ? this.errorf("got quoted positional parameter. Cannot mix named and positional parameters") : (this.lexerShortcodeState.paramElements = 1, this.backup(), e2 === 34 ? () => this.lexShortcodeQuotedParamVal(!t2, 15) : () => this.lexShortCodeParamRawStringVal(15));
            if (e2 === 96 && t2)
              return this.errorf("unrecognized escape character");
            r2 = false;
          } else if (e2 === 61) {
            this.backup(), s2 = true;
            break;
          }
          if (!Pr(e2) && e2 !== 46) {
            this.backup();
            break;
          }
        }
        if (this.lexerShortcodeState.paramElements === 0)
          this.lexerShortcodeState.paramElements++, s2 && this.lexerShortcodeState.paramElements++;
        else {
          if (s2 && this.lexerShortcodeState.paramElements === 1)
            return this.errorf(`got named parameter '${new TextDecoder().decode(this.current())}'. Cannot mix named and positional parameters`);
          if (!s2 && this.lexerShortcodeState.paramElements === 2)
            return this.errorf(`got positional parameter '${new TextDecoder().decode(this.current())}'. Cannot mix named and positional parameters`);
        }
        return this.emit(15), this.lexInsideShortcode;
      }
      lexShortcodeParamVal() {
        const t2 = this.next();
        if (xr(t2))
          return this.ignore(), () => this.lexShortcodeParamVal();
        switch (this.backup(), t2) {
          case 34:
            return this.next(), this.ignore(), () => this.lexShortcodeQuotedParamVal(false, 16);
          case 96:
            return this.next(), this.ignore(), () => this.lexShortCodeParamRawStringVal(16);
          default:
            return () => this.lexShortcodeValueUnquoted();
        }
      }
      lexShortcodeValueUnquoted() {
        for (; ; ) {
          const t2 = this.next();
          if (t2 === hr || xr(t2) || this.isRightShortcodeDelim())
            return this.backup(), this.pos > this.start && this.emit(16), this.lexInsideShortcode;
        }
      }
      lexShortcodeQuotedParamVal(t2, e2) {
        let r2 = false, s2 = false, n3 = 0;
        t:
          for (; ; ) {
            const e3 = this.next();
            switch (true) {
              case e3 === 92:
                if (this.peek() === 34) {
                  if (r2 && !t2) {
                    this.backup();
                    break t;
                  }
                  r2 && (s2 = true, n3 = 1);
                } else if (this.peek() === 96)
                  return this.errorf("unrecognized escape character");
                break;
              case e3 === hr:
              case e3 === 10:
                return this.errorf(`unterminated quoted string in shortcode parameter-argument: '${new TextDecoder().decode(this.current())}'`);
              case e3 === 34:
                if (n3 === 0) {
                  if (r2) {
                    this.backup();
                    break t;
                  }
                  r2 = true, this.ignore();
                } else
                  n3 = 0;
            }
          }
        s2 ? this.ignoreEscapesAndEmit(e2, true) : this.emitString(e2);
        const i2 = this.next();
        return i2 === 92 ? this.peek() === 34 && (this.ignore(), this.next(), this.ignore()) : i2 === 34 ? this.ignore() : this.backup(), this.lexInsideShortcode;
      }
      lexShortCodeParamRawStringVal(t2) {
        let e2 = false;
        t:
          for (; ; )
            switch (this.next()) {
              case 96:
                if (e2) {
                  this.backup();
                  break t;
                }
                e2 = true, this.ignore();
                break;
              case hr:
                return this.errorf(`unterminated raw string in shortcode parameter-argument: '${new TextDecoder().decode(this.input.slice(this.start, this.pos))}'`);
            }
        return this.emitString(t2), this.next(), this.ignore(), this.lexInsideShortcode;
      }
      lexDone() {
        return this.pos > this.start && this.emit(18), this.emit(1), null;
      }
      lexShortcodeRightDelim() {
        return this.pos += this.currentRightShortcodeDelim().length, this.emit(this.lexerShortcodeState.currRightDelimItem), this.lexerShortcodeState.closingState = 0, () => this.lexMainSection();
      }
      lexShortcodeValue() {
        switch (this.next()) {
          case hr:
            return this.errorf("unterminated quoted string in shortcode parameter");
          case 32:
          case 9:
            return this.ignore(), () => this.lexShortcodeValue();
          case 34:
            return this.ignore(), () => this.lexShortcodeValueQuoted();
          default:
            return this.backup(), () => this.lexShortcodeValueUnquoted();
        }
      }
      lexShortcodeValueQuoted() {
        for (; ; )
          switch (this.next()) {
            case hr:
              return this.errorf("unterminated quoted string in shortcode parameter");
            case 92:
              this.peek() === 34 && this.next();
              break;
            case 34:
              return this.backup(), this.emitString(16), this.next(), this.ignore(), this.lexInsideShortcode;
          }
      }
      isRightShortcodeDelim() {
        return this.hasPrefix(this.currentRightShortcodeDelim());
      }
      lexComment() {
        const t2 = this.index(new Uint8Array([...Er, ...this.currentRightShortcodeDelim()]));
        return t2 <= 1 ? this.errorf("comment must be closed") : (this.emit(18), this.pos += br.length, this.ignore(), this.pos += t2 - br.length, this.emit(18), this.pos += Er.length, this.ignore(), this.pos += this.currentRightShortcodeDelim().length, this.emit(18), this.lexMainSection);
      }
      isComment() {
        return !(this.pos + 2 > this.input.length) && this.input[this.pos] === 47 && this.input[this.pos + 1] === 42;
      }
    };
    function Fr(t2) {
      t2.backup();
      let e2 = false, r2 = 0;
      for (; ; ) {
        const s2 = t2.next();
        switch (true) {
          case s2 === hr:
            return t2.errorf("unexpected EOF parsing JSON front matter");
          case s2 === 123:
            e2 || r2++;
            break;
          case s2 === 125:
            e2 || r2--;
            break;
          case s2 === 34:
            e2 = !e2;
            break;
          case s2 === 92:
            t2.next();
        }
        if (r2 === 0)
          break;
      }
      return t2.consumeCRLF(), t2.emit(5), () => t2.lexMainSection();
    }
    function Dr(t2) {
      if (t2.summaryDivider = ur, t2.backup(), !t2.hasPrefix(wr))
        return () => t2.lexMainSection();
      t:
        for (; ; ) {
          const e2 = t2.next();
          switch (true) {
            case e2 === 10:
              if (!t2.hasPrefix(wr))
                break t;
              break;
            case e2 === hr:
              break t;
          }
        }
      return t2.emit(6), () => t2.lexMainSection();
    }
    function Ar(t2) {
      return t2.lexIntroSection();
    }
    var kr = A("markdown", { component: "pageparser" });
    q();
    var Ir = A("markdown", { component: "parseinfo" });
    var Cr = class {
      constructor(t2, e2) {
        __publicField(this, "source");
        __publicField(this, "posMainContent", -1);
        __publicField(this, "itemsStep1", []);
        __publicField(this, "handlers");
        this.source = t2, this.handlers = e2, this.validateHandlers();
      }
      validateHandlers() {
        if (!this.handlers.frontMatterHandler())
          throw new Error("no front matter handler");
        if (!this.handlers.summaryHandler())
          throw new Error("no summary handler");
        if (!this.handlers.shortcodeHandler())
          throw new Error("no shortcode handler");
        if (!this.handlers.bytesHandler())
          throw new Error("no bytes handler");
      }
      isEmpty() {
        return this.itemsStep1.length === 0;
      }
      async parse() {
        const t2 = function(t3, e2 = {}) {
          const [r2, s2] = function(t4, e3) {
            const [r3, s3] = function(t5, e4) {
              const r4 = function(t6, e5, r5) {
                return new Nr(t6, Ar, r5);
              }(t5, 0, e4);
              return r4.run(), [r4, null];
            }(t4, e3);
            return s3 ? [[], s3] : [r3.items, r3.err];
          }(t3, e2);
          if (s2)
            throw kr.error("Error parsing bytes:", s2), s2;
          return r2;
        }(this.source, {});
        this.itemsStep1 = t2;
      }
      async handle() {
        if (this.isEmpty())
          return;
        const t2 = new Lr(this.itemsStep1);
        for (; ; ) {
          const e2 = t2.Next();
          try {
            if (e2.Type === 7)
              Ir.info(`Ignoring item at position ${e2.Pos()}: ${e2.ValStr(this.source)}`);
            else if (e2.IsFrontMatter()) {
              await this.handlers.frontMatterHandler()(e2);
              const r2 = t2.Peek();
              r2.IsDone() || (this.posMainContent = r2.Pos());
            } else if (e2.Type === 2)
              await this.handlers.summaryHandler()(e2, t2);
            else if (e2.IsLeftShortcodeDelim()) {
              t2.Backup();
              const e3 = t2.Current();
              await this.handlers.shortcodeHandler()(e3, t2);
            } else {
              if (e2.IsEOF())
                break;
              if (e2.IsError())
                throw Ir.error(`Error parsing item at position ${e2.Pos()}: ${e2.Err}`), this.createError(e2.Err || new Error("Unknown parsing error"), e2);
              await this.handlers.bytesHandler()(e2);
            }
          } catch (t3) {
            throw this.createError(t3, e2);
          }
        }
      }
      getMainContentPosition() {
        return this.posMainContent;
      }
      getItems() {
        return this.itemsStep1;
      }
      getSource() {
        return this.source;
      }
      createError(t2, e2) {
        const r2 = function(t3, e3, r3) {
          const s3 = typeof e3 == "string" ? (n3 = e3, new TextEncoder().encode(n3)) : e3;
          var n3;
          if (r3 < 0)
            return { filename: "", line: 1, column: 1, offset: 0 };
          let i2 = 1, a2 = 1;
          for (let t4 = 0; t4 < Math.min(r3, s3.length); t4++)
            s3[t4] === 10 ? (i2++, a2 = 1) : a2++;
          return { filename: "", line: i2, column: a2, offset: r3 };
        }(0, this.source, e2.Pos()), s2 = new Error(`${t2.message} at line ${r2.line}, column ${r2.column}`);
        return s2.position = r2, s2;
      }
    };
    q();
    var Or = A("markdown", { component: "vo/shortcode" });
    var _r = class {
      constructor(t2 = 0, e2 = "", r2 = null, s2 = 0, n3 = 0, i2 = false, a2 = false) {
        __publicField(this, "name");
        __publicField(this, "params");
        __publicField(this, "pos");
        __publicField(this, "length");
        __publicField(this, "rawContent");
        __publicField(this, "placeholder");
        __publicField(this, "inline");
        __publicField(this, "closed");
        __publicField(this, "inner");
        __publicField(this, "ordinal");
        __publicField(this, "indentation");
        __publicField(this, "doMarkup");
        __publicField(this, "isClosing");
        __publicField(this, "info");
        __publicField(this, "templs");
        this.ordinal = t2, this.name = e2, this.params = r2, this.pos = s2, this.length = n3, this.rawContent = "", this.inline = i2, this.closed = a2, this.doMarkup = false, this.isClosing = false, this.placeholder = "", this.inner = [];
      }
      needsInner() {
        return !this.inline;
      }
    };
    var Mr = class {
      constructor(t2, e2 = Date.now()) {
        __publicField(this, "shortcodes", []);
        __publicField(this, "nameSet", /* @__PURE__ */ new Set());
        __publicField(this, "source");
        __publicField(this, "ordinal", 0);
        __publicField(this, "pid");
        __publicField(this, "openShortcodes", /* @__PURE__ */ new Map());
        __publicField(this, "paramElements", 0);
        this.source = t2, this.pid = e2;
      }
      parseItem(t2, e2) {
        const r2 = this.extractShortcode(this.ordinal, 0, e2);
        if (!r2)
          throw new Error("Failed to extract shortcode");
        r2.pos = t2.Pos() + t2.ValStr(this.source).length, r2.length = e2.Current().Pos() + e2.Current().ValStr(this.source).length - r2.pos;
        const s2 = this.source.slice(r2.pos, r2.pos + r2.length);
        return r2.rawContent = new TextDecoder().decode(s2), r2.name && this.nameSet.add(r2.name), r2.params ?? (r2.params = []), r2.placeholder = jr("s", this.pid, this.ordinal), this.ordinal++, this.shortcodes.push(r2), r2;
      }
      extractShortcode(t2, e2, r2) {
        const s2 = new _r(t2);
        if (r2.Pos() > 0) {
          r2.Backup();
          const t3 = r2.Next();
          t3.IsIndentation() && (s2.indentation = t3.ValStr(this.source));
        }
        let n3 = 0, i2 = 0;
        const a2 = e2 + 1;
        let o2 = false;
        const h2 = "failed to extract shortcode";
        let c2 = 0;
        for (; ; ) {
          const t3 = r2.Next();
          if (t3.IsLeftShortcodeDelim()) {
            const e3 = r2.Peek();
            if (e3.IsRightShortcodeDelim())
              throw new Error("shortcode has no name");
            if (e3.IsShortcodeClose())
              continue;
            if (n3 > 0) {
              r2.Backup();
              const t4 = this.extractShortcode(i2, a2, r2);
              i2++, t4 && t4.name && (this.nameSet.add(t4.name), Array.isArray(s2.inner) || (s2.inner = []), s2.inner.push(t4));
            } else
              s2.doMarkup = t3.IsShortcodeMarkupDelimiter();
            n3++;
          } else if (t3.IsRightShortcodeDelim()) {
            if (!s2.inline && !s2.needsInner())
              return this.openShortcodes.set(s2.name, false), s2;
          } else {
            if (t3.IsShortcodeClose()) {
              o2 = true;
              const t4 = r2.Peek();
              if (!s2.inline && !s2.needsInner()) {
                if (t4.IsError())
                  continue;
                throw new Error(`${h2}: shortcode "${s2.name}" does not evaluate .Inner or .InnerDeindent, yet a closing tag was provided`);
              }
              return t4.IsRightShortcodeDelim() ? r2.Consume(1) : (s2.isClosing = true, r2.Consume(2)), s2.inline || this.openShortcodes.set(s2.name, false), s2;
            }
            if (t3.IsText()) {
              Array.isArray(s2.inner) || (s2.inner = []);
              const e3 = t3.ValStr(this.source);
              s2.inner.push(e3);
            } else if (t3.IsShortcodeName() || t3.IsInlineShortcodeName()) {
              if (s2.name = t3.ValStr(this.source).trim(), s2.inline = t3.IsInlineShortcodeName(), this.openShortcodes.has(s2.name) && this.openShortcodes.get(s2.name))
                throw new Error(`shortcode ${s2.name} nested in itself`);
              if (s2.inline || this.openShortcodes.set(s2.name, true), s2.inline) {
                const t4 = this.source.slice(r2.Pos() + 3), e3 = Br(t4, "/");
                if (e3 !== this.source.length - 1) {
                  const r3 = new TextDecoder().decode(t4.slice(e3 + 1));
                  if (e3 === -1 || !r3.startsWith(s2.name + " "))
                    throw new Error("inline shortcodes do not support nesting");
                }
              }
            } else if (t3.IsShortcodeParam()) {
              if (!r2.IsValueNext()) {
                Or.warn(`${h2}: shortcode "${s2.name}" has a parameter without a value`);
                continue;
              }
              if (r2.Peek().IsShortcodeParamVal())
                if (s2.params === null || s2.params === void 0) {
                  const e3 = {}, n4 = t3.ValStr(this.source);
                  r2.Next(), e3[n4] = r2.Current().ValTyped(this.source), s2.params = e3;
                } else {
                  if (Array.isArray(s2.params))
                    throw new Error(`${h2}: invalid state: invalid param type Array for shortcode "${s2.name}", expected a map`);
                  {
                    const e3 = t3.ValStr(this.source);
                    r2.Next(), s2.params[e3] = r2.Current().ValTyped(this.source);
                  }
                }
              else if (s2.params === null || s2.params === void 0) {
                const e3 = [];
                e3.push(t3.ValTyped(this.source)), s2.params = e3;
              } else {
                if (!Array.isArray(s2.params))
                  throw new Error(`${h2}: invalid state: invalid param type Object for shortcode "${s2.name}", expected an array`);
                s2.params.push(t3.ValTyped(this.source));
              }
            } else if (t3.IsShortcodeParamVal()) {
              if (c2 === 0 && (c2 = 1), Array.isArray(s2.params))
                s2.params.push(t3.ValTyped(this.source));
              else if (s2.params === null || s2.params === void 0) {
                const e3 = [];
                e3.push(t3.ValTyped(this.source)), s2.params = e3;
              }
            } else if (t3.IsDone()) {
              if (!t3.IsError() && !o2 && s2.needsInner())
                throw new Error(`${h2}: shortcode "${s2.name}" must be closed or self-closed`);
              r2.Backup();
              break;
            }
          }
        }
        return s2.inline || this.openShortcodes.set(s2.name, false), s2;
      }
      getShortcodes() {
        return this.shortcodes;
      }
      getNames() {
        return Array.from(this.nameSet);
      }
    };
    var Ur = (jr("TOC", 0, 0), "HAHAHUGOSHORTCODE");
    function jr(t2, e2, r2) {
      return `${Ur}${t2}${e2}${r2}HBHB`;
    }
    function Br(t2, e2) {
      const r2 = e2.charCodeAt(0);
      for (let e3 = 0; e3 < t2.length; e3++)
        if (!qr(t2[e3]) && t2[e3] === r2)
          return e3;
      return -1;
    }
    function qr(t2) {
      return t2 === 32 || t2 === 9 || t2 === 13 || t2 === 10;
    }
    var Wr = class {
      constructor(t2) {
        __publicField(this, "type");
        __publicField(this, "mainType");
        __publicField(this, "subType");
        __publicField(this, "delimiter");
        __publicField(this, "firstSuffix");
        __publicField(this, "mimeSuffix");
        __publicField(this, "suffixesCSV");
        this.type = t2.type, this.mainType = t2.mainType, this.subType = t2.subType, this.delimiter = t2.delimiter, this.firstSuffix = t2.firstSuffix, this.mimeSuffix = t2.mimeSuffix, this.suffixesCSV = t2.suffixesCSV;
      }
      sub() {
        if (this.subType)
          return this.subType;
        const t2 = this.type.split("/");
        return t2.length === 2 ? t2[1].split("+")[0] : "";
      }
      getMimeSuffix() {
        if (this.mimeSuffix)
          return this.mimeSuffix;
        const t2 = this.type.indexOf("+");
        return t2 !== -1 ? this.type.substring(t2 + 1) : void 0;
      }
      getSuffixList() {
        return this.suffixesCSV ? this.suffixesCSV.split(",") : [];
      }
    };
    q(), A("markdown", { component: "content" });
    var zr = "HUGOMORE42";
    var Hr = new TextEncoder().encode(`

${zr}

`);
    var Gr = class {
      constructor(t2, e2) {
        __publicField(this, "hasSummaryDivider", false);
        __publicField(this, "summaryTruncated", false);
        __publicField(this, "rawSource");
        __publicField(this, "items", []);
        __publicField(this, "renderer");
        this.rawSource = t2, this.renderer = e2;
      }
      isEmpty() {
        return !this.rawSource || this.rawSource.length === 0;
      }
      setSummaryDivider() {
        this.hasSummaryDivider = true;
      }
      getHasSummaryDivider() {
        return this.hasSummaryDivider;
      }
      setSummaryTruncated() {
        this.summaryTruncated = true;
      }
      getTruncated() {
        return this.summaryTruncated;
      }
      addReplacement(t2, e2) {
        const r2 = { val: t2, source: e2 };
        this.items.push(r2);
      }
      addShortcode(t2) {
        this.items.push(t2);
      }
      addItem(t2) {
        this.items.push(t2);
      }
      addItems(...t2) {
        this.items.push(...t2);
      }
      rawContent() {
        return new TextDecoder().decode(this.rawSource);
      }
      pureContent() {
        const t2 = [], e2 = new TextDecoder(), r2 = new TextEncoder();
        for (const e3 of this.items)
          if (this.isItem(e3)) {
            const r3 = this.rawSource.slice(e3.Pos(), e3.Pos() + e3.Val(this.rawSource).length);
            t2.push(r3);
          } else
            this.isContentReplacement(e3) ? t2.push(e3.val) : this.isShortcode(e3) && t2.push(r2.encode(e3.placeholder));
        const s2 = t2.reduce((t3, e3) => t3 + e3.length, 0), n3 = new Uint8Array(s2);
        let i2 = 0;
        for (const e3 of t2)
          n3.set(e3, i2), i2 += e3.length;
        return e2.decode(n3);
      }
      pureContentWithoutPlaceholder() {
        const t2 = [], e2 = new TextDecoder();
        for (const e3 of this.items)
          if (this.isItem(e3)) {
            const r3 = this.rawSource.slice(e3.Pos(), e3.Pos() + e3.Val(this.rawSource).length);
            t2.push(r3);
          } else
            this.isContentReplacement(e3) ? t2.push(e3.val) : this.isShortcode(e3);
        const r2 = t2.reduce((t3, e3) => t3 + e3.length, 0), s2 = new Uint8Array(r2);
        let n3 = 0;
        for (const e3 of t2)
          s2.set(e3, n3), n3 += e3.length;
        return e2.decode(s2);
      }
      renderedContent(t2) {
        let e2 = this.pureContent();
        if (t2) {
          for (const r2 of this.items)
            if (this.isShortcode(r2)) {
              const s2 = t2(r2);
              e2 = e2.replace(r2.placeholder, s2);
            }
        }
        return e2;
      }
      async renderedContentAsync(t2) {
        let e2 = await this.renderer.render(this.pureContent());
        if (t2) {
          for (const r2 of this.items)
            if (this.isShortcode(r2))
              try {
                const s2 = await t2(r2);
                e2 = e2.replace(r2.placeholder, s2);
              } catch (t3) {
              }
        }
        return e2;
      }
      getItems() {
        return [...this.items];
      }
      getShortcodes() {
        return this.items.filter(this.isShortcode);
      }
      getTextItems() {
        return this.items.filter(this.isItem);
      }
      getReplacements() {
        return this.items.filter(this.isContentReplacement);
      }
      extractSummary(t2, e2) {
        const r2 = new TextDecoder().decode(t2), s2 = this.extractSummaryFromHTML(e2, r2, 70, this.containsCJK(r2)), n3 = s2.summaryLowHigh.high > s2.summaryLowHigh.low ? r2.substring(s2.summaryLowHigh.low, s2.summaryLowHigh.high).trim() : "";
        if (n3)
          return this.summaryTruncated = s2.truncated, { summary: n3, truncated: s2.truncated };
        const i2 = this.trimShortHTML(t2);
        return this.summaryTruncated = i2.length < t2.length, { summary: new TextDecoder().decode(t2), truncated: this.summaryTruncated };
      }
      extractSummaryFromHTML(t2, e2, r2, s2) {
        const n3 = { source: e2, summaryLowHigh: { low: 0, high: e2.length }, truncated: false };
        if (r2 <= 0)
          return n3;
        let i2 = 0;
        const a2 = e2.split(/\s+/);
        for (let t3 = 0; t3 < a2.length && i2 < r2; t3++) {
          const o2 = a2[t3].trim();
          if (o2.length !== 0 && !this.isProbablyHTMLToken(o2)) {
            if (s2) {
              const t4 = this.stripHTML(o2), e3 = [...t4].length;
              i2 += t4.length === t4.replace(/[^\u0000-\u007F]/g, "").length ? 1 : e3;
            } else
              i2 += 1;
            if (i2 >= r2) {
              const r3 = a2.slice(0, t3 + 1).join(" "), s3 = e2.indexOf(r3) + r3.length;
              n3.summaryLowHigh = { low: 0, high: Math.min(s3, e2.length) }, n3.truncated = true;
              break;
            }
          }
        }
        return n3;
      }
      containsCJK(t2) {
        return /[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(t2);
      }
      isProbablyHTMLToken(t2) {
        return t2 === ">" || /^<\/?[A-Za-z]+>?$/.test(t2) || /^[A-Za-z]+=["']/.test(t2);
      }
      stripHTML(t2) {
        return t2.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
      }
      trimShortHTML(t2) {
        const e2 = new TextDecoder(), r2 = new TextEncoder();
        let s2 = e2.decode(t2);
        return (s2.match(/<p>/g) || []).length === 1 && (s2 = s2.trim(), s2.startsWith("<p>") && s2.endsWith("</p>") && (s2 = s2.slice(3, -4).trim())), r2.encode(s2);
      }
      cleanDividerPlaceholders(t2) {
        return this.hasSummaryDivider ? t2.replace(new RegExp(zr, "g"), "") : t2;
      }
      getDividedSummary(t2) {
        const e2 = t2;
        if (this.hasSummaryDivider) {
          const t3 = e2.indexOf(zr);
          if (t3 !== -1)
            return e2.substring(0, t3).trim();
        }
        return "";
      }
      async getRenderedSummary(t2, e2) {
        if (this.hasSummaryDivider && t2)
          return this.getDividedSummary(t2);
        const r2 = this.pureContentWithoutPlaceholder(), s2 = new TextEncoder().encode(r2), n3 = new Wr({ type: "text/html", mainType: "text", subType: "html", delimiter: ".", firstSuffix: { suffix: "html", fullSuffix: ".html" }, mimeSuffix: "", suffixesCSV: "html" }), i2 = this.extractSummary(s2, n3);
        let a2 = i2.summary;
        return i2.truncated && (a2 += "..."), e2 && a2.length > e2 && (a2 = a2.substring(0, e2).trim() + "..."), await this.renderer.render(a2);
      }
      getWordCount() {
        return this.pureContent().trim().split(/\s+/).filter((t2) => t2.length > 0).length;
      }
      getReadingTime(t2 = 200) {
        const e2 = this.getWordCount();
        return Math.ceil(e2 / t2);
      }
      isItem(t2) {
        return "Type" in t2 && "firstByte" in t2 && "low" in t2 && "high" in t2;
      }
      isShortcode(t2) {
        return "name" in t2 && "placeholder" in t2 && "params" in t2;
      }
      isContentReplacement(t2) {
        return "val" in t2 && "source" in t2;
      }
    };
    var Vr = p(require_js_yaml());
    var Kr = require_dist();
    var Jr = class {
      constructor(t2) {
        this.buffer = t2;
      }
      bytes() {
        return this.buffer.bytes();
      }
      toString() {
        return new TextDecoder().decode(this.bytes());
      }
    };
    var Yr = class {
      constructor(t2, e2) {
        this.parsingResult = t2, this.renderingResult = e2;
      }
      headers() {
        return this.parsingResult.headers();
      }
      tableOfContents() {
        return this.parsingResult.tableOfContents();
      }
      bytes() {
        return this.renderingResult.bytes();
      }
    };
    q(), A("markdown", { component: "MarkdownImpl" });
    var Zr = class {
      constructor(t2, e2) {
        this.renderer = t2, this.highlighter = e2;
      }
      async render(t2, e2) {
        const r2 = await this.parse(t2), s2 = await this.renderToBytes(t2, e2, r2);
        return new Yr(r2, s2);
      }
      async highlight(t2, e2, r2) {
        return this.highlighter.highlight(t2, e2, r2);
      }
      async highlightCodeBlock(t2, e2) {
        return this.highlighter.highlightCodeBlock(t2, e2);
      }
      async renderCodeblock(t2, e2, r2) {
        return this.highlighter.renderCodeblock(t2, e2, r2);
      }
      isDefaultCodeBlockRenderer() {
        return this.highlighter.isDefaultCodeBlockRenderer();
      }
      async prepareRender(t2) {
        const e2 = await this.parseContent(t2), r2 = e2.frontMatter?.params, s2 = await this.renderer.parse(e2.content.pureContent());
        return { frontMatter: () => r2 || {}, toc: () => s2.tableOfContents(), render: async (t3) => {
          const s3 = await e2.content.renderedContentAsync(t3.shortcodeRenderer), n3 = await e2.content.getRenderedSummary(s3, t3.maxSummaryLength), i2 = e2.content.getWordCount(), a2 = e2.content.getReadingTime(t3.wordsPerMinute), o2 = { renderedContent: e2.content.cleanDividerPlaceholders(s3), wordCount: i2, readingTime: a2 };
          return r2 && (o2.frontMatter = r2), n3 && (o2.summary = n3), o2;
        } };
      }
      async parseAndRenderContent(t2, e2 = {}) {
        const r2 = await this.parseContent(t2), s2 = r2.frontMatter?.params;
        let n3;
        n3 = e2.shortcodeRenderer && r2.shortcodes.length > 0 ? await r2.content.renderedContentAsync(e2.shortcodeRenderer) : r2.content.pureContent();
        const i2 = await this.renderer.render(n3), a2 = r2.content.getDividedSummary(i2), o2 = { renderedContent: i2, wordCount: r2.content.getWordCount(), readingTime: r2.content.getReadingTime(e2.wordsPerMinute) };
        return s2 && (o2.frontMatter = s2), a2 && (o2.summary = a2), o2;
      }
      async parseContent(t2) {
        let e2;
        const r2 = new Gr(t2, this.renderer), s2 = new Mr(t2), n3 = [], i2 = function(t3, e3) {
          return new Cr(t3, e3);
        }(t2, { frontMatterHandler: () => (r3) => {
          e2 = this.parseFrontMatter(r3, t2);
        }, summaryHandler: () => (e3, s3) => {
          let n4 = -1;
          s3.PeekWalk((e4) => (n4 !== -1 || e4.IsDone() || (n4 = e4.Pos()), !e4.IsNonWhitespace(t2) || (r2.setSummaryTruncated(), false))), r2.setSummaryDivider(), r2.addReplacement(Hr, e3);
        }, shortcodeHandler: () => (t3, e3) => {
          const i3 = s2.parseItem(t3, e3);
          n3.push(i3), r2.addShortcode(i3);
        }, bytesHandler: () => (t3) => {
          r2.addItem(t3);
        } });
        return await i2.parse(), await i2.handle(), { frontMatter: e2, content: r2, shortcodes: n3, summary: await r2.getRenderedSummary(), wordCount: r2.getWordCount(), readingTime: r2.getReadingTime() };
      }
      parseFrontMatter(t2, e2) {
        const r2 = t2.ValStr(e2);
        let s2, n3 = {};
        switch (t2.Type) {
          case 3:
            s2 = "yaml", n3 = this.parseYAML(r2);
            break;
          case 4:
            s2 = "toml", n3 = this.parseTOML(r2);
            break;
          case 5:
            s2 = "json", n3 = this.parseJSON(r2);
            break;
          case 6:
            s2 = "org", n3 = this.parseOrg(r2);
            break;
          default:
            s2 = "yaml";
        }
        return { params: n3, format: s2 };
      }
      parseYAML(t2) {
        try {
          const e2 = Vr.load(t2);
          return e2 && typeof e2 == "object" && !Array.isArray(e2) ? e2 : {};
        } catch (t3) {
          return {};
        }
      }
      parseTOML(t2) {
        try {
          const e2 = (0, Kr.parse)(t2);
          return e2 && typeof e2 == "object" && !Array.isArray(e2) ? e2 : {};
        } catch (t3) {
          return {};
        }
      }
      parseJSON(t2) {
        try {
          return JSON.parse(t2);
        } catch (t3) {
          return {};
        }
      }
      parseOrg(t2) {
        const e2 = {}, r2 = t2.split("\n");
        for (const t3 of r2) {
          const r3 = t3.trim();
          if (!r3.startsWith("#+"))
            continue;
          const s2 = r3.match(/^#\+([^:]+):\s*(.*)$/);
          if (s2) {
            const t4 = s2[1].trim().toLowerCase(), r4 = s2[2].trim();
            e2[t4] = this.parseValue(r4);
          }
        }
        return e2;
      }
      parseValue(t2) {
        if (t2.startsWith('"') && t2.endsWith('"') || t2.startsWith("'") && t2.endsWith("'"))
          return t2.slice(1, -1);
        if (t2 === "true")
          return true;
        if (t2 === "false")
          return false;
        if (/^-?\d+$/.test(t2))
          return parseInt(t2, 10);
        if (/^-?\d*\.\d+$/.test(t2))
          return parseFloat(t2);
        if (t2.startsWith("[") && t2.endsWith("]")) {
          const e2 = t2.slice(1, -1).trim();
          return e2 ? e2.split(",").map((t3) => this.parseValue(t3.trim())) : [];
        }
        return t2;
      }
      async parse(t2) {
        const e2 = new TextDecoder().decode(t2.src);
        return await this.renderer.parse(e2);
      }
      async renderToBytes(t2, e2, r2) {
        const s2 = new TextDecoder().decode(t2.src), n3 = await this.renderer.render(s2), i2 = new Xe();
        return await i2.writeString(n3), new Jr(i2);
      }
    };
    q();
    var Xr = p(require_js_yaml());
    var Qr = ((t2) => (t2[t2.File = 0] = "File", t2[t2.ContentResource = 1] = "ContentResource", t2[t2.ContentSingle = 2] = "ContentSingle", t2[t2.Leaf = 3] = "Leaf", t2[t2.Branch = 4] = "Branch", t2))(Qr || {});
    var ts = { CONTENT_EXTENSIONS: [".md", ".markdown", ".mdown", ".mkd", ".mkdn", ".html", ".htm", ".xml"], HTML_EXTENSIONS: [".html", ".htm"], INDEX_NAMES: ["index", "_index"], PATH_SEPARATOR: "/", EXTENSION_SEPARATOR: ".", LANGUAGE_SEPARATOR: ".", SYSTEM_PATH_SEPARATOR: (() => {
      try {
        return require("path").sep;
      } catch {
        return "/";
      }
    })(), COMPONENT_FOLDER_CONTENT: "content", COMPONENT_FOLDER_STATIC: "static", COMPONENT_FOLDER_LAYOUTS: "layouts", COMPONENT_FOLDER_ARCHETYPES: "archetypes", COMPONENT_FOLDER_DATA: "data", COMPONENT_FOLDER_ASSETS: "assets", COMPONENT_FOLDER_I18N: "i18n", normalizePath: (t2) => {
      let e2 = t2.replace(/\\/g, "/");
      return e2.startsWith("//") && (e2 = e2.substring(1)), e2;
    } };
    var es = class t2 {
      constructor(t3, e2, r2, s2, n3, i2 = false, a2) {
        this.original = t3, this.normalized = e2, this.positions = r2, this.identifiers = s2, this.bundleType = n3, this.disabled = i2, this.component = a2;
      }
      withBundleType(e2) {
        return new t2(this.original, this.normalized, this.positions, this.identifiers, e2, this.disabled);
      }
      withDisabled(e2) {
        return new t2(this.original, this.normalized, this.positions, this.identifiers, this.bundleType, e2);
      }
      hasIdentifiers() {
        return this.identifiers.length > 0;
      }
      firstIdentifier() {
        return this.identifiers.length > 0 ? this.identifiers[0] : null;
      }
      lastIdentifier() {
        return this.identifiers.length > 0 ? this.identifiers[this.identifiers.length - 1] : null;
      }
      getIdentifier(t3) {
        return t3 >= 0 && t3 < this.identifiers.length ? this.identifiers[t3] : null;
      }
      isContentComponent(t3) {
        return t3 === "content" || t3 === "archetypes";
      }
      clone() {
        return new t2(this.original, this.normalized, { ...this.positions }, [...this.identifiers], this.bundleType, this.disabled, this.component);
      }
      toString() {
        return `PathComponents{original="${this.original}", normalized="${this.normalized}", bundleType=${Qr[this.bundleType]}, identifiers=${this.identifiers.length}}`;
      }
    };
    var rs = class t2 {
      constructor(t3 = -1, e2 = -1, r2 = -1, s2 = -1) {
        this.containerLow = t3, this.containerHigh = e2, this.sectionHigh = r2, this.identifierLanguage = s2;
      }
      reset() {
        this.containerLow = -1, this.containerHigh = -1, this.sectionHigh = -1, this.identifierLanguage = -1;
      }
      hasContainer() {
        return this.containerLow !== -1 && this.containerHigh !== -1;
      }
      hasSection() {
        return this.sectionHigh > 0;
      }
      hasLanguageIdentifier() {
        return this.identifierLanguage !== -1;
      }
      clone() {
        return new t2(this.containerLow, this.containerHigh, this.sectionHigh, this.identifierLanguage);
      }
    };
    var ss = class {
      constructor(t2, e2) {
        if (this.low = t2, this.high = e2, t2 > e2)
          throw new Error(`Invalid range: low (${t2}) must be <= high (${e2})`);
      }
      length() {
        return this.high - this.low;
      }
      isEmpty() {
        return this.low === this.high;
      }
      contains(t2) {
        return t2 >= this.low && t2 < this.high;
      }
      substring(t2) {
        return t2.substring(this.low, this.high);
      }
      toString() {
        return `[${this.low}, ${this.high})`;
      }
    };
    var ns = class {
      static createEmpty(t2 = "", e2 = 0) {
        return new es(t2, t2, new rs(), [], e2, false);
      }
      static create(t2, e2, r2 = 0) {
        return new es(t2, e2 || t2, new rs(), [], r2, false);
      }
      static createFull(t2, e2, r2, s2, n3, i2 = false) {
        return new es(t2, e2, r2, s2, n3, i2);
      }
    };
    var is = class t2 {
      constructor(t3) {
        __publicField(this, "R");
        __publicField(this, "shouldTrimLeadingSlash", false);
        this.components = t3;
      }
      component() {
        if (this.components.component)
          return this.components.component;
        const t3 = this.components.normalized.split("/").filter((t4) => t4.length > 0);
        return t3.length === 0 ? "content" : { static: "static", layouts: "layouts", themes: "themes", archetypes: "archetypes", data: "data", i18n: "i18n", assets: "assets" }[t3[0]] || "content";
      }
      path() {
        return this.norm(this.components.normalized);
      }
      name() {
        return this.components.positions.containerHigh > 0 ? this.components.normalized.substring(this.components.positions.containerHigh) : this.components.normalized;
      }
      nameNoExt() {
        const t3 = this.components.firstIdentifier();
        return t3 ? this.components.normalized.substring(this.components.positions.containerHigh, t3.low - 1) : this.components.normalized.substring(this.components.positions.containerHigh);
      }
      nameNoLang() {
        if (this.components.identifiers.length >= 2) {
          const t3 = this.components.identifiers[this.components.identifiers.length - 1], e2 = this.components.identifiers[this.components.identifiers.length - 2], r2 = this.components.normalized.substring(e2.low, e2.high);
          if (["en", "fr", "es", "de", "zh", "ja", "ko", "pt", "it", "ru", "ar"].includes(r2)) {
            const r3 = this.components.positions.containerHigh;
            return this.components.normalized.substring(r3, e2.low - 1) + this.components.normalized.substring(t3.low - 1);
          }
        }
        return this.name();
      }
      dir() {
        let t3 = "";
        return this.components.positions.containerHigh > 0 && (t3 = this.components.normalized.substring(0, this.components.positions.containerHigh - 1)), t3 === "" && (t3 = "/"), this.norm(t3);
      }
      ext() {
        if (this.components.identifiers.length === 0)
          return "";
        const t3 = this.components.identifiers[this.components.identifiers.length - 1], e2 = this.components.normalized.substring(t3.low, t3.high);
        return e2 ? "." + e2 : "";
      }
      lang() {
        if (this.components.identifiers.length >= 2) {
          const t3 = this.components.identifiers[this.components.identifiers.length - 2], e2 = this.components.normalized.substring(t3.low, t3.high);
          if (["en", "fr", "es", "de", "zh", "ja", "ko", "pt", "it", "ru", "ar"].includes(e2))
            return "." + e2;
        }
        return "";
      }
      section() {
        if (this.components.positions.sectionHigh <= 0)
          return "";
        const t3 = this.components.normalized.substring(1, this.components.positions.sectionHigh);
        return t3 === "_index.md" || t3 === "index.md" || t3.endsWith("/_index.md") || t3.endsWith("/index.md") ? "" : this.norm(t3);
      }
      sections() {
        const t3 = this.dir();
        if (t3 === "/" || t3 === "")
          return [];
        const e2 = [], r2 = (t3.startsWith("/") ? t3.substring(1) : t3).split("/").filter((t4) => t4.length > 0);
        let s2 = "";
        for (const t4 of r2)
          s2 === "" ? s2 = t4 : s2 += "/" + t4, e2.push(this.norm(s2));
        return e2;
      }
      container() {
        return this.components.positions.containerLow === -1 ? "" : this.norm(this.components.normalized.substring(this.components.positions.containerLow, this.components.positions.containerHigh - 1));
      }
      containerDir() {
        return this.isLeafBundle() || this.isBranchBundle(), this.dir();
      }
      base() {
        return this.isBranchBundle() && this.components.normalized === "/_index.md" ? "/" : this.isLeafBundle() ? this.baseInternal(false, true) : this.isContent() && !this.isBundle() ? this.pathNoIdentifier() : this.isContent() ? this.isBundle() ? this.baseInternal(false, true) : this.baseInternal(!this.isContentPage(), this.isBundle()) : this.path();
      }
      baseNoLeadingSlash() {
        return this.base().substring(1);
      }
      baseNameNoIdentifier() {
        return this.isBundle() ? this.container() : this.nameNoIdentifier();
      }
      nameNoIdentifier() {
        if (this.components.identifiers.length === 0)
          return this.name();
        const t3 = this.components.identifiers[0], e2 = this.components.positions.containerHigh;
        return this.components.normalized.substring(e2, t3.low - 1);
      }
      pathNoLang() {
        return this.baseInternal(true, false);
      }
      pathNoIdentifier() {
        if (this.components.identifiers.length === 0)
          return this.path();
        const t3 = this.components.identifiers[0], e2 = this.components.normalized.substring(0, t3.low - 1);
        return this.norm(e2);
      }
      pathRel(t3) {
        let e2 = t3.base();
        return e2.endsWith("/") || (e2 += "/"), this.path().replace(new RegExp("^" + this.escapeRegExp(e2)), "");
      }
      baseRel(t3) {
        let e2 = t3.base();
        return e2 === "/" && (e2 = ""), this.base().substring(e2.length + 1);
      }
      trimLeadingSlash() {
        const e2 = this.components.clone(), r2 = new t2(e2);
        return r2.setShouldTrimLeadingSlash(true), r2;
      }
      identifier(t3) {
        const e2 = this.components.identifiers.length;
        if (e2 === 0 || t3 < 0 || t3 >= e2)
          return "";
        let r2;
        r2 = e2 === 1 ? 0 : t3 === 0 ? e2 - 1 : e2 - 1 - t3;
        const s2 = this.identifierAsString(r2);
        return s2 ? "." + s2 : "";
      }
      identifiers() {
        const t3 = [], e2 = this.components.identifiers.length;
        for (let r2 = 0; r2 < e2; r2++) {
          const e3 = this.identifier(r2);
          e3 && t3.push(e3);
        }
        return t3;
      }
      bundleType() {
        return this.components.bundleType;
      }
      isContent() {
        return this.bundleType() >= 1;
      }
      isBundle() {
        return this.bundleType() > 3;
      }
      isBranchBundle() {
        return this.bundleType() === 4;
      }
      isLeafBundle() {
        return this.bundleType() === 3;
      }
      isHTML() {
        const t3 = this.ext().toLowerCase();
        return ts.HTML_EXTENSIONS.some((e2) => e2 === t3);
      }
      disabled() {
        return this.components.disabled;
      }
      forBundleType(e2) {
        const r2 = this.components.withBundleType(e2);
        return new t2(r2);
      }
      unnormalized() {
        if (!this.R)
          if (this.components.original === this.components.normalized)
            this.R = this;
          else {
            const e2 = new es(this.components.original, this.components.original, this.components.positions, this.components.identifiers, this.components.bundleType, this.components.disabled);
            this.R = new t2(e2);
          }
        return this.R;
      }
      setShouldTrimLeadingSlash(t3) {
        this.shouldTrimLeadingSlash = t3;
      }
      norm(t3) {
        return this.shouldTrimLeadingSlash && t3.startsWith("/") ? t3.substring(1) : t3;
      }
      isContentPage() {
        return this.bundleType() >= 2;
      }
      baseInternal(t3, e2) {
        if (this.components.identifiers.length === 0)
          return this.norm(this.components.normalized);
        if (t3 && this.components.identifiers.length === 1)
          return this.norm(this.components.normalized);
        let r2 = this.components.identifiers[this.components.identifiers.length - 1].low - 1;
        if (e2 && (r2 = this.components.positions.containerHigh - 1), r2 === 0 && r2++, !t3)
          return this.norm(this.components.normalized.substring(0, r2));
        const s2 = this.components.identifiers[0];
        return this.norm(this.components.normalized.substring(0, r2) + this.components.normalized.substring(s2.low - 1, s2.high));
      }
      identifierAsString(t3) {
        const e2 = this.identifierIndex(t3);
        if (e2 === -1)
          return "";
        const r2 = this.components.identifiers[e2];
        return this.components.normalized.substring(r2.low, r2.high);
      }
      identifierIndex(t3) {
        return t3 < 0 || t3 >= this.components.identifiers.length ? -1 : t3;
      }
      escapeRegExp(t3) {
        return t3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      toString() {
        return `Path{path="${this.path()}", component="${this.component()}", bundleType=${Qr[this.bundleType()]}}`;
      }
      equals(t3) {
        return this.path() === t3.path() && this.component() === t3.component() && this.bundleType() === t3.bundleType();
      }
      hashCode() {
        return `${this.component()}:${this.path()}:${this.bundleType()}`;
      }
    };
    var as = class {
      static fromString(t2, e2) {
        const r2 = new es(e2, e2, { containerLow: -1, containerHigh: -1, sectionHigh: -1, identifierLanguage: -1 }, [], 0, false);
        return new is(r2);
      }
      static hasExtension(t2, e2) {
        const r2 = t2.ext(), s2 = e2.startsWith(".") ? e2 : "." + e2;
        return r2.toLowerCase() === s2.toLowerCase();
      }
      static isUnder(t2, e2) {
        const r2 = t2.path();
        let s2;
        s2 = e2.isBranchBundle() ? e2.dir() : e2.path();
        const n3 = s2 === "/" ? "/" : s2 + "/";
        return r2 !== s2 && r2.startsWith(n3);
      }
      static relativeTo(t2, e2) {
        return e2.pathRel(t2);
      }
      static compare(t2, e2) {
        const r2 = t2.path().localeCompare(e2.path());
        if (r2 !== 0)
          return r2;
        const s2 = t2.component().localeCompare(e2.component());
        return s2 !== 0 ? s2 : t2.bundleType() - e2.bundleType();
      }
    };
    var os = class {
      constructor(t2, e2) {
        __publicField(this, "normalizer");
        __publicField(this, "extChecker");
        this.normalizer = t2 || new hs(), this.extChecker = e2 || new us();
      }
      parse(t2, e2) {
        let r2 = e2;
        r2 && r2 !== "" || (r2 = "/");
        const s2 = this.normalizer.normalize(r2), n3 = this.createPathComponents(t2, s2, e2);
        return new is(n3);
      }
      parseIdentity(t2, e2) {
        const r2 = this.parse(t2, e2);
        return { identifierBase: () => r2.base() };
      }
      parseBaseAndBaseNameNoIdentifier(t2, e2) {
        const r2 = this.parse(t2, e2);
        return [r2.base(), r2.baseNameNoIdentifier()];
      }
      createPathComponents(t2, e2, r2) {
        let s2 = t2, n3 = e2;
        if (e2.startsWith("/")) {
          const r3 = e2.split("/").filter((t3) => t3.length > 0);
          if (r3.length > 0) {
            const e3 = r3[0];
            ["static", "layouts", "themes", "archetypes", "data", "i18n", "assets"].includes(e3) && t2 === "content" && (s2 = e3), ["images", "assets", "static", "css", "js", "fonts"].includes(e3) && t2 === "content" && (s2 = "static");
          }
        }
        const i2 = n3.lastIndexOf("/"), a2 = i2 >= 0 ? n3.substring(i2 + 1) : n3;
        i2 >= 0 && n3.substring(0, i2);
        let o2 = this.detectBundleType(a2, s2);
        const h2 = this.calculatePathPositions(n3), c2 = this.extractIdentifiers(n3, a2);
        return new es(r2, n3, h2, c2, o2, false, s2);
      }
      detectBundleType(t2, e2) {
        if (e2 !== "content" && e2 !== "archetypes")
          return 0;
        let r2 = t2.split(".")[0];
        return r2 === "index" && this.isContentFile(t2) ? 3 : r2 === "_index" && this.isContentFile(t2) ? 4 : this.isContentFile(t2) ? 2 : 0;
      }
      isContentFile(t2) {
        const e2 = this.getFileExtension(t2);
        return ["md", "html", "markdown", "mdown", "mkd", "mkdn", "htm"].includes(e2.toLowerCase());
      }
      getFileExtension(t2) {
        const e2 = t2.lastIndexOf(".");
        return e2 > 0 && e2 < t2.length - 1 ? t2.substring(e2 + 1) : "";
      }
      calculatePathPositions(t2) {
        let e2 = -1, r2 = -1, s2 = -1;
        for (let n3 = t2.length - 1; n3 >= 0; n3--)
          t2[n3] === "/" && (s2 === -1 ? s2 = n3 + 1 : r2 === -1 && (r2 = n3 + 1), n3 > 0 && (e2 = n3));
        return new rs(r2, s2, e2, -1);
      }
      extractIdentifiers(t2, e2) {
        const r2 = [], s2 = t2.substring(0, t2.length - e2.length).length, n3 = e2.split(".");
        if (n3.length <= 1)
          return r2;
        let i2 = s2 + n3[0].length;
        for (let t3 = 1; t3 < n3.length; t3++) {
          const e3 = i2 + 1, s3 = e3 + n3[t3].length;
          r2.push(new ss(e3, s3)), i2 = s3;
        }
        return r2;
      }
    };
    var hs = class {
      constructor(t2 = true, e2 = true) {
        this.toLowerCase = t2, this.replaceSpaces = e2;
      }
      normalize(t2) {
        let e2 = t2;
        return e2 = e2.replace(/\\/g, "/"), this.toLowerCase && (e2 = e2.toLowerCase()), this.replaceSpaces && (e2 = e2.replace(/\s/g, "-")), e2;
      }
    };
    var cs = class {
      constructor(t2 = true, e2 = true) {
        this.toLowerCase = t2, this.replaceSpaces = e2;
      }
      normalize(t2) {
        let e2 = t2;
        return e2 = e2.replace(/\\/g, "/"), this.toLowerCase && (e2 = e2.toLowerCase()), this.replaceSpaces && (e2 = e2.replace(/\s+/g, "-")), e2;
      }
    };
    var us = class {
      isContentExt(t2) {
        return ts.CONTENT_EXTENSIONS.includes(t2.toLowerCase());
      }
      isHTML(t2) {
        return ts.HTML_EXTENSIONS.includes(t2.toLowerCase());
      }
      hasExt(t2) {
        for (let e2 = t2.length - 1; e2 >= 0; e2--) {
          if (t2[e2] === ".")
            return true;
          if (t2[e2] === "/")
            return false;
        }
        return false;
      }
    };
    var ls = class t2 {
      static parseBasic(t3) {
        const e2 = t3.lastIndexOf("/"), r2 = e2 >= 0 ? t3.substring(0, e2) : "", s2 = e2 >= 0 ? t3.substring(e2 + 1) : t3, n3 = s2.lastIndexOf("."), i2 = n3 >= 0 ? s2.substring(n3) : "", a2 = n3 >= 0 ? s2.substring(0, n3) : s2;
        return { dir: r2, name: s2, ext: i2, nameWithoutExt: a2 };
      }
      static join(...t3) {
        return t3.filter((t4) => t4.length > 0).map((t4) => t4.replace(/^\/+|\/+$/g, "")).join("/").replace(/\/+/g, "/");
      }
      static normalizeBasic(t3) {
        return new cs().normalize(t3);
      }
      static isBundle(e2) {
        const r2 = t2.parseBasic(e2);
        return ts.INDEX_NAMES.includes(r2.nameWithoutExt);
      }
      static extractSection(t3) {
        const e2 = t3.startsWith("/") ? t3.substring(1) : t3, r2 = e2.indexOf("/");
        return r2 >= 0 ? e2.substring(0, r2) : e2;
      }
      static removeExtension(t3) {
        const e2 = t3.lastIndexOf(".");
        return e2 > t3.lastIndexOf("/") ? t3.substring(0, e2) : t3;
      }
      static hasExtension(t3) {
        return new us().hasExt(t3);
      }
    };
    var fs7 = class {
      constructor(t2, e2) {
        __publicField(this, "processor");
        __publicField(this, "pool");
        const r2 = t2?.normalizer ? { normalize: t2.normalizer } : new cs(t2?.normalize !== false, t2?.replaceSpaces !== false), s2 = new us();
        this.processor = new os(r2, s2), e2 && (this.pool = e2);
      }
      create(t2, e2, r2) {
        return this.pool && this.pool.get(), this.processor.parse(t2, e2);
      }
      createFromComponents(t2) {
        return new is(t2);
      }
      createMany(t2, e2, r2) {
        return e2.map((e3) => this.create(t2, e3, r2));
      }
      createWithConfig(t2, e2, r2) {
        const s2 = {};
        return r2?.toLowerCase !== void 0 && (s2.normalize = r2.toLowerCase), r2?.replaceSpaces !== void 0 && (s2.replaceSpaces = r2.replaceSpaces), r2?.customNormalizer !== void 0 && (s2.normalizer = r2.customNormalizer), this.create(t2, e2, s2);
      }
    };
    var ws = class extends fs7 {
      constructor() {
        super({ normalize: true, replaceSpaces: true });
      }
    };
    var ds = class {
      constructor(t2 = 100) {
        __publicField(this, "pool", []);
        __publicField(this, "maxSize");
        this.maxSize = t2;
      }
      get() {
        if (this.pool.length > 0)
          return this.pool.pop();
        const t2 = ns.createEmpty();
        return new is(t2);
      }
      put(t2) {
        this.pool.length < this.maxSize && this.pool.push(t2);
      }
      clear() {
        this.pool = [];
      }
      size() {
        return this.pool.length;
      }
    };
    var gs = class {
      constructor(t2) {
        __publicField(this, "component", "");
        __publicField(this, "path", "");
        __publicField(this, "config", {});
        __publicField(this, "factory");
        this.factory = t2 || new ws();
      }
      withComponent(t2) {
        return this.component = t2, this;
      }
      withPath(t2) {
        return this.path = t2, this;
      }
      withNormalization(t2) {
        return this.config.normalize = t2, this;
      }
      withSpaceReplacement(t2) {
        return this.config.replaceSpaces = t2, this;
      }
      withNormalizer(t2) {
        return this.config.normalizer = t2, this;
      }
      build() {
        if (!this.component || !this.path)
          throw new Error("Component and path must be set");
        return this.factory.create(this.component, this.path, this.config);
      }
      reset() {
        return this.component = "", this.path = "", this.config = {}, this;
      }
    };
    var _a2;
    var ps = (_a2 = class {
      static createContentPath(e2) {
        return _a2.defaultFactory.create("content", e2);
      }
      static createStaticPath(e2) {
        return _a2.defaultFactory.create("static", e2);
      }
      static createLayoutPath(e2) {
        return _a2.defaultFactory.create("layouts", e2);
      }
      static createArchetypePath(e2) {
        return _a2.defaultFactory.create("archetypes", e2);
      }
      static createDataPath(e2) {
        return _a2.defaultFactory.create("data", e2);
      }
      static createThemePath(e2) {
        return _a2.defaultFactory.create("themes", e2);
      }
      static createFromConfig(t2) {
        const e2 = {};
        t2.normalize !== void 0 && (e2.normalize = t2.normalize), t2.replaceSpaces !== void 0 && (e2.replaceSpaces = t2.replaceSpaces);
        const r2 = new fs7(e2);
        return t2.paths.map((e3) => r2.create(t2.component, e3));
      }
      static builder() {
        return new gs();
      }
      static createWithPool(t2, e2, r2) {
        return new fs7(void 0, r2).create(t2, e2);
      }
    }, __publicField(_a2, "defaultFactory", new ws()), _a2);
    var ms = { createContentPath: ps.createContentPath, createStaticPath: ps.createStaticPath, createLayoutPath: ps.createLayoutPath, createArchetypePath: ps.createArchetypePath, createDataPath: ps.createDataPath, createThemePath: ps.createThemePath, builder: ps.builder, parseBasic: ls.parseBasic, join: ls.join, normalizeBasic: ls.normalizeBasic, isBundle: ls.isBundle, extractSection: ls.extractSection, removeExtension: ls.removeExtension, checkExtension: ls.hasExtension, hasSpecificExtension: as.hasExtension, isUnder: as.isUnder, relativeTo: as.relativeTo, compare: as.compare, createProcessor: () => new os(), createFactory: () => new ws(), createPool: (t2) => new ds(t2), createNormalizer: (t2) => new cs(t2?.toLowerCase, t2?.replaceSpaces) };
    var ys = A("content", { component: "translator" });
    var bs = class {
      constructor(t2) {
        __publicField(this, "contentLanguage");
        __publicField(this, "translateFuncs", /* @__PURE__ */ new Map());
        this.contentLanguage = t2;
      }
      translate(t2, e2) {
        const r2 = t2.toLowerCase(), s2 = this.translateFuncs.get(r2);
        if (s2) {
          const t3 = s2(e2);
          if (t3)
            return t3;
        }
        ys.info(`Translation func for language ${t2} not found, use default.`);
        const n3 = this.translateFuncs.get(this.contentLanguage.toLowerCase());
        if (n3) {
          const t3 = n3(e2);
          if (t3)
            return t3;
        }
        return ys.info("i18n not initialized; if you need string translations, check that you have a bundle in /i18n that matches the site language or the default language."), `[i18n] ${e2}`;
      }
      async setupTranslateFuncs(t2) {
        try {
          await t2.walkI18n("", { walkFn: async (t3, e2) => {
            if (t3.endsWith(".yaml") || t3.endsWith(".yml"))
              try {
                const r2 = (ts.normalizePath(t3).split("/").pop() || "").replace(/\.(yaml|yml)$/, "").toLowerCase(), s2 = await this.readI18nFile(e2), n3 = this.parseI18nContent(s2), i2 = /* @__PURE__ */ new Map();
                n3.forEach((t4) => {
                  i2.set(t4.id, t4.translation);
                });
                const a2 = (t4) => i2.get(t4) || (ys.warn(`i18n|MISSING_TRANSLATION|${r2}|${t4}`), "");
                this.translateFuncs.set(r2, a2), ys.info(`\u2705 Loaded i18n translations for language: ${r2} (${n3.length} items)`);
              } catch (e3) {
                ys.error(`\u274C Failed to load i18n file ${t3}:`, e3);
              }
          } }, {}), ys.info(`\u{1F30D} Translation setup complete. Loaded ${this.translateFuncs.size} languages: [${Array.from(this.translateFuncs.keys()).join(", ")}]`);
        } catch (t3) {
          throw t3;
        }
      }
      async readI18nFile(t2) {
        let e2 = null;
        try {
          e2 = await t2.open();
          const r2 = await e2.stat(), s2 = new Uint8Array(r2.size()), n3 = await e2.read(s2), i2 = new TextDecoder("utf-8").decode(n3.buffer);
          return i2.charCodeAt(0) === 65279 ? i2.slice(1) : i2;
        } catch (t3) {
          throw ys.error("\u274C Failed to read i18n file:", t3), t3;
        } finally {
          if (e2)
            try {
              await e2.close();
            } catch (t3) {
              ys.warn(`Failed to close i18n file: ${t3}`);
            }
        }
      }
      parseI18nContent(t2) {
        try {
          const e2 = Xr.load(t2);
          return Array.isArray(e2) ? e2.filter((t3) => t3 && typeof t3 == "object" && t3.id && t3.translation).map((t3) => ({ id: String(t3.id), translation: String(t3.translation) })) : (ys.warn("i18n YAML content is not an array"), []);
        } catch (t3) {
          return ys.error("\u274C Failed to parse i18n YAML content:", t3), [];
        }
      }
      getAvailableLanguages() {
        return Array.from(this.translateFuncs.keys());
      }
      hasLanguage(t2) {
        return this.translateFuncs.has(t2.toLowerCase());
      }
    };
    q();
    var Es = A("content", { component: "content" });
    var Ss = { [He]: He, [Ge]: Ge, [Ve]: Ve, [Ke]: Ke, [Je]: Je, [Ze]: "404", [Ye]: Ye, taxonomyterm: Ke };
    function vs(t2) {
      return Ss[t2.toLowerCase()] || "";
    }
    q(), A("content", { component: "identity" });
    var Ts = class {
      constructor(t2, e2 = "", r2 = 0) {
        __publicField(this, "id");
        __publicField(this, "lang");
        __publicField(this, "langIdx");
        __publicField(this, "stale", true);
        this.id = t2, this.lang = e2, this.langIdx = r2;
      }
      ID() {
        return this.id;
      }
      identifierBase() {
        return `${this.id}-${this.lang}`;
      }
      pageLanguage() {
        return this.lang;
      }
      pageLanguageIndex() {
        return this.langIdx;
      }
      pageIdentity() {
        return this;
      }
      markStale() {
        this.stale || (this.stale = true);
      }
      isStale() {
        return this.stale;
      }
      clearStale() {
        this.stale && (this.stale = false);
      }
    };
    var xs = p(require("crypto"));
    var Ps = p(require("path"));
    q(), A("content", { component: "FileInfo" });
    var $s = /* @__PURE__ */ new Set([".md"]);
    var Rs = class t2 {
      constructor(t3, e2) {
        __publicField(this, "fileMetaInfo");
        __publicField(this, "pathInfo");
        __publicField(this, "bundleType");
        __publicField(this, "uniqueIDCache");
        __publicField(this, "lazyInitDone", false);
        this.fileMetaInfo = t3;
        const r2 = ms.createProcessor();
        this.pathInfo = r2.parse(ts.COMPONENT_FOLDER_CONTENT, e2), this.bundleType = 0, this.determineBundleType();
      }
      static newFileInfo(e2) {
        const r2 = ts.normalizePath(e2.relativeFilename());
        return new t2(e2, r2);
      }
      pageFile() {
        return this;
      }
      shiftToResource() {
        this.isContent() && (this.bundleType = 1);
      }
      relPath() {
        const t3 = this.pathInfo.dir(), e2 = t3.startsWith("/") ? t3.substring(1) : t3;
        return Ps.join(e2, this.pathInfo.name());
      }
      section() {
        return this.pathInfo.section();
      }
      isZero() {
        return this.fileMetaInfo == null;
      }
      filename() {
        return this.fileMetaInfo.fileName();
      }
      dir() {
        return this.pathToDir(this.pathInfo.dir());
      }
      ext() {
        return this.pathInfo.ext();
      }
      logicalName() {
        return this.pathInfo.name();
      }
      baseFileName() {
        return this.pathInfo.nameNoExt();
      }
      translationBaseName() {
        return this.pathInfo.nameNoIdentifier();
      }
      contentBaseName() {
        return this.pathInfo.baseNameNoIdentifier();
      }
      baseNameNoIdentifier() {
        return this.pathInfo.baseNameNoIdentifier();
      }
      root() {
        return this.pathInfo.dir() || "/";
      }
      uniqueID() {
        return this.init(), this.uniqueIDCache;
      }
      fileInfo() {
        return this.fileMetaInfo;
      }
      type() {
        const t3 = this.section();
        return t3 !== "" ? t3 : "page";
      }
      async open() {
        return await this.fileMetaInfo.open();
      }
      paths() {
        return this.pathInfo;
      }
      path() {
        return this.pathInfo.path();
      }
      toString() {
        return this.baseFileName();
      }
      getBundleType() {
        return this.bundleType;
      }
      isBundle() {
        return this.bundleType >= 3;
      }
      isLeafBundle() {
        return this.bundleType === 3;
      }
      isBranchBundle() {
        return this.bundleType === 4;
      }
      isContentResource() {
        return this.bundleType === 1;
      }
      isContent() {
        return this.bundleType >= 1;
      }
      init() {
        if (!this.lazyInitDone) {
          this.lazyInitDone = true;
          const t3 = this.relPath().replace(/\\/g, "/");
          this.uniqueIDCache = xs.createHash("md5").update(t3).digest("hex");
        }
      }
      pathToDir(t3) {
        return t3 === "" ? t3 : Ps.normalize(t3.substring(1) + "/");
      }
      determineBundleType() {
        var t3;
        if (t3 = this.pathInfo.ext(), $s.has(t3))
          switch (this.pathInfo.nameNoIdentifier()) {
            case "index":
              this.bundleType = 3;
              break;
            case "_index":
              this.bundleType = 4;
              break;
            default:
              this.bundleType = 2;
          }
      }
    };
    function Ls(t2) {
      return Rs.newFileInfo(t2);
    }
    function Ns(t2) {
      Fs(As).sort(t2);
    }
    function Fs(t2) {
      return new Ds(t2);
    }
    var Ds = class {
      constructor(t2) {
        this.by = t2;
      }
      sort(t2) {
        !function(t3, e2) {
          const r2 = Array.from({ length: e2.len() }, (t4, e3) => e3);
          r2.sort((t4, r3) => e2.less(t4, r3) ? -1 : e2.less(r3, t4) ? 1 : t4 - r3);
          const s2 = [...t3];
          for (let e3 = 0; e3 < r2.length; e3++)
            t3[e3] = s2[r2[e3]];
        }(t2, new Os(t2, this.by));
      }
    };
    var As = (t2, e2) => Cs((t3) => t3.title(), t2, e2) < 0;
    var ks = (t2, e2) => Cs((t3) => t3.pageIdentity().pageLanguage(), t2, e2) < 0;
    var Is = (t2, e2) => t2.pageWeight() < e2.pageWeight();
    var Cs = (t2, e2, r2) => {
      const s2 = t2(e2), n3 = t2(r2);
      return s2 < n3 ? -1 : s2 > n3 ? 1 : 0;
    };
    var Os = class {
      constructor(t2, e2) {
        this.pages = t2, this.by = e2;
      }
      len() {
        return this.pages.length;
      }
      swap(t2, e2) {
        [this.pages[t2], this.pages[e2]] = [this.pages[e2], this.pages[t2]];
      }
      less(t2, e2) {
        return this.by(this.pages[t2], this.pages[e2]);
      }
    };
    var _s = class {
      static toString(t2) {
        return t2 == null ? "" : typeof t2 == "string" ? t2 : typeof t2 == "number" || typeof t2 == "boolean" ? t2.toString() : String(t2);
      }
      static toInt(t2) {
        if (t2 == null)
          return 0;
        if (typeof t2 == "number")
          return Math.floor(t2);
        if (typeof t2 == "string") {
          const e2 = parseInt(t2, 10);
          return isNaN(e2) ? 0 : e2;
        }
        return 0;
      }
      static toTime(t2) {
        if (t2 == null)
          return new Date();
        if (t2 instanceof Date)
          return t2;
        if (typeof t2 == "string") {
          const e2 = new Date(t2);
          return isNaN(e2.getTime()) ? new Date() : e2;
        }
        return typeof t2 == "number" ? new Date(t2) : new Date();
      }
    };
    var Ms = class {
      static sliceToLower(t2) {
        return t2.map((t3) => t3.toLowerCase());
      }
    };
    var Us = class {
      static toStringSlicePreserveString(t2) {
        return t2 == null ? null : Array.isArray(t2) ? t2.map((t3) => _s.toString(t3)) : typeof t2 == "string" ? [t2] : [_s.toString(t2)];
      }
    };
    var js = p(require("path"));
    function Bs() {
      return { path: "", lang: "", kind: "", title: "", description: "", weight: 999, date: new Date(), terms: {}, params: {} };
    }
    var qs = class {
      constructor(t2, e2, r2) {
        __publicField(this, "params");
        __publicField(this, "langSvc");
        __publicField(this, "taxonomySvc");
        this.params = t2, this.langSvc = e2, this.taxonomySvc = r2;
      }
      async parse(t2) {
        const e2 = { terms: {}, params: this.params, path: "", lang: "", kind: "", title: "", description: "", weight: 0, date: new Date() };
        try {
          await this.parseCustomized(e2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseTerms(e2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseTitle(e2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseDescription(e2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseWeight(e2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseDate(e2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseOrganization(e2, t2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseAuthor(e2, t2);
        } catch (t3) {
          throw t3;
        }
        try {
          await this.parseMenu(e2);
        } catch (t3) {
          throw t3;
        }
        return e2;
      }
      async parseDate(t2) {
        if (t2.date = new Date(), this.params) {
          const e2 = this.params.date;
          e2 != null && (t2.date = _s.toTime(e2));
        }
      }
      async parseWeight(t2) {
        if (t2.weight = 1e4, this.params) {
          const e2 = this.params.weight;
          e2 != null && (t2.weight = _s.toInt(e2));
        }
      }
      async parseTitle(t2) {
        if (this.params) {
          const e2 = this.params.title;
          e2 != null && (t2.title = _s.toString(e2));
        }
      }
      async parseDescription(t2) {
        if (this.params) {
          const e2 = this.params.description;
          e2 != null && (t2.description = _s.toString(e2));
        }
      }
      async parseCustomized(t2) {
        if (!this.params)
          return;
        const e2 = this.params.path;
        e2 != null && (t2.path = this.toSlashPreserveLeading(_s.toString(e2)));
        const r2 = this.params.lang;
        if (r2 != null) {
          const e3 = _s.toString(r2).toLowerCase();
          this.langSvc.isLanguageValid(e3) && (t2.lang = e3);
        }
        const s2 = this.params.kind;
        if (s2 != null) {
          const e3 = _s.toString(s2);
          if (e3 !== "") {
            const r3 = vs(e3);
            if (r3 === "")
              throw new Error(`unknown kind "${e3}" in front matter`);
            t2.kind = r3;
          }
        }
      }
      async parseTerms(t2) {
        const e2 = this.taxonomySvc.views();
        for (const r2 of e2) {
          const e3 = Us.toStringSlicePreserveString(zs(this.params || {}, r2.plural(), false));
          e3 !== null && (t2.terms[r2.plural()] = e3);
        }
      }
      async parseOrganization(t2, e2) {
        if (!this.params)
          return;
        const r2 = this.params.organization;
        if (!r2 || typeof r2 != "object")
          return;
        const s2 = {};
        r2.name !== void 0 && r2.name !== null && (s2.name = _s.toString(r2.name)), r2.description !== void 0 && r2.description !== null && (s2.description = _s.toString(r2.description)), r2.vision !== void 0 && r2.vision !== null && (s2.vision = _s.toString(r2.vision)), r2.website !== void 0 && r2.website !== null && (s2.website = _s.toString(r2.website)), r2.logo !== void 0 && r2.logo !== null && (s2.logo = js.default.join(e2, _s.toString(r2.logo)));
        const n3 = this.parseContact(r2.contact);
        n3 && (s2.contact = n3);
        const i2 = this.parseSocial(r2.social);
        i2 && (s2.social = i2), Object.keys(s2).length > 0 && (t2.organization = s2);
      }
      async parseMenu(t2) {
        if (!this.params)
          return;
        const e2 = this.params.menu;
        if (!e2 || typeof e2 != "object")
          return;
        const r2 = {};
        for (const [t3, s2] of Object.entries(e2))
          if (s2 !== false) {
            if (Array.isArray(s2)) {
              const e3 = this.parseMenuItems(s2);
              e3.length > 0 && (r2[t3] = e3);
            } else if (s2 && typeof s2 == "object") {
              const e3 = {};
              for (const [t4, r3] of Object.entries(s2))
                if (r3 === false)
                  e3[t4] = false;
                else if (Array.isArray(r3)) {
                  const s3 = this.parseMenuItems(r3);
                  s3.length > 0 && (e3[t4] = s3);
                }
              Object.keys(e3).length > 0 && (r2[t3] = e3);
            }
          } else
            r2[t3] = false;
        Object.keys(r2).length > 0 && (t2.menu = r2);
      }
      parseMenuItems(t2) {
        const e2 = [];
        for (const r2 of t2) {
          if (!r2 || typeof r2 != "object")
            continue;
          const t3 = { title: "", url: "" };
          if (r2.title !== void 0 && r2.title !== null && (t3.title = _s.toString(r2.title), r2.url !== void 0 && r2.url !== null)) {
            {
              const e3 = _s.toString(r2.url);
              t3.url = e3 === "" ? "" : e3;
            }
            if (r2.weight !== void 0 && r2.weight !== null && (t3.weight = _s.toInt(r2.weight)), Array.isArray(r2.children)) {
              const e3 = this.parseMenuItems(r2.children);
              e3.length > 0 && (t3.children = e3);
            }
            e2.push(t3);
          }
        }
        return e2;
      }
      async parseAuthor(t2, e2) {
        if (!this.params)
          return;
        const r2 = this.params.author;
        if (!r2 || typeof r2 != "object")
          return;
        const s2 = {};
        r2.name !== void 0 && r2.name !== null && (s2.name = _s.toString(r2.name)), r2.description !== void 0 && r2.description !== null && (s2.description = _s.toString(r2.description)), r2.website !== void 0 && r2.website !== null && (s2.website = _s.toString(r2.website)), r2.avatar !== void 0 && r2.avatar !== null && (s2.avatar = js.default.join(e2, _s.toString(r2.avatar)));
        const n3 = this.parseContact(r2.contact);
        n3 && (s2.contact = n3);
        const i2 = this.parseSocial(r2.social);
        i2 && (s2.social = i2), Object.keys(s2).length > 0 && (t2.author = s2);
      }
      parseContact(t2) {
        if (!t2 || typeof t2 != "object")
          return null;
        const e2 = {};
        return t2.email !== void 0 && t2.email !== null && (e2.email = _s.toString(t2.email)), t2.address !== void 0 && t2.address !== null && (e2.address = _s.toString(t2.address)), t2.phone !== void 0 && t2.phone !== null && (e2.phone = _s.toString(t2.phone)), Object.keys(e2).length > 0 ? e2 : null;
      }
      parseSocial(t2) {
        if (!t2 || typeof t2 != "object")
          return null;
        const e2 = {}, r2 = ["github", "twitter", "linkedin"];
        for (const s2 of r2)
          t2[s2] !== void 0 && t2[s2] !== null && (e2[s2] = _s.toString(t2[s2]));
        for (const [s2, n3] of Object.entries(t2))
          r2.includes(s2) || n3 == null || (e2[s2] = _s.toString(n3));
        return Object.keys(e2).length > 0 ? e2 : null;
      }
      toSlashPreserveLeading(t2) {
        return t2.replace(/\\/g, "/");
      }
    };
    function Ws(t2, e2) {
      return zs(t2, e2, true);
    }
    function zs(t2, e2, r2) {
      const s2 = t2[e2.toLowerCase()];
      if (s2 == null)
        return null;
      switch (typeof s2) {
        case "boolean":
          return s2;
        case "string":
          return r2 ? s2.toLowerCase() : s2;
        case "number":
          return Number.isInteger(s2) ? _s.toInt(s2) : s2;
        default:
          return s2 instanceof Date ? s2 : Array.isArray(s2) && s2.every((t3) => typeof t3 == "string") && r2 ? Ms.sliceToLower(s2) : s2;
      }
    }
    var Hs = (t2) => {
      if (t2 === 0)
        throw new Error("dimension flag not set");
      return t2 - 1;
    };
    var Gs = class {
      constructor(t2, e2) {
        __publicField(this, "key");
        __publicField(this, "val");
        this.key = t2, this.val = e2;
      }
    };
    var Vs = class {
      constructor(t2, e2) {
        __publicField(this, "label");
        __publicField(this, "node");
        this.label = t2, this.node = e2;
      }
    };
    var Ks = class {
      constructor() {
        __publicField(this, "leaf", null);
        __publicField(this, "prefix", "");
        __publicField(this, "edges", []);
      }
      isLeaf() {
        return this.leaf !== null;
      }
      addEdge(t2) {
        const e2 = this.edges.length;
        let r2 = 0;
        for (; r2 < e2 && this.edges[r2].label < t2.label; )
          r2++;
        this.edges.splice(r2, 0, t2);
      }
      updateEdge(t2, e2) {
        const r2 = this.edges.length;
        let s2 = 0;
        for (; s2 < r2 && this.edges[s2].label < t2; )
          s2++;
        if (!(s2 < r2 && this.edges[s2].label === t2))
          throw new Error("replacing missing edge");
        this.edges[s2].node = e2;
      }
      getEdge(t2) {
        const e2 = this.edges.length;
        let r2 = 0;
        for (; r2 < e2 && this.edges[r2].label < t2; )
          r2++;
        return r2 < e2 && this.edges[r2].label === t2 ? this.edges[r2].node : null;
      }
      delEdge(t2) {
        const e2 = this.edges.length;
        let r2 = 0;
        for (; r2 < e2 && this.edges[r2].label < t2; )
          r2++;
        r2 < e2 && this.edges[r2].label === t2 && this.edges.splice(r2, 1);
      }
      mergeChild() {
        const t2 = this.edges[0].node;
        this.prefix = this.prefix + t2.prefix, this.leaf = t2.leaf, this.edges = t2.edges;
      }
    };
    function Js(t2, e2) {
      const r2 = Math.min(t2.length, e2.length);
      let s2 = 0;
      for (s2 = 0; s2 < r2 && t2[s2] === e2[s2]; s2++)
        ;
      return s2;
    }
    var Ys = class t2 {
      constructor() {
        __publicField(this, "root");
        __publicField(this, "size");
        this.root = new Ks(), this.size = 0;
      }
      static newFromMap(e2) {
        const r2 = new t2();
        if (e2)
          if (e2 instanceof Map)
            e2.forEach((t3, e3) => {
              r2.insert(e3, t3);
            });
          else
            for (const [t3, s2] of Object.entries(e2))
              r2.insert(t3, s2);
        return r2;
      }
      len() {
        return this.size;
      }
      insert(t3, e2) {
        let r2 = null, s2 = this.root, n3 = t3;
        for (; ; ) {
          if (n3.length === 0) {
            if (s2.isLeaf()) {
              const t4 = s2.leaf.val;
              return s2.leaf.val = e2, [t4, true];
            }
            return s2.leaf = new Gs(t3, e2), this.size++, [void 0, false];
          }
          if (r2 = s2, s2 = s2.getEdge(n3.charCodeAt(0)), s2 === null) {
            const s3 = new Vs(n3.charCodeAt(0), new Ks());
            return s3.node.leaf = new Gs(t3, e2), s3.node.prefix = n3, r2.addEdge(s3), this.size++, [void 0, false];
          }
          const i2 = Js(n3, s2.prefix);
          if (i2 === s2.prefix.length) {
            n3 = n3.substring(i2);
            continue;
          }
          this.size++;
          const a2 = new Ks();
          a2.prefix = n3.substring(0, i2), r2.updateEdge(n3.charCodeAt(0), a2), a2.addEdge(new Vs(s2.prefix.charCodeAt(i2), s2)), s2.prefix = s2.prefix.substring(i2);
          const o2 = new Gs(t3, e2);
          if (n3 = n3.substring(i2), n3.length === 0)
            return a2.leaf = o2, [void 0, false];
          const h2 = new Ks();
          return h2.leaf = o2, h2.prefix = n3, a2.addEdge(new Vs(n3.charCodeAt(0), h2)), [void 0, false];
        }
      }
      delete(t3) {
        let e2 = null, r2 = 0, s2 = this.root, n3 = t3;
        for (; ; ) {
          if (n3.length === 0) {
            if (!s2.isLeaf())
              break;
            const t4 = s2.leaf;
            return s2.leaf = null, this.size--, e2 !== null && s2.edges.length === 0 && e2.delEdge(r2), s2 !== this.root && s2.edges.length === 1 && s2.mergeChild(), e2 === null || e2 === this.root || e2.edges.length !== 1 || e2.isLeaf() || e2.mergeChild(), [t4.val, true];
          }
          if (e2 = s2, r2 = n3.charCodeAt(0), s2 = s2.getEdge(r2), s2 === null)
            break;
          if (!n3.startsWith(s2.prefix))
            break;
          n3 = n3.substring(s2.prefix.length);
        }
        return [void 0, false];
      }
      async deletePrefix(t3) {
        return await this.L(null, this.root, t3);
      }
      async L(t3, e2, r2) {
        if (r2.length === 0) {
          let r3 = 0;
          return await Zs(e2, (t4, e3) => (r3++, Promise.resolve(false))), e2.isLeaf() && (e2.leaf = null), e2.edges = [], t3 === null || t3 === this.root || t3.edges.length !== 1 || t3.isLeaf() || t3.mergeChild(), this.size -= r3, r3;
        }
        const s2 = r2.charCodeAt(0), n3 = e2.getEdge(s2);
        return n3 === null || !n3.prefix.startsWith(r2) && !r2.startsWith(n3.prefix) ? 0 : (r2 = n3.prefix.length > r2.length ? r2.substring(r2.length) : r2.substring(n3.prefix.length), this.L(e2, n3, r2));
      }
      get(t3) {
        let e2 = this.root, r2 = t3;
        for (; ; ) {
          if (r2.length === 0) {
            if (e2.isLeaf())
              return [e2.leaf.val, true];
            break;
          }
          if (e2 = e2.getEdge(r2.charCodeAt(0)), e2 === null)
            break;
          if (!r2.startsWith(e2.prefix))
            break;
          r2 = r2.substring(e2.prefix.length);
        }
        return [void 0, false];
      }
      longestPrefix(t3) {
        let e2 = null, r2 = this.root, s2 = t3;
        for (; r2.isLeaf() && (e2 = r2.leaf), s2.length !== 0 && (r2 = r2.getEdge(s2.charCodeAt(0)), r2 !== null) && s2.startsWith(r2.prefix); )
          s2 = s2.substring(r2.prefix.length);
        return e2 !== null ? [e2.key, e2.val, true] : ["", void 0, false];
      }
      minimum() {
        let t3 = this.root;
        for (; ; ) {
          if (t3.isLeaf())
            return [t3.leaf.key, t3.leaf.val, true];
          if (!(t3.edges.length > 0))
            break;
          t3 = t3.edges[0].node;
        }
        return ["", void 0, false];
      }
      maximum() {
        let t3 = this.root;
        for (; ; ) {
          const e2 = t3.edges.length;
          if (!(e2 > 0)) {
            if (t3.isLeaf())
              return [t3.leaf.key, t3.leaf.val, true];
            break;
          }
          t3 = t3.edges[e2 - 1].node;
        }
        return ["", void 0, false];
      }
      async walk(t3) {
        await Zs(this.root, t3);
      }
      async walkPrefix(t3, e2) {
        let r2 = this.root, s2 = t3;
        for (; ; ) {
          if (s2.length === 0)
            return void await Zs(r2, e2);
          if (r2 = r2.getEdge(s2.charCodeAt(0)), r2 === null)
            return;
          if (!s2.startsWith(r2.prefix))
            return void (r2.prefix.startsWith(s2) && await Zs(r2, e2));
          s2 = s2.substring(r2.prefix.length);
        }
      }
      async walkPath(t3, e2) {
        let r2 = this.root, s2 = t3;
        for (; ; ) {
          if (r2.leaf !== null && await e2(r2.leaf.key, r2.leaf.val))
            return;
          if (s2.length === 0)
            return;
          if (r2 = r2.getEdge(s2.charCodeAt(0)), r2 === null)
            return;
          if (!s2.startsWith(r2.prefix))
            break;
          s2 = s2.substring(r2.prefix.length);
        }
      }
      async toMap() {
        const t3 = {};
        return await this.walk((e2, r2) => (t3[e2] = r2, Promise.resolve(false))), t3;
      }
    };
    async function Zs(t2, e2) {
      if (t2.leaf !== null && await e2(t2.leaf.key, t2.leaf.val))
        return true;
      let r2 = 0, s2 = t2.edges.length;
      for (; r2 < s2; ) {
        const n3 = t2.edges[r2];
        if (await Zs(n3.node, e2))
          return true;
        if (t2.edges.length === 0)
          return Zs(t2, e2);
        t2.edges.length >= s2 && r2++, s2 = t2.edges.length;
      }
      return false;
    }
    var Xs = class {
      constructor(t2) {
        __publicField(this, "trees");
        this.trees = t2;
      }
      walkPrefixRaw(t2, e2) {
        for (const r2 of this.trees)
          r2.walkPrefixRaw(t2, e2);
      }
    };
    var Qs = class {
      constructor(t2) {
        __publicField(this, "trees");
        this.trees = t2;
      }
      delete(t2) {
        for (const e2 of this.trees)
          e2.delete(t2);
      }
      deleteAll(t2) {
        for (const e2 of this.trees)
          e2.deleteAll(t2);
      }
      async deletePrefix(t2) {
        let e2 = 0;
        for (const r2 of this.trees)
          e2 += await r2.deletePrefix(t2);
        return Promise.resolve(e2);
      }
      async deletePrefixAll(t2) {
        let e2 = 0;
        for (const r2 of this.trees)
          e2 += await r2.deletePrefixAll(t2);
        return e2;
      }
      lock(t2) {
        const e2 = this.trees.map((e3) => e3.lock(t2));
        return () => {
          for (const t3 of e2)
            t3();
        };
      }
      canLock() {
        for (const t2 of this.trees)
          if (!t2.canLock())
            return false;
        return true;
      }
    };
    function tn(t2) {
      return t2 === "/" ? "" : t2;
    }
    function en2(t2) {
      const e2 = function(t3) {
        return t3 === "" ? null : t3.length < 2 ? new Error(`too short key: "${t3}"`) : t3[0] !== "/" ? new Error(`key must start with '/': "${t3}"`) : t3[t3.length - 1] === "/" ? new Error(`key must not end with '/': "${t3}"`) : null;
      }(t2);
      if (e2)
        throw e2;
      return t2;
    }
    function rn() {
      return new sn();
    }
    var sn = class {
      constructor() {
        __publicField(this, "mu");
        __publicField(this, "tree");
        __publicField(this, "zero");
        this.tree = new Ys(), this.zero = void 0;
        let t2 = false, e2 = 0;
        this.mu = { lock: () => {
          for (; t2 || e2 > 0; )
            ;
          t2 = true;
        }, unlock: () => {
          t2 = false;
        }, rLock: () => {
          for (; t2; )
            ;
          e2++;
        }, rUnlock: () => {
          e2--;
        } };
      }
      get(t2) {
        this.mu.rLock();
        try {
          const [e2, r2] = this.tree.get(t2);
          return r2 ? e2 : this.zero;
        } finally {
          this.mu.rUnlock();
        }
      }
      longestPrefix(t2) {
        this.mu.rLock();
        try {
          const [e2, r2, s2] = this.tree.longestPrefix(t2);
          return s2 ? [e2, r2] : ["", this.zero];
        } finally {
          this.mu.rUnlock();
        }
      }
      insert(t2, e2) {
        this.mu.lock();
        try {
          return this.tree.insert(t2, e2), e2;
        } finally {
          this.mu.unlock();
        }
      }
      async walkPrefix(t2, e2, r2) {
        switch (t2) {
          case 0:
            break;
          case 1:
            this.mu.rLock();
            break;
          case 2:
            this.mu.lock();
        }
        try {
          let t3 = null;
          return await this.tree.walkPrefix(e2, async (e3, s2) => {
            const [n3, i2] = r2(e3, s2);
            return i2 ? (t3 = i2, Promise.resolve(true)) : n3;
          }), t3;
        } finally {
          switch (t2) {
            case 0:
              break;
            case 1:
              this.mu.rUnlock();
              break;
            case 2:
              this.mu.unlock();
          }
        }
      }
    };
    var nn = class t2 {
      constructor(t3, e2) {
        __publicField(this, "d");
        __publicField(this, "v");
        __publicField(this, "trees");
        if (e2 <= 0)
          throw new Error("length must be > 0");
        this.d = t3, this.v = 0, this.trees = [];
        for (let t4 = 0; t4 < e2; t4++)
          this.trees.push(rn());
      }
      static newTreeShiftTree(e2, r2) {
        return new t2(e2, r2);
      }
      shape(e2, r2) {
        if (e2 !== this.d)
          throw new Error("dimension mismatch");
        if (r2 >= this.trees.length)
          throw new Error("value out of range");
        const s2 = Object.create(t2.prototype);
        return Object.assign(s2, this), s2.v = r2, s2;
      }
      get(t3) {
        return this.trees[this.v].get(t3);
      }
      longestPrefix(t3) {
        return this.trees[this.v].longestPrefix(t3);
      }
      insert(t3, e2) {
        return this.trees[this.v].insert(t3, e2);
      }
      async walkPrefix(t3, e2, r2) {
        return await this.trees[this.v].walkPrefix(t3, e2, r2);
      }
      delete(t3) {
        for (const e2 of this.trees)
          e2.tree.delete(t3);
      }
      async deletePrefix(t3) {
        let e2 = 0;
        for (const r2 of this.trees)
          e2 += await r2.tree.deletePrefix(t3);
        return e2;
      }
      lock(t3) {
        if (t3) {
          for (const t4 of this.trees)
            t4.mu.lock();
          return () => {
            for (const t4 of this.trees)
              t4.mu.unlock();
          };
        }
        for (const t4 of this.trees)
          t4.mu.rLock();
        return () => {
          for (const t4 of this.trees)
            t4.mu.rUnlock();
        };
      }
    };
    var an = class t2 {
      constructor(t3) {
        __publicField(this, "tree");
        __publicField(this, "dims");
        __publicField(this, "shifter");
        __publicField(this, "mu");
        if (!t3.shifter)
          throw new Error("Shifter is required");
        this.shifter = t3.shifter, this.tree = new Ys(), this.dims = [0];
        let e2 = false, r2 = 0;
        this.mu = { lock: () => {
          for (; e2 || r2 > 0; )
            ;
          e2 = true;
        }, unlock: () => {
          e2 = false;
        }, rLock: () => {
          for (; e2; )
            ;
          r2++;
        }, rUnlock: () => {
          r2--;
        }, tryLock: () => !(e2 || r2 > 0 || (e2 = true, 0)) };
      }
      static new(e2) {
        return new t2(e2);
      }
      delete(t3) {
        this.deleteInternal(t3);
      }
      async deleteAll(t3) {
        await this.tree.walkPrefix(t3, (t4, e2) => {
          const [r2, s2] = this.tree.delete(t4);
          return Promise.resolve(false);
        });
      }
      async deletePrefix(t3) {
        let e2 = 0;
        const r2 = [];
        await this.tree.walkPrefix(t3, (t4, e3) => (r2.push(t4), Promise.resolve(false)));
        for (const t4 of r2)
          this.deleteInternal(t4) && e2++;
        return e2;
      }
      deleteInternal(t3) {
        let e2 = false;
        const [r2, s2] = this.tree.get(t3);
        if (s2) {
          const [s3, n3] = this.shifter.delete(r2, this.dims);
          e2 = s3, n3 && this.tree.delete(t3);
        }
        return e2;
      }
      async deletePrefixAll(t3) {
        let e2 = 0;
        return await this.tree.walkPrefix(t3, (t4, r2) => {
          const [s2, n3] = this.tree.delete(t4);
          return n3 && e2++, Promise.resolve(false);
        }), e2;
      }
      increment(t3) {
        return this.shape(t3, this.dims[t3] + 1);
      }
      insertIntoCurrentDimension(t3, e2) {
        t3 = en2(tn(t3));
        const [r2, s2] = this.tree.get(t3);
        return s2 && (e2 = this.shifter.insertInto(r2, e2, this.dims)), this.tree.insert(t3, e2), [e2, true];
      }
      insertIntoValuesDimension(t3, e2) {
        t3 = en2(tn(t3));
        const [r2, s2] = this.tree.get(t3);
        return s2 && (e2 = this.shifter.insert(r2, e2)), this.tree.insert(t3, e2), [e2, true];
      }
      insertRawWithLock(t3, e2) {
        this.mu.lock();
        try {
          return this.tree.insert(t3, e2);
        } finally {
          this.mu.unlock();
        }
      }
      insertWithLock(t3, e2) {
        this.mu.lock();
        try {
          return this.insertIntoValuesDimension(t3, e2);
        } finally {
          this.mu.unlock();
        }
      }
      len() {
        return this.tree.len();
      }
      canLock() {
        const t3 = this.mu.tryLock();
        return t3 && this.mu.unlock(), t3;
      }
      lock(t3) {
        return t3 ? this.mu.lock() : this.mu.rLock(), () => {
          t3 ? this.mu.unlock() : this.mu.rUnlock();
        };
      }
      longestPrefix(t3, e2, r2) {
        let s2 = t3;
        for (; ; ) {
          const [t4, n3, i2] = this.tree.longestPrefix(s2);
          if (i2) {
            const [s3, i3] = this.shift(n3, e2);
            if (i3 && (!r2 || r2(s3)))
              return [t4, s3];
          }
          if (s2 === "" || s2 === "/")
            return ["", void 0];
          const a2 = s2.lastIndexOf("/");
          if (a2 === 0)
            s2 = "";
          else {
            if (!(a2 > 0))
              break;
            s2 = s2.substring(0, a2);
          }
        }
        return ["", void 0];
      }
      longestPrefixAll(t3) {
        const [e2, , r2] = this.tree.longestPrefix(t3);
        return [e2, r2];
      }
      getRaw(t3) {
        const [e2, r2] = this.tree.get(t3);
        return r2 ? [e2, true] : [void 0, false];
      }
      async walkPrefixRaw(t3, e2) {
        await this.tree.walkPrefix(t3, (t4, r2) => e2(t4, r2));
      }
      shape(t3, e2) {
        const r2 = this.clone();
        return r2.dims[t3] = e2, r2;
      }
      toString() {
        return `Root{${this.dims}}`;
      }
      get(t3) {
        const [e2] = this.getInternal(t3);
        return e2;
      }
      forEachInDimension(t3, e2, r2) {
        t3 = tn(t3);
        const [s2, n3] = this.tree.get(t3);
        n3 && this.shifter.forEachInDimension(s2, e2, r2);
      }
      has(t3) {
        const [, e2] = this.getInternal(t3);
        return e2;
      }
      clone() {
        const e2 = Object.create(t2.prototype);
        return Object.assign(e2, this), e2.dims = [...this.dims], e2;
      }
      shift(t3, e2) {
        const [r2, s2] = this.shifter.shift(t3, this.dims, e2);
        return [r2, s2];
      }
      getInternal(t3) {
        t3 = tn(t3);
        const [e2, r2] = this.tree.get(t3);
        if (!r2)
          return [void 0, false];
        const [s2, n3] = this.shift(e2, true);
        return [s2, n3];
      }
    };
    var on = class t2 {
      constructor(t3) {
        __publicField(this, "tree");
        __publicField(this, "handle");
        __publicField(this, "prefix");
        __publicField(this, "lockType");
        __publicField(this, "noShift");
        __publicField(this, "exact");
        __publicField(this, "debug");
        __publicField(this, "walkContext");
        __publicField(this, "skipPrefixes", []);
        if (!t3.tree)
          throw new Error("Tree is required");
        this.tree = t3.tree, this.handle = t3.handle, this.prefix = t3.prefix || "", this.lockType = t3.lockType || 0, this.noShift = t3.noShift || false, this.exact = t3.exact || false, this.debug = t3.debug || false, this.walkContext = t3.walkContext;
      }
      extend() {
        const e2 = new t2({ tree: this.tree, handle: this.handle, prefix: this.prefix, lockType: this.lockType, noShift: this.noShift, exact: this.exact, debug: this.debug, walkContext: this.walkContext });
        return e2.resetLocalState(), e2;
      }
      skipPrefix(...t3) {
        this.skipPrefixes.push(...t3);
      }
      shouldSkip(t3) {
        for (const e2 of this.skipPrefixes)
          if (t3.startsWith(e2))
            return true;
        return false;
      }
      async walk() {
        this.resetLocalState();
        let t3 = null;
        this.lockType > 0 && (t3 = this.tree.lock(this.lockType === 2));
        try {
          let t4 = null;
          const e2 = async (e3, r2) => {
            if (this.shouldSkip(e3))
              return false;
            const [s2, n3, i2] = this.toT(this.tree, r2);
            if (!n3)
              return false;
            const [a2, o2] = await this.handle(e3, s2, i2);
            return !(!a2 && !o2 || (t4 = o2, 0));
          };
          return this.prefix !== "" ? await this.tree.tree.walkPrefix(this.prefix, e2) : await this.tree.tree.walk(e2), t4;
        } finally {
          t3 && t3();
        }
      }
      resetLocalState() {
        this.skipPrefixes = [];
      }
      toT(t3, e2) {
        if (this.noShift)
          return [e2, true, 2];
        {
          const [r2, s2, n3] = t3.shifter.shift(e2, t3.dims, this.exact);
          return [r2, s2, n3];
        }
      }
    };
    var hn = class {
      delete(t2, e2) {
        return [t2.delete(e2[Hs(1)]), t2.isEmpty()];
      }
      shift(t2, e2, r2) {
        const [s2, n3] = t2.shift(e2[Hs(1)], r2);
        return s2 !== null ? n3 ? [s2, true, 1] : [s2, true, 2] : [new fn(), false, 2];
      }
      forEachInDimension(t2, e2, r2) {
        if (e2 !== Hs(1))
          throw new Error("only language dimension supported");
        r2(t2);
      }
      insertInto(t2, e2, r2) {
        return t2.mergeWithLang(e2, r2[Hs(1)]);
      }
      insert(t2, e2) {
        return t2.merge(e2);
      }
    };
    var cn = class extends hn {
      shift(t2, e2, r2) {
        const [s2, n3] = t2.shift(e2[Hs(1)], r2);
        return s2 !== null && n3 ? [s2, true, 1] : [new fn(), false, 2];
      }
    };
    var un = class extends hn {
      shift(t2, e2, r2) {
        const [s2, n3] = t2.shift(e2[Hs(1)], r2);
        return s2 !== null ? n3 ? [s2, true, 1] : [s2, true, 2] : [new fn(), false, 2];
      }
    };
    var ln = class {
      constructor(t2, e2) {
        __publicField(this, "pageTreesNodeInstance");
        __publicField(this, "term");
        this.pageTreesNodeInstance = t2, this.term = e2;
      }
      getPage() {
        return this.pageTreesNodeInstance.getPage();
      }
      getPages() {
        return this.pageTreesNodeInstance.getPages();
      }
      getResource() {
        return this.pageTreesNodeInstance.getResource();
      }
      isEmpty() {
        return this.pageTreesNodeInstance.isEmpty();
      }
      shift(t2, e2) {
        return this.pageTreesNodeInstance.shift(t2, e2);
      }
    };
    var fn = class {
      constructor() {
        __publicField(this, "nodes");
        this.nodes = /* @__PURE__ */ new Map();
      }
      setNode(t2, e2) {
        this.nodes.set(t2, e2);
      }
      merge(t2) {
        const e2 = /* @__PURE__ */ new Map();
        for (const t3 of this.nodes.keys())
          e2.set(t3.pageLanguage(), t3);
        for (const [r2, s2] of t2.nodes.entries()) {
          const t3 = e2.get(r2.pageLanguage());
          t3 ? this.nodes.set(t3, s2) : this.nodes.set(r2, s2);
        }
        return this;
      }
      mergeWithLang(t2, e2) {
        const r2 = /* @__PURE__ */ new Map();
        for (const t3 of this.nodes.keys())
          r2.set(t3.pageLanguage(), t3);
        for (const [s2, n3] of t2.nodes.entries()) {
          const t3 = r2.get(s2.pageLanguage());
          if (t3) {
            const r3 = this.nodes.get(t3);
            r3 && r3.pageIdentity().pageLanguageIndex() === e2 && this.remove(t3);
          }
          this.nodes.set(s2, n3);
        }
        return this;
      }
      remove(t2) {
        const e2 = this.nodes.get(t2);
        return !!e2 && (this.markStale(e2), this.nodes.delete(t2), true);
      }
      delete(t2) {
        for (const [e2, r2] of this.nodes.entries())
          if (r2.pageIdentity().pageLanguageIndex() === t2)
            return this.remove(e2);
        return false;
      }
      isEmpty() {
        return this.nodes.size === 0;
      }
      shift(t2, e2) {
        let r2 = null;
        for (const [e3, s2] of this.nodes.entries())
          if (r2 === null && (r2 = s2), s2.pageIdentity().pageLanguageIndex() === t2)
            return [dn(s2), true];
        return r2 === null || e2 ? [null, false] : [dn(r2), false];
      }
      getPage() {
        for (const t2 of this.nodes.values())
          if (t2 && typeof t2.kind == "function")
            return [t2, true];
        return [null, false];
      }
      getPages() {
        const t2 = [];
        for (const e2 of this.nodes.values())
          e2 && typeof e2.kind == "function" && t2.push(e2);
        return t2;
      }
      getResource() {
        for (const t2 of this.nodes.values())
          return [t2, true];
        return [null, false];
      }
      markStale(t2) {
        "staleVersions" in t2 && t2.staleVersions;
      }
    };
    var wn = class {
      constructor() {
        __publicField(this, "treePages");
        __publicField(this, "treeResources");
        __publicField(this, "treePagesResources");
        __publicField(this, "treeTaxonomyEntries");
        __publicField(this, "resourceTrees");
        this.treePages = new an({ shifter: new cn() }), this.treeResources = new an({ shifter: new un() }), this.treeTaxonomyEntries = nn.newTreeShiftTree(0, 10), this.treePagesResources = new Xs([]), this.resourceTrees = new Qs([]), this.treePagesResources = new Xs([this.treePages, this.treeResources]), this.resourceTrees = new Qs([this.treeResources]);
      }
      createMutableTrees() {
        this.treePagesResources = new Xs([this.treePages, this.treeResources]), this.resourceTrees = new Qs([this.treeResources]);
      }
      get TreePages() {
        return this.treePages;
      }
      get TreeResources() {
        return this.treeResources;
      }
      get TreePagesResources() {
        return this.treePagesResources;
      }
      get TreeTaxonomyEntries() {
        return this.treeTaxonomyEntries;
      }
      get ResourceTrees() {
        return this.resourceTrees;
      }
    };
    function dn(t2) {
      const e2 = new fn();
      return t2 && e2.setNode(t2.pageIdentity(), t2), e2;
    }
    q();
    var gn = 0;
    var pn = A("content", { component: "pagesource" });
    var mn = class {
      constructor(t2) {
        __publicField(this, "id");
        __publicField(this, "identity");
        __publicField(this, "file");
        this.id = (++gn).toString(), this.identity = new Ts(gn), this.file = t2;
      }
      sourceKey() {
        return `${this.identity.lang}/${this.file.filename()}`.replace(/\\/g, "/");
      }
      async contentSource() {
        return await this.readSourceAll();
      }
      async readSourceAll() {
        try {
          const t2 = await this.file.open(), e2 = await t2.stat(), r2 = new Uint8Array(e2.size()), s2 = await t2.read(r2);
          return await t2.close(), s2.buffer;
        } catch (t2) {
          const e2 = t2 instanceof Error ? t2.message : String(t2);
          throw new Error(`Failed to read file content: ${e2}`);
        }
      }
      async posOffset(t2) {
        try {
          const e2 = await this.contentSource();
          return function(t3, e3, r2) {
            if (r2 < 0)
              return { filename: t3, lineNumber: 0, columnNumber: 0, offset: 0 };
            const s2 = e3.slice(0, r2);
            let n3 = 1;
            for (let t4 = 0; t4 < s2.length; t4++)
              s2[t4] === 10 && n3++;
            let i2 = -1;
            for (let t4 = s2.length - 1; t4 >= 0; t4--)
              if (s2[t4] === 10) {
                i2 = t4;
                break;
              }
            return { filename: t3, lineNumber: n3, columnNumber: r2 - i2, offset: r2 };
          }(this.file.filename(), e2, t2);
        } catch (t3) {
          throw new Error(`failed to read content source for "${this.file.filename()}": ${t3}`);
        }
      }
      pageIdentity() {
        return this.identity;
      }
      pageFile() {
        return this.file;
      }
      staleVersions() {
        return [];
      }
      section() {
        return this.file.section();
      }
      paths() {
        return this.file.paths();
      }
      path() {
        return this.file.paths().path();
      }
      opener() {
        return () => this.file.open();
      }
      openReader() {
        return { read: async () => new Uint8Array(0) };
      }
      async content() {
        try {
          return pn.error(`Reading content not implemented from: ${this.file.filename()}`), new Uint8Array(0);
        } catch (t2) {
          const e2 = `failed to read content source for "${this.file.filename()}": ${t2}`;
          throw pn.error(e2), new Error(e2);
        }
      }
    };
    function yn(t2) {
      return new mn(t2);
    }
    q();
    var bn = A("content", { component: "pagemap" });
    function En(t2) {
      return t2.endsWith("/") || (t2 += "/"), t2;
    }
    var Sn = new fn();
    var vn = class {
      constructor() {
        __publicField(this, "initOnce", false);
        __publicField(this, "m", /* @__PURE__ */ new Map());
      }
    };
    var Tn = class {
      constructor(t2) {
        __publicField(this, "initFn");
        __publicField(this, "contentTreeReverseIndexMap");
        this.initFn = t2, this.contentTreeReverseIndexMap = new vn();
      }
      reset() {
        this.contentTreeReverseIndexMap = new vn();
      }
      get(t2) {
        return this.contentTreeReverseIndexMap.initOnce || (this.contentTreeReverseIndexMap.m = /* @__PURE__ */ new Map(), this.initFn(this.contentTreeReverseIndexMap.m), this.contentTreeReverseIndexMap.initOnce = true), this.contentTreeReverseIndexMap.m.get(t2) || null;
      }
    };
    var xn = (t2) => t2.kind() === "page";
    var Pn = (t2) => !t2.shouldList || t2.shouldList(false);
    var $n = (t2) => !t2.shouldList || t2.shouldList(true);
    var Rn = class {
      constructor(t2, e2, r2 = Pn) {
        __publicField(this, "path");
        __publicField(this, "keyPart");
        __publicField(this, "include");
        this.path = t2, this.keyPart = e2, this.include = r2;
      }
      key() {
        return this.path + "/" + this.keyPart;
      }
    };
    var Ln = class extends Rn {
      constructor(t2, e2, r2, s2, n3, i2) {
        super(t2, e2, i2);
        __publicField(this, "recursive");
        __publicField(this, "includeSelf");
        __publicField(this, "index");
        this.recursive = r2, this.includeSelf = s2, this.index = n3;
      }
      key() {
        return "gagesInSection/" + super.key() + "/" + this.recursive.toString() + "/" + this.index.toString() + "/" + this.includeSelf.toString();
      }
    };
    var Nn = class extends wn {
      constructor(t2) {
        super();
        __publicField(this, "pageReverseIndex", null);
        __publicField(this, "pageBuilder");
        this.pageBuilder = t2;
      }
      setupReverseIndex() {
        this.pageReverseIndex = new Tn(async (t2) => {
          const e2 = new on({ tree: this.treePages, lockType: 1, handle: async (e3, r2, s2) => {
            if (r2) {
              const [e4, s3] = r2.getPage();
              if (!s3)
                return [false, null];
              e4.pageFile && e4.pageFile() && ((e5, r3) => {
                const s4 = t2.get(e5);
                s4 && s4 !== Sn ? t2.set(e5, Sn) : s4 || t2.set(e5, r3);
              })(e4.paths().baseNameNoIdentifier(), r2);
            }
            return [false, null];
          } });
          try {
            await e2.walk();
          } catch (t3) {
            bn.error(`setupReverseIndex error: ${t3}`);
          }
        });
      }
      insertResourceNode(t2, e2) {
        const r2 = this.treeResources, s2 = r2.lock(true);
        try {
          r2.insertIntoValuesDimension(t2, e2);
        } finally {
          s2();
        }
      }
      async addFi(t2) {
        if (t2.fileInfo().isDir())
          return;
        const e2 = yn(t2), r2 = e2.paths().base();
        switch (e2.file.getBundleType()) {
          case 0:
            this.insertResourceNode(r2, dn(e2));
            break;
          case 1:
            const t3 = await this.pageBuilder.withSource(e2).build();
            if (!t3)
              return;
            this.insertResourceNode(r2, dn(t3));
            break;
          default:
            const s2 = await this.pageBuilder.withSource(e2).build();
            this.treePages.insertWithLock(e2.paths().base(), dn(s2));
        }
      }
      async assemble() {
        await this.assembleStructurePages(), await this.applyAggregates(), await this.cleanPages(), await this.assembleTerms();
      }
      async assembleTerms() {
        for (const t2 of this.pageBuilder.langSvc.languageIndexes()) {
          const e2 = this.treePages.shape(0, t2), r2 = this.treeTaxonomyEntries.shape(0, t2);
          await this.pageBuilder.term.assemble(e2, r2, this.pageBuilder, t2);
        }
      }
      async cleanPages() {
      }
      async applyAggregates() {
      }
      async assembleStructurePages() {
        await this.addMissingTaxonomies();
        for (const t2 of this.pageBuilder.langSvc.languageIndexes()) {
          const e2 = this.treePages.shape(0, t2);
          await this.pageBuilder.section.assemble(e2, this.pageBuilder, t2);
        }
        await this.addMissingStandalone();
      }
      async addMissingTaxonomies() {
        const t2 = this.treePages.lock(true);
        try {
          for (const t3 of this.pageBuilder.langSvc.languageIndexes()) {
            const e2 = this.treePages.shape(0, t3);
            await this.pageBuilder.taxonomy.assemble(e2, this.pageBuilder, t3);
          }
        } finally {
          t2();
        }
      }
      async addMissingStandalone() {
        const t2 = this.treePages, e2 = t2.lock(true);
        try {
          await this.pageBuilder.standalone.assemble(t2, this.pageBuilder);
        } finally {
          e2();
        }
      }
      async getResourcesForPage(t2) {
        const e2 = [];
        return await this.forEachResourceInPage(t2, 0, false, (t3, r2, s2) => {
          const [n3, i2] = r2.getResource();
          return i2 && e2.push(n3), [false, null];
        }), e2;
      }
      async forEachResourceInPage(t2, e2, r2, s2) {
        let n3 = t2.paths().base();
        n3 === "/" && (n3 = "");
        const i2 = En(n3), a2 = t2.kind() !== "page", o2 = new on({ tree: this.treeResources.shape(0, t2.pageIdentity().pageLanguageIndex()), prefix: i2, lockType: e2, exact: r2, handle: async (t3, e3, r3) => {
          if (a2) {
            const [e4] = this.treePages.longestPrefixAll(t3);
            if (e4 !== n3 && this.pathDir(e4) !== this.pathDir(t3))
              return o2.skipPrefix(e4 + "/"), [false, null];
          }
          return s2(t3, e3, r3);
        } });
        try {
          await o2.walk();
        } catch (t3) {
          bn.error(`forEachResourceInPage error: ${t3}`);
        }
      }
      async getPagesInSection(t2, e2) {
        const r2 = e2.key(), s2 = this.treePages.shape(0, t2);
        return this.getOrCreatePagesFromCacheSync(null, r2, async (t3) => {
          const r3 = En(e2.path), n3 = [];
          let i2 = "";
          const a2 = e2.include, o2 = new on({ tree: s2, prefix: r3, handle: async (t4, r4, s3) => {
            if (e2.recursive) {
              const [t5, e3] = r4.getPage();
              return e3 && a2(t5) && n3.push(t5), [false, null];
            }
            const [h2, c2] = r4.getPage();
            if (c2 && a2(h2) && n3.push(h2), !h2.isPage || !h2.isPage()) {
              const e3 = t4 + "/";
              i2 !== "" && i2 === e3 || o2.skipPrefix(e3), i2 = e3;
            }
            return [false, null];
          } });
          try {
            if (await o2.walk(), e2.includeSelf) {
              const t5 = s2.get(e2.path);
              if (t5) {
                const [e3, r4] = t5.getPage();
                r4 && a2(e3) && n3.push(e3);
              }
            }
            const t4 = n3;
            return function(t5) {
              Fs(Is).sort(t5);
            }(t4), Promise.resolve(t4);
          } catch (t4) {
            bn.error(`getPagesInSection error: ${t4}`);
          }
          return Promise.resolve(n3);
        });
      }
      async getOrCreatePagesFromCacheSync(t2, e2, r2) {
        return await r2(e2);
      }
      async getPagesWithTerm(t2, e2) {
        const r2 = e2.key(), s2 = this.treeTaxonomyEntries.shape(0, t2);
        return await this.getOrCreatePagesFromCacheSync(null, r2, async (t3) => {
          const r3 = [], n3 = e2.include;
          try {
            await s2.walkPrefix(0, En(e2.path), (t5, e3) => {
              const [s3, i2] = e3.getPage();
              return i2 && n3(s3) && r3.push(s3), [false, null];
            });
            const t4 = r3;
            return Ns(t4), t4;
          } catch (t4) {
            bn.error(`getPagesWithTerm error: ${t4}`);
          }
          return r3;
        });
      }
      getTermsForPageInTaxonomy(t2, e2, r2) {
        const s2 = ((n3 = r2).startsWith("/") || (n3 = "/" + n3), n3);
        var n3;
        const i2 = this.treeTaxonomyEntries.shape(0, t2);
        return this.getOrCreatePagesFromCacheSync(null, s2 + e2, async (t3) => {
          const r3 = [];
          try {
            await i2.walkPrefix(0, En(s2), (t5, s3) => (t5.endsWith(e2) && r3.push(s3.term.page), [false, null]));
            const t4 = r3;
            return Ns(t4), t4;
          } catch (t4) {
            bn.error(`getTermsForPageInTaxonomy error: ${t4}`);
          }
          return r3;
        });
      }
      async getSections(t2, e2) {
        const r2 = [];
        let s2 = "";
        const n3 = this.treePages.shape(0, t2), i2 = new on({ tree: n3, prefix: e2, handle: async (t3, e3, n4) => {
          const [a2, o2] = e3.getPage();
          return o2 ? (a2.isPage && a2.isPage() || (s2 !== "" && t3.startsWith(s2) || (a2.isSection && a2.isSection() && a2.shouldList && a2.shouldList(false) && a2.parent && a2.parent() === a2 ? r2.push(a2) : i2.skipPrefix(t3 + "/")), s2 = t3 + "/"), [false, null]) : [false, null];
        } });
        try {
          await i2.walk();
          const t3 = r2;
          return Ns(t3), t3;
        } catch (t3) {
          bn.error(`getSections error: ${t3}`);
        }
        return r2;
      }
      pathDir(t2) {
        const e2 = t2.lastIndexOf("/");
        return e2 === -1 ? "" : t2.substring(0, e2);
      }
    };
    q();
    var Fn = A("content", { component: "pagecollector" });
    var Dn = class {
      constructor(t2, e2) {
        __publicField(this, "m");
        __publicField(this, "fs");
        __publicField(this, "processedPaths", /* @__PURE__ */ new Set());
        this.m = t2, this.fs = e2;
      }
      async collect() {
        try {
          const t2 = "", e2 = this.fs.contentFs();
          for (const r2 of e2) {
            this.processedPaths.clear();
            const e3 = await r2.stat(t2);
            await this.collectDir(r2, t2, e3);
          }
        } catch (t2) {
          Fn.error(`Failed to collect directory: ${t2}, continuing...`);
        }
      }
      async collectDir(t2, e2, r2) {
        try {
          await this.fs.walkContent(t2, e2, { hookPre: async (t3, e3, r3) => {
            const s2 = e3;
            if (this.processedPaths.has(s2))
              return Fn.warn("Path already processed!", { path: s2, dirName: t3.name(), dirIsDir: t3.isDir(), readdirLength: r3.length }), [];
            if (this.processedPaths.add(s2), r3.length === 0)
              return [];
            for (const t4 of r3) {
              if (t4.isDir && t4.isDir())
                continue;
              const e4 = Ls(t4);
              await this.m.addFi(e4);
            }
            return r3;
          }, walkFn: async (t3, e3) => {
          } }, { info: r2 });
        } catch (t3) {
          throw Fn.error(`Failed to collect directory: ${t3}`, { path: e2, rootName: r2.name(), rootIsDir: r2.isDir(), stack: t3.stack || "No stack trace available" }), new Error(`Failed to collect directory: ${t3}`);
        }
      }
      async handleBundleLeaf(t2, e2, r2, s2) {
        const n3 = e2.paths(), i2 = async (t3, r3) => {
          if (r3.isDir())
            return;
          const s3 = Ls(r3);
          r3 !== e2.fileInfo() && (s3.isLeafBundle() && s3.paths().dir() === n3.dir() || s3.shiftToResource()), await this.m.addFi(s3);
        }, a2 = this.fs.contentFs();
        for (const e3 of a2)
          await this.fs.walkContent(e3, r2, { walkFn: i2 }, { info: t2, dirEntries: s2 });
      }
    };
    q();
    var An = A("content", { component: "content" });
    var kn = class {
      constructor(t2, e2, r2, s2) {
        __publicField(this, "fs");
        __publicField(this, "converter");
        __publicField(this, "pageMap");
        __publicField(this, "translator");
        this.fs = t2, this.converter = e2, this.pageMap = r2, this.translator = s2;
      }
      setTemplateSvc(t2) {
        this.pageMap.pageBuilder.templateSvc = t2;
      }
      async renderString(t2, ...e2) {
        if (e2.length < 1 || e2.length > 2)
          throw new Error("RenderString want 1 or 2 arguments");
        let r2 = 1;
        if (e2.length !== 1) {
          const t3 = e2[0];
          if (typeof t3 != "object" || t3 === null)
            throw new Error("first argument must be a map");
          throw new Error("RenderString not implemented yet");
        }
        r2 = 0;
        const s2 = e2[0], n3 = String(s2);
        return Ls(this.fs.newFileMetaInfoWithContent(n3)), n3;
      }
      async collectPages() {
        try {
          await this.process(), await this.assemble();
        } catch (t2) {
          throw new Error(`process/assemble: ${t2}`);
        }
      }
      async process() {
        try {
          const t2 = new Dn(this.pageMap, this.fs);
          await t2.collect();
        } catch (t2) {
          throw t2;
        }
      }
      async assemble() {
        try {
          await this.pageMap.assemble();
        } catch (t2) {
          throw t2;
        }
      }
      async getPageSources(t2) {
        let e2 = t2.paths().base();
        return e2 === "/" && (e2 = ""), await this.pageMap.getResourcesForPage(t2);
      }
      async globalPages(t2) {
        return await this.pageMap.getPagesInSection(t2, new Ln("", "global", true, true, 0, $n));
      }
      async globalRegularPages() {
        return await this.pageMap.getPagesInSection(0, new Ln("", "global", true, true, 0, (t2) => $n(t2) && xn(t2)));
      }
      async walkPages(t2, e2) {
        const r2 = this.pageMap.treePages.shape(0, t2), s2 = new on({ tree: r2, handle: async (t3, r3, s3) => {
          const [n3, i2] = r3.getPage();
          if (!i2)
            return [false, null];
          try {
            await e2(n3);
          } catch (t4) {
            return [false, t4 instanceof Error ? t4 : new Error(String(t4))];
          }
          return [false, null];
        } });
        try {
          await s2.walk();
        } catch (e3) {
          throw An.error(`WalkPages failed for langIndex ${t2}:`, e3), e3;
        }
      }
      async walkTaxonomies(t2, e2) {
        try {
          const r2 = this.pageMap.treePages.shape(0, t2), s2 = this.pageMap.pageBuilder.taxonomy;
          for (const n3 of s2.views) {
            const i2 = s2.pluralTreeKey(n3.plural()), a2 = new on({ tree: r2, prefix: En(i2), lockType: 1, handle: async (r3, s3, i3) => {
              const [a3, o2] = s3.getPage();
              if (!o2)
                return [false, null];
              if (a3.kind() === "term") {
                const s4 = a3;
                if (!s4.term)
                  return [true, new Error("term is empty")];
                const i4 = s4.term.toLowerCase();
                try {
                  const a4 = this.pageMap.treeTaxonomyEntries.shape(0, t2);
                  return await a4.walkPrefix(1, En(r3), (t3, r4) => {
                    const [a5, o3] = r4.getPage();
                    return o3 ? (e2(n3.plural(), i4, { weight: () => r4.term.Weight(), ordinal: () => r4.term.Ordinal(), page: () => a5, owner: () => s4 }).catch((t4) => {
                      An.error("Error in taxonomy walker:", t4);
                    }), [false, null]) : [false, null];
                  }), [false, null];
                } catch (t3) {
                  return [true, t3];
                }
              }
              return [false, null];
            } });
            await a2.walk();
          }
        } catch (t3) {
          throw t3;
        }
      }
      getPageFromPath(t2, e2) {
        try {
          const r2 = ms.createProcessor().parse(ts.COMPONENT_FOLDER_CONTENT, e2);
          let s2 = this.pageMap.treePages.shape(0, t2).get(r2.base());
          if (s2) {
            const [t3, e3] = s2.getPage();
            if (e3)
              return t3;
          }
          return null;
        } catch (t3) {
          return An.error(`\u274C Content.getPageFromPath error for path "${e2}":`, t3), null;
        }
      }
      getPageFromFile(t2, e2) {
        try {
          let r2 = this.pageMap.treePages.shape(0, t2).get(e2.paths().base());
          if (r2) {
            const [t3, e3] = r2.getPage();
            if (e3)
              return t3;
          }
          return null;
        } catch (t3) {
          return An.error(`\u274C Content.getPageFromPath error for path "${e2.path()}":`, t3), null;
        }
      }
      async handleChangeFiles(t2) {
        const e2 = [];
        for (const [r2, s2] of t2)
          try {
            await this.addOrUpdateFile(s2, e2);
          } catch (t3) {
            An.error(`Failed to process file change for ${r2}:`, t3);
          }
        return e2;
      }
      async addOrUpdateFile(t2, e2) {
        if (!t2.isDir())
          try {
            const r2 = Ls(t2), s2 = r2.paths().base();
            s2 && e2.push(s2), await this.pageMap.addFi(r2);
            const n3 = this.getPageFromFile(0, r2);
            n3 && n3.pageIdentity && n3.pageIdentity().markStale();
          } catch (e3) {
            throw An.error(`Failed to add/update file in PageMap: ${t2.fileName()}`, e3), e3;
          }
      }
      translate(t2, e2) {
        return this.translator ? this.translator.translate(t2, e2) : (An.warn("Translator not initialized, returning fallback translation"), `[i18n] ${e2}`);
      }
      getAvailableLanguages() {
        return this.translator ? this.translator.getAvailableLanguages() : [];
      }
      hasLanguageSupport(t2) {
        return !!this.translator && this.translator.hasLanguage(t2);
      }
    };
    var In = class {
      constructor(t2) {
        __publicField(this, "md");
        this.md = t2;
      }
      async convert(t2, e2) {
        return this.md.render(e2, t2);
      }
      async parseContent(t2) {
        return this.md.parseContent(t2);
      }
      async parseAndRenderContent(t2, e2) {
        return this.md.parseAndRenderContent(t2, e2);
      }
      async prepareRender(t2) {
        return this.md.prepareRender(t2);
      }
    };
    var Cn = class {
      constructor(t2) {
        __publicField(this, "rawSource");
        __publicField(this, "frontMatter");
        __publicField(this, "renderedContent", "");
        __publicField(this, "summary", "");
        __publicField(this, "wordCount", 0);
        __publicField(this, "readingTime", 0);
        __publicField(this, "toc");
        __publicField(this, "lazyRendered", true);
        __publicField(this, "lazyRender");
        this.rawSource = t2;
      }
      updateWithContentResult(t2) {
        t2.frontMatter && (this.frontMatter = t2.frontMatter), this.renderedContent = t2.renderedContent || "", this.summary = t2.summary, this.wordCount = t2.wordCount || 0, this.readingTime = t2.readingTime || 0;
      }
      getRawSource() {
        return this.rawSource;
      }
      async RenderedContent() {
        return await this.render(), this.renderedContent;
      }
      async Summary() {
        return await this.render(), this.summary;
      }
      async WordCount() {
        return await this.render(), this.wordCount;
      }
      async ReadingTime() {
        return await this.render(), this.readingTime;
      }
      async render() {
        return this.lazyRendered && this.lazyRender && (await this.lazyRender(), this.lazyRendered = false), Promise.resolve();
      }
      isEmpty() {
        return !this.rawSource || this.rawSource.length === 0;
      }
    };
    function On(t2) {
      return new Cn(t2);
    }
    q();
    var _n = A("content", { component: "section" });
    var Mn = class {
      constructor(t2) {
        __publicField(this, "home");
        __publicField(this, "seen");
        __publicField(this, "fsSvc");
        this.home = null, this.seen = {}, this.fsSvc = t2;
      }
      isHome(t2) {
        return t2 === "";
      }
      isSectionExist(t2) {
        return !(t2 !== "" && !this.seen[t2] && (this.seen[t2] = true, 1));
      }
      async assemble(t2, e2, r2) {
        this.seen = {};
        const s2 = new on({ tree: t2, lockType: 2, handle: async (t3, n3, i2) => {
          if (!n3)
            throw new Error("n is null");
          const [a2, o2] = n3.getPage();
          if (!o2)
            return [false, null];
          if (this.isHome(t3))
            return this.home = a2, [false, null];
          const h2 = a2.kind();
          if (h2 !== vs("page") && h2 !== vs("section"))
            return [false, null];
          const c2 = a2.paths().sections();
          for (const t4 of c2)
            if (!this.isSectionExist(t4))
              try {
                const n4 = yn(Ls(this.fsSvc.newFileMetaInfo("/" + t4 + "/_index.md"))), i3 = n4.paths().base();
                if (!s2.tree.get(i3)) {
                  const t5 = await e2.withSource(n4).withLangIdx(r2).kindBuild();
                  s2.tree.insertIntoValuesDimension(i3, dn(t5));
                }
              } catch (t5) {
                return [false, t5];
              }
          return [false, null];
        } });
        try {
          await s2.walk();
        } catch (t3) {
          throw _n.error("Error walking pages:", t3), t3;
        }
        if (!this.home && (await this.createHome(e2), this.home)) {
          const e3 = this.home;
          t2.insertWithLock(e3.paths().base(), dn(e3));
        }
      }
      async createHome(t2) {
        const e2 = yn(Ls(this.fsSvc.newFileMetaInfo("/_index.md"))), r2 = await t2.withSource(e2).kindBuild();
        this.home = r2;
      }
    };
    var Un = "_sitemap";
    var jn = class {
      constructor(t2) {
        __publicField(this, "fsSvc");
        this.fsSvc = t2;
      }
      async assemble(t2, e2) {
        const r2 = "/404", s2 = await this.addStandalone(r2, e2);
        t2.insertIntoValuesDimension(r2, dn(s2));
        const n3 = "/" + Un, i2 = await this.addStandalone(n3, e2);
        t2.insertIntoValuesDimension(n3, dn(i2));
      }
      async addStandalone(t2, e2) {
        const r2 = yn(Ls(this.fsSvc.newFileMetaInfo(t2 + ".md")));
        return await e2.withSource(r2).kindBuild();
      }
    };
    q();
    var Bn = class {
      constructor(t2, e2) {
        __publicField(this, "source");
        __publicField(this, "pageKind");
        __publicField(this, "baseName");
        __publicField(this, "target", null);
        this.source = t2, this.pageKind = e2, this.baseName = "", this.setBasename(), this.buildTarget();
      }
      setBasename() {
        switch (this.pageKind) {
          case vs("404"):
            this.baseName = "404";
            break;
          case vs("sitemap"):
            this.baseName = "sitemap";
            break;
          default:
            this.baseName = this.source.paths().baseNameNoIdentifier() || "index";
        }
      }
      buildTarget() {
        let t2 = "", e2 = "";
        const r2 = "index";
        switch (this.pageKind) {
          case vs("home"):
            t2 = `${r2}.html`, e2 = "";
            break;
          case vs("page"):
            const s2 = this.source.paths().containerDir();
            t2 = s2 && s2 !== "/" ? `${s2}/${this.baseName}.html` : `/${this.baseName}.html`, e2 = s2 || "";
            break;
          case vs("section"):
          case vs("taxonomy"):
          case vs("term"):
            const n3 = this.source.paths().dir();
            t2 = n3 ? `${n3}/${r2}.html` : `${r2}.html`, e2 = n3 || "";
            break;
          case vs("404"):
            const i2 = this.source.paths().dir();
            t2 = i2 ? `${i2}/${this.baseName}.html` : `${this.baseName}.html`, e2 = i2 || "";
            break;
          case vs("sitemap"):
            const a2 = this.source.paths().dir();
            t2 = a2 ? `${a2}/${this.baseName}.xml` : `${this.baseName}.xml`, e2 = a2 || "";
            break;
          default:
            t2 = `${r2}.html`, e2 = "";
        }
        this.target = { prefix: this.source.identity.pageLanguage(), filePath: t2, subResourceBaseTarget: e2 };
      }
      createBasicResult() {
        return { bytes: () => new Uint8Array(), headers: () => [], tableOfContents: () => ({ toHTML: (t2, e2, r2) => "" }) };
      }
      output(t2) {
        return { targetFileBase: () => {
          if (!this.target)
            return "index.html";
          const t3 = this.target.filePath, e2 = t3.lastIndexOf("/");
          return e2 >= 0 ? t3.substring(e2 + 1) : t3;
        }, targetFilePath: () => this.target.filePath, targetSubResourceDir: () => this.target.subResourceBaseTarget, targetPrefix: () => this.target.prefix, content: async () => t2.content ? t2.content.RenderedContent() : "", summary: async () => t2.content ? t2.content.Summary() : "", tableOfContents: () => t2.content && t2.content.toc ? t2.content.toc.toHTML(1, 6, false) : "", result: () => this.createBasicResult(), readingTime: async () => t2.content ? t2.content.ReadingTime() : 0, wordCount: async () => t2.content ? t2.content.WordCount() : 0 };
      }
    };
    q(), A("content", { component: "paginator" });
    var qn = class {
      constructor(t2, e2, r2, s2) {
        __publicField(this, "paginatedElements");
        __publicField(this, "N");
        __publicField(this, "base");
        __publicField(this, "total");
        __publicField(this, "size");
        if (this.paginatedElements = t2, this.base = s2, this.total = e2, this.size = r2, this.N = [], t2.length > 0)
          for (let e3 = 0; e3 < t2.length; e3++)
            this.N.push(new Wn(e3 + 1, this));
        else
          this.N.push(new Wn(1, this));
      }
      totalPages() {
        return this.paginatedElements.length;
      }
      pagers() {
        return [...this.N];
      }
      getElement(t2) {
        return this.paginatedElements.length === 0 ? [] : this.paginatedElements[t2 - 1] || [];
      }
      getBase() {
        return this.base;
      }
      getPagers() {
        return this.N;
      }
      getAllPages() {
        const t2 = [];
        for (const e2 of this.paginatedElements)
          t2.push(...e2);
        return t2;
      }
    };
    var Wn = class {
      constructor(t2, e2) {
        __publicField(this, "number");
        __publicField(this, "paginator");
        this.number = t2, this.paginator = e2;
      }
      pageNumber() {
        return this.number;
      }
      totalPages() {
        return this.paginator.totalPages();
      }
      url() {
        const t2 = this.pageNumber();
        if (t2 > 1) {
          const e2 = `/page/${t2}/`;
          return this.pathJoin(this.paginator.getBase(), e2);
        }
        return this.paginator.getBase();
      }
      pages() {
        return this.element();
      }
      allPages() {
        return this.paginator.getAllPages();
      }
      pagers() {
        return this.paginator.pagers();
      }
      first() {
        return this.paginator.getPagers()[0];
      }
      last() {
        const t2 = this.paginator.getPagers();
        return t2[t2.length - 1];
      }
      hasPrev() {
        return this.pageNumber() > 1;
      }
      prev() {
        return this.hasPrev() ? this.paginator.getPagers()[this.pageNumber() - 2] : null;
      }
      hasNext() {
        return this.pageNumber() < this.paginator.totalPages();
      }
      next() {
        return this.hasNext() ? this.paginator.getPagers()[this.pageNumber()] : null;
      }
      element() {
        return this.paginator.getElement(this.pageNumber());
      }
      pathJoin(t2, e2) {
        return t2.endsWith("/") && (t2 = t2.slice(0, -1)), e2.startsWith("/") || (e2 = "/" + e2), t2 + e2;
      }
    };
    var zn = class {
      constructor(t2, e2) {
        __publicField(this, "currentPager", null);
        __publicField(this, "initialized", false);
        __publicField(this, "svc");
        __publicField(this, "page");
        this.svc = t2, this.page = e2;
      }
      async current() {
        return this.initialized || await this.initializePaginator(), this.currentPager ? this.currentPager : new qn([], 0, 10, this.page.paths().base()).pagers()[0];
      }
      setCurrent(t2) {
        this.currentPager = t2;
      }
      async paginate(t2) {
        if (!this.initialized) {
          const e2 = this.svc.pageSize();
          let r2;
          r2 = Array.isArray(t2) && t2.length > 0 && "key" in t2[0] ? this.newPaginatorFromPageGroups(t2, e2, this.page.paths().base()) : this.newPaginatorFromPages(t2, e2, this.page.paths().base()), this.currentPager = r2.pagers()[0], this.initialized = true;
        }
        return this.currentPager || this.current();
      }
      async paginator() {
        return this.initialized || await this.initializePaginator(), this.currentPager || this.current();
      }
      async initializePaginator() {
        try {
          const t2 = this.svc.pageSize();
          let e2 = [];
          switch (this.page.kind()) {
            case "home":
              e2 = await this.svc.globalRegularPages();
              break;
            case "term":
            case "taxonomy":
              const t3 = await this.page.pages();
              e2 = t3?.length ? Array.from({ length: t3.length }, (e3, r4) => t3[r4]) : [];
              break;
            default:
              const r3 = await this.page.regularPages();
              e2 = r3 && r3.length > 0 ? Array.from({ length: r3.length }, (t4, e3) => r3[e3]) : await this.svc.globalRegularPages();
          }
          const r2 = this.page.paths().base(), s2 = this.newPaginatorFromPages(e2, t2, r2);
          this.currentPager = s2.pagers()[0], this.initialized = true;
        } catch (t2) {
          const e2 = this.page.paths().base(), r2 = new qn([], 0, 10, e2);
          this.currentPager = r2.pagers()[0], this.initialized = true;
        }
      }
      newPaginatorFromPages(t2, e2, r2) {
        if (e2 <= 0)
          throw new Error("paginator size must be positive");
        const s2 = this.splitPages(t2, e2);
        return new qn(s2, t2.length, e2, r2);
      }
      newPaginatorFromPageGroups(t2, e2, r2) {
        if (e2 <= 0)
          throw new Error("paginator size must be positive");
        const s2 = [];
        if (t2 && t2.length > 0)
          for (let e3 = 0; e3 < t2.length; e3++) {
            const r3 = t2[e3];
            if (r3 && r3.pages) {
              const t3 = r3.pages();
              if (t3)
                for (let e4 = 0; e4 < t3.length; e4++)
                  s2.push(t3[e4]);
            }
          }
        const n3 = this.splitPages(s2, e2);
        return new qn(n3, s2.length, e2, r2);
      }
      splitPages(t2, e2) {
        const r2 = [];
        for (let s2 = 0; s2 < t2.length; s2 += e2) {
          const n3 = Math.min(s2 + e2, t2.length);
          r2.push(t2.slice(s2, n3));
        }
        return r2;
      }
    };
    var Hn = class {
      constructor() {
        __publicField(this, "values");
        this.values = /* @__PURE__ */ new Map();
      }
      add(t2, e2) {
        const r2 = this.values.get(t2);
        let s2;
        return s2 = r2 !== void 0 ? Array.isArray(r2) ? [...r2, e2] : typeof r2 == "number" && typeof e2 == "number" || typeof r2 == "string" && typeof e2 == "string" ? r2 + e2 : e2 : e2, this.values.set(t2, s2), "";
      }
      Add(t2, e2) {
        return this.add(t2, e2);
      }
      set(t2, e2) {
        return this.values.set(t2, e2), "";
      }
      Set(t2, e2) {
        return this.set(t2, e2);
      }
      delete(t2) {
        return this.values.delete(t2), "";
      }
      get(t2) {
        return this.values.get(t2);
      }
      Get(t2) {
        return this.get(t2);
      }
      getValues() {
        return this.values;
      }
      setInMap(t2, e2, r2) {
        let s2 = this.values.get(t2);
        return s2 && typeof s2 == "object" || (s2 = {}, this.values.set(t2, s2)), s2[e2] = r2, "";
      }
    };
    function Gn(t2) {
      const e2 = t2.lastIndexOf("/");
      if (e2 === -1)
        return "";
      let r2 = t2.slice(0, e2 + 1);
      return r2.length > 1 && r2.endsWith("/") && (r2 = r2.slice(0, -1)), r2;
    }
    var Vn = p(require("path"));
    q(), A("content", { component: "page" });
    var Kn = class {
      constructor(t2, e2, r2, s2, n3 = "", i2 = "page", a2 = null) {
        __publicField(this, "source");
        __publicField(this, "content");
        __publicField(this, "meta");
        __publicField(this, "layout");
        __publicField(this, "pagerManager");
        __publicField(this, "title_");
        __publicField(this, "description_", "");
        __publicField(this, "kind_");
        __publicField(this, "pageMap");
        __publicField(this, "output_", null);
        __publicField(this, "store_", null);
        this.source = t2, this.content = e2, this.meta = r2, this.layout = s2, this.title_ = n3, this.kind_ = i2, this.pageMap = a2, this.pagerManager = new zn({ pageSize: () => 10, globalRegularPages: async () => [] }, this);
      }
      rawContent() {
        if (!this.content)
          return "";
        const t2 = this.content.getRawSource();
        return new TextDecoder().decode(t2);
      }
      pageIdentity() {
        return this.source.identity;
      }
      pageFile() {
        return this.source.file;
      }
      staleVersions() {
        return [];
      }
      section() {
        return this.source.file.section();
      }
      paths() {
        return this.source.file.paths();
      }
      path() {
        return this.source.file.paths().path();
      }
      posOffset(t2) {
        return this.source.posOffset(t2);
      }
      description() {
        return this.description_;
      }
      get Description() {
        return this.description();
      }
      StaticURL(t2) {
        return /^(https?:)?\/\//.test(t2) ? t2 : ((t2 = (t2 = Vn.default.normalize(t2)).replace(/\\/g, "/")).startsWith("/") && (t2 = t2.slice(1)), `${this.meta.pageBaseUrl().replace(/\/+$/, "")}/${t2}`);
      }
      params() {
        return this.meta.params();
      }
      get Params() {
        return this.params();
      }
      store() {
        return this.store_ || (this.store_ = new Hn()), this.store_;
      }
      get Store() {
        return this.store();
      }
      scratch() {
        return this.store();
      }
      get Scratch() {
        return this.scratch();
      }
      pageBaseUrl() {
        return this.meta.pageBaseUrl();
      }
      pageWeight() {
        return this.meta.pageWeight();
      }
      pageDate() {
        return this.meta.pageDate();
      }
      publishDate() {
        return this.meta.publishDate();
      }
      async relatedKeywords(t2) {
        return this.meta.relatedKeywords(t2);
      }
      shouldList(t2) {
        return this.meta.shouldList(t2);
      }
      shouldListAny() {
        return this.meta.shouldListAny();
      }
      noLink() {
        return this.meta.noLink();
      }
      organization() {
        return this.meta.organization();
      }
      author() {
        return this.meta.author();
      }
      menu() {
        return this.meta.menu();
      }
      async current() {
        return await this.pagerManager.current();
      }
      setCurrent(t2) {
        this.pagerManager.setCurrent(t2);
      }
      async paginator() {
        return await this.pagerManager.paginator();
      }
      async paginate(t2) {
        return this.pagerManager.paginate(t2);
      }
      file() {
        return this.source.file;
      }
      get Type() {
        return this.file().type();
      }
      name() {
        return this.source.file.baseFileName();
      }
      title() {
        return this.title_;
      }
      get Title() {
        return this.title();
      }
      kind() {
        return this.kind_;
      }
      isHome() {
        return this.kind() === vs("home");
      }
      isPage() {
        return this.kind() === vs("page");
      }
      isSection() {
        return this.kind() === vs("section");
      }
      isAncestor(t2) {
        return t2.path() !== this.path() && t2.paths().base().startsWith(this.paths().base());
      }
      eq(t2) {
        return this.pageIdentity().identifierBase() === t2.pageIdentity().identifierBase();
      }
      layouts() {
        switch (this.kind_) {
          case vs("home"):
            return this.source.file.isBranchBundle() ? this.layout.homeList() : this.layout.home();
          case vs("page"):
            return this.layout.page(this.source.file.section(), this.source.file.baseFileName());
          case vs("section"):
            return this.layout.section(this.source.file.section());
          case vs("taxonomy"):
            return this.layout.taxonomy();
          case vs("term"):
            return this.layout.term();
          case vs("404"):
            return this.layout.standalone404();
          case vs("sitemap"):
            return this.layout.standaloneSitemap();
          default:
            return [];
        }
      }
      output() {
        return this.output_ || (this.output_ = new Bn(this.source, this.kind())), this.output_.output(this);
      }
      get TargetPath() {
        return this.output().targetFilePath();
      }
      get Summary() {
        return this.output().summary();
      }
      truncated() {
        return true;
      }
      parent() {
        if (this.isHome())
          return null;
        let t2 = this.paths().containerDir();
        if (t2 === "")
          return null;
        for (; ; ) {
          const e2 = this.pageMap?.treePages.longestPrefix(t2, true);
          if (!e2)
            return null;
          const [r2, s2] = e2;
          if (!s2)
            return null;
          const [n3, i2] = s2.getPage();
          if (!n3)
            return null;
          if (this.isBundled())
            return i2 ? n3 : null;
          if (!n3.isPage())
            return i2 ? n3 : null;
          t2 = Gn(t2);
        }
      }
      async Pages() {
        return await this.pages();
      }
      async pages() {
        const t2 = this.pageIdentity().pageLanguageIndex();
        switch (this.kind()) {
          case He:
          case Ve:
          case Ge:
            return await this.pageMap.getPagesInSection(t2, new Ln(this.paths().base(), "page-section", false, false, t2, (t3) => Pn(t3) && (xn(t3) || ((t4) => t4.kind() === "section")(t3))));
          case Je:
            return await this.pageMap.getPagesWithTerm(t2, new Rn(this.paths().base(), "term"));
          case Ke:
            return await this.pageMap.getPagesInSection(t2, new Ln(this.paths().base(), "term", true, false, t2, (t3) => Pn(t3) && ((t4) => t4.kind() === "term")(t3)));
          default:
            return Promise.resolve([]);
        }
      }
      prevInSection() {
        return null;
      }
      nextInSection() {
        return null;
      }
      sections(t2) {
        return [];
      }
      async regularPages() {
        const t2 = this.pageIdentity().pageLanguageIndex();
        switch (this.kind()) {
          case He:
          case Ve:
          case Ge:
          case Ke:
            return this.pageMap ? await this.pageMap.getPagesInSection(t2, new Ln(this.paths().base(), "", false, false, t2, (t3) => Pn(t3) && xn(t3))) : [];
          case Je:
            return this.pageMap ? await this.pageMap.getPagesWithTerm(t2, new Rn(this.paths().base(), "", (t3) => Pn(t3) && xn(t3))) : [];
          default:
            return [];
        }
      }
      regularPagesRecursive() {
        return [];
      }
      async terms(t2, e2) {
        return this.pageMap ? this.pageMap?.getTermsForPageInTaxonomy(t2, this.paths().base(), e2) : null;
      }
      async isTranslated() {
        return (await this.translations()).length > 0;
      }
      async translations() {
        const t2 = this.path() + "/" + this.pageIdentity().pageLanguage() + "/translations";
        if (!this.pageMap)
          return [];
        try {
          return await this.pageMap.getOrCreatePagesFromCacheSync(null, t2, async (t3) => {
            const e2 = await this.allTranslations(), r2 = [];
            for (let t4 = 0; t4 < e2.length; t4++) {
              const s2 = e2.at(t4);
              s2 && !s2.eq(this) && r2.push(s2);
            }
            return r2;
          });
        } catch (t3) {
          throw t3;
        }
      }
      async allTranslations() {
        const t2 = this.path() + "/translations-all";
        if (!this.pageMap)
          return [];
        try {
          return await this.pageMap.getOrCreatePagesFromCacheSync(null, t2, async (t3) => {
            const e2 = [];
            var r2;
            return this.pageMap.treePages.forEachInDimension(this.paths().base(), Hs(1), (t4) => {
              if (t4 != null) {
                const r3 = t4.getPages();
                e2.push(...r3);
              }
              return false;
            }), r2 = e2, Fs(ks).sort(r2), e2;
          });
        } catch (t3) {
          throw t3;
        }
      }
      isBundled() {
        return this.source.file.isBundle();
      }
    };
    var Jn = class extends Kn {
      constructor(t2, e2, r2, s2, n3, i2 = "", a2 = "taxonomy", o2 = null) {
        super(t2, e2, r2, s2, i2, a2, o2);
        __publicField(this, "singular");
        this.singular = n3;
      }
      params() {
        const t2 = super.params();
        return t2.Singular = this.singular, t2;
      }
    };
    var Yn = class extends Jn {
      constructor(t2, e2, r2, s2, n3, i2, a2 = "", o2 = "term", h2 = null) {
        super(t2, e2, r2, s2, n3, a2, o2, h2);
        __publicField(this, "term");
        this.term = i2;
      }
      params() {
        const t2 = super.params();
        return t2.Term = this.term, t2;
      }
    };
    var Zn = class {
      constructor(t2, e2 = "always", r2 = {}, s2 = 0, n3 = new Date(), i2, a2, o2) {
        __publicField(this, "baseURL");
        __publicField(this, "list");
        __publicField(this, "parameters");
        __publicField(this, "weight");
        __publicField(this, "date");
        __publicField(this, "org");
        __publicField(this, "authorInfo");
        __publicField(this, "menuConfig");
        this.baseURL = t2, this.list = e2, this.parameters = r2, this.weight = s2, this.date = n3, this.org = i2, this.authorInfo = a2, this.menuConfig = o2;
      }
      description() {
        return "";
      }
      params() {
        return this.parameters;
      }
      pageBaseUrl() {
        return this.baseURL;
      }
      pageWeight() {
        return this.weight;
      }
      pageDate() {
        return this.date;
      }
      publishDate() {
        return this.pageDate();
      }
      async relatedKeywords(t2) {
        return [];
      }
      shouldList(t2) {
        switch (this.list) {
          case "always":
          default:
            return true;
          case "never":
            return false;
          case "local":
            return !t2;
        }
      }
      shouldListAny() {
        return this.shouldList(true) || this.shouldList(false);
      }
      noLink() {
        return false;
      }
      organization() {
        return this.org;
      }
      author() {
        return this.authorInfo;
      }
      menu() {
        return this.menuConfig;
      }
    };
    var Xn = class {
      home() {
        return ["index.html", "_default/index.html", "_default/single.html"];
      }
      homeList() {
        return ["index.html", "_default/index.html", "_default/list.html"];
      }
      section(t2) {
        return [`${t2}/section.html`, `${t2}/list.html`, "_default/section.html", "_default/list.html", "_default/index.html"];
      }
      page(t2, e2) {
        const r2 = t2 ? `${t2}/${e2}` : e2, s2 = t2 ? `${t2}/single.html` : "single.html", n3 = [];
        return r2 !== "index" && n3.push(`${r2}.html`), n3.push(s2), e2 !== "index" && n3.push(`_default/${e2}.html`), n3.push("_default/single.html"), n3.push("index.html"), n3.push("_default/index.html"), n3;
      }
      taxonomy() {
        return ["taxonomy/taxonomy.html", "taxonomy/list.html", "_default/list.html", "_default/taxonomy.html"];
      }
      term() {
        return ["taxonomy/tag.html", "term/term.html", "taxonomy/list.html", "_default/list.html", "_default/term.html"];
      }
      standalone404() {
        return ["404.html"];
      }
      standaloneSitemap() {
        return ["sitemap.xml", "_default/sitemap.xml"];
      }
    };
    var Qn = class {
      constructor(t2, e2, r2, s2, n3, i2, a2, o2 = "", h2 = 0) {
        __publicField(this, "F");
        __publicField(this, "D");
        __publicField(this, "A");
        __publicField(this, "k");
        __publicField(this, "u");
        __publicField(this, "I");
        __publicField(this, "C");
        __publicField(this, "O");
        __publicField(this, "_", null);
        __publicField(this, "M");
        __publicField(this, "U", null);
        __publicField(this, "j", null);
        this.F = t2, this.D = e2, this.A = r2, this.k = s2, this.u = n3, this.I = i2, this.C = a2, this.O = o2, this.M = h2;
      }
      get params() {
        return this.F;
      }
      get Params() {
        return this.F;
      }
      get IsNamedParams() {
        return this.I;
      }
      get inner() {
        return this.D;
      }
      get Inner() {
        return this.D;
      }
      get page() {
        return this.A;
      }
      get Page() {
        return this.A;
      }
      get parent() {
        return this.k;
      }
      get Parent() {
        return this.k;
      }
      get name() {
        return this.u;
      }
      get isNamedParams() {
        return this.I;
      }
      get ordinal() {
        return this.C;
      }
      get Ordinal() {
        return this.C;
      }
      innerDeindent() {
        if (this.O === "")
          return this.D;
        if (this._ === null) {
          const t2 = this.D.split("\n");
          this._ = t2.map((t3) => t3.startsWith(this.O) ? t3.substring(this.O.length) : t3).join("\n");
        }
        return this._;
      }
      get InnerDeindent() {
        return this.innerDeindent();
      }
      async position() {
        return this.U || (this.U = await this.A.posOffset(this.M)), this.U;
      }
      scratch() {
        return this.j || (this.j = new Hn()), this.j;
      }
      get(t2) {
        return this.F ? Array.isArray(this.F) ? typeof t2 == "number" ? t2 >= this.F.length ? "" : this.F[t2] : null : typeof this.F == "object" && typeof t2 == "string" ? this.F[t2] || "" : null : null;
      }
      Get(t2) {
        return this.get(t2);
      }
    };
    var ti = "partials/";
    var ei = class extends Error {
      constructor(t2, e2) {
        super(t2), this.code = e2, this.name = "TemplateError";
      }
    };
    var ri = (new ei("template not found", "TEMPLATE_NOT_FOUND"), new ei("template parse failed", "PARSE_FAILED"), new ei("template execute failed", "EXECUTE_FAILED"), new ei("invalid template", "INVALID_TEMPLATE"), p(require("path")));
    var si = class {
      constructor() {
        __publicField(this, "baseof", /* @__PURE__ */ new Map());
        __publicField(this, "needsBaseof", /* @__PURE__ */ new Map());
      }
      getTemplateSearchOrder(t2) {
        const e2 = [];
        return e2.push("_default/baseof.html"), e2;
      }
      getBaseOf(t2) {
        return this.baseof.get(t2) || null;
      }
      getNeedsBaseOf(t2) {
        return this.needsBaseof.get(t2) || null;
      }
      addBaseOf(t2, e2) {
        this.baseof.set(t2, e2);
      }
      addNeedsBaseOf(t2, e2) {
        this.needsBaseof.set(t2, e2);
      }
      isBaseTemplatePath(t2) {
        return ri.basename(t2).includes("baseof");
      }
      needsBaseOf(t2, e2) {
        return !this.noBaseNeeded(t2) && this.needsBaseTemplate(e2);
      }
      noBaseNeeded(t2) {
        return !!t2.startsWith(ti);
      }
      needsBaseTemplate(t2) {
        let e2 = -1, r2 = false;
        for (let s2 = 0; s2 < t2.length; )
          if (!r2 && t2.substring(s2).startsWith("{{/*"))
            r2 = true, s2 += 4;
          else if (!r2 && t2.substring(s2).startsWith("{{- /*"))
            r2 = true, s2 += 6;
          else if (r2 && t2.substring(s2).startsWith("*/}}"))
            r2 = false, s2 += 4;
          else if (r2 && t2.substring(s2).startsWith("*/ -}}"))
            r2 = false, s2 += 6;
          else {
            const n3 = t2[s2];
            if (!r2) {
              if (t2.substring(s2).startsWith("{{")) {
                e2 = s2;
                break;
              }
              if (!/\s/.test(n3))
                break;
            }
            s2++;
          }
        return e2 !== -1 && /^{{-?\s*define/.test(t2.substring(e2));
      }
      getAllBaseOf() {
        return new Map(this.baseof);
      }
      getAllNeedsBaseOf() {
        return new Map(this.needsBaseof);
      }
      clear() {
        this.baseof.clear(), this.needsBaseof.clear();
      }
      getStats() {
        return { baseOfCount: this.baseof.size, needsBaseOfCount: this.needsBaseof.size };
      }
    };
    var ni = class t2 {
      constructor(t3, e2, r2) {
        this.name = t3, this.template = e2, this.fi = r2;
      }
      identifierBase() {
        return this.name;
      }
      errWithFileContext(t3, e2) {
        const r2 = `${t3}: ${e2.message}`, s2 = new ei(r2, "TEMPLATE_FILE_ERROR");
        return Object.defineProperty(s2, "fileName", { value: this.name, enumerable: true }), Object.defineProperty(s2, "fileContent", { value: this.template, enumerable: true }), s2;
      }
      isZero() {
        return this.name === "";
      }
      copy() {
        return new t2(this.name, this.template, this.fi);
      }
      getCleanContent() {
        return ii(this.template);
      }
    };
    function ii(t2) {
      for (let e2 = 0; e2 < t2.length; e2++) {
        const r2 = t2[e2];
        if (e2 === 0 && r2 !== "\uFEFF")
          return t2;
        if (e2 > 0)
          return t2.substring(e2);
      }
      return t2;
    }
    function ai(t2) {
      return function(t3) {
        return t3.includes("_shortcodes/");
      }(t2) ? 1 : t2.includes("_partials/") ? 2 : 0;
    }
    q(), A("template", { component: "namespace" });
    var oi = class {
      constructor() {
        __publicField(this, "templates", /* @__PURE__ */ new Map());
        __publicField(this, "mutex", /* @__PURE__ */ new Set());
      }
      addTemplate(t2, e2) {
        this.withLock(() => {
          this.templates.set(t2, e2);
        });
      }
      findTemplate(t2) {
        return this.withReadLock(() => {
          if (this.templates.has(t2))
            return this.templates.get(t2) || null;
          if (!t2.endsWith(".html")) {
            const e2 = t2 + ".html";
            if (this.templates.has(e2))
              return this.templates.get(e2) || null;
          }
          for (const [e2, r2] of this.templates.entries())
            if (e2.includes(t2))
              return r2;
          return null;
        });
      }
      getTemplates() {
        return this.withReadLock(() => new Map(this.templates));
      }
      hasTemplate(t2) {
        return this.withReadLock(() => this.templates.has(t2));
      }
      getTemplateNames() {
        return this.withReadLock(() => Array.from(this.templates.keys()));
      }
      removeTemplate(t2) {
        return this.withLock(() => this.templates.delete(t2));
      }
      clear() {
        this.withLock(() => {
          this.templates.clear();
        });
      }
      size() {
        return this.withReadLock(() => this.templates.size);
      }
      getTemplatesByPattern(t2) {
        return this.withReadLock(() => {
          const e2 = [];
          for (const [r2, s2] of this.templates)
            t2.test(r2) && e2.push(s2);
          return e2;
        });
      }
      withLock(t2) {
        const e2 = "write";
        for (; this.mutex.has(e2); )
          ;
        this.mutex.add(e2);
        try {
          return t2();
        } finally {
          this.mutex.delete(e2);
        }
      }
      withReadLock(t2) {
        const e2 = "read";
        this.mutex.add(e2);
        try {
          return t2();
        } finally {
          this.mutex.delete(e2);
        }
      }
    };
    var hi = class extends oi {
      lookup(t2) {
        const e2 = this.findTemplate(t2);
        return e2 ? e2.template : null;
      }
      findTemplateWithDependencies(t2) {
        return this.findTemplate(t2);
      }
      getTemplatesNeedingBase() {
        return this.withReadLock(() => Array.from(this.templates.values()).filter((t2) => t2.baseInfo));
      }
    };
    var ci = class extends oi {
      lookup(t2) {
        const e2 = this.findTemplate(t2);
        return e2 ? e2.template : null;
      }
      addPartialTemplate(t2, e2) {
        const r2 = { ...e2, type: 2 };
        this.addTemplate(t2, r2);
      }
    };
    var ui = class extends oi {
      lookup(t2) {
        const e2 = this.findTemplate(t2);
        return e2 ? e2.template : null;
      }
      addShortcodeTemplate(t2, e2) {
        const r2 = { ...e2, type: 1 };
        this.addTemplate(t2, r2);
      }
      getShortcode(t2) {
        return this.lookup("_shortcodes/" + t2);
      }
      hasShortcode(t2) {
        return this.hasTemplate(t2);
      }
      getShortcodeNames() {
        return this.getTemplateNames();
      }
    };
    var li = class {
      async execute(t2, e2) {
        try {
          const [r2, s2] = await t2.Execute(e2);
          if (s2)
            throw new ei(`Template execution failed: ${s2.message}`, "EXECUTION_FAILED");
          return r2;
        } catch (t3) {
          if (t3 instanceof ei)
            throw t3;
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new ei(`Template execution failed: ${e3}`, "EXECUTION_FAILED");
        }
      }
      async executeWithTimeout(t2, e2, r2) {
        return new Promise(async (s2, n3) => {
          const i2 = setTimeout(() => {
            n3(new ei("Template execution timeout", "EXECUTION_TIMEOUT"));
          }, r2);
          await this.execute(t2, e2).then((t3) => {
            clearTimeout(i2), s2(t3);
          }).catch((t3) => {
            clearTimeout(i2), n3(t3);
          });
        });
      }
      async executeSafely(t2, e2) {
        try {
          return { result: await this.execute(t2, e2), error: null };
        } catch (t3) {
          if (t3 instanceof ei)
            return { result: null, error: t3 };
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          return { result: null, error: new ei(`Execution failed: ${e3}`, "EXECUTION_ERROR") };
        }
      }
      async executeBatch(t2) {
        return (await Promise.allSettled(t2.map(async ({ name: t3, template: e2, data: r2 }) => {
          try {
            return { name: t3, result: await this.execute(e2, r2), error: null };
          } catch (e3) {
            return { name: t3, result: null, error: e3 instanceof ei ? e3 : new ei(`Batch execution failed: ${e3.message}`, "BATCH_EXECUTION_FAILED") };
          }
        }))).map((t3) => t3.status === "fulfilled" ? t3.value : { name: "unknown", result: null, error: new ei(`Batch execution failed: ${t3.reason}`, "BATCH_EXECUTION_FAILED") });
      }
      async executeWithContext(t2, e2, r2) {
        if (r2.signal?.aborted)
          throw new ei("Template execution was cancelled", "EXECUTION_CANCELLED");
        const s2 = new Promise((t3, e3) => {
          r2.signal && r2.signal.addEventListener("abort", () => {
            e3(new ei("Template execution was cancelled", "EXECUTION_CANCELLED"));
          });
        }), n3 = r2.timeout ? new Promise((t3, e3) => {
          setTimeout(() => {
            e3(new ei("Template execution timeout", "EXECUTION_TIMEOUT"));
          }, r2.timeout);
        }) : new Promise(() => {
        });
        try {
          return await Promise.race([this.execute(t2, e2), s2, n3]);
        } catch (t3) {
          if (t3 instanceof ei)
            throw t3;
          throw new ei(`Context execution failed: ${t3.message}`, "CONTEXT_EXECUTION_FAILED");
        }
      }
    };
    var fi = require_dist2();
    var wi = require_dist2();
    q(), q();
    var di = A("content", { component: "cache" });
    var gi = class {
      constructor() {
        __publicField(this, "cache", /* @__PURE__ */ new Map());
        __publicField(this, "pendingPromises", /* @__PURE__ */ new Map());
        __publicField(this, "deletedKeys", /* @__PURE__ */ new Set());
      }
      get(t2) {
        return this.cache.get(t2);
      }
      set(t2, e2) {
        this.deletedKeys.has(t2) || this.cache.set(t2, e2), this.pendingPromises.delete(t2), this.deletedKeys.delete(t2);
      }
      has(t2) {
        return this.cache.has(t2);
      }
      isPending(t2) {
        return this.pendingPromises.has(t2);
      }
      delete(t2) {
        return this.deletedKeys.add(t2), this.pendingPromises.delete(t2), this.cache.delete(t2);
      }
      clear() {
        this.cache.clear(), this.pendingPromises.clear(), this.deletedKeys.clear();
      }
      size() {
        return this.cache.size;
      }
      pendingCount() {
        return this.pendingPromises.size;
      }
      async getOrCreate(t2, e2) {
        const r2 = this.cache.get(t2);
        if (r2 !== void 0)
          return r2;
        const s2 = this.pendingPromises.get(t2);
        return s2 ? await s2 : this.createAndCache(t2, e2);
      }
      async createAndCache(t2, e2) {
        const r2 = this.executeCreate(t2, e2);
        this.pendingPromises.set(t2, r2);
        try {
          const e3 = await r2;
          return this.deletedKeys.has(t2) ? (this.deletedKeys.delete(t2), this.pendingPromises.delete(t2), e3) : (this.set(t2, e3), e3);
        } catch (e3) {
          throw this.pendingPromises.delete(t2), di.error(`Failed to create value for key ${String(t2)} : ${e3}`), e3;
        }
      }
      async executeCreate(t2, e2) {
        try {
          return await e2(t2);
        } catch (e3) {
          const r2 = e3 instanceof Error ? e3.message : String(e3), s2 = new Error(`Cache creation failed for key ${String(t2)}: ${r2}`);
          throw e3 instanceof Error && e3.stack && (s2.stack = e3.stack, s2.originalError = e3), s2;
        }
      }
      getStats() {
        return { size: this.cache.size, pendingCount: this.pendingPromises.size, keys: Array.from(this.cache.keys()), pendingKeys: Array.from(this.pendingPromises.keys()) };
      }
      async preload(t2) {
        const e2 = t2.filter(({ key: t3 }) => !this.has(t3) && !this.isPending(t3)).map(({ key: t3, create: e3 }) => this.getOrCreate(t3, e3));
        e2.length > 0 && await Promise.allSettled(e2);
      }
    };
    var pi = (new gi(), A("template", { component: "parser" }));
    var mi = class {
      constructor(t2 = /* @__PURE__ */ new Map()) {
        __publicField(this, "prototypeText");
        __publicField(this, "prototypeTextClone");
        __publicField(this, "readyInit", false);
        __publicField(this, "funcMap");
        __publicField(this, "parseOverlapCache");
        this.funcMap = t2, this.prototypeText = (0, fi.New)(""), this.parseOverlapCache = new gi(), this.funcMap.size > 0 && this.prototypeText.Funcs(this.funcMap);
      }
      async markReady() {
        this.readyInit || (this.prototypeTextClone = this.prototypeText, this.readyInit = true);
      }
      async parse(t2) {
        try {
          const e2 = (0, fi.New)(t2.name);
          this.funcMap && this.funcMap.size > 0 && e2.Funcs(this.funcMap);
          const [r2, s2] = e2.Parse(t2.template);
          if (s2)
            throw new ei(`Parse failed: ${s2.message}`, "PARSE_FAILED");
          return { template: r2, info: t2, type: ai(t2.name) };
        } catch (t3) {
          if (t3 instanceof ei)
            throw t3;
          const e2 = t3 instanceof Error ? t3.message : String(t3);
          throw new ei(`Parse failed: ${e2}`, "PARSE_FAILED");
        }
      }
      async parseWithLock(t2, e2) {
        try {
          this.prototypeTextClone || await this.markReady();
          const r2 = (0, fi.New)(t2);
          this.funcMap && this.funcMap.size > 0 && r2.Funcs(this.funcMap);
          const [s2, n3] = r2.Parse(e2);
          if (n3)
            throw new ei(`Parse with lock failed: ${n3.message}`, "PARSE_LOCK_FAILED");
          return s2;
        } catch (t3) {
          if (t3 instanceof ei)
            throw t3;
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new ei(`Parse with lock failed: ${e3}`, "PARSE_LOCK_FAILED");
        }
      }
      async parseOverlap(t2, e2, r2) {
        const s2 = `${t2.name}::${e2.name || "empty"}`;
        return this.parseOverlapCache.getOrCreate(s2, async () => {
          try {
            const s3 = { template: await this.applyBaseTemplate(t2, e2, r2), info: t2, type: ai(t2.name) };
            return e2.isZero && !e2.name || (s3.baseInfo = e2), [s3, true, null];
          } catch (t3) {
            const e3 = t3 instanceof ei ? t3 : new ei(`Parse overlap failed: ${t3.message}`, "PARSE_OVERLAP_FAILED");
            return pi.error(`Failed to parse template overlap for key: ${s2}: ${e3.message}`), [null, false, e3];
          }
        });
      }
      async applyBaseTemplate(t2, e2, r2) {
        try {
          const s2 = (0, fi.New)(t2.name);
          if (this.funcMap && this.funcMap.size > 0 && s2.Funcs(this.funcMap), !e2.isZero || e2.name) {
            const [t3, r3] = s2.Parse(e2.template);
            if (r3)
              throw new ei(`Base template parse failed: ${r3.message}`, "BASE_PARSE_FAILED");
          }
          const [n3, i2] = s2.Clone();
          if (i2)
            throw new ei(`Template clone failed: ${i2.message}`, "CLONE_FAILED");
          const [a2, o2] = n3.Parse(t2.template);
          if (o2)
            throw new ei(`Overlay template parse failed: ${o2.message}`, "OVERLAY_PARSE_FAILED");
          const h2 = await this.getDependencies(a2, /* @__PURE__ */ new Map(), r2);
          for (const [e3, r3] of h2)
            if (e3 !== t2.name)
              try {
                if (r3.template.Tree) {
                  const [, t3] = a2.AddParseTree(e3, r3.template.Tree);
                  if (t3)
                    throw pi.error(`AddParseTree failed: ${t3.message} with name ${e3}`), new ei(`AddParseTree failed: ${t3.message}`, "ADD_PARSE_TREE_FAILED");
                }
              } catch (r4) {
                throw pi.error(`Error adding dependency ${e3} to template ${t2.name}:`, r4), new ei(`Failed to add dependency ${e3}: ${r4.message}`, "DEPENDENCY_ADD_FAILED");
              }
          return a2;
        } catch (t3) {
          if (t3 instanceof ei)
            throw t3;
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new ei(`Apply base template failed: ${e3}`, "APPLY_BASE_FAILED");
        }
      }
      async getDependencies(t2, e2, r2) {
        const s2 = /* @__PURE__ */ new Map();
        if (e2.has(t2.Name()))
          return s2;
        e2.set(t2.Name(), t2);
        try {
          const n3 = /* @__PURE__ */ new Set(), i2 = (t3) => {
            if (!t3)
              return;
            const e3 = t3.Type();
            if (e3 === wi.NodeType.NodeTemplate) {
              const e4 = t3.Name;
              e4 && n3.add(e4);
            } else if (e3 === wi.NodeType.NodeList) {
              const e4 = t3;
              if (e4.Nodes)
                for (const t4 of e4.Nodes)
                  i2(t4);
            }
            if (e3 === wi.NodeType.NodeAction) {
              const e4 = t3;
              e4.Pipe && i2(e4.Pipe);
            } else if (e3 === wi.NodeType.NodePipe) {
              const e4 = t3;
              if (e4.Cmds)
                for (const t4 of e4.Cmds)
                  i2(t4);
            } else if (e3 === wi.NodeType.NodeCommand) {
              const e4 = t3;
              if (e4.Args)
                for (const t4 of e4.Args)
                  i2(t4);
            } else if (e3 === wi.NodeType.NodeIf || e3 === wi.NodeType.NodeRange || e3 === wi.NodeType.NodeWith) {
              const e4 = t3;
              e4.Pipe && i2(e4.Pipe), e4.List && i2(e4.List), e4.ElseList && i2(e4.ElseList);
            }
          };
          t2.Tree && t2.Tree.Root && i2(t2.Tree.Root);
          for (const t3 of n3) {
            const n4 = r2(t3);
            if (n4 && (s2.set(t3, n4), !e2.has(n4.template.Name()))) {
              const t4 = await this.getDependencies(n4.template, e2, r2);
              for (const [e3, r3] of t4)
                s2.has(e3) || s2.set(e3, r3);
            }
          }
        } catch (e3) {
          pi.error(`Error getting dependencies for template ${t2.Name()}:`, e3);
        }
        return s2;
      }
      setFuncMap(t2) {
        this.funcMap = new Map([...this.funcMap, ...t2]), this.funcMap.size > 0 && this.prototypeText.Funcs(this.funcMap);
      }
      getFuncMap() {
        return new Map(this.funcMap);
      }
      async parseMultiple(t2) {
        const e2 = await Promise.allSettled(t2.map((t3) => this.parse(t3))), r2 = [], s2 = [];
        for (const t3 of e2)
          t3.status === "fulfilled" ? r2.push(t3.value) : s2.push(t3.reason);
        if (s2.length > 0)
          throw new ei(`Failed to parse ${s2.length} templates: ${s2.map((t3) => t3.message).join(", ")}`, "MULTIPLE_PARSE_FAILED");
        return r2;
      }
      clearCache() {
        this.parseOverlapCache.clear();
      }
      getCacheStats() {
        return this.parseOverlapCache.getStats();
      }
    };
    var yi = class {
      constructor(t2, e2) {
        __publicField(this, "baseOf");
        __publicField(this, "funcsv");
        if (this.baseOf = t2 || new si(), this.funcsv = /* @__PURE__ */ new Map(), e2)
          for (const [t3, r2] of e2)
            this.funcsv.set(t3, r2);
      }
      findNoDependence(t2, e2) {
        try {
          const r2 = e2.lookup(t2);
          return r2 ? [r2, true, null] : [null, false, null];
        } catch (t3) {
          return [null, false, t3];
        }
      }
      findTemplate(t2, e2) {
        try {
          const r2 = e2.lookup(t2);
          if (r2)
            return [r2, true, null];
          const s2 = e2.findTemplateWithDependencies(t2);
          return s2 && s2.baseInfo ? [s2.template, true, null] : [null, false, null];
        } catch (t3) {
          return [null, false, t3];
        }
      }
      findPartial(t2, e2) {
        try {
          const r2 = e2.lookup(t2);
          return r2 ? [r2, true, null] : [null, false, null];
        } catch (t3) {
          return [null, false, t3];
        }
      }
      findShortcode(t2, e2) {
        try {
          const r2 = e2.getShortcode(t2);
          return r2 ? [r2, true, null] : [null, false, null];
        } catch (t3) {
          return [null, false, t3];
        }
      }
      findDependentInfo(t2) {
        const e2 = this.baseOf.getNeedsBaseOf(t2);
        if (!e2)
          return [null, null, false];
        let r2 = null, s2 = false;
        for (const e3 of this.baseOf.getTemplateSearchOrder(t2))
          if (r2 = this.baseOf.getBaseOf(e3), r2) {
            s2 = true;
            break;
          }
        return [e2, r2, s2];
      }
      getFunc(t2) {
        return this.funcsv.get(t2);
      }
      setFunc(t2, e2) {
        this.funcsv.set(t2, e2);
      }
      setFuncMap(t2) {
        this.funcsv.clear();
        for (const [e2, r2] of t2)
          this.funcsv.set(e2, r2);
      }
      getFuncMap() {
        return new Map(this.funcsv);
      }
      newTemplateLookup(t2) {
        return (e2) => t2.findTemplate(e2);
      }
      getBaseOf() {
        return this.baseOf;
      }
      setBaseOf(t2) {
        this.baseOf = t2;
      }
      hasDependencies(t2) {
        const [e2, r2, s2] = this.findDependentInfo(t2);
        return s2 && (e2 !== null || r2 !== null);
      }
      getAllFunctions() {
        return Array.from(this.funcsv.keys());
      }
      clearFunctions() {
        this.funcsv.clear();
      }
      getStats() {
        const t2 = this.baseOf.getStats();
        return { functionCount: this.funcsv.size, baseTemplateCount: t2.baseOfCount, dependentTemplateCount: t2.needsBaseOfCount };
      }
    };
    q();
    var bi = A("template", { component: "template-engine" });
    var Ei = class {
      constructor(t2, e2, r2, s2, n3, i2, a2) {
        __publicField(this, "executor");
        __publicField(this, "lookup");
        __publicField(this, "parser");
        __publicField(this, "templateNamespace");
        __publicField(this, "partialNamespace");
        __publicField(this, "shortcodeNamespace");
        __publicField(this, "fs");
        this.executor = t2, this.lookup = e2, this.parser = r2, this.templateNamespace = s2, this.partialNamespace = n3, this.shortcodeNamespace = i2, this.fs = a2;
      }
      async markReady() {
        try {
          await this.parser.markReady();
        } catch (t2) {
          throw new ei(`Failed to mark template engine ready: ${t2.message}`, "TEMPLATE_ENGINE_READY_FAILED");
        }
      }
      async getTemplate(t2) {
        const [e2, r2, s2] = this.lookup.findTemplate(t2, this.templateNamespace);
        if (s2)
          return [null, false, s2];
        if (r2 && e2)
          return [e2, true, null];
        const [n3, i2, a2] = this.lookup.findDependentInfo(t2);
        if (a2 && n3)
          try {
            const [t3, e3, r3] = await this.parser.parseOverlap(n3, i2 || n3, this.lookup.newTemplateLookup(this.templateNamespace));
            if (r3)
              return [null, false, r3];
            if (e3 && t3)
              return [t3.template, true, null];
          } catch (t3) {
            return [null, false, t3];
          }
        return [null, false, null];
      }
      async getPartial(t2) {
        let e2 = t2.startsWith(ti) ? t2 : `${ti}${t2}`;
        return e2 = t2.endsWith(".html") ? e2 : `${e2}.html`, this.lookup.findPartial(e2, this.partialNamespace);
      }
      async getShortcode(t2) {
        return this.lookup.findShortcode(t2, this.shortcodeNamespace);
      }
      async get(t2) {
        switch (ai(t2)) {
          case 1:
            return this.getShortcode(t2);
          case 2:
            return this.getPartial(t2);
          default:
            return this.getTemplate(t2);
        }
      }
      async findFirst(t2) {
        if (!t2 || t2.length === 0)
          return [null, null, false, null];
        for (const e2 of t2)
          try {
            const [t3, r2, s2] = await this.get(e2);
            if (s2)
              continue;
            if (r2 && t3)
              return [t3, e2, true, null];
          } catch (t3) {
            bi.error("Error finding template:", t3);
          }
        return [null, null, false, null];
      }
      hasShortcode(t2) {
        return this.shortcodeNamespace.hasShortcode(t2);
      }
      getShortcodeNames() {
        return this.shortcodeNamespace.getShortcodeNames();
      }
      getShortcodeCount() {
        return this.getShortcodeNames().length;
      }
      async loadTemplates() {
        const t2 = async (t3, e2) => {
          if (e2.isDir())
            return;
          const r2 = t3.startsWith(ts.SYSTEM_PATH_SEPARATOR) ? t3.substring(1) : t3, s2 = ts.normalizePath(r2);
          try {
            await this.addTemplateFileInfo(s2, e2);
          } catch (t4) {
            bi.error("Error adding template:", new ei(`Failed to add template ${s2}: ${t4.message}`, "LOAD_TEMPLATE_FAILED"));
          }
        };
        try {
          await this.fs.walk("", { walkFn: t2 }, {});
        } catch (t3) {
          if (!t3.message?.includes("ENOENT") && !t3.message?.includes("no such file"))
            throw t3;
        }
      }
      async addTemplateFileInfo(t2, e2) {
        try {
          const r2 = await async function(t3, e3) {
            let r3 = null;
            try {
              r3 = await e3.open();
              const s2 = await r3.stat(), n3 = new Uint8Array(s2.size()), i2 = await r3.read(n3), a2 = ii(new TextDecoder("utf-8").decode(i2.buffer));
              return new ni(t3, a2, e3);
            } catch (r4) {
              throw new ni(t3, "", e3).errWithFileContext("failed to load template", r4);
            } finally {
              if (r3)
                try {
                  await r3.close();
                } catch (t4) {
                  console.warn(`Failed to close template file: ${t4}`);
                }
            }
          }(t2, e2);
          await this.addTemplate(r2.name, r2);
        } catch (e3) {
          throw new ei(`Failed to load template info for ${t2}: ${e3.message}`, "LOAD_TEMPLATE_INFO_FAILED");
        }
      }
      async addTemplate(t2, e2) {
        try {
          if (this.lookup.getBaseOf().isBaseTemplatePath(t2))
            return void this.lookup.getBaseOf().addBaseOf(t2, e2);
          if (this.lookup.getBaseOf().needsBaseOf(t2, e2.template))
            return void this.lookup.getBaseOf().addNeedsBaseOf(t2, e2);
          const r2 = ai(t2), s2 = await this.parser.parse(e2);
          switch (r2) {
            case 1:
              this.shortcodeNamespace.addShortcodeTemplate(t2, s2);
              break;
            case 2:
              this.partialNamespace.addPartialTemplate(t2, s2);
              break;
            default:
              this.templateNamespace.addTemplate(t2, s2);
          }
        } catch (e3) {
          throw new ei(`Failed to add template ${t2}: ${e3.message}`, "ADD_TEMPLATE_FAILED");
        }
      }
      async execute(t2, e2) {
        const [r2, s2, n3] = await this.get(t2);
        if (n3)
          throw n3;
        if (!s2 || !r2)
          throw new ei(`Template not found: ${t2}`, "TEMPLATE_NOT_FOUND");
        return await this.executor.execute(r2, e2);
      }
      async executeRaw(t2, e2, r2) {
        const s2 = await this.parser.parseWithLock(t2, e2);
        if (!s2)
          throw new ei(`Raw Template parse error: ${t2}`, "TEMPLATE_PARSE_ERROR");
        return await this.executor.execute(s2, r2);
      }
      async executeShortcode(t2, e2) {
        const r2 = this.shortcodeNamespace.getShortcode(t2);
        if (!r2)
          throw new ei(`Shortcode template '${t2}' not found`, "SHORTCODE_NOT_FOUND");
        try {
          return await this.executor.execute(r2, e2);
        } catch (e3) {
          throw new ei(`Error executing shortcode template '${t2}': ${e3.message}`, "SHORTCODE_EXECUTION_FAILED");
        }
      }
      async executeSafely(t2, e2) {
        try {
          return { result: await this.execute(t2, e2), error: null };
        } catch (t3) {
          return t3 instanceof ei ? { result: null, error: t3 } : { result: null, error: new ei(`Execute safely failed: ${t3.message}`, "EXECUTE_SAFELY_FAILED") };
        }
      }
      async executeShortcodeSafely(t2, e2) {
        try {
          return { result: await this.executeShortcode(t2, e2), error: null };
        } catch (t3) {
          return t3 instanceof ei ? { result: null, error: t3 } : { result: null, error: new ei(`Execute shortcode safely failed: ${t3.message}`, "EXECUTE_SHORTCODE_SAFELY_FAILED") };
        }
      }
      async hasTemplate(t2) {
        const [, e2] = await this.get(t2);
        return e2;
      }
      getTemplateNames() {
        return this.templateNamespace.getTemplateNames();
      }
      getPartialTemplateNames() {
        return this.partialNamespace.getTemplateNames();
      }
      getAllTemplateNames() {
        return [...this.templateNamespace.getTemplateNames(), ...this.partialNamespace.getTemplateNames(), ...this.shortcodeNamespace.getTemplateNames()];
      }
      getPartialNamespace() {
        return this.partialNamespace;
      }
      getShortcodeNamespace() {
        return this.shortcodeNamespace;
      }
      getTemplateNamespace() {
        return this.templateNamespace;
      }
      clear() {
        this.templateNamespace.clear(), this.lookup.getBaseOf().clear();
      }
      getTemplatesByPattern(t2) {
        return this.templateNamespace.getTemplatesByPattern(t2).map((t3) => t3.info.name);
      }
    };
    q();
    var Si = p(require("crypto"));
    var vi = A("template", { component: "registry" });
    var Ti = [];
    var xi = class {
      constructor() {
        __publicField(this, "engine", null);
        __publicField(this, "execute", async (t2, e2) => {
          if (!this.engine)
            return vi.error(`Partial function called but engine not set: ${t2}`), `<!-- Partial function called but engine not ready: ${t2} -->`;
          try {
            const r2 = t2.startsWith("partials/") ? t2 : `partials/${t2}`;
            return await this.executePartial(r2, e2);
          } catch (e3) {
            return vi.error(`Partial execution failed for "${t2}":`, e3), `<!-- Partial execution failed: ${t2} - ${e3.message} -->`;
          }
        });
      }
      getFunctionName() {
        return "partial";
      }
      updateEngine(t2) {
        this.engine = t2;
      }
      async executePartial(t2, e2) {
        if (!this.engine)
          return `<!-- Template engine not available: ${t2} -->`;
        try {
          const [r2, s2, n3] = await this.engine.getPartial(t2);
          if (n3)
            return vi.error("Error getting partial template:", n3), `<!-- Error getting partial template: ${t2} - ${n3.message} -->`;
          if (!s2 || !r2)
            return vi.warn(`Template not found: ${t2}`), `<!-- Template not found: ${t2} -->`;
          const [i2, a2] = await r2.Execute(e2);
          return a2 ? (vi.error("Template execution error:", a2), `<!-- Template execution error: ${t2} - ${a2.message} -->`) : i2;
        } catch (e3) {
          return vi.error("Sync partial execution failed:", e3), `<!-- Partial sync execution failed: ${t2} - ${e3.message} -->`;
        }
      }
    };
    var Pi = class {
      registerCoreFunctions(t2) {
        this.registerCryptoFunctions(t2), this.registerStringFunctions(t2), this.registerMathFunctions(t2), this.registerTimeFunctions(t2), this.registerCollectionFunctions(t2), this.registerSafeFunctions(t2), this.registerReflectFunctions(t2), this.registerFmtFunctions(t2), this.registerPathFunctions(t2), this.registerTransformFunctions(t2);
      }
      registerCryptoFunctions(t2) {
        t2.set("md5", (t3) => t3 ? Si.createHash("md5").update(t3).digest("hex") : ""), t2.set("encryptAESGCM", (t3, e2) => {
          if (!t3 || !e2)
            return "";
          const r2 = Si.randomBytes(16), s2 = Si.randomBytes(12), n3 = Si.pbkdf2Sync(t3, r2, 1e5, 32, "sha256"), i2 = Si.createCipheriv("aes-256-gcm", n3, s2), a2 = Buffer.concat([i2.update(e2, "utf8"), i2.final()]), o2 = i2.getAuthTag();
          return Buffer.concat([r2, s2, o2, a2]).toString("base64");
        });
      }
      registerExtendedFunctions(t2, e2) {
        this.registerURLFunctions(t2, e2), this.registerSiteFunctions(t2, e2), this.registerResourcesFunctions(t2, e2), this.registerHugoFunctions(t2, e2), this.registerLanguageFunctions(t2, e2);
      }
      registerAllFunctions(t2, e2) {
        this.registerCoreFunctions(t2), this.registerStringFunctions(t2), this.registerMathFunctions(t2), this.registerTimeFunctions(t2), this.registerCollectionFunctions(t2), this.registerEngineDependentFunctions(t2), e2 && (this.registerURLFunctions(t2, e2), this.registerExtendedFunctions(t2, e2));
      }
      registerEngineDependentFunctions(t2) {
        const e2 = new xi();
        Ti.push(e2), t2.set(e2.getFunctionName(), e2.execute);
      }
      registerURLFunctions(t2, e2) {
        t2.set("urls", () => ({ Parse: (t3) => {
          try {
            return { Host: new URL(t3).host };
          } catch {
            return { Host: "" };
          }
        }, JoinPath: (...t3) => t3.filter((t4) => t4 !== "").map((t4) => t4.replace(/^\/+|\/+$/g, "")).join("/"), URLize: (t3) => e2.urlize(t3), Abs: (t3) => e2.absURL(t3), Rel: (t3) => e2.relURL(t3), AbsLangURL: (t3) => e2.absURL(t3), RelLangURL: (t3) => e2.relURL(t3), Sanitize: (t3) => {
          try {
            return new URL(t3).toString();
          } catch {
            return t3.replace(/[<>"'%{}|\\^`]/g, "");
          }
        }, PathEscape: (t3) => encodeURIComponent(t3).replace(/%2F/g, "/").replace(/[!'()*]/g, (t4) => `%${t4.charCodeAt(0).toString(16).toUpperCase()}`), QueryEscape: (t3) => encodeURIComponent(t3), QueryUnescape: (t3) => {
          try {
            return decodeURIComponent(t3);
          } catch {
            return t3;
          }
        }, IsAbs: (t3) => {
          try {
            return new URL(t3).protocol !== "";
          } catch {
            return false;
          }
        }, IsRelative: (t3) => {
          try {
            return new URL(t3), false;
          } catch {
            return true;
          }
        } })), t2.set("absURL", (t3) => e2.absURL(t3)), t2.set("relURL", (t3) => e2.relURL(t3)), t2.set("urlize", (t3) => e2.urlize(t3)), t2.set("relref", (t3, r2) => {
          if (/^https?:\/\//.test(r2))
            return r2;
          let s2 = "";
          const n3 = r2.indexOf("#");
          return n3 !== -1 && (s2 = r2.slice(n3), r2 = r2.slice(0, n3)), (r2 = r2.replace(/^\/+|\/+$/g, "")).startsWith("./") || r2.startsWith("../") || r2.startsWith("/") ? e2.relURL(r2 + s2) : e2.relURL("/" + r2 + s2);
        }), t2.set("ref", (t3, r2) => {
          if (/^https?:\/\//.test(r2))
            return r2;
          let s2 = "";
          const n3 = r2.indexOf("#");
          return n3 !== -1 && (s2 = r2.slice(n3), r2 = r2.slice(0, n3)), (r2 = r2.replace(/^\/+|\/+$/g, "")).startsWith("./") || r2.startsWith("../") || r2.startsWith("/") ? e2.absURL(r2 + s2) : e2.absURL("/" + r2 + s2);
        }), t2.set("absLangURL", (t3) => e2.absURL(t3)), t2.set("relLangURL", (t3) => e2.relURL(t3));
      }
      registerSiteFunctions(t2, e2) {
        t2.set("Site", () => ({ Title: e2.title(), BaseURL: e2.baseURL(), Params: e2.params(), Menus: e2.menus(), IsMultiLingual: e2.isMultiLanguage(), LanguageCode: e2.defaultLanguage() }));
      }
      registerResourcesFunctions(t2, e2) {
        t2.set("resources", () => ({ Get: async (t3) => await e2.Get(t3), GetRemote: async (t3) => await e2.GetRemote(t3), Minify: async (t3) => await e2.Minify(t3), Fingerprint: async (t3) => await e2.Fingerprint(t3), ExecuteAsTemplate: async (t3, r2, s2) => await e2.ExecuteAsTemplate(t3, r2, s2) }));
      }
      registerHugoFunctions(t2, e2) {
        t2.set("hugo", () => ({ Version: e2.version(), Environment: e2.environment(), Generator: e2.generator() }));
      }
      registerLanguageFunctions(t2, e2) {
        const { lang: r2 } = (L(), m(x));
        t2.set("lang", () => ({ getAllCodes: () => r2.getAllCodes(), getAllNames: () => r2.getAllNames(), getCodesByDirection: (t3) => r2.getCodesByDirection(t3), getNamesByDirection: (t3) => r2.getNamesByDirection(t3), getCodeNameMap: () => r2.getCodeNameMap(), getCodeNameMapByDirection: (t3) => r2.getCodeNameMapByDirection(t3), getNameByCode: (t3) => r2.getNameByCode(t3), getLanguageInfo: (t3) => r2.getLanguageInfo(t3), isSupported: (t3) => r2.isSupported(t3), getDirection: (t3) => r2.getDirection(t3), isLTR: (t3) => r2.isLTR(t3), isRTL: (t3) => r2.isRTL(t3) })), t2.set("langName", (t3) => r2.getNameByCode(t3) || t3), t2.set("langDirection", (t3) => r2.getDirection(t3) || "ltr"), t2.set("isLTR", (t3) => r2.isLTR(t3)), t2.set("isRTL", (t3) => r2.isRTL(t3)), t2.set("i18n", (t3) => e2.translate(t3));
      }
      registerStringFunctions(t2) {
        t2.set("humanize", (t3) => t3 ? (t3 = (t3 = (t3 = (t3 = t3.replace(/([a-z])([A-Z])/g, "$1 $2")).replace(/[_-]+/g, " ")).replace(/\.[^/.]+$/, "")).charAt(0).toUpperCase() + t3.slice(1).toLowerCase()).trim() : ""), t2.set("upper", (t3) => t3.toUpperCase()), t2.set("lower", (t3) => t3.toLowerCase()), t2.set("title", (t3) => t3.replace(/\w\S*/g, (t4) => t4.charAt(0).toUpperCase() + t4.substr(1).toLowerCase())), t2.set("trim", (t3) => t3.trim()), t2.set("replace", (...t3) => {
          if (t3.length < 3)
            throw new Error("replace requires at least 3 arguments: string, old, new");
          const e2 = String(t3[0]), r2 = String(t3[1]), s2 = String(t3[2]);
          if (t3.length >= 4) {
            const n3 = Number(t3[3]);
            if (isNaN(n3))
              throw new Error("replace limit must be a number");
            let i2 = e2, a2 = 0, o2 = 0;
            for (; a2 < n3 && o2 < i2.length; ) {
              const t4 = i2.indexOf(r2, o2);
              if (t4 === -1)
                break;
              i2 = i2.substring(0, t4) + s2 + i2.substring(t4 + r2.length), o2 = t4 + s2.length, a2++;
            }
            return i2;
          }
          return e2.split(r2).join(s2);
        }), t2.set("replaceRE", (...e2) => {
          if (e2.length < 3)
            throw new Error("replaceRE requires at least 3 arguments: pattern, replacement, string");
          const r2 = e2[0], s2 = e2[1], n3 = e2[2], i2 = e2.length >= 4 ? e2[3] : void 0;
          return t2.get("strings")().ReplaceRE(r2, s2, n3, i2);
        }), t2.set("split", (t3, e2) => t3 == null ? (vi.warn("split function: first argument is null or undefined"), []) : typeof t3 != "string" ? (vi.warn("split function: first argument must be a string, got:", typeof t3, "value:", t3), Array.isArray(t3) ? t3 : String(t3).split(e2)) : t3.split(e2)), t2.set("splitRegex", (t3, e2) => {
          if (t3 == null)
            return vi.warn("splitRegex function: first argument is null or undefined"), [];
          if (typeof t3 != "string") {
            if (vi.warn("splitRegex function: first argument must be a string, got:", typeof t3, "value:", t3), Array.isArray(t3))
              return t3;
            const r2 = String(t3);
            try {
              const t4 = new RegExp(e2);
              return r2.split(t4);
            } catch (t4) {
              return vi.warn("splitRegex function: invalid regex pattern:", e2, "error:", t4), [r2];
            }
          }
          try {
            const r2 = new RegExp(e2);
            return t3.split(r2);
          } catch (r2) {
            return vi.warn("splitRegex function: invalid regex pattern:", e2, "error:", r2), [t3];
          }
        }), t2.set("delimit", (t3, e2) => Array.isArray(t3) ? t3.join(e2) : String(t3)), t2.set("in", (t3, e2) => (Array.isArray(t3) || typeof t3 == "string" && typeof e2 == "string") && t3.includes(e2)), t2.set("hasPrefix", (t3, e2) => t3.startsWith(e2)), t2.set("hasSuffix", (t3, e2) => t3.endsWith(e2)), t2.set("strings", () => ({ ToLower: (t3) => String(t3).toLowerCase(), ToUpper: (t3) => String(t3).toUpperCase(), Title: (t3) => String(t3).replace(/\w\S*/g, (t4) => t4.charAt(0).toUpperCase() + t4.substr(1).toLowerCase()), Trim: (t3, e2) => String(t3).split("").filter((t4) => !e2.includes(t4)).join(""), TrimSpace: (t3) => String(t3).trim(), TrimLeft: (t3, e2) => {
          const r2 = String(e2);
          let s2 = 0;
          for (; s2 < r2.length && t3.includes(r2[s2]); )
            s2++;
          return r2.slice(s2);
        }, TrimRight: (t3, e2) => {
          const r2 = String(e2);
          let s2 = r2.length - 1;
          for (; s2 >= 0 && t3.includes(r2[s2]); )
            s2--;
          return r2.slice(0, s2 + 1);
        }, TrimPrefix: (t3, e2) => {
          const r2 = String(e2);
          return r2.startsWith(t3) ? r2.slice(t3.length) : r2;
        }, TrimSuffix: (t3, e2) => {
          const r2 = String(e2);
          return r2.endsWith(t3) ? r2.slice(0, -t3.length) : r2;
        }, Contains: (t3, e2) => String(t3).includes(e2), ContainsAny: (t3, e2) => {
          const r2 = String(t3);
          return e2.split("").some((t4) => r2.includes(t4));
        }, HasPrefix: (t3, e2) => String(t3).startsWith(e2), HasSuffix: (t3, e2) => String(t3).endsWith(e2), Replace: (t3, e2, r2, s2) => {
          const n3 = String(t3);
          if (s2 === void 0)
            return n3.split(e2).join(r2);
          let i2 = n3, a2 = 0, o2 = 0;
          for (; a2 < s2 && o2 < i2.length; ) {
            const t4 = i2.indexOf(e2, o2);
            if (t4 === -1)
              break;
            i2 = i2.substring(0, t4) + r2 + i2.substring(t4 + e2.length), o2 = t4 + r2.length, a2++;
          }
          return i2;
        }, ReplaceRE: (t3, e2, r2, s2) => {
          const n3 = String(t3), i2 = String(e2), a2 = String(r2);
          let o2, h2 = -1;
          if (s2 !== void 0) {
            const t4 = parseInt(String(s2), 10);
            if (isNaN(t4))
              throw new Error("limit argument must be integer");
            h2 = t4;
          }
          try {
            o2 = new RegExp(n3, "g");
          } catch (t4) {
            throw new Error(`invalid regular expression: ${n3}`);
          }
          let c2 = 0;
          return a2.replace(o2, (t4) => h2 >= 0 && c2 >= h2 ? t4 : (c2++, i2));
        }, Split: (t3, e2) => String(t3).split(e2), SliceString: (t3, e2, r2) => {
          const s2 = String(t3);
          return r2 !== void 0 ? s2.slice(e2, r2) : s2.slice(e2);
        }, Substr: (t3, e2, r2) => {
          const s2 = String(t3);
          return e2 < 0 && (e2 = s2.length + e2), e2 < 0 && (e2 = 0), e2 >= s2.length ? "" : r2 === void 0 ? s2.slice(e2) : r2 <= 0 ? "" : s2.slice(e2, e2 + r2);
        }, Count: (t3, e2) => {
          const r2 = String(e2);
          return t3 ? (r2.match(new RegExp(t3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g")) || []).length : r2.length + 1;
        }, CountWords: (t3) => {
          const e2 = String(t3).trim();
          return e2 ? e2.split(/\s+/).length : 0;
        }, CountRunes: (t3) => String(t3).replace(/\s/g, "").length, RuneCount: (t3) => String(t3).length, Repeat: (t3, e2) => {
          if (t3 < 0)
            throw new Error("strings: negative Repeat count");
          return String(e2).repeat(t3);
        }, FirstUpper: (t3) => {
          const e2 = String(t3);
          return e2.charAt(0).toUpperCase() + e2.slice(1);
        } })), t2.set("substr", (t3, ...e2) => {
          const r2 = String(t3), s2 = Array.from(r2), n3 = s2.length;
          let i2, a2;
          switch (e2.length) {
            case 0:
              throw new Error("too few arguments");
            case 1:
              const t4 = Number(e2[0]);
              if (isNaN(t4) || !Number.isInteger(t4))
                throw new Error("start argument must be an integer");
              i2 = t4, a2 = n3;
              break;
            case 2:
              const r3 = Number(e2[0]), s3 = Number(e2[1]);
              if (isNaN(r3) || !Number.isInteger(r3))
                throw new Error("start argument must be an integer");
              if (isNaN(s3) || !Number.isInteger(s3))
                throw new Error("length argument must be an integer");
              i2 = r3, a2 = s3;
              break;
            default:
              throw new Error("too many arguments");
          }
          if (n3 === 0)
            return "";
          if (i2 < 0 && (i2 += n3), i2 < 0 && (i2 = 0), i2 > n3 - 1)
            return "";
          let o2 = n3;
          return a2 === 0 ? "" : (a2 < 0 ? o2 += a2 : a2 > 0 && (o2 = i2 + a2), i2 >= o2 || o2 < 0 ? "" : (o2 > n3 && (o2 = n3), s2.slice(i2, o2).join("")));
        }), t2.set("truncate", (t3, ...e2) => {
          const r2 = Number(t3);
          if (isNaN(r2) || !Number.isInteger(r2))
            throw new Error("truncate length must be an integer");
          let s2, n3 = " \u2026";
          switch (e2.length) {
            case 0:
              throw new Error("truncate requires a length and a string");
            case 1:
              s2 = e2[0], n3 = " \u2026";
              break;
            case 2:
              n3 = String(e2[0]), s2 = e2[1];
              break;
            default:
              throw new Error("too many arguments passed to truncate");
          }
          const i2 = String(s2), a2 = /<[^>]+>/.test(i2);
          return Array.from(i2).length <= r2 ? a2 ? i2 : this.escapeHTML(i2) : a2 ? this.truncateHTML(i2, r2, n3) : this.truncateText(i2, r2, n3);
        });
      }
      escapeHTML(t2) {
        return t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      }
      truncateText(t2, e2, r2) {
        const s2 = Array.from(t2);
        if (s2.length <= e2)
          return this.escapeHTML(t2);
        let n3 = 0, i2 = 0;
        for (let t3 = 0; t3 < s2.length && i2 < e2; t3++) {
          const e3 = s2[t3];
          i2++, /\s/.test(e3) && (n3 = t3), /[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(e3) && (n3 = t3);
        }
        let a2 = i2 >= e2 ? n3 > 0 ? n3 : e2 : s2.length;
        const o2 = s2.slice(0, a2).join("");
        return this.escapeHTML(o2) + r2;
      }
      truncateHTML(t2, e2, r2) {
        const s2 = /^<(\/)?([^ ]+?)(?:(\s*\/)| .*?)?>/, n3 = /* @__PURE__ */ new Set(["br", "col", "link", "base", "img", "param", "area", "hr", "input"]), i2 = [];
        let a2 = 0, o2 = 0, h2 = 0, c2 = 0, u2 = 0;
        const l2 = Array.from(t2);
        for (; u2 < l2.length; ) {
          const t3 = l2[u2];
          if (t3 === "<") {
            const t4 = l2.slice(u2).join("").match(s2);
            if (t4) {
              const e3 = t4[0], r3 = t4[1] === "/", s3 = t4[2].toLowerCase(), h3 = t4[3] === "/";
              u2 += e3.length, a2 = o2, n3.has(s3) || h3 || i2.push({ name: s3, pos: u2 - e3.length, openTag: !r3 });
              continue;
            }
          }
          if (h2++, /\s/.test(t3) ? a2 = o2 : /[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(t3) ? a2 = u2 : o2 = u2 + 1, h2 > e2) {
            c2 = a2 > 0 ? a2 : u2;
            break;
          }
          u2++;
        }
        if (h2 <= e2)
          return t2;
        let f2 = l2.slice(0, c2).join("") + r2, w2 = null;
        for (let t3 = i2.length - 1; t3 >= 0; t3--) {
          const e3 = i2[t3];
          e3.pos >= c2 || w2 !== null ? w2 !== null && w2.name === e3.name && (w2 = null) : e3.openTag ? f2 += `</${e3.name}>` : w2 = e3;
        }
        return f2;
      }
      registerMathFunctions(t2) {
        t2.set("add", (t3, e2) => t3 + e2), t2.set("sub", (t3, e2) => t3 - e2), t2.set("mul", (t3, e2) => t3 * e2), t2.set("div", (t3, e2) => e2 !== 0 ? t3 / e2 : 0), t2.set("mod", (t3, e2) => e2 !== 0 ? t3 % e2 : 0), t2.set("math", () => ({ Abs: (t3) => {
          const e2 = Number(t3);
          if (isNaN(e2))
            throw new Error("the math.Abs function requires a numeric argument");
          return Math.abs(e2);
        }, Add: (...t3) => {
          if (t3.length < 2)
            throw new Error("must provide at least two numbers");
          return t3.reduce((t4, e2) => {
            const r2 = Number(e2);
            if (isNaN(r2))
              throw new Error("Add operator can't be used with non-numeric values");
            return t4 + r2;
          }, 0);
        }, Ceil: (t3) => {
          const e2 = Number(t3);
          if (isNaN(e2))
            throw new Error("Ceil operator can't be used with non-numeric value");
          return Math.ceil(e2);
        }, Div: (...t3) => {
          if (t3.length < 2)
            throw new Error("must provide at least two numbers");
          return t3.reduce((t4, e2, r2) => {
            const s2 = Number(e2);
            if (isNaN(s2))
              throw new Error("Div operator can't be used with non-numeric values");
            if (r2 === 0)
              return s2;
            if (s2 === 0)
              throw new Error("division by zero");
            return t4 / s2;
          });
        }, Floor: (t3) => {
          const e2 = Number(t3);
          if (isNaN(e2))
            throw new Error("Floor operator can't be used with non-numeric value");
          return Math.floor(e2);
        }, Log: (t3) => {
          const e2 = Number(t3);
          if (isNaN(e2))
            throw new Error("Log operator can't be used with non-numeric value");
          return Math.log(e2);
        }, Max: (...t3) => {
          if (t3.length === 0)
            throw new Error("must provide at least one number");
          const e2 = t3.flat().map((t4) => {
            const e3 = Number(t4);
            if (isNaN(e3))
              throw new Error("Max operator can't be used with non-numeric values");
            return e3;
          });
          return Math.max(...e2);
        }, Min: (...t3) => {
          if (t3.length === 0)
            throw new Error("must provide at least one number");
          const e2 = t3.flat().map((t4) => {
            const e3 = Number(t4);
            if (isNaN(e3))
              throw new Error("Min operator can't be used with non-numeric values");
            return e3;
          });
          return Math.min(...e2);
        }, Mod: (t3, e2) => {
          const r2 = Number(t3), s2 = Number(e2);
          if (isNaN(r2) || isNaN(s2))
            throw new Error("modulo operator can't be used with non-numeric value");
          if (s2 === 0)
            throw new Error("the number can't be divided by zero at modulo operation");
          return r2 % s2;
        }, ModBool: (t3, e2) => {
          const r2 = Number(t3), s2 = Number(e2);
          if (isNaN(r2) || isNaN(s2))
            throw new Error("modulo operator can't be used with non-numeric value");
          if (s2 === 0)
            throw new Error("the number can't be divided by zero at modulo operation");
          return r2 % s2 === 0;
        }, Mul: (...t3) => {
          if (t3.length < 2)
            throw new Error("must provide at least two numbers");
          return t3.reduce((t4, e2) => {
            const r2 = Number(e2);
            if (isNaN(r2))
              throw new Error("Mul operator can't be used with non-numeric values");
            return t4 * r2;
          }, 1);
        }, Pow: (t3, e2) => {
          const r2 = Number(t3), s2 = Number(e2);
          if (isNaN(r2) || isNaN(s2))
            throw new Error("Pow operator can't be used with non-numeric value");
          return Math.pow(r2, s2);
        }, Rand: () => Math.random(), Round: (t3) => {
          const e2 = Number(t3);
          if (isNaN(e2))
            throw new Error("Round operator can't be used with non-numeric value");
          return Math.round(e2);
        }, Sqrt: (t3) => {
          const e2 = Number(t3);
          if (isNaN(e2))
            throw new Error("Sqrt operator can't be used with non-numeric value");
          return Math.sqrt(e2);
        }, Sub: (...t3) => {
          if (t3.length < 2)
            throw new Error("must provide at least two numbers");
          return t3.reduce((t4, e2, r2) => {
            const s2 = Number(e2);
            if (isNaN(s2))
              throw new Error("Sub operator can't be used with non-numeric values");
            return r2 === 0 ? s2 : t4 - s2;
          });
        }, Sum: (...t3) => {
          if (t3.length === 0)
            throw new Error("must provide at least one number");
          return t3.flat().map((t4) => {
            const e2 = Number(t4);
            if (isNaN(e2))
              throw new Error("Sum operator can't be used with non-numeric values");
            return e2;
          }).reduce((t4, e2) => t4 + e2, 0);
        }, Product: (...t3) => {
          if (t3.length === 0)
            throw new Error("must provide at least one number");
          return t3.flat().map((t4) => {
            const e2 = Number(t4);
            if (isNaN(e2))
              throw new Error("Product operator can't be used with non-numeric values");
            return e2;
          }).reduce((t4, e2) => t4 * e2, 1);
        } }));
      }
      registerTimeFunctions(t2) {
        t2.set("time", () => ({ AsTime: (t3) => {
          if (!t3)
            return null;
          if (t3 instanceof Date)
            return t3;
          if (typeof t3 == "string") {
            const e2 = new Date(t3);
            return isNaN(e2.getTime()) ? null : e2;
          }
          if (typeof t3 == "number") {
            const e2 = new Date(t3 < 1e10 ? 1e3 * t3 : t3);
            return isNaN(e2.getTime()) ? null : e2;
          }
          return null;
        }, Format: (t3, e2) => {
          const r2 = e2 instanceof Date ? e2 : new Date(e2);
          if (isNaN(r2.getTime()))
            return "";
          const s2 = r2.getFullYear(), n3 = r2.getMonth() + 1, i2 = r2.getDate(), a2 = r2.getHours(), o2 = r2.getMinutes(), h2 = r2.getSeconds(), c2 = r2.toLocaleString("en-US", { weekday: "short" }), u2 = r2.toLocaleString("en-US", { month: "short" }), l2 = [{ pattern: "2006", placeholder: "{{YEAR_FULL}}", value: s2.toString() }, { pattern: "January", placeholder: "{{MONTH_FULL}}", value: r2.toLocaleString("en-US", { month: "long" }) }, { pattern: "Monday", placeholder: "{{WEEKDAY_FULL}}", value: r2.toLocaleString("en-US", { weekday: "long" }) }, { pattern: "MST", placeholder: "{{TIMEZONE}}", value: r2.toLocaleString("en-US", { timeZoneName: "short" }) }, { pattern: "Jan", placeholder: "{{MONTH_SHORT}}", value: u2 }, { pattern: "Mon", placeholder: "{{WEEKDAY_SHORT}}", value: c2 }, { pattern: "06", placeholder: "{{YEAR_SHORT}}", value: s2.toString().slice(-2) }, { pattern: "15", placeholder: "{{HOUR_24}}", value: a2.toString().padStart(2, "0") }, { pattern: "01", placeholder: "{{MONTH_ZERO}}", value: n3.toString().padStart(2, "0") }, { pattern: "02", placeholder: "{{DAY_ZERO}}", value: i2.toString().padStart(2, "0") }, { pattern: "04", placeholder: "{{MINUTE_ZERO}}", value: o2.toString().padStart(2, "0") }, { pattern: "05", placeholder: "{{SECOND_ZERO}}", value: h2.toString().padStart(2, "0") }, { pattern: "PM", placeholder: "{{AMPM_UPPER}}", value: a2 >= 12 ? "PM" : "AM" }, { pattern: "pm", placeholder: "{{AMPM_LOWER}}", value: a2 >= 12 ? "pm" : "am" }, { pattern: "3", placeholder: "{{HOUR_12}}", value: ((a2 + 11) % 12 + 1).toString() }, { pattern: "1", placeholder: "{{MONTH_NUM}}", value: n3.toString() }, { pattern: "2", placeholder: "{{DAY_NUM}}", value: i2.toString() }, { pattern: "4", placeholder: "{{MINUTE_NUM}}", value: o2.toString() }, { pattern: "5", placeholder: "{{SECOND_NUM}}", value: h2.toString() }];
          let f2 = t3;
          for (const { pattern: t4, placeholder: e3 } of l2) {
            const r3 = t4.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            f2 = f2.replace(new RegExp(r3, "g"), e3);
          }
          for (const { placeholder: t4, value: e3 } of l2)
            f2 = f2.replace(new RegExp(t4.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), e3);
          return f2;
        }, Now: () => new Date(), Parse: (t3, e2) => {
          try {
            const t4 = new Date(e2);
            return isNaN(t4.getTime()) ? null : t4;
          } catch {
            return null;
          }
        }, Unix: (t3) => {
          const e2 = t3 instanceof Date ? t3 : new Date(t3);
          return Math.floor(e2.getTime() / 1e3);
        }, UnixNano: (t3) => 1e6 * (t3 instanceof Date ? t3 : new Date(t3)).getTime() })), t2.set("now", () => {
          const t3 = new Date();
          return { Format: (e2) => {
            const r2 = t3.getFullYear(), s2 = t3.getMonth() + 1, n3 = t3.getDate(), i2 = t3.getHours(), a2 = t3.getMinutes(), o2 = t3.getSeconds(), h2 = [{ pattern: "2006", value: r2.toString() }, { pattern: "06", value: r2.toString().slice(-2) }, { pattern: "01", value: s2.toString().padStart(2, "0") }, { pattern: "1", value: s2.toString() }, { pattern: "02", value: n3.toString().padStart(2, "0") }, { pattern: "2", value: n3.toString() }, { pattern: "15", value: i2.toString().padStart(2, "0") }, { pattern: "3", value: (i2 % 12 || 12).toString() }, { pattern: "04", value: a2.toString().padStart(2, "0") }, { pattern: "4", value: a2.toString() }, { pattern: "05", value: o2.toString().padStart(2, "0") }, { pattern: "5", value: o2.toString() }];
            let c2 = e2;
            for (const { pattern: t4, value: e3 } of h2) {
              const r3 = new RegExp(`\\b${t4}\\b`, "g");
              c2 = c2.replace(r3, e3);
            }
            return e2 === "2006" ? r2.toString() : e2 === "06" ? r2.toString().slice(-2) : e2 === "01" ? s2.toString().padStart(2, "0") : e2 === "02" ? n3.toString().padStart(2, "0") : e2 === "15" ? i2.toString().padStart(2, "0") : e2 === "04" ? a2.toString().padStart(2, "0") : e2 === "05" ? o2.toString().padStart(2, "0") : c2;
          }, getTime: () => t3.getTime(), toString: () => t3.toString(), toISOString: () => t3.toISOString() };
        }), t2.set("dateFormat", (t3, e2) => e2.toLocaleDateString());
      }
      registerCollectionFunctions(t2) {
        t2.set("len", (t3) => Array.isArray(t3) || typeof t3 == "string" ? t3.length : t3 && typeof t3 == "object" ? Object.keys(t3).length : 0), t2.set("first", (t3, e2) => Array.isArray(t3) ? t3.slice(0, 1) : Array.isArray(e2) ? e2.slice(0, t3) : []), t2.set("last", (t3, e2) => Array.isArray(t3) ? t3.slice(-1) : Array.isArray(e2) ? e2.slice(-t3) : []), t2.set("merge", (...t3) => {
          const e2 = {};
          for (const r2 of t3)
            r2 && typeof r2 == "object" && !Array.isArray(r2) && Object.assign(e2, r2);
          return e2;
        }), t2.set("index", (t3, ...e2) => {
          try {
            return this.doIndex(t3, e2);
          } catch (r2) {
            return vi.error(`Index of type ${typeof t3} with args [${e2.join(", ")}] failed:`, r2), null;
          }
        }), t2.set("reverse", (t3) => Array.isArray(t3) ? [...t3].reverse() : t3), t2.set("append", (...t3) => {
          if (t3.length < 2)
            return t3[0] || [];
          const e2 = Array.isArray(t3[0]) ? [...t3[0]] : [t3[0]];
          for (let r2 = 1; r2 < t3.length; r2++)
            Array.isArray(t3[r2]) ? e2.push(...t3[r2]) : e2.push(t3[r2]);
          return e2;
        }), t2.set("prepend", (t3, ...e2) => Array.isArray(t3) ? [...e2, ...t3] : [...e2, t3]), t2.set("seq", (...t3) => {
          if (t3.length < 1 || t3.length > 3)
            throw new Error("invalid number of arguments to Seq");
          const e2 = t3.map((t4) => {
            const e3 = Number(t4);
            if (isNaN(e3))
              throw new Error("invalid arguments to Seq");
            return Math.floor(e3);
          });
          let r2, s2 = 1, n3 = e2[0];
          if (e2.length === 1) {
            if (r2 = n3, r2 === 0)
              return [];
            r2 > 0 ? n3 = 1 : (n3 = -1, s2 = -1);
          } else if (e2.length === 2)
            r2 = e2[1], r2 < n3 && (s2 = -1);
          else {
            if (s2 = e2[1], r2 = e2[2], s2 === 0)
              throw new Error("'increment' must not be 0");
            if (n3 < r2 && s2 < 0)
              throw new Error("'increment' must be > 0");
            if (n3 > r2 && s2 > 0)
              throw new Error("'increment' must be < 0");
          }
          if (r2 < -1e5)
            throw new Error("size of result exceeds limit");
          const i2 = Math.floor((r2 - n3) / s2) + 1;
          if (i2 <= 0 || i2 > 2e3)
            throw new Error("size of result exceeds limit");
          const a2 = new Array(i2);
          let o2 = n3;
          for (let t4 = 0; t4 < i2 && (a2[t4] = o2, o2 += s2, !(s2 < 0 && o2 < r2 || s2 > 0 && o2 > r2)); t4++)
            ;
          return a2;
        }), t2.set("sort", (t3, ...e2) => {
          if (t3 == null)
            throw new Error("sequence must be provided");
          let r2;
          if (Array.isArray(t3))
            r2 = [...t3];
          else {
            if (typeof t3 != "object" || t3 === null)
              throw new Error("can't sort " + typeof t3);
            r2 = Object.values(t3);
          }
          if (r2.length === 0)
            return r2;
          let s2 = "", n3 = true;
          for (let t4 = 0; t4 < e2.length; t4++) {
            const r3 = e2[t4];
            t4 === 0 ? typeof r3 == "string" && (s2 = r3) : t4 === 1 && typeof r3 == "string" && r3.toLowerCase() === "desc" && (n3 = false);
          }
          const i2 = (t4, e3) => {
            if (!e3 || e3 === "value")
              return t4;
            const r3 = e3.split(".");
            let s3 = t4;
            for (const t5 of r3) {
              if (s3 == null)
                return;
              if (typeof s3 != "object")
                return;
              s3 = s3[t5];
            }
            return s3;
          };
          return r2.sort((t4, e3) => {
            let r3 = s2 ? i2(t4, s2) : t4, a2 = s2 ? i2(e3, s2) : e3;
            if (r3 == null)
              return a2 == null ? 0 : n3 ? -1 : 1;
            if (a2 == null)
              return n3 ? 1 : -1;
            if (typeof r3 == "string" && typeof a2 == "string") {
              const t5 = r3.localeCompare(a2);
              return n3 ? t5 : -t5;
            }
            if (typeof r3 == "number" && typeof a2 == "number") {
              const t5 = r3 - a2;
              return n3 ? t5 : -t5;
            }
            const o2 = String(r3), h2 = String(a2), c2 = o2.localeCompare(h2);
            return n3 ? c2 : -c2;
          });
        }), t2.set("where", (() => (t3, e2, ...r2) => {
          if (!t3)
            return [];
          let s2, n3 = "==";
          if (r2.length === 1)
            s2 = r2[0];
          else {
            if (r2.length !== 2)
              throw new Error("where function requires 2-4 arguments");
            n3 = r2[0], s2 = r2[1];
          }
          const i2 = [];
          if (Array.isArray(t3))
            for (let r3 = 0; r3 < t3.length; r3++) {
              const a2 = t3[r3], o2 = this.getNestedValue(a2, e2);
              this.checkCondition(o2, s2, n3) && i2.push(a2);
            }
          else if (typeof t3 == "object") {
            for (const [r3, a2] of Object.entries(t3))
              if (Array.isArray(a2)) {
                const t4 = a2.filter((t5) => {
                  const r4 = this.getNestedValue(t5, e2);
                  return this.checkCondition(r4, s2, n3);
                });
                t4.length > 0 && i2.push({ [r3]: t4 });
              }
          }
          return i2;
        })()), t2.set("intersect", (t3, e2) => Array.isArray(t3) && Array.isArray(e2) ? t3.filter((t4) => e2.includes(t4)) : []), t2.set("querify", (...t3) => {
          let e2 = [];
          if (e2 = t3.length === 1 && Array.isArray(t3[0]) ? t3[0] : t3, e2.length % 2 != 0)
            throw new Error("querify requires an even number of arguments (key-value pairs)");
          const r2 = [];
          for (let t4 = 0; t4 < e2.length; t4 += 2) {
            const s2 = String(e2[t4]), n3 = String(e2[t4 + 1]);
            r2.push([s2, n3]);
          }
          return r2.sort((t4, e3) => t4[0].localeCompare(e3[0])), r2.map(([t4, e3]) => `${encodeURIComponent(t4).replace(/%20/g, "+")}=${encodeURIComponent(e3).replace(/%20/g, "+")}`).join("&");
        }), t2.set("isset", (t3, e2) => {
          if (t3 == null)
            return false;
          if (Array.isArray(t3)) {
            const r2 = Number(e2);
            return isNaN(r2) || !Number.isInteger(r2) ? (console.warn(`isset unable to use key of type ${typeof e2} as index`), false) : t3.length > r2 && r2 >= 0;
          }
          if (typeof t3 == "object")
            return e2 in t3;
          if (typeof t3 == "string") {
            const r2 = Number(e2);
            return isNaN(r2) || !Number.isInteger(r2) ? (console.warn(`isset unable to use key of type ${typeof e2} as index`), false) : t3.length > r2 && r2 >= 0;
          }
          return console.warn(`calling isset with unsupported type "${typeof t3}" (${t3.constructor?.name || typeof t3}) will always return false.`), false;
        });
      }
      doIndex(t2, e2) {
        if (t2 == null)
          return null;
        if (e2.length === 0)
          return t2;
        let r2 = t2;
        for (const t3 of e2) {
          if (r2 == null)
            return null;
          if (Array.isArray(r2))
            r2 = this.indexArray(r2, t3);
          else if (typeof r2 == "string")
            r2 = this.indexString(r2, t3);
          else {
            if (typeof r2 != "object")
              throw new Error("can't index item of type " + typeof r2);
            r2 = this.indexObject(r2, t3);
          }
        }
        return r2;
      }
      indexArray(t2, e2) {
        const r2 = this.toInteger(e2);
        if (r2 === null)
          throw new Error("cannot index slice/array with type " + typeof e2);
        return r2 < 0 || r2 >= t2.length ? null : t2[r2];
      }
      indexString(t2, e2) {
        const r2 = this.toInteger(e2);
        if (r2 === null)
          throw new Error("cannot index string with type " + typeof e2);
        return r2 < 0 || r2 >= t2.length ? null : t2.charAt(r2);
      }
      indexObject(t2, e2) {
        const r2 = String(e2);
        if (t2.hasOwnProperty(r2))
          return t2[r2];
        const s2 = Object.keys(t2).find((t3) => t3.toLowerCase() === r2.toLowerCase());
        if (s2)
          return t2[s2];
        if (t2 instanceof Map) {
          if (t2.has(r2))
            return t2.get(r2);
          for (const e3 of t2.keys())
            if (String(e3).toLowerCase() === r2.toLowerCase())
              return t2.get(e3);
        }
        return null;
      }
      toInteger(t2) {
        if (typeof t2 == "number")
          return Number.isInteger(t2) ? t2 : Math.floor(t2);
        if (typeof t2 == "string") {
          const e2 = parseInt(t2, 10);
          if (!isNaN(e2))
            return e2;
        }
        return null;
      }
      checkCondition(t2, e2, r2) {
        const s2 = r2.toLowerCase().trim();
        if (t2 == null && e2 == null)
          return ["==", "=", "eq", ""].includes(s2);
        if (t2 == null || e2 == null)
          return ["!=", "<>", "ne"].includes(s2);
        if (s2 === "in")
          return (Array.isArray(e2) || typeof e2 == "string" && typeof t2 == "string") && e2.includes(t2);
        if (s2 === "intersect")
          return !(!Array.isArray(t2) || !Array.isArray(e2)) && t2.some((t3) => e2.includes(t3));
        const [n3, i2] = this.normalizeForComparison(t2, e2);
        switch (s2) {
          case "":
          case "=":
          case "==":
          case "eq":
            return n3 === i2;
          case "!=":
          case "<>":
          case "ne":
            return n3 !== i2;
          case "<":
          case "lt":
            return n3 < i2;
          case "<=":
          case "le":
            return n3 <= i2;
          case ">":
          case "gt":
            return n3 > i2;
          case ">=":
          case "ge":
            return n3 >= i2;
          default:
            return false;
        }
      }
      normalizeForComparison(t2, e2) {
        if (typeof t2 == "number" && typeof e2 == "number")
          return [t2, e2];
        if (typeof t2 == "number" && typeof e2 == "string") {
          const r2 = parseFloat(e2);
          if (!isNaN(r2))
            return [t2, r2];
        }
        if (typeof t2 == "string" && typeof e2 == "number") {
          const r2 = parseFloat(t2);
          if (!isNaN(r2))
            return [r2, e2];
        }
        return typeof t2 == "string" && typeof e2 == "string" || typeof t2 == "boolean" && typeof e2 == "boolean" ? [t2, e2] : [String(t2), String(e2)];
      }
      registerSafeFunctions(t2) {
        t2.set("return", (...t3) => t3.length === 0 ? "" : t3.length === 1 ? t3[0] : t3), t2.set("cond", (...t3) => {
          if (t3.length < 2)
            throw new Error("cond requires at least 2 arguments");
          const e2 = t3[0], r2 = t3[1], s2 = t3.length > 2 ? t3[2] : "";
          let n3 = false;
          return e2 === true || e2 === 1 ? n3 = true : typeof e2 == "string" ? n3 = e2.length > 0 && e2 !== "false" && e2 !== "0" : typeof e2 == "number" ? n3 = e2 !== 0 : Array.isArray(e2) ? n3 = e2.length > 0 : e2 && typeof e2 == "object" && (n3 = Object.keys(e2).length > 0), n3 ? r2 : s2;
        }), t2.set("safeHTML", (t3) => t3), t2.set("safeCSS", (t3) => t3), t2.set("safeJS", (t3) => t3), t2.set("safeURL", (t3) => t3), t2.set("dict", (...t3) => {
          if (t3.length % 2 != 0)
            throw new Error("dict requires an even number of arguments");
          const e2 = {};
          for (let r2 = 0; r2 < t3.length; r2 += 2)
            e2[String(t3[r2])] = t3[r2 + 1];
          return e2;
        }), t2.set("slice", (...t3) => t3), t2.set("default", (t3, e2) => e2 != null && e2 !== "" && e2 !== 0 ? e2 : t3), t2.set("jsonify", (...t3) => {
          if (t3.length === 0)
            return "";
          let e2, r2 = {};
          if (t3.length === 1)
            e2 = t3[0];
          else {
            if (t3.length !== 2)
              throw new Error("too many arguments to jsonify");
            {
              const s2 = t3[0];
              e2 = t3[1], s2 && typeof s2 == "object" && (r2.prefix = s2.prefix || "", r2.indent = s2.indent || "", r2.noHTMLEscape = s2.noHTMLEscape || false);
            }
          }
          try {
            let t4;
            return r2.indent ? (t4 = JSON.stringify(e2, null, r2.indent), r2.prefix && (t4 = t4.split("\n").map((t5) => r2.prefix + t5).join("\n"))) : t4 = JSON.stringify(e2), r2.noHTMLEscape || (t4 = t4.replace(/&/g, "\\u0026").replace(/</g, "\\u003c").replace(/>/g, "\\u003e")), t4;
          } catch (t4) {
            throw new Error(`failed to jsonify object: ${t4.message}`);
          }
        });
      }
      registerFmtFunctions(t2) {
        t2.set("printf", (t3, ...e2) => {
          let r2 = t3, s2 = 0;
          return r2 = r2.replace(/%[vsdft%]/g, (t4) => {
            if (t4 === "%%")
              return "%";
            if (s2 >= e2.length)
              return t4;
            const r3 = e2[s2++];
            switch (t4) {
              case "%v":
              case "%s":
              default:
                return String(r3);
              case "%d":
                return String(Math.floor(Number(r3) || 0));
              case "%f":
                return String(Number(r3) || 0);
              case "%t":
                return String(Boolean(r3));
            }
          }), r2;
        }), t2.set("print", (...t3) => t3.map((t4) => String(t4)).join(" ")), t2.set("println", (...t3) => t3.map((t4) => String(t4)).join(" ") + "\n"), t2.set("errorf", (t3, ...e2) => {
          let r2 = t3;
          for (let t4 = 0; t4 < e2.length; t4++)
            r2 = r2.replace(/%[sd%]/, String(e2[t4]));
          return vi.error("Template Error:", r2), "";
        }), t2.set("warnf", (t3, ...e2) => {
          let r2 = t3;
          for (let t4 = 0; t4 < e2.length; t4++)
            r2 = r2.replace(/%[sd%]/, String(e2[t4]));
          return vi.warn("Template Warning:", r2), "";
        }), t2.set("fmt", () => ({ Print: (...t3) => t3.map((t4) => String(t4)).join(" "), Printf: (t3, ...e2) => {
          let r2 = t3;
          for (let t4 = 0; t4 < e2.length; t4++)
            r2 = r2.replace(/%[sd%]/, String(e2[t4]));
          return r2;
        }, Println: (...t3) => t3.map((t4) => String(t4)).join(" ") + "\n", Errorf: (t3, ...e2) => {
          let r2 = t3;
          for (let t4 = 0; t4 < e2.length; t4++)
            r2 = r2.replace(/%[sd%]/, String(e2[t4]));
          return vi.error("Template Error:", r2), "";
        }, Erroridf: (t3, e2, ...r2) => {
          let s2 = e2;
          for (let t4 = 0; t4 < r2.length; t4++)
            s2 = s2.replace(/%[sd%]/, String(r2[t4]));
          return vi.error("Template Error:", s2), "";
        }, Warnf: (t3, ...e2) => {
          let r2 = t3;
          for (let t4 = 0; t4 < e2.length; t4++)
            r2 = r2.replace(/%[sd%]/, String(e2[t4]));
          return vi.error("Template Warning:", r2), "";
        }, Warnidf: (t3, e2, ...r2) => {
          let s2 = e2;
          for (let t4 = 0; t4 < r2.length; t4++)
            s2 = s2.replace(/%[sd%]/, String(r2[t4]));
          return vi.error("Template Warning:", s2), "";
        } }));
      }
      registerReflectFunctions(t2) {
        t2.set("reflect", () => ({ IsMap: (t3) => {
          if (t3 == null)
            return false;
          if (typeof t3 != "object" || Array.isArray(t3))
            return false;
          if (t3 instanceof Map)
            return true;
          if (t3.constructor === Object)
            return true;
          const e2 = Object.getPrototypeOf(t3);
          return e2 === Object.prototype || e2 === null;
        }, IsSlice: (t3) => Array.isArray(t3) }));
      }
      registerPathFunctions(t2) {
        t2.set("path", () => ({ Base: (t3) => {
          if (!t3)
            return ".";
          if (!(t3 = (t3 = t3.replace(/\\/g, "/")).replace(/\/+$/, "")))
            return "/";
          const e2 = t3.split("/");
          return e2[e2.length - 1] || "/";
        }, Clean: (t3) => {
          if (!t3)
            return ".";
          const e2 = (t3 = t3.replace(/\\/g, "/")).startsWith("/"), r2 = t3.split("/").filter((t4) => t4 && t4 !== "."), s2 = [];
          for (const t4 of r2)
            t4 === ".." ? s2.length > 0 && s2[s2.length - 1] !== ".." ? s2.pop() : e2 || s2.push("..") : s2.push(t4);
          return t3 = s2.join("/"), e2 && (t3 = "/" + t3), t3 || (e2 ? "/" : ".");
        }, Dir: (t3) => {
          if (!t3)
            return ".";
          if (!(t3 = t3.replace(/\/+$/, "")))
            return "/";
          const e2 = t3.split("/");
          return e2.pop(), e2.join("/") || ".";
        }, Ext: (t3) => {
          const e2 = t3.split("/").pop() || "", r2 = e2.lastIndexOf(".");
          return r2 === -1 || r2 === 0 ? "" : e2.substring(r2);
        }, IsAbs: (t3) => t3.startsWith("/"), Join: (...t3) => {
          if (t3.length === 0)
            return ".";
          let e2 = t3.filter((t4) => t4).map((t4) => t4.replace(/^\/+|\/+$/g, "")).join("/");
          return t3[0] && t3[0].startsWith("/") && (e2 = "/" + e2), e2 || ".";
        }, Split: (t3) => {
          if (!t3)
            return [".", ""];
          const e2 = t3.lastIndexOf("/");
          return e2 === -1 ? ["", t3] : [t3.substring(0, e2), t3.substring(e2 + 1)];
        } }));
      }
      registerTransformFunctions(t2) {
        t2.set("transform", () => ({ Unmarshal: (...t3) => {
          if (t3.length < 1 || t3.length > 2)
            throw new Error("unmarshal takes 1 or 2 arguments");
          let e2, r2, s2 = {};
          if (t3.length === 1)
            e2 = t3[0];
          else {
            const r3 = t3[0];
            if (!r3 || typeof r3 != "object")
              throw new Error("first argument must be a map");
            s2 = r3, e2 = t3[1];
          }
          if (e2 && typeof e2 == "object" && typeof e2.Content == "function")
            try {
              const t4 = e2.Content();
              return this.unmarshalContent(t4, s2);
            } catch (t4) {
              throw new Error(`failed to get content from resource: ${t4.message}`);
            }
          if (typeof e2 == "string")
            r2 = e2;
          else {
            if (!e2 || typeof e2.toString != "function")
              throw new Error(`type ${typeof e2} not supported`);
            r2 = e2.toString();
          }
          return r2 && r2.trim() !== "" ? this.unmarshalContent(r2, s2) : null;
        }, Plainify: (t3) => {
          const e2 = String(t3);
          return this.stripHTML(e2);
        } })), t2.set("unmarshal", (...e2) => t2.get("transform")().Unmarshal(...e2)), t2.set("plainify", (t3) => {
          const e2 = String(t3);
          return this.stripHTML(e2);
        });
      }
      stripHTML(t2) {
        if (!t2.includes("<") && !t2.includes(">"))
          return t2;
        let e2 = t2.replace(/\n/g, " ").replace(/<\/p>/gi, "\n").replace(/<br\s*\/?>/gi, "\n").replace(/<\/div>/gi, "\n").replace(/<\/h[1-6]>/gi, "\n").replace(/<\/li>/gi, "\n").replace(/<\/tr>/gi, "\n").replace(/<\/blockquote>/gi, "\n");
        e2 = e2.replace(/<[^>]*>/g, "");
        const r2 = e2.split("\n");
        return e2 = r2.map((t3) => t3.trim().replace(/\s+/g, " ")).filter((t3) => t3.length > 0).join("\n").trim(), e2 = e2.replace(/\n\s*\n/g, "\n"), e2;
      }
      unmarshalContent(t2, e2 = {}) {
        const r2 = t2.trim();
        if (!r2)
          return null;
        let s2 = e2.format;
        s2 || (s2 = this.detectFormat(r2));
        try {
          switch (s2.toLowerCase()) {
            case "json":
              return JSON.parse(r2);
            case "yaml":
            case "yml":
              return this.parseYAML(r2);
            case "toml":
              return this.parseTOML(r2);
            case "csv":
              return this.parseCSV(r2);
            default:
              throw new Error(`format "${s2}" not supported`);
          }
        } catch (t3) {
          throw new Error(`failed to unmarshal ${s2}: ${t3.message}`);
        }
      }
      detectFormat(t2) {
        const e2 = t2.trim();
        if (e2.startsWith("{") && e2.endsWith("}") || e2.startsWith("[") && e2.endsWith("]"))
          try {
            return JSON.parse(e2), "json";
          } catch {
          }
        return e2.startsWith("---") || /^[a-zA-Z_][a-zA-Z0-9_]*\s*:\s*.+/m.test(e2) ? "yaml" : /^\[.*\]$/m.test(e2) || /^[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*.+/m.test(e2) ? "toml" : /^[^,\n]*,[^,\n]*/.test(e2) ? "csv" : "json";
      }
      parseYAML(t2) {
        const e2 = t2.split("\n"), r2 = {};
        for (const t3 of e2) {
          const e3 = t3.trim();
          if (!e3 || e3.startsWith("#") || e3 === "---")
            continue;
          const s2 = e3.indexOf(":");
          if (s2 > 0) {
            const t4 = e3.substring(0, s2).trim();
            let n3 = e3.substring(s2 + 1).trim();
            (n3.startsWith('"') && n3.endsWith('"') || n3.startsWith("'") && n3.endsWith("'")) && (n3 = n3.slice(1, -1)), n3 === "true" ? r2[t4] = true : n3 === "false" ? r2[t4] = false : /^\d+$/.test(n3) ? r2[t4] = parseInt(n3, 10) : /^\d*\.\d+$/.test(n3) ? r2[t4] = parseFloat(n3) : r2[t4] = n3;
          }
        }
        return r2;
      }
      parseTOML(t2) {
        const e2 = t2.split("\n"), r2 = {};
        let s2 = "";
        for (const t3 of e2) {
          const e3 = t3.trim();
          if (!e3 || e3.startsWith("#"))
            continue;
          if (e3.startsWith("[") && e3.endsWith("]")) {
            s2 = e3.slice(1, -1), r2[s2] || (r2[s2] = {});
            continue;
          }
          const n3 = e3.indexOf("=");
          if (n3 > 0) {
            const t4 = e3.substring(0, n3).trim();
            let i2, a2 = e3.substring(n3 + 1).trim();
            (a2.startsWith('"') && a2.endsWith('"') || a2.startsWith("'") && a2.endsWith("'")) && (a2 = a2.slice(1, -1)), i2 = a2 === "true" || a2 !== "false" && (/^\d+$/.test(a2) ? parseInt(a2, 10) : /^\d*\.\d+$/.test(a2) ? parseFloat(a2) : a2), s2 ? r2[s2][t4] = i2 : r2[t4] = i2;
          }
        }
        return r2;
      }
      parseCSV(t2) {
        const e2 = t2.trim().split("\n");
        if (e2.length === 0)
          return [];
        const r2 = this.parseCSVLine(e2[0]), s2 = [];
        for (let t3 = 1; t3 < e2.length; t3++) {
          const n3 = this.parseCSVLine(e2[t3]), i2 = {};
          for (let t4 = 0; t4 < r2.length; t4++) {
            const e3 = r2[t4], s3 = t4 < n3.length ? n3[t4] : "";
            /^\d+$/.test(s3) ? i2[e3] = parseInt(s3, 10) : /^\d*\.\d+$/.test(s3) ? i2[e3] = parseFloat(s3) : i2[e3] = s3 === "true" || s3 !== "false" && s3;
          }
          s2.push(i2);
        }
        return s2;
      }
      parseCSVLine(t2) {
        const e2 = [];
        let r2 = "", s2 = false;
        for (let n3 = 0; n3 < t2.length; n3++) {
          const i2 = t2[n3];
          i2 === '"' ? s2 && t2[n3 + 1] === '"' ? (r2 += '"', n3++) : s2 = !s2 : i2 !== "," || s2 ? r2 += i2 : (e2.push(r2.trim()), r2 = "");
        }
        return e2.push(r2.trim()), e2;
      }
      getNestedValue(t2, e2) {
        if (!t2 || !e2)
          return;
        const r2 = e2.replace(/^\\.+/, "").split(".");
        let s2 = t2;
        for (let t3 = 0; t3 < r2.length; t3++) {
          const e3 = r2[t3];
          if (s2 == null)
            return;
          if (typeof s2 == "object") {
            if (s2.hasOwnProperty(e3)) {
              s2 = s2[e3];
              continue;
            }
            const t4 = Object.keys(s2).find((t5) => t5.toLowerCase() === e3.toLowerCase());
            if (t4) {
              s2 = s2[t4];
              continue;
            }
            const r3 = e3.toLowerCase();
            if (typeof s2[r3] == "function")
              try {
                s2 = s2[r3]();
                continue;
              } catch (t5) {
                return;
              }
            return;
          }
          return;
        }
        return s2;
      }
    };
    function $i() {
      return new Pi();
    }
    var Ri = class {
      async create(t2) {
        return this.createWithConfig(t2, {});
      }
      async createWithConfig(t2, e2) {
        try {
          const r2 = new Li().withFs(t2).withNamespaces(new hi(), new ci(), new ui());
          e2.services ? r2.withServices(e2.services) : e2.funcMap ? r2.withFuncMap(e2.funcMap) : r2.withFuncMap(function() {
            const t3 = /* @__PURE__ */ new Map();
            return $i().registerCoreFunctions(t3), t3;
          }());
          const s2 = await r2.buildLookup().buildParser().buildExecutor().build();
          return await s2.markReady(), s2;
        } catch (t3) {
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new ei(`Failed to create template engine: ${e3}`, "FACTORY_CREATE_FAILED");
        }
      }
      async createWithServices(t2, e2) {
        return this.createWithConfig(t2, { services: e2 });
      }
    };
    var Li = class {
      constructor() {
        __publicField(this, "funcMap", /* @__PURE__ */ new Map());
        __publicField(this, "services");
        __publicField(this, "fs");
        __publicField(this, "templateNamespace");
        __publicField(this, "partialNamespace");
        __publicField(this, "shortcodeNamespace");
        __publicField(this, "lookup");
        __publicField(this, "parser");
        __publicField(this, "executor");
      }
      withFs(t2) {
        return this.fs = t2, this;
      }
      withNamespaces(t2, e2, r2) {
        return this.templateNamespace = t2, this.partialNamespace = e2, this.shortcodeNamespace = r2, this;
      }
      withFuncMap(t2) {
        return this.funcMap = new Map([...this.funcMap, ...t2]), this;
      }
      withServices(t2) {
        return this.services = t2, this.funcMap = function(t3) {
          const e2 = /* @__PURE__ */ new Map();
          return $i().registerAllFunctions(e2, t3), e2;
        }(t2), this;
      }
      buildLookup() {
        const t2 = new si();
        return this.lookup = function(t3, e2) {
          return new yi(t3, e2);
        }(t2, this.funcMap), this;
      }
      buildParser() {
        return this.parser = function(t2 = /* @__PURE__ */ new Map()) {
          return new mi(t2);
        }(this.funcMap), this;
      }
      buildExecutor() {
        return this.executor = new li(), this;
      }
      async build() {
        if (!this.fs)
          throw new ei("File system is required", "BUILDER_FS_REQUIRED");
        if (!this.templateNamespace)
          throw new ei("Template namespace is required", "BUILDER_TEMPLATE_NAMESPACE_REQUIRED");
        if (!this.partialNamespace)
          throw new ei("Partial namespace is required", "BUILDER_PARTIAL_NAMESPACE_REQUIRED");
        if (!this.shortcodeNamespace)
          throw new ei("Shortcode namespace is required", "BUILDER_SHORTCODE_NAMESPACE_REQUIRED");
        if (!this.lookup)
          throw new ei("Lookup is required", "BUILDER_LOOKUP_REQUIRED");
        if (!this.parser)
          throw new ei("Parser is required", "BUILDER_PARSER_REQUIRED");
        if (!this.executor)
          throw new ei("Executor is required", "BUILDER_EXECUTOR_REQUIRED");
        const t2 = (e2 = this.executor, r2 = this.lookup, s2 = this.parser, n3 = this.templateNamespace, i2 = this.partialNamespace, a2 = this.shortcodeNamespace, o2 = this.fs, new Ei(e2, r2, s2, n3, i2, a2, o2));
        var e2, r2, s2, n3, i2, a2, o2;
        !function(t3) {
          for (const e3 of Ti)
            try {
              e3.updateEngine(t3);
            } catch (t4) {
              vi.error(`\u274C Failed to update function ${e3.getFunctionName()}:`, t4);
            }
        }(t2);
        try {
          await t2.loadTemplates();
        } catch (t3) {
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw new ei(`Failed to load templates: ${e3}`, "BUILDER_LOAD_TEMPLATES_FAILED");
        }
        return t2;
      }
    };
    var Ni = A("content", { component: "pagebuilder" });
    var Fi = class {
      constructor(t2, e2, r2, s2, n3, i2, a2, o2, h2, c2, u2) {
        __publicField(this, "urlSvc");
        __publicField(this, "langSvc");
        __publicField(this, "taxonomySvc");
        __publicField(this, "templateSvc");
        __publicField(this, "pageMapper");
        __publicField(this, "taxonomy");
        __publicField(this, "term");
        __publicField(this, "section");
        __publicField(this, "standalone");
        __publicField(this, "converter");
        __publicField(this, "contentHub");
        __publicField(this, "source");
        __publicField(this, "sourceByte");
        __publicField(this, "kind");
        __publicField(this, "singular");
        __publicField(this, "term_");
        __publicField(this, "langIdx");
        __publicField(this, "fm");
        __publicField(this, "fmParser");
        __publicField(this, "c");
        __publicField(this, "renderableDocument", null);
        this.urlSvc = t2, this.langSvc = e2, this.taxonomySvc = r2, this.templateSvc = s2, this.pageMapper = null, this.taxonomy = i2, this.term = a2, this.section = o2, this.standalone = h2, this.converter = c2, this.contentHub = u2, this.source = null, this.sourceByte = new Uint8Array(), this.kind = "", this.singular = "", this.term_ = "", this.langIdx = -1, this.fm = null, this.fmParser = null, this.c = null;
      }
      withSource(t2) {
        const e2 = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        return e2.reset(), e2.source = t2, e2;
      }
      withLangIdx(t2) {
        return this.langIdx = t2, this;
      }
      reset() {
        this.c = null, this.kind = "", this.langIdx = -1;
      }
      async build() {
        if (!this.source)
          throw new Error("source for page builder is nil");
        const t2 = await this.source.contentSource();
        this.sourceByte = t2, await this.parse(t2);
        const e2 = await this.buildInternal();
        return await this.render(e2), e2;
      }
      async kindBuild() {
        if (!this.source)
          throw new Error("source for page builder is nil");
        return await this.parseKind(), this.langIdx === -1 ? await this.parseLanguageByDefault() : await this.parseLanguageByIdx(this.langIdx), this.fm = Bs(), this.c = On(new Uint8Array()), await this.buildInternal();
      }
      async buildInternal() {
        switch (this.kind) {
          case vs("home"):
            return await this.buildHome();
          case vs("section"):
            return await this.buildSection();
          case vs("page"):
            return await this.buildPage();
          case vs("taxonomy"):
            return await this.buildTaxonomy();
          case vs("term"):
            return await this.buildTerm();
          case vs("404"):
            return await this.build404();
          case vs("sitemap"):
            return await this.buildSitemap();
          default:
            throw new Error(`unknown kind "${this.kind}"`);
        }
      }
      async buildPage() {
        const t2 = await this.newPage(this.source, this.c);
        return await this.applyFrontMatter(t2), t2.pageMap = this.pageMapper, await this.buildOutput(t2), await this.adaptPagination(t2), t2;
      }
      async buildPageWithKind(t2) {
        const e2 = await this.newPage(this.source, this.c);
        if (await this.applyFrontMatter(e2), e2.pageMap = this.pageMapper, e2.kind_ = t2, t2 === vs("sitemap") || t2 === vs("404")) {
          const t3 = e2.meta;
          t3 && (t3.list = "never");
        }
        return await this.buildOutput(e2), e2;
      }
      async applyFrontMatter(t2) {
        if (this.fm) {
          t2.title_ = this.fm.title, t2.description_ = this.fm.description;
          const e2 = t2.meta;
          e2 && (e2.weight = this.fm.weight, e2.parameters = this.fm.params || {}, e2.date = this.fm.date, this.fm.organization !== void 0 && (e2.org = this.fm.organization), this.fm.author !== void 0 && (e2.authorInfo = this.fm.author), this.fm.menu !== void 0 && (e2.menuConfig = this.fm.menu));
        }
      }
      async buildHome() {
        const t2 = await this.buildPageWithKind(vs("home"));
        return await this.buildPagination(t2), t2;
      }
      async buildSection() {
        const t2 = await this.buildPageWithKind(vs("section"));
        return await this.buildPagination(t2), t2;
      }
      async build404() {
        const t2 = await this.buildPageWithKind(vs("404"));
        return await this.adaptPagination(t2), t2;
      }
      async buildSitemap() {
        const t2 = await this.buildPageWithKind(vs("sitemap"));
        return await this.adaptPagination(t2), t2;
      }
      async buildTaxonomy() {
        const t2 = this.taxonomy.getTaxonomy(this.source.file.paths().path()), e2 = t2 ? t2.singular() : "", r2 = await this.newTaxonomy(this.source, this.c, e2);
        return r2.pageMap = this.pageMapper, await this.buildOutput(r2), await this.buildPagination(r2), r2;
      }
      async buildTerm() {
        const t2 = this.source.file.paths(), e2 = this.taxonomy.getTaxonomy(t2.path()), r2 = e2 ? e2.singular() : "", s2 = t2.unnormalized().baseNameNoIdentifier(), n3 = await this.newTerm(this.source, this.c, r2, s2);
        return n3.pageMap = this.pageMapper, await this.buildOutput(n3), await this.buildPagination(n3), n3;
      }
      async render(t2) {
        if (this.c?.lazyRendered)
          return void (this.c.lazyRender = async () => {
            const e3 = await this.renderableDocument?.render({ maxSummaryLength: 300, wordsPerMinute: 200, shortcodeRenderer: this.createShortcodeRenderer(t2) });
            this.c?.updateWithContentResult(e3);
          });
        const e2 = await this.renderableDocument?.render({ maxSummaryLength: 300, wordsPerMinute: 200, shortcodeRenderer: this.createShortcodeRenderer(t2) });
        this.c?.updateWithContentResult(e2);
      }
      async parse(t2) {
        this.renderableDocument = await this.converter.prepareRender(t2), this.c = On(t2), this.c.toc = this.renderableDocument.toc(), this.fmParser = new qs(this.renderableDocument.frontMatter(), this.langSvc, this.taxonomySvc), await this.parseFrontMatter(), await this.parseLanguage(), await this.parseKind(), await this.parseTerms();
      }
      async parseTerms() {
        this.fm && this.fm.terms && (this.term.terms = this.fm.terms);
      }
      async parseKind() {
        const t2 = this.source.file.paths();
        let e2 = "";
        if (this.fm && (e2 = this.fm.kind || ""), e2 === "")
          switch (e2 = vs("page"), t2.baseNoLeadingSlash()) {
            case "/":
            case "":
              e2 = vs("home");
              break;
            case "404":
              e2 = vs("404");
              break;
            case Un:
              e2 = vs("sitemap");
              break;
            default:
              if (this.source.file.isBranchBundle()) {
                e2 = vs("section");
                const r2 = this.taxonomy.getTaxonomy(t2.path());
                this.taxonomy.isZero(r2) || (e2 = this.taxonomy.isTaxonomyPath(t2.path()) ? vs("taxonomy") : vs("term"));
              }
          }
        this.kind = e2;
      }
      async parseLanguageByDefault() {
        const t2 = this.langSvc.defaultLanguage(), e2 = await this.langSvc.getLanguageIndex(t2);
        this.source.identity.lang = t2, this.source.identity.langIdx = e2;
      }
      async parseLanguageByIdx(t2) {
        const e2 = this.langSvc.getLanguageByIndex(t2);
        this.source.identity.lang = e2, this.source.identity.langIdx = t2;
      }
      async parseLanguage() {
        const [t2, e2] = this.langSvc.getSourceLang(this.source.file.fileInfo().root());
        if (e2) {
          const e3 = this.langSvc.getLanguageIndex(t2);
          return this.source.identity.lang = t2, void (this.source.identity.langIdx = e3);
        }
        await this.parseLanguageByDefault();
      }
      async parseFrontMatter() {
        this.fmParser ? this.fm = await this.fmParser.parse(this.urlSvc.baseUrl()) : this.fm = Bs();
      }
      createShortcodeRenderer(t2) {
        return async (e2) => {
          if (!this.templateSvc)
            return Ni.warn(`Template service not available for shortcode: ${e2.name}`), "";
          try {
            return e2.name ? await this.doRenderShortcode(e2, null, 0, t2) : (Ni.warn("Shortcode missing name"), "");
          } catch (t3) {
            return Ni.error(`Error rendering shortcode "${e2.name}":`, t3), "";
          }
        };
      }
      async doRenderShortcode(t2, e2, r2, s2) {
        if (t2.inline)
          return Ni.warn("Inline shortcodes are not supported yet."), "";
        let n3 = new Qn(t2.params || {}, "", s2, e2, t2.name, typeof t2.params == "object" && !Array.isArray(t2.params), t2.ordinal || 0, t2.indentation || "", t2.pos || 0);
        if (t2.inner && t2.inner.length > 0) {
          let i2 = "";
          for (const e3 of t2.inner)
            if (typeof e3 == "string")
              i2 += e3;
            else {
              if (typeof e3 != "object" || !("name" in e3))
                return Ni.error(`Illegal state on shortcode rendering of "${t2.name}". Illegal type in inner data: ${typeof e3}`), "";
              i2 += await this.doRenderShortcode(e3, n3, r2 + 1, s2);
            }
          if (t2.doMarkup)
            try {
              const r3 = await this.renderShortcodeMarkdown(s2, i2);
              n3 = new Qn(t2.params || {}, r3, s2, e2, t2.name, typeof t2.params == "object" && !Array.isArray(t2.params), t2.ordinal || 0, t2.indentation || "", t2.pos || 0);
            } catch (t3) {
              throw new Error(`Failed to process inner content: ${t3}`);
            }
          else
            n3 = new Qn(t2.params || {}, i2, s2, e2, t2.name, typeof t2.params == "object" && !Array.isArray(t2.params), t2.ordinal || 0, t2.indentation || "", t2.pos || 0);
        }
        try {
          let e3 = await this.templateSvc?.execute(t2.name, n3);
          if (!t2.inner?.length && t2.indentation) {
            const r3 = e3?.split("\n");
            e3 = r3?.map((e4, r4) => r4 === 0 ? e4 : t2.indentation + e4).join("\n");
          }
          return e3 || "";
        } catch (e3) {
          if (e3 instanceof ei && e3.code === "SHORTCODE_NOT_FOUND")
            return t2.rawContent;
          throw new Error(`Failed to process shortcode: ${e3 instanceof Error ? e3.message : String(e3)}`);
        }
      }
      async renderShortcodeMarkdown(t2, e2) {
        try {
          const r2 = { document: t2, documentID: t2.path(), documentName: t2.name(), filename: t2.pageFile().filename() }, s2 = { ctx: {}, src: new TextEncoder().encode(e2), renderTOC: false, getRenderer: () => null }, n3 = await this.converter.convert(r2, s2);
          let i2 = new TextDecoder().decode(n3.bytes());
          return i2.includes("\n") || (i2 = i2.replace(/^<p>(.*)<\/p>\n$/, "$1")), i2;
        } catch (t3) {
          return Ni.error("Error rendering shortcode markdown:", t3), "";
        }
      }
      async buildPagination(t2) {
        const e2 = new zn({ pageSize: () => 10, globalRegularPages: async () => this.contentHub ? await this.contentHub.globalRegularPages() : [] }, t2);
        t2.pagerManager = e2;
      }
      async adaptPagination(t2) {
        const e2 = { current: () => new qn([], 0, 10, t2.path()).pagers()[0], setCurrent: (e3) => {
          throw new Error(`pagination not supported for this page: ${t2.path()}`);
        }, paginator: async () => {
          throw new Error(`pagination not supported for this page: ${t2.path()}`);
        }, paginate: async (e3) => {
          throw new Error(`pagination not supported for this page: ${t2.path()}`);
        } };
        t2.pagerManager = e2;
      }
      async buildOutput(t2) {
      }
      async newPage(t2, e2) {
        const r2 = new Zn(this.urlSvc.baseUrl(), "always", {}, 0, new Date()), s2 = new Xn();
        return new Kn(t2, e2, r2, s2, "", vs("page"), this.pageMapper);
      }
      async newTaxonomy(t2, e2, r2) {
        const s2 = new Zn(this.urlSvc.baseUrl(), "always", {}, 0, new Date()), n3 = new Xn();
        return new Jn(t2, e2, s2, n3, r2, r2, vs("taxonomy"), this.pageMapper);
      }
      async newTerm(t2, e2, r2, s2) {
        const n3 = new Zn(this.urlSvc.baseUrl(), "always", {}, 0, new Date()), i2 = new Xn();
        return new Yn(t2, e2, n3, i2, r2, s2, s2, vs("term"), this.pageMapper);
      }
    };
    var Di = p(require("path"));
    var Ai = p(require("path"));
    var ki = class {
      constructor(t2, e2) {
        __publicField(this, "views");
        __publicField(this, "fsSvc");
        this.views = t2, this.fsSvc = e2;
      }
      async assemble(t2, e2, r2) {
        for (const s2 of this.views) {
          const n3 = this.pluralTreeKey(s2.plural()), i2 = (t2.get(n3), yn(Ls(this.fsSvc.newFileMetaInfo(n3 + "/_index.md")))), a2 = await e2.withSource(i2).withLangIdx(r2).kindBuild();
          t2.insertIntoValuesDimension(n3, dn(a2));
        }
      }
      isTaxonomyPath(t2) {
        const e2 = this.getTaxonomy(t2);
        return !!e2 && t2 === Di.join(this.pluralTreeKey(e2.plural()), "_index.md");
      }
      pluralTreeKey(t2) {
        return function(...t3) {
          let e2 = "";
          return t3.length > 0 && (e2 = t3[0], t3.length > 1 && (e2 = Di.join(...t3))), e2 = e2.replace(/^[\.\/ \s]+|[\.\/ \s]+$/g, ""), e2 = Ai.posix.normalize(e2.toLowerCase().replace(/[^\w\-_\/]/g, "")), e2 === "" || e2 === "/" ? "" : (e2[0] !== "/" && (e2 = "/" + e2), e2);
        }(t2);
      }
      getTaxonomy(t2) {
        for (const e2 of this.views)
          if (t2.startsWith(this.pluralTreeKey(e2.plural())))
            return e2;
        return null;
      }
      isZero(t2) {
        return !t2 || t2.singular() === "";
      }
    };
    q();
    var Ii = A("content", { component: "term" });
    function Ci(t2) {
      return t2 ? Array.isArray(t2) ? t2.map((t3) => String(t3)) : typeof t2 == "string" ? [t2] : [String(t2)] : null;
    }
    function Oi(t2) {
      if (typeof t2 == "number")
        return Math.floor(t2);
      if (typeof t2 == "string") {
        const e2 = parseInt(t2, 10);
        if (isNaN(e2))
          throw new Error(`cannot convert "${t2}" to int`);
        return e2;
      }
      throw new Error(`cannot convert ${typeof t2} to int`);
    }
    var _i = class {
      constructor(t2) {
        __publicField(this, "terms");
        __publicField(this, "fsSvc");
        this.terms = {}, this.fsSvc = t2;
      }
      async assemble(t2, e2, r2, s2) {
        const n3 = new on({ tree: t2, lockType: 2, handle: async (n4, i2, a2) => {
          const [o2, h2] = i2.getPage();
          if (!h2)
            return [false, null];
          for (const i3 of r2.taxonomy.views) {
            const a3 = Ci(zs(o2.params(), i3.plural(), false));
            if (!a3)
              continue;
            const h3 = Ws(o2.params(), i3.plural() + "_weight");
            let c2 = 0;
            if (h3 == null || h3 === "")
              c2 = 0;
            else
              try {
                c2 = Oi(h3);
              } catch (t3) {
                Ii.warn(`Unable to convert taxonomy weight ${h3} to int for "${o2.paths().path()}"`);
              }
            for (let h4 = 0; h4 < a3.length; h4++) {
              const u2 = a3[h4];
              if (u2 === "")
                continue;
              const l2 = "/" + i3.plural() + "/" + u2;
              try {
                const a4 = Ls(this.fsSvc.newFileMetaInfo(l2 + "/_index.md")), f2 = a4.paths(), w2 = yn(a4), d2 = await r2.withSource(w2).withLangIdx(s2).kindBuild();
                t2.insertIntoValuesDimension(f2.base(), dn(d2));
                const g2 = t2.get(f2.base());
                if (g2) {
                  const [t3, e3] = g2.getPage();
                  if (!e3)
                    return [false, null];
                  const r3 = t3;
                  r3.term = u2, r3.singular = i3.singular();
                }
                let p2 = n4;
                p2 === "" && (p2 = "/");
                const m2 = f2.base() + p2, [y2, b2] = g2.getPage();
                if (!b2)
                  return [false, null];
                e2.insert(m2, new ln(dn(o2), { page: y2, ordinal: h4, weight: c2, Weight: () => c2, Ordinal: () => h4 }));
              } catch (t3) {
                return [false, t3];
              }
            }
          }
          return [false, null];
        } });
        try {
          return await n3.walk(), null;
        } catch (t3) {
          return t3;
        }
      }
    };
    var Mi = p(require("path"));
    q(), q(), A("site", { component: "pager" });
    var Ui = class t2 {
      constructor(t3, e2) {
        __publicField(this, "page");
        __publicField(this, "pager");
        this.page = t3, this.pager = e2;
      }
      pageNumber() {
        return this.pager.pageNumber();
      }
      totalPages() {
        return this.pager.totalPages();
      }
      url() {
        return this.pager.url();
      }
      pages() {
        return this.pager.pages();
      }
      allPages() {
        return this.pager.allPages();
      }
      pagers() {
        return this.pager.pagers();
      }
      first() {
        return this.pager.first();
      }
      last() {
        return this.pager.last();
      }
      hasPrev() {
        return this.pager.hasPrev();
      }
      prev() {
        return this.pager.prev();
      }
      hasNext() {
        return this.pager.hasNext();
      }
      next() {
        return this.pager.next();
      }
      get PageNumber() {
        return this.pageNumber();
      }
      get TotalPages() {
        return this.totalPages();
      }
      get URL() {
        let t3 = this.url();
        return t3.startsWith("/") && (t3 = t3.slice(1)), this.page.Site.getURL().relURL(t3);
      }
      get HasPrev() {
        return this.hasPrev();
      }
      get HasNext() {
        return this.hasNext();
      }
      get First() {
        const e2 = this.first();
        return e2 ? new t2(this.page, e2) : null;
      }
      get Last() {
        const e2 = this.last();
        return e2 ? new t2(this.page, e2) : null;
      }
      get Prev() {
        const e2 = this.prev();
        return e2 ? new t2(this.page, e2) : null;
      }
      get Next() {
        const e2 = this.next();
        return e2 ? new t2(this.page, e2) : null;
      }
      get Pagers() {
        return this.pagers().map((e2) => new t2(this.page, e2));
      }
      get Pages() {
        const t3 = this.pages();
        return this.page.sitePages(t3);
      }
      get AllPages() {
        const t3 = this.pager.allPages();
        return this.page.sitePages(t3);
      }
    };
    var ji = A("site", { component: "page" });
    var Bi = class t2 {
      constructor(t3, e2, r2, s2, n3) {
        __publicField(this, "tmplSvc");
        __publicField(this, "langSvc");
        __publicField(this, "publisher");
        __publicField(this, "contentPage");
        __publicField(this, "pageOutput", null);
        __publicField(this, "site");
        __publicField(this, "resources", []);
        __publicField(this, "B", null);
        this.tmplSvc = t3, this.langSvc = e2, this.publisher = r2, this.contentPage = s2, this.site = n3;
      }
      async processResources(t3) {
        this.resources = t3;
      }
      async render() {
        try {
          await this.renderResources(), await this.renderPage();
        } catch (t3) {
          ji.error(`Failed to render page ${this.paths().path()}: ${t3}`);
        }
      }
      getPageOutput() {
        return this.pageOutput || (this.pageOutput = this.output()), this.pageOutput;
      }
      async renderPage() {
        const t3 = this.layouts(), { preparer: e2, found: r2 } = await this.tmplSvc.lookupLayout(t3);
        if (!r2)
          return void ji.warn(`Failed to find layout: ${t3.join(",")} for page ${this.paths().path()}`);
        const s2 = [];
        let n3 = this.getPageOutput().targetPrefix();
        n3 = this.site.getLanguage().getCurrentLanguage() === n3 && n3 === this.langSvc.defaultLanguage() ? "" : this.site.getLanguage().getCurrentLanguage(), s2.push(Mi.default.join(n3, this.getPageOutput().targetFilePath())), await this.renderAndWritePage(e2, s2);
        const i2 = await this.current();
        if (i2) {
          let t4 = i2.next();
          for (; t4; ) {
            this.setCurrent(t4);
            const r3 = [Mi.default.join(n3, t4.url(), this.getPageOutput().targetFileBase())];
            await this.renderAndWritePage(e2, r3), t4 = t4.next();
          }
        }
      }
      async renderAndWritePage(t3, e2) {
        try {
          const r2 = await this.tmplSvc.executeWithContext(t3, this);
          await this.publisher.publishSource(r2, ...e2);
        } catch (t4) {
          throw this.errorf(t4, "failed to publish page");
        }
      }
      async renderResources() {
        for (const t3 of this.resources) {
          const e2 = [];
          let r2 = this.getPageOutput().targetPrefix();
          r2 = this.site.getLanguage().getCurrentLanguage() === r2 && r2 === this.langSvc.defaultLanguage() ? "" : this.site.getLanguage().getCurrentLanguage();
          let s2 = t3.path();
          e2.push(Mi.default.join(r2, s2));
          let n3 = null;
          try {
            const r3 = () => t3.pageFile().open();
            if (n3 = await r3(), !n3)
              throw new Error("Failed to open resource stream");
            let s3;
            s3 = typeof n3.read == "function" ? new ReadableStream({ async start(t4) {
              try {
                const e3 = new Uint8Array(8192);
                for (; ; ) {
                  const r4 = await n3.read(e3);
                  if (r4.bytesRead === 0)
                    break;
                  t4.enqueue(e3.slice(0, r4.bytesRead));
                }
                t4.close();
              } catch (e3) {
                t4.error(e3);
              }
            } }) : new ReadableStream({ start(t4) {
              t4.close();
            } }), await this.publisher.publishFiles(s3, ...e2);
          } catch (t4) {
            throw this.errorf(t4, "failed to publish page resources");
          } finally {
            if (n3)
              try {
                await n3.close();
              } catch (t4) {
                ji.warn(`Failed to close resource stream: ${t4}`);
              }
          }
        }
      }
      errorf(t3, e2, ...r2) {
        const s2 = [this.pageIdentity().pageLanguage(), this.paths().path(), ...r2], n3 = `[%s] page "%s": ${e2}: %s`, i2 = this.sprintf(n3, ...s2, t3.message || t3);
        return new Error(i2);
      }
      sprintf(t3, ...e2) {
        let r2 = 0;
        return t3.replace(/%s/g, () => e2[r2++] || "");
      }
      clone() {
        const e2 = new t2(this.tmplSvc, this.langSvc, this.publisher, this.contentPage, this.site);
        return e2.resources = [...this.resources], e2.pageOutput = this.pageOutput, e2;
      }
      pageIdentity() {
        return this.contentPage.pageIdentity();
      }
      pageFile() {
        return this.contentPage.pageFile();
      }
      staleVersions() {
        return this.contentPage.staleVersions();
      }
      section() {
        return this.contentPage.section();
      }
      paths() {
        return this.contentPage.paths();
      }
      path() {
        return this.contentPage.path();
      }
      file() {
        return this.contentPage.file();
      }
      name() {
        return this.contentPage.name();
      }
      title() {
        return this.contentPage.title();
      }
      kind() {
        return this.contentPage.kind();
      }
      scratch() {
        return this.contentPage.scratch();
      }
      get Scratch() {
        return this.contentPage.scratch();
      }
      IsAncestor(t3) {
        return this.contentPage.isAncestor(t3.contentPage);
      }
      get Title() {
        return this.title();
      }
      get Section() {
        return this.contentPage.section();
      }
      get LinkTitle() {
        return this.title();
      }
      get IsSection() {
        return this.contentPage.isSection();
      }
      get IsPage() {
        return this.contentPage.isPage();
      }
      get Content() {
        return this.getPageOutput().content();
      }
      async Summary() {
        return this.contentPage.output().summary();
      }
      async ReadingTime() {
        return await this.getPageOutput().readingTime();
      }
      async WordCount() {
        return await this.getPageOutput().wordCount();
      }
      get Description() {
        return this.description();
      }
      get Date() {
        return this.pageDate();
      }
      get LocalDate() {
        return this.pageDate().toLocaleDateString();
      }
      get RelPermalink() {
        let t3;
        if (this.pageIdentity().pageLanguage() === this.langSvc.defaultLanguage())
          t3 = this.getPageOutput().targetFilePath();
        else {
          const e2 = this.getPageOutput().targetPrefix(), r2 = this.getPageOutput().targetFilePath();
          t3 = this.pathJoin(e2, r2);
        }
        return t3.startsWith("/") && (t3 = t3.slice(1)), this.site.getURL().relURL(t3);
      }
      get GitInfo() {
        return {};
      }
      get File() {
        return { BaseFileName: this.contentPage.file().baseFileName(), Dir: this.contentPage.file().dir() };
      }
      isHome() {
        return this.contentPage.isHome();
      }
      get IsHome() {
        return this.isHome();
      }
      isPage() {
        return this.contentPage.isPage();
      }
      isSection() {
        return this.contentPage.isSection();
      }
      isAncestor(t3) {
        return this.contentPage.isAncestor(t3);
      }
      eq(t3) {
        return this.contentPage.eq(t3);
      }
      isBundled() {
        return this.contentPage.isBundled();
      }
      layouts() {
        return this.contentPage.layouts();
      }
      output() {
        return this.contentPage.output();
      }
      pageOutputs() {
        return [this.contentPage.output()];
      }
      truncated() {
        return this.contentPage.truncated();
      }
      get Truncated() {
        return this.contentPage.truncated();
      }
      parent() {
        return this.contentPage.parent();
      }
      pages() {
        return this.contentPage.pages();
      }
      isStale() {
        return this.contentPage.pageIdentity().isStale();
      }
      clearStale() {
        this.contentPage.pageIdentity().clearStale();
      }
      prevInSection() {
        return this.contentPage.prevInSection();
      }
      nextInSection() {
        return this.contentPage.nextInSection();
      }
      sections(t3) {
        return this.contentPage.sections(t3);
      }
      regularPages() {
        return this.contentPage.regularPages();
      }
      regularPagesRecursive() {
        return this.contentPage.regularPagesRecursive();
      }
      terms(t3, e2) {
        return this.contentPage.terms(t3, e2);
      }
      isTranslated() {
        return this.contentPage.isTranslated();
      }
      translations() {
        return this.contentPage.translations();
      }
      rawContent() {
        return this.contentPage.rawContent();
      }
      description() {
        return this.contentPage.description ? this.contentPage.description() : "";
      }
      params() {
        return this.contentPage.params ? this.contentPage.params() : {};
      }
      pageBaseUrl() {
        return this.contentPage.pageBaseUrl() ? this.contentPage.pageBaseUrl() : "";
      }
      pageWeight() {
        return this.contentPage.pageWeight ? this.contentPage.pageWeight() : 0;
      }
      pageDate() {
        return this.contentPage.pageDate ? this.contentPage.pageDate() : new Date();
      }
      publishDate() {
        return this.contentPage.publishDate ? this.contentPage.publishDate() : new Date();
      }
      get PublishDate() {
        return this.publishDate();
      }
      async relatedKeywords(t3) {
        return this.contentPage.relatedKeywords ? await this.contentPage.relatedKeywords(t3) : [];
      }
      shouldList(t3) {
        return !this.contentPage.shouldList || this.contentPage.shouldList(t3);
      }
      shouldListAny() {
        return !this.contentPage.shouldListAny || this.contentPage.shouldListAny();
      }
      noLink() {
        return !!this.contentPage.noLink && this.contentPage.noLink();
      }
      organization() {
        return this.contentPage.organization ? this.contentPage.organization() : void 0;
      }
      author() {
        return this.contentPage.author ? this.contentPage.author() : void 0;
      }
      menu() {
        return this.contentPage.menu ? this.contentPage.menu() : void 0;
      }
      current() {
        return this.contentPage.current();
      }
      setCurrent(t3) {
        this.contentPage.setCurrent(t3);
      }
      posOffset(t3) {
        return this.contentPage.posOffset(t3);
      }
      paginator() {
        return this.contentPage.paginator();
      }
      async paginate(t3) {
        return this.contentPage.paginate(t3);
      }
      get Plain() {
        return this.rawContent();
      }
      get TableOfContents() {
        return this.getPageOutput().tableOfContents();
      }
      get Params() {
        return this.params();
      }
      get Site() {
        return this.site;
      }
      get Sites() {
        return { First: this.site, Default: this.site };
      }
      get Lastmod() {
        return this.contentPage.pageDate ? this.contentPage.pageDate() : null;
      }
      get Sitemap() {
        return { ChangeFreq: "weekly", Priority: 0.5, Filename: "sitemap.xml" };
      }
      get IsTranslated() {
        return this.isTranslated();
      }
      async Paginator() {
        return this.B || await this.setupCurrentPaginator(), this.B;
      }
      async Paginate(t3) {
        try {
          const e2 = t3.map((t4) => t4.contentPage), r2 = await this.contentPage.paginate(e2);
          return r2 && (this.B = new Ui(this, r2)), this.B;
        } catch (t4) {
          return ji.error("Error during pagination:", t4), null;
        }
      }
      async setupCurrentPaginator() {
        try {
          const t3 = await this.contentPage.paginator();
          this.B = t3 ? new Ui(this, t3) : null;
        } catch (t3) {
          ji.error("Error initializing Paginator:", t3), this.B = null;
        }
      }
      get Language() {
        return { Lang: this.pageIdentity().pageLanguage(), LanguageName: this.langSvc.getLanguageName(this.pageIdentity().pageLanguage()), Title: this.title(), Weight: this.pageWeight() };
      }
      get Permalink() {
        return this.RelPermalink;
      }
      sitePages(t3) {
        const e2 = [];
        for (const r2 of t3) {
          const t4 = this.sitePage(r2);
          t4 && e2.push(t4);
        }
        return e2;
      }
      sitePage(e2) {
        try {
          return e2 === null ? (ji.warn(`Invalid content page provided: ${e2}`), null) : new t2(this.tmplSvc, this.langSvc, this.publisher, e2, this.site);
        } catch (t3) {
          return ji.error(`Error creating site page: ${t3}`), null;
        }
      }
      pathJoin(...t3) {
        return t3.filter((t4) => t4 && t4.length > 0).map((t4) => t4.replace(/^\/+|\/+$/g, "")).filter((t4) => t4.length > 0).join("/");
      }
      joinURL(t3, e2) {
        return t3 ? e2 ? (t3.endsWith("/") && (t3 = t3.slice(0, -1)), e2.startsWith("/") || (e2 = "/" + e2), t3 + e2) : t3 : e2;
      }
      async Translations() {
        const t3 = await this.translations();
        return Array.isArray(t3) ? t3.map((t4) => this.sitePage(t4)).filter((t4) => t4 !== null) : [];
      }
      async GetTerms(t3) {
        const e2 = await this.terms(this.site.getLanguage().currentLanguageIndex(), t3);
        return Array.isArray(e2) ? e2.map((t4) => this.sitePage(t4)).filter((t4) => t4 !== null) : [];
      }
      async Pages() {
        return await this.getSitePages();
      }
      get Page() {
        return this.contentPage;
      }
      get Kind() {
        return this.kind();
      }
      get Type() {
        if (this.kind() === "home")
          return "page";
        if (this.kind() === "page") {
          const t3 = this.section();
          if (t3 && t3.length > 0)
            return t3;
        }
        return "page";
      }
      get Parent() {
        return this.sitePage(this.contentPage.parent());
      }
      async getSitePages() {
        const t3 = await this.contentPage.pages();
        return !t3 || Array.isArray(t3) && t3.length === 0 ? [] : this.sitePages(t3);
      }
    };
    q(), z(), q(), A("site", { component: "menu" });
    var qi = class t2 {
      constructor(t3) {
        __publicField(this, "q");
        __publicField(this, "W");
        __publicField(this, "H");
        __publicField(this, "G");
        __publicField(this, "V");
        this.q = t3.title, this.W = t3.url, this.H = t3.children || [], this.G = t3.weight || 0, this.V = t3.identifier || this.W;
      }
      title() {
        return this.q;
      }
      get Title() {
        return this.title();
      }
      url() {
        return this.W;
      }
      get URL() {
        return this.url();
      }
      children() {
        return [...this.H];
      }
      get Children() {
        return this.children();
      }
      weight() {
        return this.G;
      }
      identifier() {
        return this.V;
      }
      hasChildren() {
        return this.H.length > 0;
      }
      get HasChildren() {
        return this.hasChildren();
      }
      addChild(e2) {
        const r2 = [...this.H, e2];
        return new t2({ title: this.q, url: this.W, children: r2, weight: this.G, identifier: this.V });
      }
      toJSON() {
        return { title: this.q, url: this.W, weight: this.G, children: this.H.map((t3) => t3.toJSON()) };
      }
      withChildren(e2) {
        return new t2({ title: this.q, url: this.W, children: e2, weight: this.G, identifier: this.V });
      }
    };
    var Wi = class {
      constructor(t2 = {}) {
        __publicField(this, "K");
        __publicField(this, "J");
        this.K = t2.nav ? this.sortMenus([...t2.nav]) : [], this.J = t2.footer ? this.sortMenus([...t2.footer]) : [];
      }
      nav() {
        return [...this.K];
      }
      get Nav() {
        return this.nav();
      }
      footer() {
        return [...this.J];
      }
      get Footer() {
        return this.footer();
      }
      sortMenus(t2) {
        return t2.sort((t3, e2) => {
          if (t3.weight() !== e2.weight())
            return e2.weight() === 0 ? -1 : t3.weight() === 0 ? 1 : t3.weight() - e2.weight();
          const r2 = t3.title().localeCompare(e2.title());
          return r2 !== 0 ? r2 : t3.identifier().localeCompare(e2.identifier());
        });
      }
      toJSON() {
        return { nav: this.K.map((t2) => t2.toJSON()), footer: this.J.map((t2) => t2.toJSON()) };
      }
    };
    function zi() {
      return new Wi({});
    }
    var Hi = A("site", { component: "site" });
    var Gi = class {
      constructor(t2, e2, r2, s2, n3, i2, a2, o2, h2, c2, u2, l2, f2, w2, d2) {
        __publicField(this, "configSvc");
        __publicField(this, "contentSvc");
        __publicField(this, "translationSvc");
        __publicField(this, "languageSvc");
        __publicField(this, "sitemap");
        __publicField(this, "staticCopySvc");
        __publicField(this, "publisher");
        __publicField(this, "template", null);
        __publicField(this, "author");
        __publicField(this, "organization");
        __publicField(this, "compiler");
        __publicField(this, "url");
        __publicField(this, "ref", null);
        __publicField(this, "language");
        __publicField(this, "navigation", null);
        __publicField(this, "title");
        __publicField(this, "home", null);
        this.configSvc = t2, this.contentSvc = e2, this.translationSvc = r2, this.languageSvc = s2, this.sitemap = n3, this.staticCopySvc = i2, this.publisher = a2, this.author = o2, this.organization = h2, this.compiler = c2, this.url = u2, this.ref = l2, this.language = f2, this.navigation = w2, this.title = d2;
      }
      get Title() {
        return this.title;
      }
      get Description() {
        return this.home?.description() || "";
      }
      get Compiler() {
        return this.compiler;
      }
      get IsGoogleAnalyticsEnabled() {
        return this.configSvc.isGoogleAnalyticsEnabled();
      }
      get GoogleAnalyticsID() {
        return this.configSvc.googleAnalyticsID();
      }
      get IsGoogleAnalyticsRespectDoNotTrack() {
        return this.configSvc.isGoogleAnalyticsRespectDoNotTrack();
      }
      get IsDisqusEnabled() {
        return this.configSvc.isDisqusEnabled();
      }
      get DisqusShortname() {
        return this.configSvc.disqusShortname();
      }
      get IsXRespectDoNotTrack() {
        return this.configSvc.isXRespectDoNotTrack();
      }
      get IsXDisableInlineCSS() {
        return this.configSvc.isXDisableInlineCSS();
      }
      get ConfiguredSocialPlatforms() {
        return this.configSvc.getConfiguredSocialPlatforms();
      }
      GetSocialLink(t2) {
        return this.configSvc.getSocialLink(t2);
      }
      GetSocialTitle(t2) {
        return this.configSvc.getSocialTitle(t2);
      }
      async Pages() {
        const t2 = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage()), e2 = await this.contentSvc.globalPages(t2);
        return this.sitePages(e2);
      }
      async RegularPages() {
        const t2 = await this.contentSvc.globalRegularPages();
        return this.sitePages(t2);
      }
      async build(t2) {
        try {
          this.template = t2, await this.setup(), await this.copyStaticFiles();
          const e2 = this.languageSvc.languageKeys();
          for (const t3 of e2)
            this.language.setCurrentLanguage(t3), await this.generateNavigations(), await this.render();
        } catch (t3) {
          const e2 = t3 instanceof Error ? t3.message : String(t3);
          throw Hi.error(`\u274C Site build failed: ${e2}`), t3;
        }
      }
      async buildWithProgress(t2, e2) {
        try {
          this.template = t2, await this.setup(), await this.copyStaticFiles();
          const r2 = this.languageSvc.languageKeys();
          for (const t3 of r2)
            this.language.setCurrentLanguage(t3), await this.generateNavigations(), await this.renderWithProgress(e2);
        } catch (t3) {
          const e3 = t3 instanceof Error ? t3.message : String(t3);
          throw Hi.error(`\u274C Site build failed: ${e3}`), t3;
        }
      }
      async setup() {
      }
      async renderAllLanguages() {
        const t2 = this.languageSvc.languageKeys();
        for (const e2 of t2)
          this.language.setCurrentLanguage(e2), await this.render();
      }
      async render() {
        try {
          await this.renderPages();
        } catch (t2) {
          throw t2;
        }
      }
      async renderWithProgress(t2) {
        try {
          await this.renderPagesWithProgress(t2);
        } catch (t3) {
          throw t3;
        }
      }
      async renderPages() {
        const t2 = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage()), e2 = [];
        await this.contentSvc.walkPages(t2, async (t3) => {
          const r2 = await this.sitePage(t3);
          e2.push(r2);
          const s2 = await this.contentSvc.getPageSources(t3);
          await r2.processResources(s2), t3.isHome() && (this.home = r2);
        });
        for (let t3 = 0; t3 < e2.length; t3++) {
          const r2 = e2[t3];
          r2.isStale() && (await r2.render(), r2.clearStale());
        }
      }
      async renderPagesWithProgress(t2) {
        const e2 = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage()), r2 = [];
        await this.contentSvc.walkPages(e2, async (t3) => {
          const e3 = await this.sitePage(t3);
          r2.push(e3);
          const s3 = await this.contentSvc.getPageSources(t3);
          await e3.processResources(s3), t3.isHome() && (this.home = e3);
        });
        const s2 = r2.length;
        for (let e3 = 0; e3 < r2.length; e3++) {
          const n3 = r2[e3];
          await n3.render(), t2?.({ currentPage: e3 + 1, totalPages: s2 });
        }
      }
      async pageOutput(t2) {
        return t2.output();
      }
      clearSiteCache() {
      }
      translate(t2) {
        return this.translationSvc.translate(this.language.getCurrentLanguage(), t2);
      }
      get Home() {
        return this.home;
      }
      get Params() {
        return this.configSvc.configParams();
      }
      get Taxonomies() {
        return this.navigation && this.navigation.getTaxonomies(this.language.getCurrentLanguage()) || new U();
      }
      get Menus() {
        return this.navigation ? this.navigation.getMenus(this.language.getCurrentLanguage()) : new Wi();
      }
      getTitle() {
        return this.title;
      }
      setTitle(t2) {
        this.title = t2;
      }
      getConfigService() {
        return this.configSvc;
      }
      getContentService() {
        return this.contentSvc;
      }
      getLanguageService() {
        return this.languageSvc;
      }
      baseURL() {
        return this.url.base;
      }
      get BaseURL() {
        return this.baseURL();
      }
      getURL() {
        return this.url;
      }
      getRef() {
        return this.ref ? this.ref : {};
      }
      getLanguage() {
        return this.language;
      }
      get Language() {
        return this.getLanguage();
      }
      get LanguageCode() {
        return this.language.lang();
      }
      get Languages() {
        return this.language.languages();
      }
      getNavigation() {
        return this.navigation ? this.navigation : {};
      }
      getPublisher() {
        return this.publisher;
      }
      getTemplate() {
        return this.template;
      }
      get Author() {
        return this.author.author(this.home?.author());
      }
      get Organization() {
        return this.organization.organization(this.home?.organization());
      }
      getCompiler() {
        return this.compiler;
      }
      getSitemap() {
        return this.sitemap;
      }
      isMultipleLanguage() {
        return this.language.isMultipleLanguage();
      }
      get IsMultilingual() {
        return this.isMultipleLanguage();
      }
      getCurrentLanguage() {
        return this.language.lang();
      }
      languagePrefix() {
        return this.language.languagePrefix();
      }
      async sitePage(t2) {
        return new Bi(this.template, this.languageSvc, this.publisher, t2, this);
      }
      sitePages(t2) {
        const e2 = [];
        for (let r2 = 0; r2 < t2.length; r2++) {
          const s2 = t2[r2];
          try {
            const t3 = this.sitePageSync(s2);
            e2.push(t3);
          } catch (t3) {
            Hi.error(`\u274C [Site.sitePages] Failed to convert page ${r2}:`, t3);
          }
        }
        return e2;
      }
      sitePageSync(t2) {
        return new Bi(this.template, this.languageSvc, this.publisher, t2, this);
      }
      async generateNavigations() {
        const t2 = this.language.getCurrentLanguage(), e2 = this.languageSvc.getLanguageIndex(t2);
        this.navigation && (await this.navigation.generateMenusForLanguage(t2, e2), await this.navigation.generateTaxonomiesForLanguage(t2, e2, this));
      }
      GetPage(...t2) {
        if (t2.length > 1)
          throw new Error(`too many arguments to .Site.GetPage: ${t2}. Use lookups on the form {{ .Site.GetPage "/posts/mypage-md" }}`);
        let e2 = t2[0];
        e2 = e2.replace(/\\/g, "/"), e2.startsWith("/") || (e2 = "/" + e2);
        try {
          const t3 = this.languageSvc.getLanguageIndex(this.language.getCurrentLanguage()), r2 = this.contentSvc.getPageFromPathSync(t3, e2);
          return r2 ? this.sitePageSync(r2) : (Hi.warn(`\u26A0\uFE0F  GetPage: No page found for key "${e2}"`), null);
        } catch (t3) {
          return Hi.error(`\u274C Error getting page "${e2}": ${t3}`), null;
        }
      }
      async copyStaticFiles() {
        try {
          await this.staticCopySvc.copyStaticFiles(this.staticCopySvc.staticFs(), this.staticCopySvc.publishFs());
        } catch (t2) {
          throw Hi.error("\u274C Static file copy failed:", t2), t2;
        }
      }
      async siteWeightedPage(t2) {
        const e2 = await this.sitePage(t2.page()), { WeightedPage: r2 } = await Promise.resolve().then(() => (z(), W));
        return new r2(e2, t2);
      }
    };
    var Vi = p(require("path"));
    q(), A("site", { component: "publisher" });
    var Ki = class {
      constructor(t2) {
        __publicField(this, "fs");
        this.fs = t2;
      }
      async publishSource(t2, ...e2) {
        const r2 = await this.openFilesForWriting(...e2);
        try {
          const e3 = typeof t2 == "string" ? new TextEncoder().encode(t2) : t2;
          await this.copyToWriter(r2, e3);
        } finally {
          await r2.close();
        }
      }
      async publishFiles(t2, ...e2) {
        const r2 = await this.openFilesForWriting(...e2);
        try {
          await this.copyStreamToWriter(r2, t2);
        } finally {
          await r2.close();
        }
      }
      async openFilesForWriting(...t2) {
        const e2 = [];
        for (const r2 of t2) {
          const t3 = await Yi(this.fs, r2);
          e2.push(t3);
        }
        return new Ji(e2);
      }
      async copyToWriter(t2, e2) {
        await t2.write(e2);
      }
      async copyStreamToWriter(t2, e2) {
        const r2 = e2.getReader();
        try {
          for (; ; ) {
            const { done: e3, value: s2 } = await r2.read();
            if (e3)
              break;
            await t2.write(s2);
          }
        } finally {
          r2.releaseLock();
        }
      }
    };
    var Ji = class {
      constructor(t2) {
        __publicField(this, "files");
        this.files = t2;
      }
      async write(t2) {
        const e2 = this.files.map((e3) => e3.write(t2));
        await Promise.all(e2);
      }
      async close() {
        const t2 = this.files.map((t3) => t3.close());
        await Promise.all(t2);
      }
    };
    async function Yi(t2, e2) {
      const r2 = Vi.default.normalize(e2);
      try {
        return await t2.create(r2);
      } catch (e3) {
        if (!function(t3) {
          return t3 && (t3.code === "ENOENT" || t3.code === "FILE_NOT_FOUND" || t3.message?.includes("not found") || t3.message?.includes("no such file"));
        }(e3))
          throw e3;
        const s2 = Vi.default.dirname(r2);
        return await t2.mkdirAll(s2, 511), await t2.create(r2);
      }
    }
    var Zi = class t2 {
      constructor(t3, e2 = false) {
        __publicField(this, "url");
        __publicField(this, "withPath");
        __publicField(this, "withPathNoTrailingSlash");
        __publicField(this, "withoutPath");
        __publicField(this, "basePath");
        __publicField(this, "basePathNoTrailingSlash");
        __publicField(this, "isRelative");
        if (this.url = t3, this.isRelative = e2, this.withPath = t3.toString(), this.withPathNoTrailingSlash = this.withPath.replace(/\/$/, ""), e2)
          this.withoutPath = "/";
        else {
          const e3 = new URL(t3.toString());
          e3.pathname = "", this.withoutPath = e3.toString().replace(/\/$/, "");
        }
        this.basePath = t3.pathname, this.basePathNoTrailingSlash = this.basePath.replace(/\/$/, "");
      }
      static fromString(e2) {
        try {
          e2 && e2 !== "/" || (e2 = "/");
          const r2 = e2.trim();
          if (r2.startsWith("/") && !r2.startsWith("//")) {
            const e3 = new URL(r2, "http://localhost");
            return e3.pathname.endsWith("/") || (e3.pathname += "/"), new t2(e3, true);
          }
          if (r2.startsWith("//")) {
            const e3 = new URL("https:" + r2);
            return e3.pathname.endsWith("/") || (e3.pathname += "/"), new t2(e3);
          }
          if (r2.includes("://")) {
            const e3 = new URL(r2);
            if (!["http:", "https:"].includes(e3.protocol))
              throw new Error(`Unsupported protocol: ${e3.protocol}. Only http and https are supported.`);
            return e3.pathname.endsWith("/") || (e3.pathname += "/"), new t2(e3);
          }
          if (r2.includes(":") && !r2.includes("/")) {
            const t3 = r2.indexOf(":"), e3 = r2.substring(0, t3 + 1);
            throw new Error(`Unsupported protocol: ${e3}. Only http and https are supported.`);
          }
          const s2 = new URL("https://" + r2);
          return s2.pathname.endsWith("/") || (s2.pathname += "/"), new t2(s2);
        } catch (t3) {
          throw new Error(`Invalid URL: ${t3?.message || "Unknown error"}`);
        }
      }
      getRoot(t3) {
        return this.isRelative ? this.basePath : t3.startsWith("/") ? this.withoutPath : this.withPath;
      }
      toString() {
        return this.isRelative ? this.basePath : this.withPath;
      }
      path() {
        return this.url.pathname;
      }
      port() {
        return this.url.port ? parseInt(this.url.port) : 0;
      }
      hostURL() {
        return this.isRelative ? "/" : this.toString().replace(this.path(), "");
      }
      protocol() {
        return this.url.protocol;
      }
      host() {
        return this.url.host;
      }
      hostname() {
        return this.url.hostname;
      }
      getURL() {
        return new URL(this.url.toString());
      }
      withProtocol(e2) {
        if (this.isRelative)
          throw new Error("Cannot change protocol of relative URL");
        const r2 = this.getURL();
        let s2 = e2;
        const n3 = s2.endsWith("://"), i2 = s2.endsWith(":");
        if (n3 ? s2 = s2.slice(0, -3) : i2 && (s2 = s2.slice(0, -1)), i2 && !r2.pathname)
          throw new Error(`cannot determine BaseURL for protocol ${e2}`);
        return r2.protocol = s2, t2.fromString(r2.toString());
      }
      withPort(e2) {
        if (this.isRelative)
          throw new Error("Cannot set port on relative URL");
        const r2 = this.getURL();
        return r2.port = e2.toString(), t2.fromString(r2.toString());
      }
      isRelativeURL() {
        return this.isRelative;
      }
      isAbsoluteURL() {
        return !this.isRelative;
      }
    };
    var Xi = class t2 {
      constructor(t3, e2 = false) {
        __publicField(this, "base");
        __publicField(this, "canonical");
        __publicField(this, "baseURL", null);
        this.base = t3, this.canonical = e2, this.setup();
      }
      setup() {
        try {
          this.baseURL = Zi.fromString(this.base);
        } catch (t3) {
          throw new Error(t3?.message || "Failed to setup URL");
        }
      }
      isAbsURL(t3) {
        return t3.startsWith("http://") || t3.startsWith("https://") ? [true, null] : [/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(t3), null];
      }
      startWithBaseUrlRoot(t3) {
        return !!this.baseURL && t3.startsWith(this.baseURL.getRoot(t3));
      }
      isProtocolRelPath(t3) {
        return t3.startsWith("//");
      }
      trimBaseUrlRoot(t3) {
        if (!this.baseURL)
          return t3;
        const e2 = this.baseURL.getRoot(t3);
        return t3.endsWith(e2) ? t3.slice(0, -e2.length) : t3;
      }
      addContextRoot(t3) {
        if (!this.baseURL)
          return t3;
        let e2 = t3;
        return this.canonical || (s2 = t3, e2 = !(r2 = this.baseURL.getRoot(t3)) || s2.startsWith(r2) ? s2 : function(...t4) {
          return t4.filter(Boolean).join("/").replace(/\/+/g, "/").replace(/\/$/, "");
        }(r2, s2)), e2;
        var r2, s2;
      }
      handleRootSuffix(t3, e2) {
        return this.baseURL ? (t3 === "" && this.baseURL.getRoot(t3).endsWith("/") && (e2 += "/"), e2) : e2;
      }
      handlePrefix(t3) {
        return t3.startsWith("/") || (t3 = "/" + t3), t3;
      }
      relURL(t3) {
        if (!t3)
          return this.baseURL ? this.baseURL.basePath : "";
        const [e2, r2] = this.isAbsURL(t3);
        if (r2)
          return t3;
        if (e2 || this.isProtocolRelPath(t3))
          return t3;
        if (!this.baseURL)
          return t3;
        let s2 = t3;
        if (t3.startsWith("/"))
          return this.baseURL.isRelativeURL() ? t3 : this.baseURL.withoutPath + t3;
        if (s2 = this.baseURL.isRelativeURL() ? (this.baseURL.basePath.endsWith("/") ? this.baseURL.basePath : this.baseURL.basePath + "/") + t3 : (this.baseURL.withPath.endsWith("/") ? this.baseURL.withPath : this.baseURL.withPath + "/") + t3, s2.includes("://")) {
          const t4 = s2.indexOf("://"), e3 = s2.substring(0, t4 + 3), r3 = s2.substring(t4 + 3);
          s2 = e3 + r3.replace(/\/+/g, "/");
        } else
          s2 = s2.replace(/\/+/g, "/");
        return s2;
      }
      absURL(t3, e2 = false, r2 = "") {
        const [s2, n3] = this.isAbsURL(t3);
        if (n3)
          return t3;
        if (s2 || this.isProtocolRelPath(t3))
          return t3;
        if (!this.baseURL)
          return t3;
        const i2 = this.baseURL.getRoot(t3);
        if (e2 && r2) {
          let e3 = false, s3 = t3;
          if (t3.startsWith("/") && (s3 = t3.slice(1)), e3 = s3 === r2 || s3.startsWith(r2 + "/"), !e3) {
            const e4 = t3 === "" || t3.endsWith("/");
            t3 = this.joinPaths(r2, t3), e4 && (t3 += "/");
          }
        }
        return function(t4, e3) {
          const r3 = `${t4.replace(/\/$/, "")}/${e3.replace(/^\//, "")}`;
          try {
            return new URL(r3);
          } catch {
            return new URL("http://" + r3);
          }
        }(i2, t3).toString();
      }
      urlize(t3) {
        return this.urlEscape(this.makePathSanitized(t3));
      }
      makePathSanitized(t3) {
        return this.makePath(t3).toLowerCase();
      }
      urlEscape(e2) {
        try {
          if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(e2))
            return new t2(e2).toString();
          const r2 = e2.match(/^([^?#]*)(\?[^#]*)?(#.*)?$/);
          if (!r2)
            return encodeURI(e2);
          const [, s2 = "", n3 = "", i2 = ""] = r2;
          return encodeURI(s2) + (n3 || "") + (i2 || "");
        } catch {
          return encodeURI(e2);
        }
      }
      makePath(t3) {
        let e2 = function(t4) {
          return t4.replace(/[\s\t\n\r]+/g, "-").replace(/[^\w\-_]/g, "").replace(/-+/g, "-").replace(/^-|-$/g, "");
        }(t3);
        return e2 = e2.normalize("NFD").replace(/[\u0300-\u036f]/g, ""), e2;
      }
      basePathNoSlash() {
        return this.baseURL ? this.baseURL.basePathNoTrailingSlash : "";
      }
      joinPaths(...t3) {
        return t3.filter(Boolean).join("/").replace(/\/+/g, "/").replace(/\/$/, "");
      }
    };
    q();
    var Qi = A("site", { component: "ref" });
    var ta = class {
      constructor(t2, e2, r2 = "#ZgotmplZ") {
        __publicField(this, "site");
        __publicField(this, "contentSvc");
        __publicField(this, "notFoundURL");
        this.site = t2, this.contentSvc = e2, this.notFoundURL = r2;
      }
      async relRefFrom(t2, e2) {
        return this.relRef(t2, e2);
      }
      async relRef(t2, e2) {
        try {
          const r2 = this.decodeRefArgs(t2);
          return r2.path ? this.refLink(r2.path, e2, true, r2.outputFormat) : "";
        } catch (t3) {
          throw new Error(`Invalid arguments to Ref: ${t3}`);
        }
      }
      decodeRefArgs(t2) {
        return { path: t2.path || "", outputFormat: t2.outputFormat || "" };
      }
      async refLink(t2, e2, r2, s2) {
        const n3 = e2;
        if (!n3 || typeof n3.unwrapPage != "function")
          throw new Error("source is not a PageWrapper");
        const i2 = n3.unwrapPage();
        let a2;
        const o2 = t2.replace(/\\/g, "/");
        try {
          a2 = new globalThis.URL(o2, "http://example.com");
        } catch (t3) {
          return Qi.error(`Failed to parse ref URL: ${t3}`), this.notFoundURL;
        }
        let h2 = null, c2 = "";
        if (a2.pathname !== "")
          try {
            h2 = await this.contentSvc.getPageRef(i2, a2.pathname, this.site.home.page);
            let t3 = null;
            if (h2 || this.isPositioner(e2) && (t3 = e2.position()), !h2)
              return this.logNotFound(a2.pathname, "page not found", i2, t3), this.notFoundURL;
            const s3 = await this.site.sitePage(h2);
            c2 = r2 ? s3.relPermalink() : s3.permalink();
          } catch (e3) {
            return Qi.error(`[${i2.pageIdentity().pageLanguage()}] REF_NOT_FOUND: Ref "${t2}": ${e3}`), this.notFoundURL;
          }
        return a2.hash && (c2 = c2 + "#" + a2.hash), c2;
      }
      isPositioner(t2) {
        return t2 && typeof t2.position == "function";
      }
      logNotFound(t2, e2, r2, s2) {
        const n3 = r2.pageIdentity().pageLanguage();
        s2 && s2.isValid() ? Qi.error(`[${n3}] REF_NOT_FOUND: Ref "${t2}": ${s2.toString()}: ${e2}`) : r2 ? Qi.error(`[${n3}] REF_NOT_FOUND: Ref "${t2}" from page "${r2.path()}": ${e2}`) : Qi.error(`[${n3}] REF_NOT_FOUND: Ref "${t2}": ${e2}`);
      }
    };
    q(), A("site", { component: "language" });
    var ea = class {
      constructor(t2) {
        __publicField(this, "collator");
        this.collator = t2;
      }
      compare(t2, e2) {
        return this.collator.compare(t2, e2);
      }
    };
    var ra = class t2 {
      constructor(t3) {
        __publicField(this, "langSvc");
        __publicField(this, "currentLocation");
        __publicField(this, "currentLanguage");
        __publicField(this, "collator", null);
        this.langSvc = t3, this.currentLocation = "UTC", this.currentLanguage = "";
      }
      currentLanguageIndex() {
        try {
          return this.langSvc.getLanguageIndex(this.currentLanguage);
        } catch (t3) {
          throw new Error(`language "${this.currentLanguage}" not found`);
        }
      }
      async setup() {
        this.currentLocation = "UTC";
      }
      languages() {
        const e2 = [];
        for (const r2 of this.langSvc.languageKeys()) {
          const s2 = new t2(this.langSvc);
          s2.currentLocation = this.currentLocation, s2.currentLanguage = r2, s2.collator = this.collator, e2.push(s2);
        }
        return e2;
      }
      getCollator() {
        if (!this.collator)
          try {
            const t3 = new Intl.Collator(this.currentLanguage || "en");
            this.collator = new ea({ compare: (e2, r2) => t3.compare(e2, r2) });
          } catch (t3) {
            const e2 = new Intl.Collator("en");
            this.collator = new ea({ compare: (t4, r2) => e2.compare(t4, r2) });
          }
        return this.collator;
      }
      location() {
        return this.currentLocation;
      }
      isMultipleLanguage() {
        return this.langSvc.languageKeys().length > 1;
      }
      languagePrefix() {
        return this.currentLanguage === this.langSvc.defaultLanguage() ? "" : this.currentLanguage;
      }
      lang() {
        return this.currentLanguage;
      }
      get Lang() {
        return this.lang();
      }
      languageName() {
        return this.langSvc.getLanguageName(this.currentLanguage);
      }
      get LanguageName() {
        return this.languageName();
      }
      defaultLanguageName() {
        return this.langSvc.getLanguageName(this.langSvc.defaultLanguage());
      }
      languageCode() {
        return this.currentLanguage;
      }
      get LanguageCode() {
        return this.languageCode();
      }
      get LanguageDirection() {
        return "ltr";
      }
      languageDirection() {
        return "ltr";
      }
      setCurrentLanguage(t3) {
        this.currentLanguage = t3;
      }
      getCurrentLanguage() {
        return this.currentLanguage;
      }
      setCurrentLocation(t3) {
        this.currentLocation = t3;
      }
    };
    var sa = class {
      constructor(t2, e2) {
        __publicField(this, "u");
        __publicField(this, "Y");
        __publicField(this, "Z");
        this.u = t2, this.Y = e2;
      }
      name() {
        return this.u;
      }
      email() {
        return this.Y;
      }
      author(t2) {
        return this.Z = t2, this;
      }
      get Name() {
        return this.Z?.name || this.name();
      }
      get Description() {
        return this.Z?.description || "";
      }
      get Avatar() {
        return this.Z?.avatar || "";
      }
      get Twitter() {
        return this.Z?.social?.twitter || "";
      }
      get Socials() {
        const t2 = [];
        if (!this.Z?.social)
          return t2;
        for (const [e2, r2] of Object.entries(this.Z.social))
          r2 && t2.push({ ID: e2, Link: r2 });
        return t2;
      }
    };
    q(), A("site", { component: "organization" });
    var na = class {
      constructor() {
        __publicField(this, "u");
        __publicField(this, "X");
        __publicField(this, "tt");
        __publicField(this, "et");
        __publicField(this, "Y");
        __publicField(this, "rt");
        __publicField(this, "st");
        __publicField(this, "nt");
        this.u = "MDFriday", this.X = "Turn markdown to website, in minutes.", this.tt = "https://mdfriday.com", this.et = "https://gohugo.net/mdfriday.svg", this.Y = "support@mdfriday.com", this.rt = "Cang long Street, Wuhan, China", this.st = "Make site generation easy and accessible for everyone.";
      }
      name() {
        return this.u;
      }
      description() {
        return this.X;
      }
      website() {
        return this.tt;
      }
      organization(t2) {
        return this.nt = t2, this;
      }
      get Name() {
        return this.nt?.name || this.name();
      }
      get Description() {
        return this.nt?.description || this.description();
      }
      get Website() {
        return this.nt?.website || this.website();
      }
      get Vision() {
        return this.nt?.vision || this.st;
      }
      get Logo() {
        return this.nt?.logo || this.et;
      }
      get Address() {
        return this.nt?.contact?.address || this.rt;
      }
      get Email() {
        return this.nt?.contact?.email || this.Y;
      }
      get Social() {
        return this.nt?.social;
      }
      SocialById(t2) {
        return this.nt?.social?.[t2] || "";
      }
      get Socials() {
        const t2 = [];
        if (!this.nt?.social)
          return t2;
        for (const [e2, r2] of Object.entries(this.nt.social))
          r2 && t2.push({ ID: e2, Link: r2 });
        return t2;
      }
    };
    var ia = class {
      constructor(t2) {
        __publicField(this, "ver");
        this.ver = t2;
      }
      version() {
        return this.ver;
      }
      environment() {
        return "production";
      }
    };
    q();
    var aa = A("site", { component: "navigation" });
    var oa = class {
      constructor(t2) {
        __publicField(this, "taxonomies");
        __publicField(this, "taxonomiesBuilder", null);
        __publicField(this, "taxonomiesCache", /* @__PURE__ */ new Map());
        __publicField(this, "menus");
        __publicField(this, "menuBuilder", null);
        __publicField(this, "menuCache", /* @__PURE__ */ new Map());
        this.taxonomies = /* @__PURE__ */ new Map(), this.menus = /* @__PURE__ */ new Map();
        for (const e2 of t2.languageKeys())
          this.menus.set(e2, zi()), this.menuCache.set(e2, false);
      }
      setMenuBuilder(t2) {
        this.menuBuilder = t2;
      }
      setTaxonomiesBuilder(t2) {
        this.taxonomiesBuilder = t2;
      }
      async generateMenusForLanguage(t2, e2) {
        if (this.menuBuilder) {
          if (this.menuCache.get(t2) !== true)
            try {
              const r2 = await this.menuBuilder.buildMenusForLanguage(e2);
              this.menus.set(t2, r2), this.menuCache.set(t2, true);
            } catch (e3) {
              aa.error(`Failed to generate menus for language ${t2}: ${e3}`);
            }
        } else
          aa.error("Menu builder not set, cannot generate menus");
      }
      async generateTaxonomiesForLanguage(t2, e2, r2) {
        if (this.taxonomiesBuilder) {
          if (this.taxonomiesCache.get(t2) !== true)
            try {
              const s2 = await this.taxonomiesBuilder.buildTaxonomiesForLanguage(e2, r2);
              this.taxonomies.set(t2, s2), this.taxonomiesCache.set(t2, true);
            } catch (e3) {
              aa.error(`Failed to generate taxonomies for language ${t2}: ${e3}`);
            }
        } else
          aa.error("Taxonomies builder not set, cannot generate taxonomies");
      }
      getMenus(t2) {
        let e2 = this.menus.get(t2);
        return e2 === void 0 && (e2 = zi()), e2;
      }
      getTaxonomies(t2) {
        return this.taxonomies.get(t2);
      }
    };
    q();
    var ha = A("site", { component: "menu-builder" });
    var ca = class {
      constructor(t2, e2) {
        __publicField(this, "contentService");
        __publicField(this, "site");
        this.contentService = t2, this.site = e2;
      }
      async buildMenusForLanguage(t2) {
        const e2 = /* @__PURE__ */ new Map();
        return await this.contentService.walkPages(t2, async (t3) => {
          await this.processPage(t3, e2);
        }), this.convertToMenus(e2);
      }
      async processPage(t2, e2) {
        try {
          const r2 = t2.menu();
          if (!r2)
            return;
          const s2 = await this.generatePageUrl(t2);
          for (const [n3, i2] of Object.entries(r2))
            await this.processMenuSection(n3, i2, s2, t2, e2);
        } catch (t3) {
          ha.error(`Error processing page for menu: ${t3}`);
        }
      }
      async processMenuSection(t2, e2, r2, s2, n3) {
        if (!(e2 === false || Array.isArray(e2) && e2.length === 0)) {
          if (Array.isArray(e2))
            await this.processMenuItems(t2, e2, r2, s2, n3);
          else if (e2 && typeof e2 == "object") {
            let i2 = 0;
            for (const [a2, o2] of Object.entries(e2))
              if (!(o2 === false || Array.isArray(o2) && o2.length === 0) && Array.isArray(o2)) {
                const e3 = `${t2}.${a2}`;
                if (await this.processMenuItems(e3, o2, r2, s2, n3), t2 === "footer") {
                  const t3 = `${e3}::__subsection__`;
                  n3.has(t3) || n3.set(t3, { title: a2, url: "", children: /* @__PURE__ */ new Map(), weight: 1e3, level: 0, menuName: e3, order: i2 });
                }
                i2++;
              }
          }
        }
      }
      async processMenuItems(t2, e2, r2, s2, n3) {
        for (let i2 = 0; i2 < e2.length; i2++) {
          const a2 = e2[i2];
          if (!a2 || typeof a2 != "object")
            continue;
          if (!a2.title || typeof a2.title != "string")
            continue;
          let o2 = a2.url || "";
          o2 = o2 === "" ? r2 : await this.processMenuItemUrl(o2);
          const h2 = typeof a2.weight == "number" ? a2.weight : 1e3, c2 = `${t2}::${a2.title}`;
          let u2 = n3.get(c2);
          u2 ? h2 < u2.weight && (u2.weight = h2, u2.url = o2) : (u2 = { title: a2.title, url: o2, children: /* @__PURE__ */ new Map(), weight: h2, level: 0, menuName: t2 || void 0, order: i2 }, n3.set(c2, u2)), Array.isArray(a2.children) && await this.processChildrenItems(c2, a2.children, r2, s2, n3, u2);
        }
      }
      async processChildrenItems(t2, e2, r2, s2, n3, i2) {
        for (let a2 = 0; a2 < e2.length; a2++) {
          const o2 = e2[a2];
          if (!o2 || typeof o2 != "object")
            continue;
          if (!o2.title || typeof o2.title != "string")
            continue;
          let h2 = o2.url || "";
          h2 = h2 === "" ? r2 : await this.processMenuItemUrl(h2);
          const c2 = typeof o2.weight == "number" ? o2.weight : 1e3, u2 = `${t2}::${o2.title}`, l2 = { title: o2.title, url: h2, children: /* @__PURE__ */ new Map(), weight: c2, level: i2.level + 1, menuName: i2.menuName || void 0, order: a2 };
          n3.set(u2, l2), i2.children.set(u2, l2), Array.isArray(o2.children) && await this.processChildrenItems(u2, o2.children, r2, s2, n3, l2);
        }
      }
      async generatePageUrl(t2) {
        try {
          return (await this.site.sitePage(t2)).RelPermalink;
        } catch (e2) {
          return ha.error(`Error generating page URL for ${t2.path()}: ${e2}`), this.fallbackUrlFromPath(t2.path());
        }
      }
      async processMenuItemUrl(t2) {
        try {
          return this.site.getURL().relURL(t2);
        } catch (e2) {
          return ha.error(`Error processing menu item URL ${t2}: ${e2}`), t2;
        }
      }
      fallbackUrlFromPath(t2) {
        let e2 = t2.replace(/\.md$/, "");
        return e2.startsWith("/") || (e2 = "/" + e2), e2.endsWith("/") || e2.includes(".") || (e2 += "/"), e2;
      }
      convertToMenus(t2) {
        const e2 = /* @__PURE__ */ new Map();
        for (const [r3, s3] of t2.entries())
          if (!r3.includes("::__subsection__") && s3.level === 0) {
            const t3 = s3.menuName || "main";
            e2.has(t3) || e2.set(t3, []), e2.get(t3).push(s3);
          }
        const r2 = this.buildMenuItems(e2.get("nav") || [], t2), s2 = [], n3 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map();
        for (const [r3, s3] of e2.entries())
          if (r3.startsWith("footer.")) {
            const e3 = r3.substring(7), a3 = this.buildMenuItems(s3, t2, false);
            n3.set(e3, a3);
            const o3 = `${r3}::__subsection__`, h2 = t2.get(o3);
            h2 && i2.set(e3, h2.order);
          }
        const a2 = Array.from(n3.entries()).sort((t3, e3) => (i2.get(t3[0]) || 0) - (i2.get(e3[0]) || 0));
        for (let t3 = 0; t3 < a2.length; t3++) {
          const [e3, r3] = a2[t3];
          if (r3.length > 0) {
            const n4 = new qi({ title: this.capitalizeFirstLetter(e3), url: "", children: r3, weight: t3 + 1, identifier: `footer-${e3}` });
            s2.push(n4);
          }
        }
        const o2 = {};
        return r2.length > 0 && (o2.nav = r2), s2.length > 0 && (o2.footer = s2), new Wi(o2);
      }
      capitalizeFirstLetter(t2) {
        return t2.charAt(0).toUpperCase() + t2.slice(1);
      }
      buildMenuItems(t2, e2, r2 = true) {
        const s2 = [];
        for (const n3 of t2) {
          const t3 = Array.from(n3.children.values()), i2 = t3.length > 0 ? this.buildMenuItems(t3, e2, r2) : [], a2 = new qi({ title: n3.title, url: n3.url, children: i2, weight: n3.weight, identifier: n3.url });
          s2.push(a2);
        }
        return r2 ? s2.sort((t3, e3) => t3.weight() !== e3.weight() ? t3.weight() - e3.weight() : t3.title().localeCompare(e3.title())) : s2.sort((e3, r3) => {
          const s3 = t2.find((t3) => t3.title === e3.title()), n3 = t2.find((t3) => t3.title === r3.title());
          return (s3?.order || 0) - (n3?.order || 0);
        });
      }
    };
    z(), q();
    var ua = A("site", { component: "navigation-factory" });
    var la = class {
      constructor(t2, e2, r2) {
        __publicField(this, "langService");
        __publicField(this, "contentService");
        __publicField(this, "site");
        this.langService = t2, this.contentService = e2, this.site = r2;
      }
      createNavigation() {
        try {
          const e2 = (t2 = this.langService, new oa(t2)), r2 = new ca(this.contentService, this.site);
          e2.setMenuBuilder(r2);
          const s2 = new j(this.contentService);
          return e2.setTaxonomiesBuilder(s2), e2;
        } catch (t3) {
          throw ua.error(`Failed to create Navigation entity: ${t3}`), t3;
        }
        var t2;
      }
    };
    q(), A("site", { component: "factory" }), q();
    var fa = p(require("path"));
    var wa = require("crypto");
    var da = require("stream");
    var ga = require("stream/promises");
    q();
    var pa = A("resources", { component: "publisher" });
    var ma = class {
      constructor() {
        __publicField(this, "value", "");
        __publicField(this, "size", 0);
        __publicField(this, "resource", null);
      }
      async setup(t2) {
        if (this.value)
          return;
        this.resource = t2;
        const e2 = await t2.readSeekCloser(), r2 = (0, wa.createHash)("sha256");
        let s2 = 0;
        const n3 = [];
        e2.on("data", (t3) => {
          r2.update(t3), s2 += t3.length, n3.push(t3);
        }), await new Promise((t3, n4) => {
          e2.on("end", () => {
            this.value = r2.digest("hex"), this.size = s2, t3();
          }), e2.on("error", n4);
        }), await e2.close();
      }
    };
    var ya = class {
      constructor() {
        __publicField(this, "hasPublished", false);
        __publicField(this, "publishPromise", null);
      }
      async do(t2) {
        if (!this.hasPublished)
          return this.publishPromise || (this.publishPromise = t2().then(() => {
            this.hasPublished = true;
          })), this.publishPromise;
      }
    };
    var ba = class t2 {
      constructor(t3, e2, r2, s2 = {}, n3) {
        __publicField(this, "h");
        __publicField(this, "openReadSeekCloser");
        __publicField(this, "it");
        __publicField(this, "paths");
        __publicField(this, "ot");
        __publicField(this, "publisher");
        __publicField(this, "publishOnce");
        this.h = new ma(), this.openReadSeekCloser = t3, this.it = e2, this.paths = r2, this.ot = s2, this.publisher = n3, this.publishOnce = new ya();
      }
      name() {
        return this.paths.pathFile();
      }
      nameNormalized() {
        return this.paths.targetPath().replace(/\\/g, "/");
      }
      mediaType() {
        return this.it;
      }
      resourceType() {
        return this.it.mainType;
      }
      relPermalink() {
        return this.publish(), this.paths.targetLink();
      }
      permalink() {
        return this.publish(), this.paths.targetPath();
      }
      async publish() {
        const t3 = this.targetPath();
        this.publisher ? await this.publishOnce.do(async () => {
          let e2 = null, r2 = null;
          try {
            e2 = await this.publisher.openPublishFileForWriting(this.paths.targetPath()), r2 = await this.readSeekCloser(), await this.copyStreamToFile(r2, e2);
          } catch (e3) {
            throw pa.errorf("\u274C [Resource.publish] Error publishing %s: %s", t3, e3), e3;
          } finally {
            if (r2)
              try {
                await r2.close();
              } catch (e3) {
                pa.errorf("\u274C [Resource.publish] Failed to close ReadSeekCloser %s: %s", t3, e3);
              }
            if (e2)
              try {
                await e2.file.close();
              } catch (e3) {
                pa.errorf("\u274C [Resource.publish] Failed to close public writer %s: %s", t3, e3);
              }
          }
        }) : pa.error("\u26A0\uFE0F [Resource.publish] No publisher for: %s", t3);
      }
      async copyStreamToFile(t3, e2) {
        const r2 = this.targetPath();
        try {
          await (0, ga.pipeline)(t3, e2);
        } catch (t4) {
          throw pa.errorf("\u274C [copyStreamToFile] Error during pipeline for %s: %s", r2, t4), t4;
        }
      }
      targetPath() {
        return this.paths.targetPath();
      }
      data() {
        return this.ot;
      }
      async readSeekCloser() {
        const t3 = await this.openReadSeekCloser();
        if (t3 && typeof t3.read == "function") {
          const e2 = t3.read();
          if (e2) {
            const r2 = new (0, require("stream").Readable)();
            let s2;
            for (r2.push(e2); (s2 = t3.read()) !== null; )
              s2 && r2.push(s2);
            return r2.push(null), Object.assign(r2, { seek: async (t4, e3) => 0, close: async () => Promise.resolve() });
          }
        }
        return t3;
      }
      async content(t3) {
        const e2 = await this.readSeekCloser();
        return new Promise((t4, r2) => {
          let s2 = "";
          e2.on("data", (t5) => {
            s2 += t5.toString();
          }), e2.on("end", () => {
            t4(s2);
          }), e2.on("error", r2);
        });
      }
      async hash() {
        return await this.h.setup(this), this.h.value;
      }
      async size() {
        return await this.h.setup(this), this.h.size;
      }
      cloneTo(t3) {
        const e2 = this.clone();
        return e2.paths = e2.paths.fromTargetPath(t3), e2;
      }
      clone() {
        const e2 = new t2(this.openReadSeekCloser, this.it, this.paths, { ...this.ot }, this.publisher);
        return e2.h = this.h, e2;
      }
      key() {
        return this.paths.targetLink();
      }
      get RelPermalink() {
        return this.relPermalink();
      }
      get Permalink() {
        return this.permalink();
      }
      get Name() {
        return this.name();
      }
      get MediaType() {
        return this.mediaType();
      }
      get ResourceType() {
        return this.resourceType();
      }
      get TargetPath() {
        return this.targetPath();
      }
      get Data() {
        return this.data();
      }
      get Content() {
        return this.content();
      }
      get Hash() {
        return () => this.hash();
      }
      get Size() {
        return () => this.size();
      }
      meta() {
        return new Ha(this.paths.targetPath(), this.it.type, this.ot);
      }
      mergeData(t3) {
        if (t3 && Object.keys(t3).length !== 0)
          for (const [e2, r2] of Object.entries(t3))
            e2 in this.ot || (this.ot[e2] = r2);
      }
      async transform(...t3) {
        let e2 = this;
        for (let r2 = 0; r2 < t3.length; r2++) {
          const s2 = t3[r2];
          try {
            const t4 = await e2.readSeekCloser(), r3 = new da.PassThrough();
            let n3 = "";
            const i2 = [], a2 = { source: { from: t4, inPath: e2.targetPath(), inMediaType: e2.mediaType() }, target: { to: r3 }, data: { ...e2.data() }, addOutPathIdentifier: (t5) => {
              const r4 = e2.targetPath(), s3 = ms.parseBasic(r4);
              let n4 = s3.dir;
              n4 = n4.replace(/\/+$/, "");
              let i3 = "";
              n4 && (i3 = n4 + "/"), i3 += s3.nameWithoutExt + t5 + s3.ext, a2.data.targetPath = i3;
            }, updateBuffer: () => {
            }, updateSource: () => {
            }, close: () => {
              t4.close();
            } };
            r3.on("data", (t5) => {
              i2.push(t5);
            });
            const o2 = new Promise((t5, e3) => {
              r3.on("end", () => {
                n3 = Buffer.concat(i2).toString(), t5();
              }), r3.on("error", (t6) => {
                e3(t6);
              });
            });
            await s2.transform(a2), await o2;
            const h2 = a2.data.targetPath || e2.targetPath(), c2 = this.createTransformedResource(n3, h2, e2.mediaType(), a2.data);
            e2 = c2, a2.close();
          } catch (t4) {
            throw t4;
          }
        }
        return e2;
      }
      createTransformedResource(e2, r2, s2, n3) {
        const i2 = this.paths.fromTargetPath(r2);
        return new t2(async () => {
          const t3 = new da.PassThrough();
          return t3.end(e2), Object.assign(t3, { seek: async (t4, e3) => 0, close: async () => Promise.resolve() });
        }, s2, i2, n3, this.publisher);
      }
    };
    var Ea = require_bundle_min();
    var Sa = class {
      constructor(t2 = false) {
        __publicField(this, "minifiers", /* @__PURE__ */ new Map());
        __publicField(this, "minifyOutput");
        this.minifyOutput = t2, this.setupMinifiers();
      }
      setupMinifiers() {
        this.minifiers.set("text/css", this.minifyCSS.bind(this)), this.minifiers.set("text/javascript", this.minifyJS.bind(this)), this.minifiers.set("application/javascript", this.minifyJS.bind(this)), this.minifiers.set("application/json", this.minifyJSON.bind(this)), this.minifiers.set("text/html", this.minifyHTML.bind(this)), this.minifiers.set("image/svg+xml", this.minifySVG.bind(this)), this.minifiers.set("application/xml", this.minifyXML.bind(this)), this.minifiers.set("text/xml", this.minifyXML.bind(this));
      }
      async minify(t2) {
        const e2 = new va(this);
        return t2.transform(e2);
      }
      getMinifier(t2) {
        return this.minifiers.get(t2) || null;
      }
      async minifyCSS(t2) {
        return t2;
      }
      async minifyJS(t2) {
        try {
          return (await (0, Ea.minify)(t2, { compress: { drop_console: false, drop_debugger: true, passes: 2 }, mangle: { toplevel: false }, format: { comments: false } })).code || t2;
        } catch (e2) {
          return t2;
        }
      }
      async minifyJSON(t2) {
        try {
          return JSON.stringify(JSON.parse(t2));
        } catch {
          return t2;
        }
      }
      async minifyHTML(t2) {
        return t2;
      }
      async minifySVG(t2) {
        return t2;
      }
      async minifyXML(t2) {
        return t2;
      }
    };
    var va = class {
      constructor(t2) {
        this.minifierClient = t2;
      }
      key() {
        return za.newResourceTransformationKey("minify");
      }
      async transform(t2) {
        t2.addOutPathIdentifier(".min");
        const e2 = t2.source.inMediaType.type, r2 = this.minifierClient.getMinifier(e2);
        if (!r2)
          return void t2.source.from.pipe(t2.target.to);
        let s2 = "";
        t2.source.from.on("data", (t3) => {
          s2 += t3.toString();
        }), await new Promise((e3, n3) => {
          t2.source.from.on("end", async () => {
            try {
              const n4 = await r2(s2);
              t2.target.to.write(n4), t2.target.to.end(), e3();
            } catch (t3) {
              n3(t3);
            }
          }), t2.source.from.on("error", n3);
        });
      }
    };
    var Ta = require("crypto");
    var xa = class {
      async fingerprint(t2, e2 = "sha256") {
        const r2 = new Pa(e2);
        return t2.transform(r2);
      }
      generateIntegrity(t2) {
        return `sha256-${(0, Ta.createHash)("sha256").update(t2, "utf8").digest("base64")}`;
      }
      generateSHA384(t2) {
        return `sha384-${(0, Ta.createHash)("sha384").update(t2, "utf8").digest("base64")}`;
      }
      generateSHA512(t2) {
        return `sha512-${(0, Ta.createHash)("sha512").update(t2, "utf8").digest("base64")}`;
      }
      verifyIntegrity(t2, e2) {
        const [r2, s2] = e2.split("-", 2);
        let n3;
        switch (r2) {
          case "sha256":
            n3 = (0, Ta.createHash)("sha256").update(t2, "utf8").digest("base64");
            break;
          case "sha384":
            n3 = (0, Ta.createHash)("sha384").update(t2, "utf8").digest("base64");
            break;
          case "sha512":
            n3 = (0, Ta.createHash)("sha512").update(t2, "utf8").digest("base64");
            break;
          default:
            return false;
        }
        return n3 === s2;
      }
    };
    var Pa = class {
      constructor(t2) {
        this.algo = t2;
      }
      key() {
        return za.newResourceTransformationKey("fingerprint", this.algo);
      }
      async transform(t2) {
        const e2 = this.newHash(this.algo);
        let r2 = "";
        const s2 = [];
        t2.source.from.on("data", (t3) => {
          e2.update(t3), s2.push(t3), r2 += t3.toString();
        }), await new Promise((r3, n3) => {
          t2.source.from.on("end", () => {
            try {
              const n4 = e2.digest(), i2 = n4.toString("hex");
              t2.data.Integrity = this.integrity(this.algo, n4);
              const a2 = i2.substring(0, 12);
              t2.addOutPathIdentifier("." + a2);
              for (const e3 of s2)
                t2.target.to.write(e3);
              t2.target.to.end(), r3();
            } catch (t3) {
              n3(t3);
            }
          }), t2.source.from.on("error", n3);
        });
      }
      newHash(t2) {
        switch (t2) {
          case "md5":
            return (0, Ta.createHash)("md5");
          case "sha256":
            return (0, Ta.createHash)("sha256");
          case "sha384":
            return (0, Ta.createHash)("sha384");
          case "sha512":
            return (0, Ta.createHash)("sha512");
          default:
            throw new Error(`Unsupported hash algorithm: "${t2}", use either md5, sha256, sha384 or sha512`);
        }
      }
      integrity(t2, e2) {
        return `${t2}-${e2.toString("base64")}`;
      }
    };
    var $a = class {
      constructor(t2, e2, r2) {
        __publicField(this, "templateExecutor");
        __publicField(this, "ht");
        __publicField(this, "data");
        this.templateExecutor = t2, this.ht = e2, this.data = r2;
      }
      key() {
        return za.newResourceTransformationKey("execute-as-template", this.ht);
      }
      async transform(t2) {
        try {
          t2.data.targetPath = this.ht;
          let e2 = "";
          if (typeof t2.source.from.read == "function") {
            let r2;
            const s2 = [];
            for (; (r2 = t2.source.from.read()) !== null; )
              r2 && s2.push(r2);
            if (s2.length > 0)
              e2 = Buffer.concat(s2).toString();
            else if (t2.source.from.ct && t2.source.from.ct.buffer) {
              const r3 = t2.source.from.ct.buffer, s3 = [];
              for (const t3 of r3)
                t3 && t3.chunk && s3.push(t3.chunk);
              s3.length > 0 && (e2 = Buffer.concat(s3).toString());
            }
          }
          if (!e2)
            return new Promise((e3, r2) => {
              const s2 = [];
              t2.source.from.on("data", (t3) => {
                s2.push(t3);
              }), t2.source.from.on("end", async () => {
                try {
                  const n3 = Buffer.concat(s2).toString();
                  await this.executeTemplate(n3, t2, e3, r2);
                } catch (e4) {
                  r2(new Error(`failed to parse Resource "${t2.source.inPath}" as Template: ${e4}`));
                }
              }), t2.source.from.on("error", (t3) => {
                r2(t3);
              }), typeof t2.source.from.resume == "function" && t2.source.from.resume();
            });
          await this.executeTemplateSync(e2, t2);
        } catch (e2) {
          throw new Error(`failed to parse Resource "${t2.source.inPath}" as Template: ${e2}`);
        }
      }
      async executeTemplateSync(t2, e2) {
        const r2 = await this.templateExecutor.executeTemplate(e2.source.inPath, t2, this.data);
        e2.target.to.write(r2), e2.target.to.end();
      }
      async executeTemplate(t2, e2, r2, s2) {
        try {
          await this.executeTemplateSync(t2, e2), r2();
        } catch (t3) {
          s2(t3 instanceof Error ? t3 : new Error(String(t3)));
        }
      }
    };
    var Ra = class {
      constructor(t2) {
        __publicField(this, "templateExecutor");
        this.templateExecutor = t2;
      }
      async executeAsTemplate(t2, e2, r2) {
        try {
          if (!t2)
            throw new Error("Resource is null or undefined");
          if (typeof t2.transform != "function")
            throw new Error("Resource does not implement Transformer interface. Resource type: " + typeof t2);
          const s2 = new $a(this.templateExecutor, e2.replace(/\\/g, "/").replace(/^\/+/, ""), r2);
          return await t2.transform(s2);
        } catch (t3) {
          throw t3;
        }
      }
    };
    var La = p(require("path"));
    q();
    var Na = require("stream");
    var Fa = A("resources", { component: "publisher" });
    var Da = class {
      constructor(t2, e2) {
        __publicField(this, "pubFs");
        __publicField(this, "urlSvc");
        this.pubFs = t2, this.urlSvc = e2;
      }
      async openPublishFileForWriting(t2) {
        const e2 = t2.replace(/^\/+/, "");
        try {
          const t3 = await this.pubFs.create(e2);
          return new Aa(t3);
        } catch (t3) {
          if (t3.code === "ENOENT" || t3.message.includes("ENOENT")) {
            const t4 = La.dirname(e2);
            await this.pubFs.mkdirAll(t4, 511);
            const r2 = await this.pubFs.create(e2), s2 = r2.close.bind(r2);
            return r2.close = async () => {
              try {
                await s2();
              } catch (t5) {
                throw Fa.errorf("\u274C [Publisher.File.close] Error closing publish file (retry) %s, $s", e2, t5), t5;
              }
            }, new Aa(r2);
          }
          throw t3;
        }
      }
      async openFilesForWriting(...t2) {
        if (t2.length === 0)
          throw new Error("No filenames provided");
        const e2 = t2[0];
        return await this.openFileForWriting(e2);
      }
      async openFileForWriting(t2) {
        const e2 = La.normalize(t2);
        try {
          return await this.pubFs.create(e2);
        } catch (t3) {
          if (!this.isFileNotFoundError(t3))
            throw t3;
          const r2 = La.dirname(e2);
          return await this.pubFs.mkdirAll(r2, 511), await this.pubFs.create(e2);
        }
      }
      isFileNotFoundError(t2) {
        return t2 && (t2.code === "ENOENT" || t2.message?.includes("no such file or directory") || t2.message?.includes("not found"));
      }
    };
    var Aa = class extends Na.Writable {
      constructor(t2) {
        super();
        __publicField(this, "file");
        this.file = t2;
      }
      ut(t2, e2, r2) {
        this.file.write(t2).then(() => r2()).catch(r2);
      }
      lt(t2) {
        this.file.sync?.().then(() => this.file.close()).then(() => t2()).catch(t2);
      }
    };
    q();
    var ka = p(require("http"));
    var Ia = p(require("https"));
    var Ca = A("resources", { component: "http-client" });
    var Oa = class {
      constructor() {
        __publicField(this, "defaultTimeout", 3e4);
        __publicField(this, "defaultHeaders", { "User-Agent": "MDFriday-Resources/1.0.0" });
      }
      async fromRemote(t2, e2) {
        return new Promise((r2) => {
          try {
            const s2 = new URL(t2), n3 = s2.protocol === "https:", i2 = n3 ? Ia : ka, a2 = { ...this.defaultHeaders, ...e2?.headers }, o2 = { hostname: s2.hostname, port: s2.port || (n3 ? 443 : 80), path: s2.pathname + s2.search, method: "GET", headers: a2, timeout: e2?.timeout || this.defaultTimeout }, h2 = i2.request(o2, (s3) => {
              if (s3.statusCode && s3.statusCode >= 300 && s3.statusCode < 400 && s3.headers.location)
                return Ca.infof("\u{1F504} [HttpClient.fromRemote] Redirecting from %s to %s", t2, s3.headers.location), void this.fromRemote(s3.headers.location, e2).then(r2);
              if (!s3.statusCode || s3.statusCode < 200 || s3.statusCode >= 300)
                return Ca.errorf("\u274C [HttpClient.fromRemote] HTTP error %d when fetching %s: %s", s3.statusCode || 0, t2, s3.statusMessage || "Unknown error"), void r2(null);
              const n4 = [];
              s3.on("data", (t3) => {
                n4.push(t3);
              }), s3.on("end", () => {
                try {
                  const e3 = Buffer.concat(n4).toString("utf8");
                  Ca.infof("\u2705 [HttpClient.fromRemote] Successfully fetched %d bytes from %s", e3.length, t2), r2(e3);
                } catch (e3) {
                  Ca.errorf("\u274C [HttpClient.fromRemote] Error converting response to string from %s: %s", t2, e3), r2(null);
                }
              }), s3.on("error", (e3) => {
                Ca.errorf("\u274C [HttpClient.fromRemote] Response error when fetching %s: %s", t2, e3.message), r2(null);
              });
            });
            h2.on("error", (e3) => {
              Ca.errorf("\u274C [HttpClient.fromRemote] Request error when fetching %s: %s", t2, e3.message), r2(null);
            }), h2.on("timeout", () => {
              h2.destroy(), Ca.errorf("\u274C [HttpClient.fromRemote] Request timeout when fetching %s", t2), r2(null);
            }), h2.end();
          } catch (e3) {
            Ca.errorf("\u274C [HttpClient.fromRemote] Error fetching content from %s: %s", t2, e3), r2(null);
          }
        });
      }
    };
    var _a = p(require("path"));
    var Ma = require("crypto");
    q();
    var Ua = A("resources", { component: "resources" });
    var ja = class {
      constructor(t2) {
        __publicField(this, "cache", /* @__PURE__ */ new Map());
        __publicField(this, "workspace");
        __publicField(this, "fsSvc");
        __publicField(this, "urlSvc");
        __publicField(this, "templateSvc");
        __publicField(this, "publisher");
        __publicField(this, "minifierClient");
        __publicField(this, "integrityClient");
        __publicField(this, "templateClient", null);
        __publicField(this, "httpClient");
        this.workspace = t2, this.fsSvc = t2, this.urlSvc = t2, this.templateSvc = t2, this.publisher = new Da(t2.publishFs(), t2), this.minifierClient = new Sa(), this.integrityClient = new xa(), this.templateClient = new Ra(this.templateSvc), this.httpClient = new Oa();
      }
      setTemplateSvc(t2) {
        this.templateSvc = t2, this.templateClient = new Ra(t2);
      }
      async getResource(t2) {
        const e2 = _a.posix.normalize(t2), r2 = `${e2}__get`;
        if (this.cache.has(r2))
          return this.cache.get(r2) || null;
        try {
          const t3 = this.workspace.assetsFs();
          if (!await t3.stat(e2))
            return null;
          const s2 = async () => {
            const r3 = await t3.open(e2);
            return await this.createReadSeekCloser(r3);
          }, n3 = await this.buildResource(e2, s2);
          return n3 && this.cache.set(r2, n3), n3;
        } catch (t3) {
          return Ua.errorf("\u274C [Resources.getResource] Error getting resource %s, %s", e2, t3), null;
        }
      }
      async getResourceWithOpener(t2, e2) {
        const r2 = _a.posix.normalize(t2), s2 = `${r2}__get_with_opener`;
        if (this.cache.has(s2))
          return this.cache.get(s2) || null;
        try {
          const t3 = await this.buildResource(r2, e2);
          return t3 && this.cache.set(s2, t3), t3;
        } catch (t3) {
          return Ua.errorf("\u274C [Resources.getResourceWithOpener] Error getting resource with opener %s, %s", r2, t3), null;
        }
      }
      async executeAsTemplate(t2, e2, r2) {
        if (!this.templateClient)
          throw new Error("Template client not available. Please set template client first.");
        const s2 = t2.key() + "-template-" + e2, n3 = this.cacheKey(s2);
        if (this.cache.has(n3))
          return this.cache.get(n3);
        try {
          const s3 = await this.templateClient.executeAsTemplate(t2, e2, r2);
          return s3 ? this.cache.set(n3, s3) : Ua.warnf("\u26A0\uFE0F [Resources.executeAsTemplate] Template execution returned null for resource %s", t2.key()), s3;
        } catch (e3) {
          throw Ua.errorf("\u274C [Resources.executeAsTemplate] Error executing template %s, %s", t2.key(), e3), e3;
        }
      }
      async minify(t2) {
        if (!this.minifierClient)
          throw new Error("Minifier client not available. Please set minifier client first.");
        const e2 = t2.key() + "-minify", r2 = this.cacheKey(e2);
        if (this.cache.has(r2))
          return this.cache.get(r2);
        try {
          const e3 = await this.minifierClient.minify(t2);
          return e3 ? this.cache.set(r2, e3) : Ua.warnf("\u26A0\uFE0F [Resources.minify] Minification returned null for resource %s", t2.key()), e3;
        } catch (e3) {
          throw Ua.errorf("\u274C [Resources.minify] Error minifying resource %s, %s", t2.key(), e3), e3;
        }
      }
      async fingerprint(t2) {
        const e2 = t2.key() + "-fingerprint", r2 = this.cacheKey(e2);
        if (this.cache.has(r2))
          return this.cache.get(r2);
        try {
          const e3 = await this.integrityClient.fingerprint(t2);
          return e3 ? this.cache.set(r2, e3) : Ua.warnf("\u26A0\uFE0F [Resources.fingerprint] Fingerprint operation returned null for resource %s", t2.key()), e3;
        } catch (e3) {
          throw Ua.errorf("\u274C [Resources.fingerprint] Error fingerprinting resource %s, %s", t2.key(), e3), e3;
        }
      }
      async getRemote(t2) {
        const e2 = `${t2}__remote`;
        if (this.cache.has(e2))
          return this.cache.get(e2) || null;
        try {
          const r2 = await this.httpClient.fromRemote(t2);
          if (!r2)
            return null;
          const s2 = async () => this.newReadSeekerNoOpCloserFromString(r2), n3 = await this.buildResource(t2, s2);
          return n3 && this.cache.set(e2, n3), n3;
        } catch (e3) {
          return Ua.errorf("\u274C [Resources.fromRemote] Error getting remote resource %s, %s", t2, e3), null;
        }
      }
      cacheKey(t2) {
        return (0, Ma.createHash)("sha256").update(t2).digest("hex").substring(0, 16);
      }
      getMinifierClient() {
        return this.minifierClient;
      }
      getIntegrityClient() {
        return this.integrityClient;
      }
      setTemplateClient(t2) {
        this.templateClient = t2;
      }
      async buildResource(t2, e2) {
        try {
          const r2 = _a.extname(t2), s2 = this.getMediaTypeFromExtension(r2), n3 = qa.newResourcePaths(t2, this.workspace);
          return new ba(e2, s2, n3, {}, this.publisher);
        } catch (e3) {
          return Ua.errorf("\u274C [Resources.buildResource] Error building resource for %s, %s", t2, e3), null;
        }
      }
      getMediaTypeFromExtension(t2) {
        const e2 = { ".js": { type: "text/javascript", mainType: "text", subType: "javascript" }, ".css": { type: "text/css", mainType: "text", subType: "css" }, ".html": { type: "text/html", mainType: "text", subType: "html" }, ".json": { type: "application/json", mainType: "application", subType: "json" }, ".svg": { type: "image/svg+xml", mainType: "image", subType: "svg+xml" }, ".xml": { type: "application/xml", mainType: "application", subType: "xml" }, ".txt": { type: "text/plain", mainType: "text", subType: "plain" } }, r2 = t2 ? e2[t2] || e2[".txt"] : e2[".html"], s2 = t2 ? t2.substring(1) : "html", n3 = t2 || ".html";
        return new Wr({ type: r2.type, mainType: r2.mainType, subType: r2.subType, delimiter: ".", firstSuffix: { suffix: s2, fullSuffix: n3 }, mimeSuffix: "", suffixesCSV: s2 });
      }
      async createReadSeekCloser(t2) {
        try {
          const e2 = [];
          let r2 = 0;
          try {
            for (; ; ) {
              const s3 = new Uint8Array(8192), n3 = await t2.read(s3);
              if (n3.bytesRead === 0)
                break;
              r2 += n3.bytesRead, e2.push(s3.slice(0, n3.bytesRead));
            }
          } finally {
            await t2.close();
          }
          let s2 = "";
          if (e2.length > 0) {
            const t3 = new Uint8Array(r2);
            let n3 = 0;
            for (const r3 of e2)
              t3.set(r3, n3), n3 += r3.length;
            s2 = new TextDecoder().decode(t3);
          }
          return this.newReadSeekerNoOpCloserFromString(s2);
        } catch (e2) {
          try {
            await t2.close();
          } catch (e3) {
            Ua.warnf("\u274C [Resources.createReadSeekCloser] Error closing file after read error %s, %s", t2.path, e3);
          }
          return this.newReadSeekerNoOpCloserFromString("");
        }
      }
      newReadSeekerNoOpCloserFromString(t2) {
        const { Readable: e2 } = require("stream"), r2 = new e2({ read() {
        } });
        return r2.push(t2), r2.push(null), Object.assign(r2, { seek: async (t3, e3) => 0, close: async () => Promise.resolve() });
      }
    };
    var Ba = p(require("path"));
    var qa = class t2 {
      constructor(t3 = "", e2 = "", r2 = "", s2 = "", n3 = [], i2 = "") {
        __publicField(this, "dir");
        __publicField(this, "baseDirTarget");
        __publicField(this, "baseDirLink");
        __publicField(this, "targetBasePaths");
        __publicField(this, "file");
        __publicField(this, "baseUrl", "");
        this.dir = t3, this.file = e2, this.baseDirTarget = r2, this.baseDirLink = s2, this.targetBasePaths = n3, this.baseUrl = i2;
      }
      static newResourcePaths(e2, r2) {
        const s2 = e2.replace(/\\/g, "/"), n3 = Ba.posix.parse(s2);
        let i2 = n3.dir;
        return i2 === "/" && (i2 = ""), new t2(i2, n3.base, r2.baseUrl(), r2.baseUrl(), [], r2.baseUrl());
      }
      join(...t3) {
        let e2 = "";
        for (let r2 = 0; r2 < t3.length; r2++) {
          const s2 = t3[r2];
          if (s2)
            if (e2 === "")
              e2 = s2;
            else {
              const t4 = !e2.endsWith("/") && !s2.startsWith("/"), r3 = e2.endsWith("/") && s2.startsWith("/");
              e2 += r3 ? s2.substring(1) : t4 ? "/" + s2 : s2;
            }
        }
        return e2.startsWith("/") && (e2 = e2.substring(1)), e2.endsWith("/") && e2.length > 1 && (e2 = e2.substring(0, e2.length - 1)), e2;
      }
      targetLink() {
        let t3 = this.join(this.baseDirLink, this.dir, this.file);
        return t3.startsWith("http://") || t3.startsWith("https://") || t3.startsWith("/") || (t3 = "/" + t3), t3;
      }
      targetPath() {
        return this.join(this.dir, this.file);
      }
      fromTargetPath(e2) {
        const r2 = e2.replace(/\\/g, "/"), s2 = Ba.posix.parse(r2);
        let n3 = s2.dir;
        return n3 === "/" && (n3 = ""), new t2(n3, s2.base, this.baseUrl, this.baseUrl, this.targetBasePaths, this.baseUrl);
      }
      pathDir() {
        return this.dir;
      }
      pathBaseDirTarget() {
        return this.baseDirTarget;
      }
      pathBaseDirLink() {
        return this.baseDirLink;
      }
      pathTargetBasePaths() {
        return this.targetBasePaths;
      }
      pathFile() {
        return this.file;
      }
    };
    var Wa = require("crypto");
    var za = class t2 {
      constructor(t3, e2 = []) {
        this.name = t3, this.elements = e2;
      }
      static newResourceTransformationKey(e2, ...r2) {
        return new t2(e2, r2);
      }
      value() {
        if (this.elements.length === 0)
          return this.name;
        const t3 = this.hashElements(...this.elements);
        return `${this.name}_${t3}`;
      }
      hashElements(...t3) {
        const e2 = t3.map((t4) => String(t4)).join("|");
        return (0, Wa.createHash)("sha256").update(e2).digest("hex").substring(0, 16);
      }
    };
    var Ha = class t2 {
      constructor(t3, e2, r2) {
        this.target = t3, this.mediaType = e2, this.metaData = r2;
      }
      marshal() {
        return JSON.stringify({ Target: this.target, MediaType: this.mediaType, Data: this.metaData });
      }
      static unmarshal(e2) {
        const r2 = JSON.parse(e2);
        return new t2(r2.Target, r2.MediaType, r2.Data || {});
      }
    };
    var Ga = A("ssg", { component: "application" });
    var Va = (t2, e2, r2, s2, n3, i2) => ({ site: t2, content: e2, fs: r2, config: s2, modules: n3, resources: i2 });
    async function Ka(t2, e2) {
      const r2 = new ze(), s2 = fa.default.join(t2, "config.json");
      return await async function(t3, e3, r3, s3, n3 = {}) {
        const i2 = { workingDir: dt.resolve(r3), modulesDir: dt.resolve(s3), publishDir: dt.resolve(ht), cacheDir: "" };
        i2.cacheDir = await async function(t4, e4) {
          if (e4 !== "")
            return e4;
          const r4 = process.env.HOME || process.env.USERPROFILE || "", s4 = dt.join(r4, ".cache", "mdf");
          try {
            return await t4.mkdirAll(s4, 493), s4;
          } catch {
            return dt.join("/tmp", "hugo-cache");
          }
        }(t3, i2.cacheDir);
        const a2 = new ft(function(t4, e4) {
          return new wt(t4, e4);
        }(t3, e3), i2);
        try {
          const e4 = await a2.loadConfigByDefault();
          for (const [t4, r5] of Object.entries(n3))
            e4.set(t4, r5);
          const r4 = dt.resolve(e4.get("publishDir") || ht);
          return await t3.mkdirAll(r4, 511), function(t4, e5, r5, s4, n4, i3, a3, o2, h2) {
            return new V(t4, e5, r5, s4, n4, i3, a3, o2, h2);
          }(t3, e4, function(t4, e5 = {}) {
            const r5 = function(t5) {
              return { baseURL: t5.baseurl || K.baseURL, title: t5.title || K.title, theme: t5.theme || K.theme, timeout: t5.timeout || K.timeout, contentDir: t5.contentDir || K.contentDir, dataDir: t5.dataDir || K.dataDir, layoutDir: t5.layoutDir || K.layoutDir, staticDir: t5.staticDir || K.staticDir, archetypeDir: t5.archetypeDir || K.archetypeDir, assetDir: t5.assetDir || K.assetDir, publishDir: t5.publishDir || K.publishDir, buildDrafts: t5.buildDrafts !== void 0 ? t5.buildDrafts : K.buildDrafts, buildExpired: t5.buildExpired !== void 0 ? t5.buildExpired : K.buildExpired, buildFuture: t5.buildFuture !== void 0 ? t5.buildFuture : K.buildFuture, copyright: t5.copyright || K.copyright, defaultContentLanguage: t5.defaultContentLanguage || K.defaultContentLanguage, defaultContentLanguageInSubdir: t5.defaultContentLanguageInSubdir !== void 0 ? t5.defaultContentLanguageInSubdir : K.defaultContentLanguageInSubdir, disableAliases: t5.disableAliases !== void 0 ? t5.disableAliases : K.disableAliases, disablePathToLower: t5.disablePathToLower !== void 0 ? t5.disablePathToLower : K.disablePathToLower, disableKinds: t5.disableKinds || K.disableKinds, disableLanguages: t5.disableLanguages || K.disableLanguages, renderSegments: t5.renderSegments || K.renderSegments, disableHugoGeneratorInject: t5.disableHugoGeneratorInject !== void 0 ? t5.disableHugoGeneratorInject : K.disableHugoGeneratorInject, disableLiveReload: t5.disableLiveReload !== void 0 ? t5.disableLiveReload : K.disableLiveReload, enableEmoji: t5.enableEmoji !== void 0 ? t5.enableEmoji : K.enableEmoji };
            }(t4);
            return new J(r5, e5);
          }(e4.get(""), e4.getParams("params")), function(t4, e5, r5) {
            return new ct(t4, e5, r5);
          }(i2.workingDir, i2.modulesDir, r4), function(t4) {
            const e5 = function(t5) {
              const e6 = { mounts: [], imports: [] };
              return t5.mounts && Array.isArray(t5.mounts) && (e6.mounts = t5.mounts.map((t6) => ({ source: t6.source || "", target: t6.target || "", lang: t6.lang }))), t5.imports && Array.isArray(t5.imports) && (e6.imports = t5.imports.map((t6) => ({ path: t6.path || "", url: t6.url, version: t6.version, mounts: t6.mounts || [] }))), e6;
            }(t4);
            return new Y(e5);
          }(e4.get("module") || {}), function(t4) {
            const e5 = function(t5) {
              const e6 = { disqus: { ...Z.disqus }, googleAnalytics: { ...Z.googleAnalytics }, rss: { ...Z.rss }, x: { ...Z.x } };
              return t5 && (t5.disqus && (e6.disqus.shortname = t5.disqus.shortname || e6.disqus.shortname), t5.googleAnalytics && (e6.googleAnalytics.id = t5.googleAnalytics.id || e6.googleAnalytics.id), t5.rss && (e6.rss.limit = t5.rss.limit !== void 0 ? t5.rss.limit : e6.rss.limit)), e6;
            }(t4);
            return new X(e5);
          }(e4.get("services")), function(t4) {
            const e5 = function(t5) {
              const e6 = { userConfig: {}, platformTemplates: [...it] };
              if (t5 && typeof t5 == "object") {
                for (const [r5, s4] of Object.entries(t5))
                  if (s4 && typeof s4 == "object") {
                    const t6 = s4;
                    t6.link && (e6.userConfig[r5] = { link: t6.link });
                  }
              }
              return e6;
            }(t4);
            return new at(e5);
          }(e4.get("social")), function(t4) {
            const e5 = function(t5) {
              const e6 = {};
              if (!t5 || Object.keys(t5).length === 0)
                return e6.en = { ...Q, title: t5?.title || Q.title, params: t5?.params || Q.params }, e6;
              for (const [r5, s4] of Object.entries(t5)) {
                const n4 = s4, i3 = v.getNameByCode(r5) || r5;
                e6[r5] = { languageCode: r5, languageName: i3, title: n4.title || t5.title || "", weight: n4.weight !== void 0 ? n4.weight : 0, contentDir: n4.contentDir || "content", disabled: n4.disabled !== void 0 && n4.disabled, params: n4.params || t5.params || {} };
              }
              return e6;
            }(t4);
            return new tt(e5);
          }(e4.get("languages")), e4.isSet("taxonomies") ? nt(e4.get("taxonomies")) : nt(e4.get("")));
        } finally {
          a2.deleteMergeStrategies();
        }
      }(r2, s2, t2, e2);
    }
    async function Ja(t2, e2) {
      const r2 = { path: t2.getDir().getWorkingDir(), publish: t2.getDir().getPublishDir(), osFs: t2.fs() };
      return await async function(t3, e3) {
        const r3 = function(t4) {
          const e4 = t4.osFs, r4 = t4.osFs, s3 = we(t4.osFs, [t4.publish]);
          return new ee(e4, r4, s3);
        }(t3), s2 = await async function(t4, e4) {
          const r4 = (s3 = t4.getSource(), new Me(s3));
          var s3;
          return await r4.collect(e4), r4;
        }(r3, e3), n3 = we(t3.osFs, [t3.path]);
        return new Se(r3, s2.overlayMountsPrompt, s2.overlayMountsWorkflow, s2.overlayMountsContent, s2.overlayMountsLayouts, s2.overlayMountsStatics, s2.overlayMountsAssets, s2.overlayMountsI18n, n3);
      }(r2, e2);
    }
    async function Ya(t2, e2, r2, s2) {
      return async function(t3) {
        const e3 = new In(function(t4) {
          const e4 = new er({ style: "github", lineNos: false, lineNoStart: 1, anchorLineNos: false, lineAnchors: "", lineNumbersInTable: true, noClasses: true, codeFences: true, guessSyntax: false, tabWidth: 4 });
          return new Zr(t4, e4);
        }(t3.markdown())), r3 = await async function(t4) {
          const e4 = new bs(t4.defaultLanguage());
          try {
            await e4.setupTranslateFuncs(t4);
          } catch (t5) {
            Es.warn("Failed to setup translator, continuing without i18n support:", t5);
          }
          return e4;
        }(t3), s3 = new Fi(t3, t3, t3, null, null, new ki(t3.views(), t3), new _i(t3), new Mn(t3), new jn(t3), e3, null), n3 = new Nn(s3);
        s3.pageMapper = n3, n3.setupReverseIndex();
        const i2 = new kn(t3, e3, n3, r3);
        return s3.contentHub = i2, i2;
      }({ baseUrl: () => e2.getRoot().baseUrl(), markdown: () => s2, newFileMetaInfo: (e3) => t2.newFileMetaInfo(e3), newFileMetaInfoWithContent: (e3) => t2.newFileMetaInfoWithContent(e3), contentFs: () => t2.contentFs(), walkContent: (e3, r3, s3, n3) => t2.walkContent(e3, r3, s3, n3), walkI18n: (e3, r3, s3) => t2.walkI18n(e3, r3, s3), isLanguageValid: (t3) => e2.getLanguage().isLanguageValid(t3), getSourceLang: (t3) => r2.getSourceLang(t3), getLanguageIndex: (t3) => e2.getLanguage().getLanguageIndex(t3), getLanguageByIndex: (t3) => e2.getLanguage().getLanguageByIndex(t3), defaultLanguage: () => e2.getLanguage().defaultLanguage(), languageIndexes: () => e2.getLanguage().languageIndexes(), views: () => e2.getTaxonomy().getViews().map((t3) => {
        const e3 = t3.singular, r3 = t3.plural;
        return { singular: () => e3 || "", plural: () => r3 || "" };
      }) });
    }
    function Za(t2, e2) {
      return new ja({ assetsFs: () => e2.assetsFs(), publishFs: () => e2.publishFs(), baseUrl: () => t2.getProvider().getString("baseURL") || "http://localhost", executeTemplate: async (t3, e3, r2) => {
        throw new Error("Template execution not initialized. Please call resources.setTemplateSvc() first.");
      } });
    }
    async function Xa(t2, e2, r2, s2) {
      const n3 = function(t3, e3, r3) {
        const s3 = t3.getProvider().getString("baseURL") || "http://localhost";
        return { relURL: (t4) => e3.getURL().relURL(t4), absURL: (t4) => e3.getURL().absURL(t4, e3.isMultipleLanguage(), e3.languagePrefix()), urlize: (t4) => e3.getURL().urlize(t4), translate: (t4) => e3.translate(t4), relRefFrom: async (t4, e4) => [t4.path || "", null], title: () => t3.getProvider().getString("title") || "My Site", baseURL: () => s3, params: () => t3.getProvider().getParams("params"), menus: () => ({}), isMultiLanguage: () => t3.getLanguage().languageKeys().length > 1, version: () => "0.1.0", environment: () => "development", generator: () => "AuPro Static Site Generator", defaultLanguage: () => t3.getLanguage().defaultLanguage(), languageKeys: () => t3.getLanguage().languageKeys(), Get: async function(t4) {
          try {
            return await r3.getResource(t4);
          } catch (e4) {
            return Ga.warn(`Resource not found: ${t4}`, e4), Promise.resolve(null);
          }
        }, GetRemote: async function(t4) {
          return await r3.getRemote(t4);
        }, Minify: async function(t4) {
          return await r3.minify(t4);
        }, Fingerprint: async function(t4) {
          return await r3.fingerprint(t4);
        }, ExecuteAsTemplate: async function(t4, e4, s4) {
          return await r3.executeAsTemplate(s4, t4, e4);
        } };
      }(e2, r2, s2), i2 = { walk: t2.walkLayouts.bind(t2) };
      return await async function(t3, e3) {
        return new Ri().createWithServices(t3, e3);
      }(i2, n3);
    }
    async function Qa(t2, e2) {
      return { async lookupLayout(e3) {
        const [r2, s2, n3, i2] = await t2.findFirst(e3);
        return i2 ? { preparer: null, found: false } : n3 && r2 && s2 ? { preparer: { name: () => s2, execute: async (t3) => {
          const [e4, s3] = await r2.Execute(t3);
          if (s3)
            throw Ga.errorf("template exec error: %s", s3), s3;
          return e4;
        } }, found: true } : { preparer: null, found: false };
      }, async executeWithContext(t3, e3) {
        if (!t3)
          return "<html><body>Default template - no preparer</body></html>";
        try {
          return await t3.execute(e3);
        } catch (t4) {
          return Ga.error(`\u274C Template execution error: ${t4}`), `<html><body>Template execution error: ${t4}</body></html>`;
        }
      } };
    }
    async function to(t2, e2, r2) {
      return function(t3) {
        const e3 = new Ki(t3.publishFs()), r3 = new Xi(t3.baseUrl(), true), s2 = new ra(t3), n3 = new sa("MDFriday", "support@mdfriday.com"), i2 = new na(), a2 = new ia("0.1.0"), o2 = new Gi(t3, t3, t3, t3, t3, t3, e3, n3, i2, a2, r3, null, s2, null, t3.siteTitle()), h2 = function(t4, e4, r4) {
          return new la(t4, e4, r4);
        }(t3, t3, o2);
        return o2.navigation = h2.createNavigation(), o2.ref = new ta({ home: { page: null }, sitePage: async (t4) => {
          const e4 = await o2.sitePage(t4);
          return { relPermalink: () => e4.path ? e4.path() : "", permalink: () => e4.path ? e4.path() : "" };
        } }, t3, "/404.html"), o2;
      }({ configParams: () => t2.getProvider().getParams("params"), siteTitle: () => t2.getProvider().getString("title") || "My Site", menus: () => ({}), isGoogleAnalyticsEnabled: () => t2.getService().isGoogleAnalyticsEnabled(), googleAnalyticsID: () => t2.getService().googleAnalyticsID(), isGoogleAnalyticsRespectDoNotTrack: () => t2.getService().isGoogleAnalyticsRespectDoNotTrack(), isDisqusEnabled: () => t2.getService().isDisqusEnabled(), disqusShortname: () => t2.getService().disqusShortname(), isXRespectDoNotTrack: () => t2.getService().isXRespectDoNotTrack(), isXDisableInlineCSS: () => t2.getService().isXDisableInlineCSS(), getConfiguredSocialPlatforms: () => t2.getSocial().getConfiguredPlatforms(), getSocialLink: (e3) => {
        const r3 = t2.getSocial().getSocialLink(e3);
        return r3 ? r3.url : "";
      }, getSocialTitle: (e3) => {
        const r3 = t2.getSocial().getSocialLink(e3);
        return r3 ? r3.title : "";
      }, globalPages: async (t3) => await r2.globalPages(t3), globalRegularPages: async () => await r2.globalRegularPages(), walkPages: async (t3, e3) => {
        await r2.walkPages(t3, e3);
      }, getPageSources: async (t3) => r2.getPageSources(t3), walkTaxonomies: async (t3, e3) => {
        await r2.walkTaxonomies(t3, e3);
      }, searchPage: async (t3, e3) => [], getPageFromPath: async (t3, e3) => {
        try {
          const s2 = r2.getPageFromPath(t3, e3);
          return s2 || Ga.error(`\u26A0\uFE0F  Application.getPageFromPath: content domain returned null for path: "${e3}"`), s2;
        } catch (t4) {
          return Ga.error("\u274C Application.getPageFromPath error delegating to content domain:", t4), null;
        }
      }, getPageFromPathSync: (t3, e3) => {
        try {
          const s2 = r2.getPageFromPath(t3, e3);
          return s2 || Ga.warn(`\u26A0\uFE0F  Application.getPageFromPathSync: content domain returned null for path: ${e3}`), s2;
        } catch (t4) {
          return Ga.error("\u274C Application.getPageFromPathSync error delegating to content domain:", t4), null;
        }
      }, getPageRef: async (t3, e3, r3) => null, translate: (t3, e3) => r2.translate(t3, e3), defaultLanguage: () => t2.getLanguage().defaultLanguage(), languageKeys: () => t2.getLanguage().languageKeys(), getLanguageIndex: (e3) => t2.getLanguage().getLanguageIndex(e3), getLanguageName: (e3) => t2.getLanguage().getLanguageName(e3), changeFreq: () => "weekly", priority: () => 0.5, generateSitemap: async () => ({ urls: [] }), publishFs: () => e2.publishFs(), staticFs: () => e2.staticFs(), copyStaticFiles: (t3, r3) => e2.copyStatic([t3], r3), workingDir: () => t2.getProvider().getString("workingDir") || process.cwd(), getResource: async (t3) => null, getResourceWithOpener: async (t3, e3) => ({ name: () => t3, readSeekCloser: e3, targetPath: () => t3 }), baseUrl: () => t2.getProvider().getString("baseURL") || "http://localhost" });
    }
    async function eo(t2, e2, r2) {
      try {
        const s2 = process.cwd();
        process.chdir(t2);
        try {
          await async function(t3, e3, r3) {
            try {
              const s3 = await Ka(t3, e3), n3 = await async function(t4) {
                const e4 = { osFs: () => t4.fs(), projDir: () => t4.getDir().getWorkingDir(), moduleDir: () => t4.getDir().getThemesDir(), moduleCacheDir: () => t4.getDir().getThemesCacheDir(), importPaths: () => t4.getModule().importPaths(), defaultLanguageKey: () => t4.getLanguage().defaultLanguage(), otherLanguageKeys: () => t4.getLanguage().otherLanguageKeys(), getRelDir: (e5, r4) => t4.getLanguage().getRelDir(e5, r4) };
                return await async function(t5) {
                  try {
                    const e5 = t5.httpClient?.(), r4 = Pt(t5.osFs(), void 0, void 0, e5), s4 = Dt(t5.osFs()), n4 = Ct(t5.osFs(), t5.moduleCacheDir()), i3 = Vt(t5, r4, s4, n4);
                    return await i3.load(), i3;
                  } catch (t6) {
                    const e5 = t6 instanceof Error ? t6.message : String(t6);
                    throw Kt.error(`Failed to create modules: ${e5}`), new mt(`Failed to create modules: ${e5}`, "FACTORY_FAILED");
                  }
                }(e4);
              }(s3), i2 = await Ja(s3, n3), a2 = await Ya(i2, s3, n3, r3), o2 = await to(s3, i2, a2), h2 = Za(s3, i2), c2 = await Xa(i2, s3, o2, h2);
              h2.setTemplateSvc({ executeTemplate: async (t4, e4, r4) => await c2.executeRaw(t4, e4, r4) }), a2.setTemplateSvc({ execute: async (t4, e4) => await c2.executeShortcode(t4, e4) }), await a2.collectPages();
              const u2 = await Qa(c2);
              await o2.build(u2);
            } catch (t4) {
              const e4 = t4 instanceof Error ? t4.message : String(t4);
              throw Ga.error(`\u274C Static site generation failed: ${e4}`), new Error(`Failed to generate static site: ${e4}`);
            }
          }(t2, e2, r2);
        } finally {
          process.chdir(s2);
        }
      } catch (t3) {
        const e3 = t3 instanceof Error ? t3.message : String(t3);
        throw Ga.error(`\u274C SSG processing failed: ${e3}`), new Error(`Failed to process SSG: ${e3}`);
      }
    }
    async function ro(t2, e2, r2, s2, n3) {
      try {
        s2?.({ stage: "config", message: "Loading configuration...", percentage: 5 });
        const i2 = await Ka(t2, e2);
        s2?.({ stage: "modules", message: "Creating and downloading modules...", percentage: 10 });
        const a2 = await async function(t3, e3, r3) {
          const s3 = { osFs: () => t3.fs(), projDir: () => t3.getDir().getWorkingDir(), moduleDir: () => t3.getDir().getThemesDir(), moduleCacheDir: () => t3.getDir().getThemesCacheDir(), importPaths: () => t3.getModule().importPaths(), defaultLanguageKey: () => t3.getLanguage().defaultLanguage(), otherLanguageKeys: () => t3.getLanguage().otherLanguageKeys(), getRelDir: (e4, r4) => t3.getLanguage().getRelDir(e4, r4), httpClient: r3 ? () => r3 : void 0 };
          return await async function(t4, e4) {
            const r4 = e4 ? (t5) => {
              e4({ stage: "modules", message: `Downloading module: ${t5.modulePath}`, percentage: 10 + Math.floor(0.2 * t5.downloadPercentage), moduleDownload: { modulePath: t5.modulePath, downloadPercentage: t5.downloadPercentage } });
            } : void 0;
            return await async function(t5, e5) {
              try {
                const r5 = t5.httpClient?.(), s4 = Pt(t5.osFs(), void 0, void 0, r5), n4 = Dt(t5.osFs()), i3 = Ct(t5.osFs(), t5.moduleCacheDir()), a3 = Vt(t5, s4, n4, i3);
                return await a3.load(e5), a3;
              } catch (t6) {
                const e6 = t6 instanceof Error ? t6.message : String(t6);
                throw Kt.error(`Failed to create modules: ${e6}`), new mt(`Failed to create modules: ${e6}`, "FACTORY_FAILED");
              }
            }(t4, r4);
          }(s3, e3);
        }(i2, s2, n3);
        s2?.({ stage: "filesystem", message: "Creating filesystem...", percentage: 30 });
        const o2 = await Ja(i2, a2);
        s2?.({ stage: "content", message: "Creating content engine...", percentage: 40 });
        const h2 = await Ya(o2, i2, a2, r2);
        s2?.({ stage: "site", message: "Creating site...", percentage: 50 });
        const c2 = await to(i2, o2, h2), u2 = Za(i2, o2);
        s2?.({ stage: "template", message: "Creating template engine...", percentage: 60 });
        const l2 = await Xa(o2, i2, c2, u2);
        u2.setTemplateSvc({ executeTemplate: async (t3, e3, r3) => await l2.executeRaw(t3, e3, r3) }), h2.setTemplateSvc({ execute: async (t3, e3) => await l2.executeShortcode(t3, e3) }), s2?.({ stage: "pages", message: "Collecting pages...", percentage: 65 }), await h2.collectPages(), s2?.({ stage: "build", message: "Building site...", percentage: 70 });
        const f2 = await Qa(l2);
        return await async function(t3, e3, r3) {
          const s3 = r3 ? (t4) => {
            const e4 = 70 + Math.floor(t4.currentPage / t4.totalPages * 29);
            r3({ stage: "build", message: `Rendering pages (${t4.currentPage}/${t4.totalPages})...`, percentage: e4, pageRender: t4 });
          } : void 0;
          await t3.buildWithProgress(e3, s3);
        }(c2, f2, s2), s2?.({ stage: "completion", message: "SSG generation completed", percentage: 100 }), Va(c2, h2, o2, i2, a2, u2);
      } catch (t3) {
        const e3 = t3 instanceof Error ? t3.message : String(t3);
        throw Ga.error(`\u274C Static site generation failed: ${e3}`), new Error(`Failed to generate static site: ${e3}`);
      }
    }
    async function so(t2, e2, r2, s2, n3) {
      try {
        const i2 = process.cwd();
        process.chdir(t2);
        try {
          await ro(t2, e2, r2, s2, n3);
        } finally {
          process.chdir(i2);
        }
      } catch (t3) {
        const e3 = t3 instanceof Error ? t3.message : String(t3);
        throw Ga.error(`\u274C SSG processing failed: ${e3}`), new Error(`Failed to process SSG: ${e3}`);
      }
    }
    q();
    var no = p(require_chokidar());
    var io = p(require("path"));
    q();
    var ao = A("web", { component: "content-file-watcher" });
    var oo = class {
      constructor(t2) {
        __publicField(this, "watcher", null);
        __publicField(this, "eventQueue", []);
        __publicField(this, "batchTimer", null);
        __publicField(this, "batchDelay");
        __publicField(this, "callbacks", []);
        this.config = t2, this.batchDelay = t2.batchDelay || 500;
      }
      async startWatching() {
        this.watcher && await this.stopWatching(), this.watcher = no.watch(this.config.contentDirs, { ignored: [/(^|[\/\\])\../, /\.tmp$/, /\.swp$/, /~$/, /\.DS_Store$/, ...this.config.ignorePatterns || []], persistent: true, ignoreInitial: true, followSymlinks: true, awaitWriteFinish: { stabilityThreshold: 100, pollInterval: 50 } }), this.watcher.on("add", (t2) => this.queueEvent(t2, "created")).on("change", (t2) => this.queueEvent(t2, "modified")).on("unlink", (t2) => this.queueEvent(t2, "deleted")).on("error", (t2) => {
          ao.error("File watcher error:", t2);
        });
      }
      onFileChange(t2) {
        this.callbacks.push(t2);
      }
      queueEvent(t2, e2) {
        let r2 = t2;
        const { projContentDirs: s2, contentDirs: n3 } = this.config;
        for (let t3 = 0; t3 < s2.length; t3++) {
          const e3 = s2[t3];
          for (let t4 = 0; t4 < n3.length; t4++) {
            const s3 = n3[t4];
            if (e3 !== s3 && r2.startsWith(s3)) {
              r2 = e3 + r2.slice(s3.length);
              break;
            }
          }
        }
        const i2 = io.normalize(r2);
        if (!this.isRelevantFile(i2))
          return;
        const a2 = { filePath: i2, eventType: e2, timestamp: Date.now(), isMarkdown: this.isMarkdownFile(i2), isImage: this.isImageFile(i2) };
        this.eventQueue.push(a2), this.scheduleBatch();
      }
      isRelevantFile(t2) {
        return this.isMarkdownFile(t2) || this.isImageFile(t2);
      }
      isMarkdownFile(t2) {
        const e2 = io.extname(t2).toLowerCase();
        return e2 === ".md" || e2 === ".markdown";
      }
      isImageFile(t2) {
        const e2 = io.extname(t2).toLowerCase();
        return [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp", ".bmp"].includes(e2);
      }
      scheduleBatch() {
        this.batchTimer && clearTimeout(this.batchTimer), this.batchTimer = setTimeout(async () => {
          if (this.eventQueue.length > 0) {
            const t2 = this.deduplicateEvents(this.eventQueue);
            this.eventQueue = [];
            for (const e2 of this.callbacks)
              try {
                await e2(t2);
              } catch (t3) {
                ao.error("Error processing file change events:", t3);
              }
          }
        }, this.batchDelay);
      }
      deduplicateEvents(t2) {
        const e2 = /* @__PURE__ */ new Map();
        for (const r2 of t2) {
          const t3 = e2.get(r2.filePath);
          (!t3 || r2.timestamp > t3.timestamp) && e2.set(r2.filePath, r2);
        }
        return Array.from(e2.values());
      }
      async stopWatching() {
        this.batchTimer && (clearTimeout(this.batchTimer), this.batchTimer = null), this.watcher && (await this.watcher.close(), this.watcher = null), this.eventQueue = [], this.callbacks = [];
      }
    };
    var ho = p(require("http"));
    var co = p(require("path"));
    var uo = p(require("fs/promises"));
    var lo = require_browser();
    q();
    var fo = A("web", { component: "livereload-server" });
    var wo = class {
      constructor(t2) {
        __publicField(this, "httpServer", null);
        __publicField(this, "wsServer", null);
        __publicField(this, "clients", /* @__PURE__ */ new Set());
        __publicField(this, "running", false);
        __publicField(this, "config");
        this.config = { port: t2.port || 8091, host: t2.host || "localhost", livereloadPort: t2.livereloadPort || 35729, enableLiveReload: t2.enableLiveReload !== false, publicDir: t2.publicDir };
      }
      async start() {
        if (this.running)
          fo.warn("LiveReloadServer already running");
        else
          try {
            await this.startHttpServer(), this.config.enableLiveReload && await this.startLiveReloadServer(), this.running = true;
          } catch (t2) {
            throw fo.error("Failed to start LiveReloadServer:", t2), t2;
          }
      }
      async stop() {
        if (this.running)
          try {
            for (const t2 of this.clients)
              t2.close();
            this.clients.clear(), this.wsServer && (this.wsServer.close(), this.wsServer = null), this.httpServer && (await new Promise((t2) => {
              this.httpServer.close(() => t2());
            }), this.httpServer = null), this.running = false;
          } catch (t2) {
            fo.error("Error stopping LiveReloadServer:", t2);
          }
      }
      notifyReload(t2) {
        if (!this.config.enableLiveReload || this.clients.size === 0)
          return;
        const e2 = { command: "reload", liveCSS: this.shouldLiveReloadCSS(t2), liveImg: this.shouldLiveReloadImages(t2) };
        if (t2 && t2.length === 1) {
          const r3 = t2[0], s2 = co.extname(r3).toLowerCase();
          s2 === ".css" ? (e2.path = r3, e2.liveCSS = true) : [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"].includes(s2) && (e2.path = r3, e2.liveImg = true);
        }
        const r2 = JSON.stringify(e2);
        for (const t3 of this.clients)
          t3.readyState === lo.WebSocket.OPEN && t3.send(r2);
      }
      getUrl() {
        return `http://${this.config.host}:${this.config.port}`;
      }
      isServerRunning() {
        return this.running;
      }
      async startHttpServer() {
        this.httpServer = ho.createServer(async (t2, e2) => {
          try {
            await this.handleHttpRequest(t2, e2);
          } catch (t3) {
            fo.error("HTTP request error:", t3), e2.statusCode = 500, e2.end("Internal Server Error");
          }
        }), await new Promise((t2, e2) => {
          this.httpServer.listen(this.config.port, this.config.host, () => {
            t2();
          }), this.httpServer.on("error", (t3) => {
            t3.code === "EADDRINUSE" ? (this.config.port++, this.config.port < 8099 ? this.httpServer.listen(this.config.port, this.config.host) : e2(new Error("No available ports"))) : e2(t3);
          });
        });
      }
      async startLiveReloadServer() {
        this.wsServer = new lo.WebSocketServer({ port: this.config.livereloadPort, host: this.config.host }), this.wsServer.on("connection", (t2) => {
          this.clients.add(t2), t2.send(JSON.stringify({ command: "hello", protocols: ["http://livereload.com/protocols/official-7"], serverName: "foundry-livereload" })), t2.on("close", () => {
            this.clients.delete(t2);
          }), t2.on("message", (t3) => {
            try {
              JSON.parse(t3.toString());
            } catch (e2) {
              fo.error("Invalid LiveReload message:", t3.toString());
            }
          });
        }), this.wsServer.on("error", (t2) => {
          fo.error("LiveReload WebSocket server error:", t2);
        });
      }
      async handleHttpRequest(t2, e2) {
        const r2 = t2.url || "/";
        let s2 = this.resolveFilePath(r2);
        try {
          if ((await uo.stat(s2)).isDirectory()) {
            const t4 = co.join(s2, "index.html");
            try {
              await uo.stat(t4), s2 = t4;
            } catch {
              return e2.statusCode = 404, void e2.end("Not Found");
            }
          }
          let t3 = await uo.readFile(s2);
          const r3 = this.getContentType(s2);
          if (e2.setHeader("Content-Type", r3), r3.includes("text/html") && this.config.enableLiveReload) {
            const e3 = t3.toString(), r4 = this.getLiveReloadScript(), s3 = e3.replace(/<\/body>/i, `${r4}
</body>`);
            t3 = Buffer.from(s3, "utf8");
          }
          e2.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"), e2.setHeader("Pragma", "no-cache"), e2.setHeader("Expires", "0"), e2.statusCode = 200, e2.end(t3);
        } catch (t3) {
          if (t3.code !== "ENOENT")
            throw t3;
          e2.statusCode = 404, e2.end("Not Found");
        }
      }
      resolveFilePath(t2) {
        const e2 = t2.split("?")[0].split("#")[0];
        let r2;
        try {
          r2 = decodeURIComponent(e2);
        } catch (t3) {
          fo.warn("Failed to decode URL:", e2, t3), r2 = e2;
        }
        const s2 = co.normalize(r2).replace(/^(\.\.[\/\\])+/, ""), n3 = s2.startsWith("/") ? s2.slice(1) : s2, i2 = co.join(this.config.publicDir, n3);
        return process.platform === "win32" && i2.length > 260 && fo.warn("Path too long for Windows filesystem:", i2), process.platform === "win32" && /[<>:"|?*\x00-\x1f]/.test(n3) && fo.warn("Path contains invalid characters for Windows:", n3), i2;
      }
      getContentType(t2) {
        return { ".html": "text/html; charset=utf-8", ".css": "text/css; charset=utf-8", ".js": "application/javascript; charset=utf-8", ".json": "application/json; charset=utf-8", ".png": "image/png", ".jpg": "image/jpeg", ".jpeg": "image/jpeg", ".gif": "image/gif", ".svg": "image/svg+xml", ".webp": "image/webp", ".ico": "image/x-icon", ".woff": "font/woff", ".woff2": "font/woff2", ".ttf": "font/ttf", ".eot": "application/vnd.ms-fontobject", ".xml": "application/xml; charset=utf-8", ".txt": "text/plain; charset=utf-8" }[co.extname(t2).toLowerCase()] || "application/octet-stream";
      }
      getLiveReloadScript() {
        return `
<script>
(function() {
  'use strict';
  
  var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  var address = protocol + '//${this.config.host}:${this.config.livereloadPort}/livereload';
  var socket = new WebSocket(address);
  
  socket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    
    if (data.command === 'reload') {
      if (data.liveCSS) {
        // \u70ED\u66F4\u65B0 CSS
        reloadCSS();
      } else if (data.liveImg) {
        // \u70ED\u66F4\u65B0\u56FE\u7247
        reloadImages();
      } else {
        // \u5B8C\u6574\u9875\u9762\u5237\u65B0
        window.location.reload();
      }
    }
  };
  
  socket.onopen = function() {
    console.log('LiveReload connected');
  };
  
  socket.onclose = function() {
    console.log('LiveReload disconnected');
    // \u5C1D\u8BD5\u91CD\u8FDE
    setTimeout(function() {
      window.location.reload();
    }, 1000);
  };
  
  function reloadCSS() {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.href;
      if (href) {
        var url = new URL(href);
        url.searchParams.set('_t', Date.now().toString());
        link.href = url.toString();
      }
    }
    console.log('CSS reloaded');
  }
  
  function reloadImages() {
    var images = document.querySelectorAll('img');
    for (var i = 0; i < images.length; i++) {
      var img = images[i];
      var src = img.src;
      if (src) {
        var url = new URL(src);
        url.searchParams.set('_t', Date.now().toString());
        img.src = url.toString();
      }
    }
    console.log('Images reloaded');
  }
})();
<\/script>`;
      }
      shouldLiveReloadCSS(t2) {
        return !!t2 && t2.some((t3) => co.extname(t3).toLowerCase() === ".css");
      }
      shouldLiveReloadImages(t2) {
        if (!t2)
          return false;
        const e2 = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"];
        return t2.some((t3) => e2.includes(co.extname(t3).toLowerCase()));
      }
    };
    var go = p(require("http"));
    var po = p(require("path"));
    var mo = p(require("fs/promises"));
    q();
    var yo = A("web", { component: "electron-livereload-server" });
    var bo = class {
      constructor(t2) {
        __publicField(this, "httpServer", null);
        __publicField(this, "running", false);
        __publicField(this, "config");
        __publicField(this, "stateFilePath");
        this.config = { port: t2.port || 8091, host: t2.host || "localhost", livereloadPort: t2.livereloadPort || 35729, enableLiveReload: t2.enableLiveReload !== false, publicDir: t2.publicDir }, this.stateFilePath = po.join(this.config.publicDir, ".foundry-livereload-state.json");
      }
      async start() {
        if (this.running)
          yo.warn("ElectronLiveReloadServer already running");
        else
          try {
            await this.startHttpServer(), this.config.enableLiveReload && await this.initStateFile(), this.running = true, yo.info(`ElectronLiveReloadServer started at ${this.getUrl()}`);
          } catch (t2) {
            throw yo.error("Failed to start ElectronLiveReloadServer:", t2), t2;
          }
      }
      async stop() {
        if (this.running)
          try {
            this.httpServer && (await new Promise((t2) => {
              this.httpServer.close(() => t2());
            }), this.httpServer = null);
            try {
              await mo.unlink(this.stateFilePath);
            } catch (t2) {
            }
            this.running = false, yo.info("ElectronLiveReloadServer stopped");
          } catch (t2) {
            yo.error("Error stopping ElectronLiveReloadServer:", t2);
          }
      }
      notifyReload(t2) {
        if (!this.config.enableLiveReload)
          return;
        const e2 = { timestamp: Date.now(), command: "reload", liveCSS: this.shouldLiveReloadCSS(t2), liveImg: this.shouldLiveReloadImages(t2), ...t2 && { changedFiles: t2 } };
        if (t2 && t2.length === 1) {
          const r2 = t2[0], s2 = po.extname(r2).toLowerCase();
          (s2 === ".css" || [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"].includes(s2)) && (e2.path = r2);
        }
        this.writeStateFile(e2).catch((t3) => {
          yo.error("Failed to write state file:", t3);
        });
      }
      getUrl() {
        return `http://${this.config.host}:${this.config.port}`;
      }
      isServerRunning() {
        return this.running;
      }
      async initStateFile() {
        const t2 = { timestamp: Date.now(), command: "hello" };
        await this.writeStateFile(t2);
      }
      async writeStateFile(t2) {
        try {
          await mo.writeFile(this.stateFilePath, JSON.stringify(t2), "utf8");
        } catch (t3) {
          yo.error("Failed to write LiveReload state file:", t3);
        }
      }
      async startHttpServer() {
        this.httpServer = go.createServer(async (t2, e2) => {
          try {
            await this.handleHttpRequest(t2, e2);
          } catch (t3) {
            yo.error("HTTP request error:", t3), e2.statusCode = 500, e2.end("Internal Server Error");
          }
        }), await new Promise((t2, e2) => {
          this.httpServer.listen(this.config.port, this.config.host, () => {
            t2();
          }), this.httpServer.on("error", (t3) => {
            t3.code === "EADDRINUSE" ? (this.config.port++, this.config.port < 8099 ? this.httpServer.listen(this.config.port, this.config.host) : e2(new Error("No available ports"))) : e2(t3);
          });
        });
      }
      async handleHttpRequest(t2, e2) {
        const r2 = t2.url || "/";
        if (r2.startsWith("/.foundry-livereload-state.json"))
          try {
            const t3 = await mo.readFile(this.stateFilePath, "utf8");
            return e2.setHeader("Content-Type", "application/json; charset=utf-8"), e2.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"), e2.setHeader("Pragma", "no-cache"), e2.setHeader("Expires", "0"), e2.statusCode = 200, void e2.end(t3);
          } catch (t3) {
            return void (t3.code === "ENOENT" ? (e2.statusCode = 404, e2.end("State file not found")) : (e2.statusCode = 500, e2.end("Internal Server Error")));
          }
        let s2 = this.resolveFilePath(r2);
        try {
          if ((await mo.stat(s2)).isDirectory()) {
            const t4 = po.join(s2, "index.html");
            try {
              await mo.stat(t4), s2 = t4;
            } catch {
              return e2.statusCode = 404, void e2.end("Not Found");
            }
          }
          let t3 = await mo.readFile(s2);
          const r3 = this.getContentType(s2);
          if (e2.setHeader("Content-Type", r3), r3.includes("text/html") && this.config.enableLiveReload) {
            const e3 = t3.toString(), r4 = this.getLiveReloadScript(), s3 = e3.replace(/<\/body>/i, `${r4}
</body>`);
            t3 = Buffer.from(s3, "utf8");
          }
          e2.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"), e2.setHeader("Pragma", "no-cache"), e2.setHeader("Expires", "0"), e2.statusCode = 200, e2.end(t3);
        } catch (t3) {
          if (t3.code !== "ENOENT")
            throw t3;
          e2.statusCode = 404, e2.end("Not Found");
        }
      }
      resolveFilePath(t2) {
        const e2 = t2.split("?")[0].split("#")[0];
        let r2;
        try {
          r2 = decodeURIComponent(e2);
        } catch (t3) {
          yo.warn("Failed to decode URL:", e2, t3), r2 = e2;
        }
        const s2 = po.normalize(r2).replace(/^(\.\.[\/\\])+/, ""), n3 = s2.startsWith("/") ? s2.slice(1) : s2;
        return po.join(this.config.publicDir, n3);
      }
      getContentType(t2) {
        return { ".html": "text/html; charset=utf-8", ".css": "text/css; charset=utf-8", ".js": "application/javascript; charset=utf-8", ".json": "application/json; charset=utf-8", ".png": "image/png", ".jpg": "image/jpeg", ".jpeg": "image/jpeg", ".gif": "image/gif", ".svg": "image/svg+xml", ".webp": "image/webp", ".ico": "image/x-icon", ".woff": "font/woff", ".woff2": "font/woff2", ".ttf": "font/ttf", ".eot": "application/vnd.ms-fontobject", ".xml": "application/xml; charset=utf-8", ".txt": "text/plain; charset=utf-8" }[po.extname(t2).toLowerCase()] || "application/octet-stream";
      }
      getLiveReloadScript() {
        return `
<script>
(function() {
  'use strict';
  
  var stateFilePath = '/.foundry-livereload-state.json';
  var storageKey = 'foundry-livereload-last-timestamp';
  var lastTimestamp = 0;
  var pollInterval = 500; // 500ms \u8F6E\u8BE2\u95F4\u9694
  
  // \u4ECE localStorage \u6062\u590D\u4E0A\u6B21\u7684\u65F6\u95F4\u6233\uFF0C\u907F\u514D\u9875\u9762\u5237\u65B0\u540E\u91CD\u590D\u89E6\u53D1
  try {
    var stored = localStorage.getItem(storageKey);
    if (stored) {
      lastTimestamp = parseInt(stored, 10) || 0;
    }
  } catch (error) {
    // localStorage \u53EF\u80FD\u4E0D\u53EF\u7528\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u503C
    console.warn('LiveReload: localStorage not available, may cause duplicate reloads');
  }
  
  function checkForReload() {
    fetch(stateFilePath + '?_t=' + Date.now(), { cache: 'no-cache' })
      .then(function(response) {
        if (!response.ok) {
          throw new Error('Failed to fetch state file');
        }
        return response.json();
      })
      .then(function(state) {
        if (state.timestamp > lastTimestamp) {
          // \u66F4\u65B0\u65F6\u95F4\u6233\u5E76\u4FDD\u5B58\u5230 localStorage
          lastTimestamp = state.timestamp;
          try {
            localStorage.setItem(storageKey, lastTimestamp.toString());
          } catch (error) {
            // localStorage \u5199\u5165\u5931\u8D25\uFF0C\u5FFD\u7565
          }
          
          if (state.command === 'reload') {
            if (state.liveCSS) {
              // \u70ED\u66F4\u65B0 CSS
              reloadCSS();
            } else if (state.liveImg) {
              // \u70ED\u66F4\u65B0\u56FE\u7247
              reloadImages();
            } else {
              // \u5B8C\u6574\u9875\u9762\u5237\u65B0
              window.location.reload();
            }
          }
        }
      })
      .catch(function(error) {
        // \u9759\u9ED8\u5904\u7406\u9519\u8BEF\uFF0C\u907F\u514D\u63A7\u5236\u53F0\u566A\u97F3
      });
  }
  
  function reloadCSS() {
    var links = document.querySelectorAll('link[rel="stylesheet"]');
    for (var i = 0; i < links.length; i++) {
      var link = links[i];
      var href = link.href;
      if (href) {
        var url = new URL(href);
        url.searchParams.set('_t', Date.now().toString());
        link.href = url.toString();
      }
    }
    console.log('CSS reloaded');
  }
  
  function reloadImages() {
    var images = document.querySelectorAll('img');
    for (var i = 0; i < images.length; i++) {
      var img = images[i];
      var src = img.src;
      if (src) {
        var url = new URL(src);
        url.searchParams.set('_t', Date.now().toString());
        img.src = url.toString();
      }
    }
    console.log('Images reloaded');
  }
  
  // \u5F00\u59CB\u8F6E\u8BE2
  setInterval(checkForReload, pollInterval);
  
  // \u521D\u59CB\u68C0\u67E5
  checkForReload();
})();
<\/script>`;
      }
      shouldLiveReloadCSS(t2) {
        return !!t2 && t2.some((t3) => po.extname(t3).toLowerCase() === ".css");
      }
      shouldLiveReloadImages(t2) {
        if (!t2)
          return false;
        const e2 = [".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp"];
        return t2.some((t3) => e2.includes(po.extname(t3).toLowerCase()));
      }
    };
    var Eo = A("build", { component: "incremental-coordinator" });
    var So = class {
      constructor(t2) {
        __publicField(this, "fileWatcher");
        __publicField(this, "liveReloadServer");
        __publicField(this, "buildInProgress", false);
        __publicField(this, "initialized", false);
        __publicField(this, "domainInstances");
        if (this.config = t2, t2.enableWatching) {
          const e2 = { contentDirs: t2.contentDirs, projContentDirs: t2.projContentDirs || t2.contentDirs, batchDelay: t2.batchDelay || 500 };
          this.fileWatcher = new oo(e2), this.fileWatcher.onFileChange((t3) => this.handleFileChanges(t3));
        }
        if (t2.liveReload?.enabled !== false) {
          const e2 = { port: t2.liveReload?.port || 8091, host: t2.liveReload?.host || "localhost", livereloadPort: t2.liveReload?.livereloadPort || 35729, publicDir: t2.publicDir, enableLiveReload: true };
          this.liveReloadServer = function(t3) {
            return function() {
              if (typeof globalThis != "undefined" && globalThis.window && globalThis.window.process && globalThis.window.process.type)
                return true;
              try {
                return require("electron"), true;
              } catch {
              }
              return !!(process.env.ELECTRON_RUN_AS_NODE || process.env.ELECTRON_NO_ATTACH_CONSOLE || process.versions && process.versions.electron);
            }() ? new bo(t3) : new wo(t3);
          }(e2);
        }
      }
      async initialize() {
        this.initialized ? Eo.warn("IncrementalBuildCoordinator already initialized") : (await this.performFullBuildAndCacheDomains(), this.initialized = true);
      }
      async performFullBuildAndCacheDomains() {
        try {
          this.domainInstances = await async function(t2, e2, r2, s2, n3) {
            try {
              return process.chdir(t2), await ro(t2, e2, r2, s2, n3);
            } catch (t3) {
              const e3 = t3 instanceof Error ? t3.message : String(t3);
              throw Ga.error(`\u274C SSG processing failed: ${e3}`), new Error(`Failed to process SSG: ${e3}`);
            }
          }(this.config.projDir, this.config.modulesDir, this.config.markdown, this.config.progressCallback, this.config.httpClient);
        } catch (t2) {
          throw Eo.error("Failed to perform full build and cache domains:", t2), t2;
        }
      }
      async startWatching() {
        if (!this.initialized)
          throw new Error("Must call initialize() before startWatching()");
        this.config.enableWatching && this.fileWatcher && await this.fileWatcher.startWatching(), this.liveReloadServer && await this.liveReloadServer.start();
      }
      async stopWatching() {
        this.fileWatcher && await this.fileWatcher.stopWatching(), this.liveReloadServer && await this.liveReloadServer.stop();
      }
      async handleFileChanges(t2) {
        if (this.buildInProgress)
          setTimeout(() => this.handleFileChanges(t2), 1e3);
        else
          try {
            if (this.buildInProgress = true, this.needFullRebuild(t2))
              return void await this.performFullRebuild(t2);
            await this.performIncrementalBuild(t2);
          } finally {
            this.buildInProgress = false;
          }
      }
      needFullRebuild(t2) {
        return t2.some((t3) => t3.eventType === "deleted" || t3.eventType === "created");
      }
      async performIncrementalBuild(t2) {
        if (!this.domainInstances)
          return Eo.error("Domain instances not available, falling back to full rebuild"), void await this.performFullRebuild(t2);
        try {
          const e2 = await this.domainInstances.fs.getFileMetaInfos(this.getEventsFilePaths(t2));
          if (await this.domainInstances.content.handleChangeFiles(e2), await this.domainInstances.site.renderAllLanguages(), this.liveReloadServer) {
            const e3 = t2.map((t3) => t3.filePath);
            this.liveReloadServer.notifyReload(e3);
          }
        } catch (e2) {
          Eo.error("Incremental build failed, falling back to full rebuild:", e2), await this.performFullRebuild(t2);
        }
      }
      getEventsFilePaths(t2) {
        return t2.map((t3) => t3.filePath);
      }
      async performFullRebuild(t2) {
        if (await so(this.config.projDir, this.config.modulesDir, this.config.markdown, (t3) => {
          Eo.info(`Rebuild progress: ${t3.stage} - ${t3.percentage}%`);
        }, this.config.httpClient), this.liveReloadServer) {
          const e2 = t2.map((t3) => t3.filePath);
          this.liveReloadServer.notifyReload(e2);
        }
      }
      isInitialized() {
        return this.initialized;
      }
      isBuildInProgress() {
        return this.buildInProgress;
      }
      getConfig() {
        return { ...this.config };
      }
      getServerUrl() {
        return this.liveReloadServer ? this.liveReloadServer.getUrl() : "";
      }
      getLiveReloadStatus() {
        if (!this.liveReloadServer)
          return { running: false };
        const t2 = this.liveReloadServer.isServerRunning();
        return { running: t2, ...t2 && { url: this.liveReloadServer.getUrl() } };
      }
    };
    async function vo(t2) {
      const e2 = new So(t2);
      return await e2.initialize(), t2.enableWatching && await e2.startWatching(), e2;
    }
    q(), A("build", { component: "incremental-ssg" });
  }
});

// node_modules/basic-ftp/dist/parseControlResponse.js
var require_parseControlResponse = __commonJS({
  "node_modules/basic-ftp/dist/parseControlResponse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.positiveIntermediate = exports2.positiveCompletion = exports2.isMultiline = exports2.isSingleLine = exports2.parseControlResponse = void 0;
    var LF = "\n";
    function parseControlResponse(text3) {
      const lines = text3.split(/\r?\n/).filter(isNotBlank);
      const messages = [];
      let startAt = 0;
      let tokenRegex;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!tokenRegex) {
          if (isMultiline(line)) {
            const token = line.substr(0, 3);
            tokenRegex = new RegExp(`^${token}(?:$| )`);
            startAt = i;
          } else if (isSingleLine(line)) {
            messages.push(line);
          }
        } else if (tokenRegex.test(line)) {
          tokenRegex = void 0;
          messages.push(lines.slice(startAt, i + 1).join(LF));
        }
      }
      const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : "";
      return { messages, rest };
    }
    exports2.parseControlResponse = parseControlResponse;
    function isSingleLine(line) {
      return /^\d\d\d(?:$| )/.test(line);
    }
    exports2.isSingleLine = isSingleLine;
    function isMultiline(line) {
      return /^\d\d\d-/.test(line);
    }
    exports2.isMultiline = isMultiline;
    function positiveCompletion(code) {
      return code >= 200 && code < 300;
    }
    exports2.positiveCompletion = positiveCompletion;
    function positiveIntermediate(code) {
      return code >= 300 && code < 400;
    }
    exports2.positiveIntermediate = positiveIntermediate;
    function isNotBlank(str) {
      return str.trim() !== "";
    }
  }
});

// node_modules/basic-ftp/dist/FtpContext.js
var require_FtpContext = __commonJS({
  "node_modules/basic-ftp/dist/FtpContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FTPContext = exports2.FTPError = void 0;
    var net_1 = require("net");
    var parseControlResponse_1 = require_parseControlResponse();
    var FTPError = class extends Error {
      constructor(res) {
        super(res.message);
        this.name = this.constructor.name;
        this.code = res.code;
      }
    };
    exports2.FTPError = FTPError;
    function doNothing() {
    }
    var FTPContext = class {
      constructor(timeout = 0, encoding = "utf8") {
        this.timeout = timeout;
        this.verbose = false;
        this.ipFamily = void 0;
        this.tlsOptions = {};
        this._partialResponse = "";
        this._encoding = encoding;
        this._socket = this.socket = this._newSocket();
        this._dataSocket = void 0;
      }
      close() {
        const message = this._task ? "User closed client during task" : "User closed client";
        const err = new Error(message);
        this.closeWithError(err);
      }
      closeWithError(err) {
        if (this._closingError) {
          return;
        }
        this._closingError = err;
        this._closeControlSocket();
        this._closeSocket(this._dataSocket);
        this._passToHandler(err);
        this._stopTrackingTask();
      }
      get closed() {
        return this.socket.remoteAddress === void 0 || this._closingError !== void 0;
      }
      reset() {
        this.socket = this._newSocket();
      }
      get socket() {
        return this._socket;
      }
      set socket(socket) {
        this.dataSocket = void 0;
        this.tlsOptions = {};
        this._partialResponse = "";
        if (this._socket) {
          const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;
          if (newSocketUpgradesExisting) {
            this._removeSocketListeners(this.socket);
          } else {
            this._closeControlSocket();
          }
        }
        if (socket) {
          this._closingError = void 0;
          socket.setTimeout(0);
          socket.setEncoding(this._encoding);
          socket.setKeepAlive(true);
          socket.on("data", (data) => this._onControlSocketData(data));
          socket.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")));
          socket.on("close", (hadError) => {
            if (!hadError)
              this.closeWithError(new Error("Server closed connection unexpectedly."));
          });
          this._setupDefaultErrorHandlers(socket, "control socket");
        }
        this._socket = socket;
      }
      get dataSocket() {
        return this._dataSocket;
      }
      set dataSocket(socket) {
        this._closeSocket(this._dataSocket);
        if (socket) {
          socket.setTimeout(0);
          this._setupDefaultErrorHandlers(socket, "data socket");
        }
        this._dataSocket = socket;
      }
      get encoding() {
        return this._encoding;
      }
      set encoding(encoding) {
        this._encoding = encoding;
        if (this.socket) {
          this.socket.setEncoding(encoding);
        }
      }
      send(command) {
        const containsPassword = command.startsWith("PASS");
        const message = containsPassword ? "> PASS ###" : `> ${command}`;
        this.log(message);
        this._socket.write(command + "\r\n", this.encoding);
      }
      request(command) {
        return this.handle(command, (res, task) => {
          if (res instanceof Error) {
            task.reject(res);
          } else {
            task.resolve(res);
          }
        });
      }
      handle(command, responseHandler) {
        if (this._task) {
          const err = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
          err.stack += `
Running task launched at: ${this._task.stack}`;
          this.closeWithError(err);
        }
        return new Promise((resolveTask, rejectTask) => {
          this._task = {
            stack: new Error().stack || "Unknown call stack",
            responseHandler,
            resolver: {
              resolve: (arg) => {
                this._stopTrackingTask();
                resolveTask(arg);
              },
              reject: (err) => {
                this._stopTrackingTask();
                rejectTask(err);
              }
            }
          };
          if (this._closingError) {
            const err = new Error(`Client is closed because ${this._closingError.message}`);
            err.stack += `
Closing reason: ${this._closingError.stack}`;
            err.code = this._closingError.code !== void 0 ? this._closingError.code : "0";
            this._passToHandler(err);
            return;
          }
          this.socket.setTimeout(this.timeout);
          if (command) {
            this.send(command);
          }
        });
      }
      log(message) {
        if (this.verbose) {
          console.log(message);
        }
      }
      get hasTLS() {
        return "encrypted" in this._socket;
      }
      _stopTrackingTask() {
        this.socket.setTimeout(0);
        this._task = void 0;
      }
      _onControlSocketData(chunk) {
        this.log(`< ${chunk}`);
        const completeResponse = this._partialResponse + chunk;
        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);
        this._partialResponse = parsed.rest;
        for (const message of parsed.messages) {
          const code = parseInt(message.substr(0, 3), 10);
          const response = { code, message };
          const err = code >= 400 ? new FTPError(response) : void 0;
          this._passToHandler(err ? err : response);
        }
      }
      _passToHandler(response) {
        if (this._task) {
          this._task.responseHandler(response, this._task.resolver);
        }
      }
      _setupDefaultErrorHandlers(socket, identifier) {
        socket.once("error", (error) => {
          error.message += ` (${identifier})`;
          this.closeWithError(error);
        });
        socket.once("close", (hadError) => {
          if (hadError) {
            this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));
          }
        });
        socket.once("timeout", () => {
          socket.destroy();
          this.closeWithError(new Error(`Timeout (${identifier})`));
        });
      }
      _closeControlSocket() {
        this._removeSocketListeners(this._socket);
        this._socket.on("error", doNothing);
        this.send("QUIT");
        this._closeSocket(this._socket);
      }
      _closeSocket(socket) {
        if (socket) {
          this._removeSocketListeners(socket);
          socket.on("error", doNothing);
          socket.destroy();
        }
      }
      _removeSocketListeners(socket) {
        socket.removeAllListeners();
        socket.removeAllListeners("timeout");
        socket.removeAllListeners("data");
        socket.removeAllListeners("end");
        socket.removeAllListeners("error");
        socket.removeAllListeners("close");
        socket.removeAllListeners("connect");
      }
      _newSocket() {
        return new net_1.Socket();
      }
    };
    exports2.FTPContext = FTPContext;
  }
});

// node_modules/basic-ftp/dist/FileInfo.js
var require_FileInfo = __commonJS({
  "node_modules/basic-ftp/dist/FileInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileInfo = exports2.FileType = void 0;
    var FileType;
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 3] = "SymbolicLink";
    })(FileType || (exports2.FileType = FileType = {}));
    var FileInfo = class {
      constructor(name) {
        this.name = name;
        this.type = FileType.Unknown;
        this.size = 0;
        this.rawModifiedAt = "";
        this.modifiedAt = void 0;
        this.permissions = void 0;
        this.hardLinkCount = void 0;
        this.link = void 0;
        this.group = void 0;
        this.user = void 0;
        this.uniqueID = void 0;
        this.name = name;
      }
      get isDirectory() {
        return this.type === FileType.Directory;
      }
      get isSymbolicLink() {
        return this.type === FileType.SymbolicLink;
      }
      get isFile() {
        return this.type === FileType.File;
      }
      get date() {
        return this.rawModifiedAt;
      }
      set date(rawModifiedAt) {
        this.rawModifiedAt = rawModifiedAt;
      }
    };
    exports2.FileInfo = FileInfo;
    FileInfo.UnixPermission = {
      Read: 4,
      Write: 2,
      Execute: 1
    };
  }
});

// node_modules/basic-ftp/dist/parseListDOS.js
var require_parseListDOS = __commonJS({
  "node_modules/basic-ftp/dist/parseListDOS.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformList = exports2.parseLine = exports2.testLine = void 0;
    var FileInfo_1 = require_FileInfo();
    var RE_LINE = new RegExp("(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)");
    function testLine(line) {
      return /^\d{2}/.test(line) && RE_LINE.test(line);
    }
    exports2.testLine = testLine;
    function parseLine(line) {
      const groups = line.match(RE_LINE);
      if (groups === null) {
        return void 0;
      }
      const name = groups[5];
      if (name === "." || name === "..") {
        return void 0;
      }
      const file = new FileInfo_1.FileInfo(name);
      const fileType = groups[3];
      if (fileType === "<DIR>") {
        file.type = FileInfo_1.FileType.Directory;
        file.size = 0;
      } else {
        file.type = FileInfo_1.FileType.File;
        file.size = parseInt(groups[4], 10);
      }
      file.rawModifiedAt = groups[1] + " " + groups[2];
      return file;
    }
    exports2.parseLine = parseLine;
    function transformList(files) {
      return files;
    }
    exports2.transformList = transformList;
  }
});

// node_modules/basic-ftp/dist/parseListUnix.js
var require_parseListUnix = __commonJS({
  "node_modules/basic-ftp/dist/parseListUnix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transformList = exports2.parseLine = exports2.testLine = void 0;
    var FileInfo_1 = require_FileInfo();
    var JA_MONTH = "\u6708";
    var JA_DAY = "\u65E5";
    var JA_YEAR = "\u5E74";
    var RE_LINE = new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}" + JA_MONTH + "\\s+\\d{1,2}" + JA_DAY + "))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}" + JA_YEAR + "))\\s(.*)");
    function testLine(line) {
      return RE_LINE.test(line);
    }
    exports2.testLine = testLine;
    function parseLine(line) {
      const groups = line.match(RE_LINE);
      if (groups === null) {
        return void 0;
      }
      const name = groups[21];
      if (name === "." || name === "..") {
        return void 0;
      }
      const file = new FileInfo_1.FileInfo(name);
      file.size = parseInt(groups[18], 10);
      file.user = groups[16];
      file.group = groups[17];
      file.hardLinkCount = parseInt(groups[15], 10);
      file.rawModifiedAt = groups[19] + " " + groups[20];
      file.permissions = {
        user: parseMode(groups[4], groups[5], groups[6]),
        group: parseMode(groups[8], groups[9], groups[10]),
        world: parseMode(groups[12], groups[13], groups[14])
      };
      switch (groups[1].charAt(0)) {
        case "d":
          file.type = FileInfo_1.FileType.Directory;
          break;
        case "e":
          file.type = FileInfo_1.FileType.SymbolicLink;
          break;
        case "l":
          file.type = FileInfo_1.FileType.SymbolicLink;
          break;
        case "b":
        case "c":
          file.type = FileInfo_1.FileType.File;
          break;
        case "f":
        case "-":
          file.type = FileInfo_1.FileType.File;
          break;
        default:
          file.type = FileInfo_1.FileType.Unknown;
      }
      if (file.isSymbolicLink) {
        const end = name.indexOf(" -> ");
        if (end !== -1) {
          file.name = name.substring(0, end);
          file.link = name.substring(end + 4);
        }
      }
      return file;
    }
    exports2.parseLine = parseLine;
    function transformList(files) {
      return files;
    }
    exports2.transformList = transformList;
    function parseMode(r, w, x) {
      let value2 = 0;
      if (r !== "-") {
        value2 += FileInfo_1.FileInfo.UnixPermission.Read;
      }
      if (w !== "-") {
        value2 += FileInfo_1.FileInfo.UnixPermission.Write;
      }
      const execToken = x.charAt(0);
      if (execToken !== "-" && execToken.toUpperCase() !== execToken) {
        value2 += FileInfo_1.FileInfo.UnixPermission.Execute;
      }
      return value2;
    }
  }
});

// node_modules/basic-ftp/dist/parseListMLSD.js
var require_parseListMLSD = __commonJS({
  "node_modules/basic-ftp/dist/parseListMLSD.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseMLSxDate = exports2.transformList = exports2.parseLine = exports2.testLine = void 0;
    var FileInfo_1 = require_FileInfo();
    function parseSize(value2, info) {
      info.size = parseInt(value2, 10);
    }
    var factHandlersByName = {
      "size": parseSize,
      "sizd": parseSize,
      "unique": (value2, info) => {
        info.uniqueID = value2;
      },
      "modify": (value2, info) => {
        info.modifiedAt = parseMLSxDate(value2);
        info.rawModifiedAt = info.modifiedAt.toISOString();
      },
      "type": (value2, info) => {
        if (value2.startsWith("OS.unix=slink")) {
          info.type = FileInfo_1.FileType.SymbolicLink;
          info.link = value2.substr(value2.indexOf(":") + 1);
          return 1;
        }
        switch (value2) {
          case "file":
            info.type = FileInfo_1.FileType.File;
            break;
          case "dir":
            info.type = FileInfo_1.FileType.Directory;
            break;
          case "OS.unix=symlink":
            info.type = FileInfo_1.FileType.SymbolicLink;
            break;
          case "cdir":
          case "pdir":
            return 2;
          default:
            info.type = FileInfo_1.FileType.Unknown;
        }
        return 1;
      },
      "unix.mode": (value2, info) => {
        const digits = value2.substr(-3);
        info.permissions = {
          user: parseInt(digits[0], 10),
          group: parseInt(digits[1], 10),
          world: parseInt(digits[2], 10)
        };
      },
      "unix.ownername": (value2, info) => {
        info.user = value2;
      },
      "unix.owner": (value2, info) => {
        if (info.user === void 0)
          info.user = value2;
      },
      get "unix.uid"() {
        return this["unix.owner"];
      },
      "unix.groupname": (value2, info) => {
        info.group = value2;
      },
      "unix.group": (value2, info) => {
        if (info.group === void 0)
          info.group = value2;
      },
      get "unix.gid"() {
        return this["unix.group"];
      }
    };
    function splitStringOnce(str, delimiter) {
      const pos2 = str.indexOf(delimiter);
      const a = str.substr(0, pos2);
      const b = str.substr(pos2 + delimiter.length);
      return [a, b];
    }
    function testLine(line) {
      return /^\S+=\S+;/.test(line) || line.startsWith(" ");
    }
    exports2.testLine = testLine;
    function parseLine(line) {
      const [packedFacts, name] = splitStringOnce(line, " ");
      if (name === "" || name === "." || name === "..") {
        return void 0;
      }
      const info = new FileInfo_1.FileInfo(name);
      const facts = packedFacts.split(";");
      for (const fact of facts) {
        const [factName, factValue] = splitStringOnce(fact, "=");
        if (!factValue) {
          continue;
        }
        const factHandler = factHandlersByName[factName.toLowerCase()];
        if (!factHandler) {
          continue;
        }
        const result = factHandler(factValue, info);
        if (result === 2) {
          return void 0;
        }
      }
      return info;
    }
    exports2.parseLine = parseLine;
    function transformList(files) {
      const nonLinksByID = /* @__PURE__ */ new Map();
      for (const file of files) {
        if (!file.isSymbolicLink && file.uniqueID !== void 0) {
          nonLinksByID.set(file.uniqueID, file);
        }
      }
      const resolvedFiles = [];
      for (const file of files) {
        if (file.isSymbolicLink && file.uniqueID !== void 0 && file.link === void 0) {
          const target = nonLinksByID.get(file.uniqueID);
          if (target !== void 0) {
            file.link = target.name;
          }
        }
        const isPartOfDirectory = !file.name.includes("/");
        if (isPartOfDirectory) {
          resolvedFiles.push(file);
        }
      }
      return resolvedFiles;
    }
    exports2.transformList = transformList;
    function parseMLSxDate(fact) {
      return new Date(Date.UTC(+fact.slice(0, 4), +fact.slice(4, 6) - 1, +fact.slice(6, 8), +fact.slice(8, 10), +fact.slice(10, 12), +fact.slice(12, 14), +fact.slice(15, 18)));
    }
    exports2.parseMLSxDate = parseMLSxDate;
  }
});

// node_modules/basic-ftp/dist/parseList.js
var require_parseList = __commonJS({
  "node_modules/basic-ftp/dist/parseList.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseList = void 0;
    var dosParser = __importStar(require_parseListDOS());
    var unixParser = __importStar(require_parseListUnix());
    var mlsdParser = __importStar(require_parseListMLSD());
    var availableParsers = [
      dosParser,
      unixParser,
      mlsdParser
    ];
    function firstCompatibleParser(line, parsers) {
      return parsers.find((parser) => parser.testLine(line) === true);
    }
    function isNotBlank(str) {
      return str.trim() !== "";
    }
    function isNotMeta(str) {
      return !str.startsWith("total");
    }
    var REGEX_NEWLINE = /\r?\n/;
    function parseList(rawList) {
      const lines = rawList.split(REGEX_NEWLINE).filter(isNotBlank).filter(isNotMeta);
      if (lines.length === 0) {
        return [];
      }
      const testLine = lines[lines.length - 1];
      const parser = firstCompatibleParser(testLine, availableParsers);
      if (!parser) {
        throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");
      }
      const files = lines.map(parser.parseLine).filter((info) => info !== void 0);
      return parser.transformList(files);
    }
    exports2.parseList = parseList;
  }
});

// node_modules/basic-ftp/dist/ProgressTracker.js
var require_ProgressTracker = __commonJS({
  "node_modules/basic-ftp/dist/ProgressTracker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressTracker = void 0;
    var ProgressTracker = class {
      constructor() {
        this.bytesOverall = 0;
        this.intervalMs = 500;
        this.onStop = noop2;
        this.onHandle = noop2;
      }
      reportTo(onHandle = noop2) {
        this.onHandle = onHandle;
      }
      start(socket, name, type) {
        let lastBytes = 0;
        this.onStop = poll(this.intervalMs, () => {
          const bytes = socket.bytesRead + socket.bytesWritten;
          this.bytesOverall += bytes - lastBytes;
          lastBytes = bytes;
          this.onHandle({
            name,
            type,
            bytes,
            bytesOverall: this.bytesOverall
          });
        });
      }
      stop() {
        this.onStop(false);
      }
      updateAndStop() {
        this.onStop(true);
      }
    };
    exports2.ProgressTracker = ProgressTracker;
    function poll(intervalMs, updateFunc) {
      const id = setInterval(updateFunc, intervalMs);
      const stopFunc = (stopWithUpdate) => {
        clearInterval(id);
        if (stopWithUpdate) {
          updateFunc();
        }
        updateFunc = noop2;
      };
      updateFunc();
      return stopFunc;
    }
    function noop2() {
    }
  }
});

// node_modules/basic-ftp/dist/StringWriter.js
var require_StringWriter = __commonJS({
  "node_modules/basic-ftp/dist/StringWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StringWriter = void 0;
    var stream_1 = require("stream");
    var StringWriter = class extends stream_1.Writable {
      constructor() {
        super(...arguments);
        this.buf = Buffer.alloc(0);
      }
      _write(chunk, _, callback) {
        if (chunk instanceof Buffer) {
          this.buf = Buffer.concat([this.buf, chunk]);
          callback(null);
        } else {
          callback(new Error("StringWriter expects chunks of type 'Buffer'."));
        }
      }
      getText(encoding) {
        return this.buf.toString(encoding);
      }
    };
    exports2.StringWriter = StringWriter;
  }
});

// node_modules/basic-ftp/dist/netUtils.js
var require_netUtils = __commonJS({
  "node_modules/basic-ftp/dist/netUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipIsPrivateV4Address = exports2.upgradeSocket = exports2.describeAddress = exports2.describeTLS = void 0;
    var tls_1 = require("tls");
    function describeTLS(socket) {
      if (socket instanceof tls_1.TLSSocket) {
        const protocol = socket.getProtocol();
        return protocol ? protocol : "Server socket or disconnected client socket";
      }
      return "No encryption";
    }
    exports2.describeTLS = describeTLS;
    function describeAddress(socket) {
      if (socket.remoteFamily === "IPv6") {
        return `[${socket.remoteAddress}]:${socket.remotePort}`;
      }
      return `${socket.remoteAddress}:${socket.remotePort}`;
    }
    exports2.describeAddress = describeAddress;
    function upgradeSocket(socket, options) {
      return new Promise((resolve, reject) => {
        const tlsOptions = Object.assign({}, options, {
          socket
        });
        const tlsSocket = (0, tls_1.connect)(tlsOptions, () => {
          const expectCertificate = tlsOptions.rejectUnauthorized !== false;
          if (expectCertificate && !tlsSocket.authorized) {
            reject(tlsSocket.authorizationError);
          } else {
            tlsSocket.removeAllListeners("error");
            resolve(tlsSocket);
          }
        }).once("error", (error) => {
          reject(error);
        });
      });
    }
    exports2.upgradeSocket = upgradeSocket;
    function ipIsPrivateV4Address(ip = "") {
      if (ip.startsWith("::ffff:")) {
        ip = ip.substr(7);
      }
      const octets = ip.split(".").map((o) => parseInt(o, 10));
      return octets[0] === 10 || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 || octets[0] === 192 && octets[1] === 168 || ip === "127.0.0.1";
    }
    exports2.ipIsPrivateV4Address = ipIsPrivateV4Address;
  }
});

// node_modules/basic-ftp/dist/transfer.js
var require_transfer = __commonJS({
  "node_modules/basic-ftp/dist/transfer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.downloadTo = exports2.uploadFrom = exports2.connectForPassiveTransfer = exports2.parsePasvResponse = exports2.enterPassiveModeIPv4 = exports2.parseEpsvResponse = exports2.enterPassiveModeIPv6 = void 0;
    var netUtils_1 = require_netUtils();
    var stream_1 = require("stream");
    var tls_1 = require("tls");
    var parseControlResponse_1 = require_parseControlResponse();
    async function enterPassiveModeIPv6(ftp2) {
      const res = await ftp2.request("EPSV");
      const port = parseEpsvResponse(res.message);
      if (!port) {
        throw new Error("Can't parse EPSV response: " + res.message);
      }
      const controlHost = ftp2.socket.remoteAddress;
      if (controlHost === void 0) {
        throw new Error("Control socket is disconnected, can't get remote address.");
      }
      await connectForPassiveTransfer(controlHost, port, ftp2);
      return res;
    }
    exports2.enterPassiveModeIPv6 = enterPassiveModeIPv6;
    function parseEpsvResponse(message) {
      const groups = message.match(/[|!]{3}(.+)[|!]/);
      if (groups === null || groups[1] === void 0) {
        throw new Error(`Can't parse response to 'EPSV': ${message}`);
      }
      const port = parseInt(groups[1], 10);
      if (Number.isNaN(port)) {
        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);
      }
      return port;
    }
    exports2.parseEpsvResponse = parseEpsvResponse;
    async function enterPassiveModeIPv4(ftp2) {
      const res = await ftp2.request("PASV");
      const target = parsePasvResponse(res.message);
      if (!target) {
        throw new Error("Can't parse PASV response: " + res.message);
      }
      const controlHost = ftp2.socket.remoteAddress;
      if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {
        target.host = controlHost;
      }
      await connectForPassiveTransfer(target.host, target.port, ftp2);
      return res;
    }
    exports2.enterPassiveModeIPv4 = enterPassiveModeIPv4;
    function parsePasvResponse(message) {
      const groups = message.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
      if (groups === null || groups.length !== 4) {
        throw new Error(`Can't parse response to 'PASV': ${message}`);
      }
      return {
        host: groups[1].replace(/,/g, "."),
        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
      };
    }
    exports2.parsePasvResponse = parsePasvResponse;
    function connectForPassiveTransfer(host, port, ftp2) {
      return new Promise((resolve, reject) => {
        let socket = ftp2._newSocket();
        const handleConnErr = function(err) {
          err.message = "Can't open data connection in passive mode: " + err.message;
          reject(err);
        };
        const handleTimeout = function() {
          socket.destroy();
          reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));
        };
        socket.setTimeout(ftp2.timeout);
        socket.on("error", handleConnErr);
        socket.on("timeout", handleTimeout);
        socket.connect({ port, host, family: ftp2.ipFamily }, () => {
          if (ftp2.socket instanceof tls_1.TLSSocket) {
            socket = (0, tls_1.connect)(Object.assign({}, ftp2.tlsOptions, {
              socket,
              session: ftp2.socket.getSession()
            }));
          }
          socket.removeListener("error", handleConnErr);
          socket.removeListener("timeout", handleTimeout);
          ftp2.dataSocket = socket;
          resolve();
        });
      });
    }
    exports2.connectForPassiveTransfer = connectForPassiveTransfer;
    var TransferResolver = class {
      constructor(ftp2, progress) {
        this.ftp = ftp2;
        this.progress = progress;
        this.response = void 0;
        this.dataTransferDone = false;
      }
      onDataStart(name, type) {
        if (this.ftp.dataSocket === void 0) {
          throw new Error("Data transfer should start but there is no data connection.");
        }
        this.ftp.socket.setTimeout(0);
        this.ftp.dataSocket.setTimeout(this.ftp.timeout);
        this.progress.start(this.ftp.dataSocket, name, type);
      }
      onDataDone(task) {
        this.progress.updateAndStop();
        this.ftp.socket.setTimeout(this.ftp.timeout);
        if (this.ftp.dataSocket) {
          this.ftp.dataSocket.setTimeout(0);
        }
        this.dataTransferDone = true;
        this.tryResolve(task);
      }
      onControlDone(task, response) {
        this.response = response;
        this.tryResolve(task);
      }
      onError(task, err) {
        this.progress.updateAndStop();
        this.ftp.socket.setTimeout(this.ftp.timeout);
        this.ftp.dataSocket = void 0;
        task.reject(err);
      }
      onUnexpectedRequest(response) {
        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);
        this.ftp.closeWithError(err);
      }
      tryResolve(task) {
        const canResolve = this.dataTransferDone && this.response !== void 0;
        if (canResolve) {
          this.ftp.dataSocket = void 0;
          task.resolve(this.response);
        }
      }
    };
    function uploadFrom(source, config) {
      const resolver = new TransferResolver(config.ftp, config.tracker);
      const fullCommand = `${config.command} ${config.remotePath}`;
      return config.ftp.handle(fullCommand, (res, task) => {
        if (res instanceof Error) {
          resolver.onError(task, res);
        } else if (res.code === 150 || res.code === 125) {
          const dataSocket = config.ftp.dataSocket;
          if (!dataSocket) {
            resolver.onError(task, new Error("Upload should begin but no data connection is available."));
            return;
          }
          const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== void 0 : true;
          onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
            config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);
            resolver.onDataStart(config.remotePath, config.type);
            (0, stream_1.pipeline)(source, dataSocket, (err) => {
              if (err) {
                resolver.onError(task, err);
              } else {
                resolver.onDataDone(task);
              }
            });
          });
        } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
          resolver.onControlDone(task, res);
        } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {
          resolver.onUnexpectedRequest(res);
        }
      });
    }
    exports2.uploadFrom = uploadFrom;
    function downloadTo(destination, config) {
      if (!config.ftp.dataSocket) {
        throw new Error("Download will be initiated but no data connection is available.");
      }
      const resolver = new TransferResolver(config.ftp, config.tracker);
      return config.ftp.handle(config.command, (res, task) => {
        if (res instanceof Error) {
          resolver.onError(task, res);
        } else if (res.code === 150 || res.code === 125) {
          const dataSocket = config.ftp.dataSocket;
          if (!dataSocket) {
            resolver.onError(task, new Error("Download should begin but no data connection is available."));
            return;
          }
          config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);
          resolver.onDataStart(config.remotePath, config.type);
          (0, stream_1.pipeline)(dataSocket, destination, (err) => {
            if (err) {
              resolver.onError(task, err);
            } else {
              resolver.onDataDone(task);
            }
          });
        } else if (res.code === 350) {
          config.ftp.send("RETR " + config.remotePath);
        } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
          resolver.onControlDone(task, res);
        } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {
          resolver.onUnexpectedRequest(res);
        }
      });
    }
    exports2.downloadTo = downloadTo;
    function onConditionOrEvent(condition, emitter, eventName, action) {
      if (condition === true) {
        action();
      } else {
        emitter.once(eventName, () => action());
      }
    }
  }
});

// node_modules/basic-ftp/dist/Client.js
var require_Client = __commonJS({
  "node_modules/basic-ftp/dist/Client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var fs_1 = require("fs");
    var path_1 = require("path");
    var tls_1 = require("tls");
    var util_1 = require("util");
    var FtpContext_1 = require_FtpContext();
    var parseList_1 = require_parseList();
    var ProgressTracker_1 = require_ProgressTracker();
    var StringWriter_1 = require_StringWriter();
    var parseListMLSD_1 = require_parseListMLSD();
    var netUtils_1 = require_netUtils();
    var transfer_1 = require_transfer();
    var parseControlResponse_1 = require_parseControlResponse();
    var fsReadDir = (0, util_1.promisify)(fs_1.readdir);
    var fsMkDir = (0, util_1.promisify)(fs_1.mkdir);
    var fsStat = (0, util_1.promisify)(fs_1.stat);
    var fsOpen = (0, util_1.promisify)(fs_1.open);
    var fsClose = (0, util_1.promisify)(fs_1.close);
    var fsUnlink = (0, util_1.promisify)(fs_1.unlink);
    var LIST_COMMANDS_DEFAULT = () => ["LIST -a", "LIST"];
    var LIST_COMMANDS_MLSD = () => ["MLSD", "LIST -a", "LIST"];
    var Client2 = class {
      constructor(timeout = 3e4) {
        this.availableListCommands = LIST_COMMANDS_DEFAULT();
        this.ftp = new FtpContext_1.FTPContext(timeout);
        this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);
        this.parseList = parseList_1.parseList;
        this._progressTracker = new ProgressTracker_1.ProgressTracker();
      }
      close() {
        this.ftp.close();
        this._progressTracker.stop();
      }
      get closed() {
        return this.ftp.closed;
      }
      connect(host = "localhost", port = 21) {
        this.ftp.reset();
        this.ftp.socket.connect({
          host,
          port,
          family: this.ftp.ipFamily
        }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
        return this._handleConnectResponse();
      }
      connectImplicitTLS(host = "localhost", port = 21, tlsOptions = {}) {
        this.ftp.reset();
        this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
        this.ftp.tlsOptions = tlsOptions;
        return this._handleConnectResponse();
      }
      _handleConnectResponse() {
        return this.ftp.handle(void 0, (res, task) => {
          if (res instanceof Error) {
            task.reject(res);
          } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
            task.resolve(res);
          } else {
            task.reject(new FtpContext_1.FTPError(res));
          }
        });
      }
      send(command, ignoreErrorCodesDEPRECATED = false) {
        if (ignoreErrorCodesDEPRECATED) {
          this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).");
          return this.sendIgnoringError(command);
        }
        return this.ftp.request(command);
      }
      sendIgnoringError(command) {
        return this.ftp.handle(command, (res, task) => {
          if (res instanceof FtpContext_1.FTPError) {
            task.resolve({ code: res.code, message: res.message });
          } else if (res instanceof Error) {
            task.reject(res);
          } else {
            task.resolve(res);
          }
        });
      }
      async useTLS(options = {}, command = "AUTH TLS") {
        const ret = await this.send(command);
        this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);
        this.ftp.tlsOptions = options;
        this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
        return ret;
      }
      login(user = "anonymous", password = "guest") {
        this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
        return this.ftp.handle("USER " + user, (res, task) => {
          if (res instanceof Error) {
            task.reject(res);
          } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
            task.resolve(res);
          } else if (res.code === 331) {
            this.ftp.send("PASS " + password);
          } else {
            task.reject(new FtpContext_1.FTPError(res));
          }
        });
      }
      async useDefaultSettings() {
        const features = await this.features();
        const supportsMLSD = features.has("MLST");
        this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();
        await this.send("TYPE I");
        await this.sendIgnoringError("STRU F");
        await this.sendIgnoringError("OPTS UTF8 ON");
        if (supportsMLSD) {
          await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;");
        }
        if (this.ftp.hasTLS) {
          await this.sendIgnoringError("PBSZ 0");
          await this.sendIgnoringError("PROT P");
        }
      }
      async access(options = {}) {
        var _a, _b;
        const useExplicitTLS = options.secure === true;
        const useImplicitTLS = options.secure === "implicit";
        let welcome;
        if (useImplicitTLS) {
          welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);
        } else {
          welcome = await this.connect(options.host, options.port);
        }
        if (useExplicitTLS) {
          const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};
          secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;
          await this.useTLS(secureOptions);
        }
        await this.sendIgnoringError("OPTS UTF8 ON");
        await this.login(options.user, options.password);
        await this.useDefaultSettings();
        return welcome;
      }
      async pwd() {
        const res = await this.send("PWD");
        const parsed = res.message.match(/"(.+)"/);
        if (parsed === null || parsed[1] === void 0) {
          throw new Error(`Can't parse response to command 'PWD': ${res.message}`);
        }
        return parsed[1];
      }
      async features() {
        const res = await this.sendIgnoringError("FEAT");
        const features = /* @__PURE__ */ new Map();
        if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {
          res.message.split("\n").slice(1, -1).forEach((line) => {
            const entry = line.trim().split(" ");
            features.set(entry[0], entry[1] || "");
          });
        }
        return features;
      }
      async cd(path8) {
        const validPath = await this.protectWhitespace(path8);
        return this.send("CWD " + validPath);
      }
      async cdup() {
        return this.send("CDUP");
      }
      async lastMod(path8) {
        const validPath = await this.protectWhitespace(path8);
        const res = await this.send(`MDTM ${validPath}`);
        const date = res.message.slice(4);
        return (0, parseListMLSD_1.parseMLSxDate)(date);
      }
      async size(path8) {
        const validPath = await this.protectWhitespace(path8);
        const command = `SIZE ${validPath}`;
        const res = await this.send(command);
        const size = parseInt(res.message.slice(4), 10);
        if (Number.isNaN(size)) {
          throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);
        }
        return size;
      }
      async rename(srcPath, destPath) {
        const validSrc = await this.protectWhitespace(srcPath);
        const validDest = await this.protectWhitespace(destPath);
        await this.send("RNFR " + validSrc);
        return this.send("RNTO " + validDest);
      }
      async remove(path8, ignoreErrorCodes = false) {
        const validPath = await this.protectWhitespace(path8);
        if (ignoreErrorCodes) {
          return this.sendIgnoringError(`DELE ${validPath}`);
        }
        return this.send(`DELE ${validPath}`);
      }
      trackProgress(handler) {
        this._progressTracker.bytesOverall = 0;
        this._progressTracker.reportTo(handler);
      }
      async uploadFrom(source, toRemotePath, options = {}) {
        return this._uploadWithCommand(source, toRemotePath, "STOR", options);
      }
      async appendFrom(source, toRemotePath, options = {}) {
        return this._uploadWithCommand(source, toRemotePath, "APPE", options);
      }
      async _uploadWithCommand(source, remotePath, command, options) {
        if (typeof source === "string") {
          return this._uploadLocalFile(source, remotePath, command, options);
        }
        return this._uploadFromStream(source, remotePath, command);
      }
      async _uploadLocalFile(localPath, remotePath, command, options) {
        const fd = await fsOpen(localPath, "r");
        const source = (0, fs_1.createReadStream)("", {
          fd,
          start: options.localStart,
          end: options.localEndInclusive,
          autoClose: false
        });
        try {
          return await this._uploadFromStream(source, remotePath, command);
        } finally {
          await ignoreError(() => fsClose(fd));
        }
      }
      async _uploadFromStream(source, remotePath, command) {
        const onError = (err) => this.ftp.closeWithError(err);
        source.once("error", onError);
        try {
          const validPath = await this.protectWhitespace(remotePath);
          await this.prepareTransfer(this.ftp);
          return await (0, transfer_1.uploadFrom)(source, {
            ftp: this.ftp,
            tracker: this._progressTracker,
            command,
            remotePath: validPath,
            type: "upload"
          });
        } finally {
          source.removeListener("error", onError);
        }
      }
      async downloadTo(destination, fromRemotePath, startAt = 0) {
        if (typeof destination === "string") {
          return this._downloadToFile(destination, fromRemotePath, startAt);
        }
        return this._downloadToStream(destination, fromRemotePath, startAt);
      }
      async _downloadToFile(localPath, remotePath, startAt) {
        const appendingToLocalFile = startAt > 0;
        const fileSystemFlags = appendingToLocalFile ? "r+" : "w";
        const fd = await fsOpen(localPath, fileSystemFlags);
        const destination = (0, fs_1.createWriteStream)("", {
          fd,
          start: startAt,
          autoClose: false
        });
        try {
          return await this._downloadToStream(destination, remotePath, startAt);
        } catch (err) {
          const localFileStats = await ignoreError(() => fsStat(localPath));
          const hasDownloadedData = localFileStats && localFileStats.size > 0;
          const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;
          if (shouldRemoveLocalFile) {
            await ignoreError(() => fsUnlink(localPath));
          }
          throw err;
        } finally {
          await ignoreError(() => fsClose(fd));
        }
      }
      async _downloadToStream(destination, remotePath, startAt) {
        const onError = (err) => this.ftp.closeWithError(err);
        destination.once("error", onError);
        try {
          const validPath = await this.protectWhitespace(remotePath);
          await this.prepareTransfer(this.ftp);
          return await (0, transfer_1.downloadTo)(destination, {
            ftp: this.ftp,
            tracker: this._progressTracker,
            command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,
            remotePath: validPath,
            type: "download"
          });
        } finally {
          destination.removeListener("error", onError);
          destination.end();
        }
      }
      async list(path8 = "") {
        const validPath = await this.protectWhitespace(path8);
        let lastError;
        for (const candidate of this.availableListCommands) {
          const command = validPath === "" ? candidate : `${candidate} ${validPath}`;
          await this.prepareTransfer(this.ftp);
          try {
            const parsedList = await this._requestListWithCommand(command);
            this.availableListCommands = [candidate];
            return parsedList;
          } catch (err) {
            const shouldTryNext = err instanceof FtpContext_1.FTPError;
            if (!shouldTryNext) {
              throw err;
            }
            lastError = err;
          }
        }
        throw lastError;
      }
      async _requestListWithCommand(command) {
        const buffer = new StringWriter_1.StringWriter();
        await (0, transfer_1.downloadTo)(buffer, {
          ftp: this.ftp,
          tracker: this._progressTracker,
          command,
          remotePath: "",
          type: "list"
        });
        const text3 = buffer.getText(this.ftp.encoding);
        this.ftp.log(text3);
        return this.parseList(text3);
      }
      async removeDir(remoteDirPath) {
        return this._exitAtCurrentDirectory(async () => {
          await this.cd(remoteDirPath);
          const absoluteDirPath = await this.pwd();
          await this.clearWorkingDir();
          const dirIsRoot = absoluteDirPath === "/";
          if (!dirIsRoot) {
            await this.cdup();
            await this.removeEmptyDir(absoluteDirPath);
          }
        });
      }
      async clearWorkingDir() {
        for (const file of await this.list()) {
          if (file.isDirectory) {
            await this.cd(file.name);
            await this.clearWorkingDir();
            await this.cdup();
            await this.removeEmptyDir(file.name);
          } else {
            await this.remove(file.name);
          }
        }
      }
      async uploadFromDir(localDirPath, remoteDirPath) {
        return this._exitAtCurrentDirectory(async () => {
          if (remoteDirPath) {
            await this.ensureDir(remoteDirPath);
          }
          return await this._uploadToWorkingDir(localDirPath);
        });
      }
      async _uploadToWorkingDir(localDirPath) {
        const files = await fsReadDir(localDirPath);
        for (const file of files) {
          const fullPath = (0, path_1.join)(localDirPath, file);
          const stats = await fsStat(fullPath);
          if (stats.isFile()) {
            await this.uploadFrom(fullPath, file);
          } else if (stats.isDirectory()) {
            await this._openDir(file);
            await this._uploadToWorkingDir(fullPath);
            await this.cdup();
          }
        }
      }
      async downloadToDir(localDirPath, remoteDirPath) {
        return this._exitAtCurrentDirectory(async () => {
          if (remoteDirPath) {
            await this.cd(remoteDirPath);
          }
          return await this._downloadFromWorkingDir(localDirPath);
        });
      }
      async _downloadFromWorkingDir(localDirPath) {
        await ensureLocalDirectory(localDirPath);
        for (const file of await this.list()) {
          const localPath = (0, path_1.join)(localDirPath, file.name);
          if (file.isDirectory) {
            await this.cd(file.name);
            await this._downloadFromWorkingDir(localPath);
            await this.cdup();
          } else if (file.isFile) {
            await this.downloadTo(localPath, file.name);
          }
        }
      }
      async ensureDir(remoteDirPath) {
        if (remoteDirPath.startsWith("/")) {
          await this.cd("/");
        }
        const names = remoteDirPath.split("/").filter((name) => name !== "");
        for (const name of names) {
          await this._openDir(name);
        }
      }
      async _openDir(dirName) {
        await this.sendIgnoringError("MKD " + dirName);
        await this.cd(dirName);
      }
      async removeEmptyDir(path8) {
        const validPath = await this.protectWhitespace(path8);
        return this.send(`RMD ${validPath}`);
      }
      async protectWhitespace(path8) {
        if (!path8.startsWith(" ")) {
          return path8;
        }
        const pwd = await this.pwd();
        const absolutePathPrefix = pwd.endsWith("/") ? pwd : pwd + "/";
        return absolutePathPrefix + path8;
      }
      async _exitAtCurrentDirectory(func) {
        const userDir = await this.pwd();
        try {
          return await func();
        } finally {
          if (!this.closed) {
            await ignoreError(() => this.cd(userDir));
          }
        }
      }
      _enterFirstCompatibleMode(strategies) {
        return async (ftp2) => {
          ftp2.log("Trying to find optimal transfer strategy...");
          let lastError = void 0;
          for (const strategy of strategies) {
            try {
              const res = await strategy(ftp2);
              ftp2.log("Optimal transfer strategy found.");
              this.prepareTransfer = strategy;
              return res;
            } catch (err) {
              lastError = err;
            }
          }
          throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);
        };
      }
      async upload(source, toRemotePath, options = {}) {
        this.ftp.log("Warning: upload() has been deprecated, use uploadFrom().");
        return this.uploadFrom(source, toRemotePath, options);
      }
      async append(source, toRemotePath, options = {}) {
        this.ftp.log("Warning: append() has been deprecated, use appendFrom().");
        return this.appendFrom(source, toRemotePath, options);
      }
      async download(destination, fromRemotePath, startAt = 0) {
        this.ftp.log("Warning: download() has been deprecated, use downloadTo().");
        return this.downloadTo(destination, fromRemotePath, startAt);
      }
      async uploadDir(localDirPath, remoteDirPath) {
        this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir().");
        return this.uploadFromDir(localDirPath, remoteDirPath);
      }
      async downloadDir(localDirPath) {
        this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir().");
        return this.downloadToDir(localDirPath);
      }
    };
    exports2.Client = Client2;
    async function ensureLocalDirectory(path8) {
      try {
        await fsStat(path8);
      } catch (err) {
        await fsMkDir(path8, { recursive: true });
      }
    }
    async function ignoreError(func) {
      try {
        return await func();
      } catch (err) {
        return void 0;
      }
    }
  }
});

// node_modules/basic-ftp/dist/StringEncoding.js
var require_StringEncoding = __commonJS({
  "node_modules/basic-ftp/dist/StringEncoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/basic-ftp/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/basic-ftp/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enterPassiveModeIPv6 = exports2.enterPassiveModeIPv4 = void 0;
    __exportStar(require_Client(), exports2);
    __exportStar(require_FtpContext(), exports2);
    __exportStar(require_FileInfo(), exports2);
    __exportStar(require_parseList(), exports2);
    __exportStar(require_StringEncoding(), exports2);
    var transfer_1 = require_transfer();
    Object.defineProperty(exports2, "enterPassiveModeIPv4", { enumerable: true, get: function() {
      return transfer_1.enterPassiveModeIPv4;
    } });
    Object.defineProperty(exports2, "enterPassiveModeIPv6", { enumerable: true, get: function() {
      return transfer_1.enterPassiveModeIPv6;
    } });
  }
});

// src/main.ts
var main_exports = {};
__export2(main_exports, {
  API_URL_DEV: () => API_URL_DEV,
  API_URL_PRO: () => API_URL_PRO,
  FRIDAY_ICON: () => FRIDAY_ICON,
  GetBaseUrl: () => GetBaseUrl,
  default: () => FridayPlugin2
});
module.exports = __toCommonJS2(main_exports);
var import_obsidian12 = require("obsidian");

// src/server.ts
var import_obsidian5 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text2(data) {
  return document.createTextNode(data);
}
function space() {
  return text2(" ");
}
function empty() {
  return text2("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value2) {
  if (value2 == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value2)
    node.setAttribute(attribute, value2);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text3, data) {
  data = "" + data;
  if (text3.data === data)
    return;
  text3.data = data;
}
function set_input_value(input, value2) {
  input.value = value2 == null ? "" : value2;
}
function set_style(node, key2, value2, important) {
  if (value2 == null) {
    node.style.removeProperty(key2);
  } else {
    node.style.setProperty(key2, value2, important ? "important" : "");
  }
}
function select_option(select, value2, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value2) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value2 !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n2 = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n2;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key2 = get_key(child_ctx);
    let block = lookup.get(key2);
    if (!block) {
      block = create_each_block2(key2, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key2, new_blocks[i] = block);
    if (key2 in old_indexes)
      deltas.set(key2, Math.abs(i - old_indexes[key2]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance5, create_fragment5, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
    const value2 = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value2)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value2);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment5 ? create_fragment5($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key2 in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key2]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/svelte/Server.svelte
var import_obsidian4 = require("obsidian");

// src/svelte/Info.svelte
function add_css(target) {
  append_styles(target, "svelte-1m52mn7", ".mdf-info.svelte-1m52mn7{font-size:0.9em;text-align:center}");
}
function create_fragment(ctx) {
  let div;
  let t0_value = ctx[0]("info.service_description") + "";
  let t0;
  let t1;
  let br0;
  let t2;
  let br1;
  let t3;
  let a;
  return {
    c() {
      div = element("div");
      t0 = text2(t0_value);
      t1 = space();
      br0 = element("br");
      t2 = space();
      br1 = element("br");
      t3 = space();
      a = element("a");
      a.innerHTML = `<img src="https://gohugo.net/mdfriday.svg" alt="MDFriday" width="20" height="20"/>`;
      attr(a, "href", "https://mdfriday.com");
      attr(a, "target", "_blank");
      attr(div, "class", "mdf-info svelte-1m52mn7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, br0);
      append(div, t2);
      append(div, br1);
      append(div, t3);
      append(div, a);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[0]("info.service_description") + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let t;
  var _a;
  let { plugin } = $$props;
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(0, t = ($$invalidate(2, _a = plugin === null || plugin === void 0 ? void 0 : plugin.i18n) === null || _a === void 0 ? void 0 : _a.t) || ((key2) => key2));
    }
  };
  return [t, plugin, _a];
}
var Info = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: 1 }, add_css);
  }
};
var Info_default = Info;

// src/svelte/Site.svelte
var import_obsidian3 = require("obsidian");

// src/svelte/ProgressBar.svelte
function add_css2(target) {
  append_styles(target, "svelte-9d941e", ".progress-container.svelte-9d941e{width:100%;background-color:#e0e0e0;border-radius:8px;height:10px;margin-top:10px;overflow:hidden;position:relative}.progress-bar.svelte-9d941e{height:10px;background-color:rgb(124 58 237);transition:width 0.4s ease;position:absolute;top:0;left:0}");
}
function create_fragment2(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "progress-bar svelte-9d941e");
      set_style(div0, "width", ctx[0] + "%");
      attr(div1, "class", "progress-container svelte-9d941e");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_style(div0, "width", ctx2[0] + "%");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { progress = 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
  };
  return [progress];
}
var ProgressBar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { progress: 0 }, add_css2);
  }
};
var ProgressBar_default = ProgressBar;

// src/svelte/Site.svelte
var path3 = __toESM2(require("path"));
var fs3 = __toESM2(require("fs"));
var import_foundry2 = __toESM2(require_dist3());
var import_jszip = __toESM2(require_jszip_min());

// src/markdown/base-renderer.ts
var import_obsidian = require("obsidian");
var import_foundry = __toESM2(require_dist3());

// src/markdown/obsidian-parser-result.ts
var ObsidianHeader = class {
  constructor(_text, _level, _id, _position) {
    this._text = _text;
    this._level = _level;
    this._id = _id;
    this._position = _position;
  }
  name() {
    return this._text;
  }
  level() {
    return this._level;
  }
  links() {
    return [];
  }
  paragraphs() {
    return [];
  }
  listParagraphs() {
    return [];
  }
  text() {
    return this._text;
  }
  id() {
    return this._id || this.generateId();
  }
  generateId() {
    return this._text.toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
  }
};
var ObsidianTocFragments = class {
  constructor(items) {
    this.items = items;
  }
  toHTML() {
    if (this.items.length === 0) {
      return "";
    }
    return `<nav class="table-of-contents">
${this.renderItems(this.items)}
</nav>`;
  }
  toMarkdown() {
    if (this.items.length === 0) {
      return "";
    }
    return this.renderMarkdownItems(this.items, 0);
  }
  isEmpty() {
    return this.items.length === 0;
  }
  getItems() {
    return [...this.items];
  }
  renderItems(items, level = 0) {
    if (items.length === 0)
      return "";
    const indent = "  ".repeat(level);
    let html = `${indent}<ul>
`;
    for (const item of items) {
      html += `${indent}  <li>
`;
      html += `${indent}    <a href="#${item.anchor}">${this.escapeHtml(item.text)}</a>
`;
      if (item.children.length > 0) {
        html += this.renderItems(item.children, level + 2);
      }
      html += `${indent}  </li>
`;
    }
    html += `${indent}</ul>
`;
    return html;
  }
  renderMarkdownItems(items, level) {
    let markdown = "";
    for (const item of items) {
      const indent = "  ".repeat(level);
      markdown += `${indent}- [${item.text}](#${item.anchor})
`;
      if (item.children.length > 0) {
        markdown += this.renderMarkdownItems(item.children, level + 1);
      }
    }
    return markdown;
  }
  escapeHtml(text3) {
    return text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
};
var ObsidianParsingResult = class {
  constructor(plugin, file, source) {
    this.plugin = plugin;
    this.file = file;
    this.source = source;
    this._headers = [];
    this.buildFromMetadata();
  }
  headers() {
    return [...this._headers];
  }
  tableOfContents() {
    return this._toc;
  }
  buildFromMetadata() {
    const metadata = this.plugin.app.metadataCache.getFileCache(this.file);
    if (metadata?.headings) {
      this._headers = this.buildHeaders(metadata.headings);
      this._toc = this.buildTableOfContents(metadata.headings);
    } else {
      this.parseFromSource();
    }
  }
  buildHeaders(headings) {
    return headings.map((heading) => {
      return new ObsidianHeader(heading.heading, heading.level, void 0, heading.position?.start ? {
        line: heading.position.start.line,
        ch: heading.position.start.col
      } : void 0);
    });
  }
  buildTableOfContents(headings) {
    const tocItems = this.buildTocItems(headings);
    return new ObsidianTocFragments(tocItems);
  }
  buildTocItems(headings) {
    const items = [];
    const stack = [];
    for (const heading of headings) {
      const tocItem = {
        text: heading.heading,
        level: heading.level,
        anchor: this.generateAnchor(heading.heading),
        children: []
      };
      while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
        stack.pop();
      }
      if (stack.length === 0) {
        items.push(tocItem);
      } else {
        stack[stack.length - 1].item.children.push(tocItem);
      }
      stack.push({ item: tocItem, level: heading.level });
    }
    return items;
  }
  generateAnchor(text3) {
    return text3.toLowerCase().replace(/[^\w\s\u4e00-\u9fff]/g, "").replace(/\s+/g, "-").replace(/^-+|-+$/g, "");
  }
  parseFromSource() {
    const lines = this.source.split("\n");
    const headings = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = line.match(/^(#{1,6})\s+(.+)$/);
      if (match) {
        const level = match[1].length;
        const text3 = match[2].trim();
        headings.push({
          text: text3,
          level,
          position: {
            start: { line: i, ch: 0 },
            end: { line: i, ch: line.length }
          }
        });
      }
    }
    this._headers = headings.map((heading) => new ObsidianHeader(heading.text, heading.level, void 0, heading.position?.start));
    const tocItems = this.buildTocItemsFromHeaders(headings);
    this._toc = new ObsidianTocFragments(tocItems);
  }
  buildTocItemsFromHeaders(headings) {
    const items = [];
    const stack = [];
    for (const heading of headings) {
      const tocItem = {
        text: heading.text,
        level: heading.level,
        anchor: heading.id || this.generateAnchor(heading.text),
        children: []
      };
      while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
        stack.pop();
      }
      if (stack.length === 0) {
        items.push(tocItem);
      } else {
        stack[stack.length - 1].item.children.push(tocItem);
      }
      stack.push({ item: tocItem, level: heading.level });
    }
    return items;
  }
  getFile() {
    return this.file;
  }
  getSource() {
    return this.source;
  }
  getMetadata() {
    return this.plugin.app.metadataCache.getFileCache(this.file);
  }
  getFlatHeaders() {
    return this._headers.map((header) => {
      const obsHeader = header;
      return {
        text: obsHeader.text(),
        level: header.level(),
        id: obsHeader.id()
      };
    });
  }
  getHeadersByLevel(level) {
    return this._headers.filter((header) => header.level() === level);
  }
  getHeadersInRange(minLevel, maxLevel) {
    return this._headers.filter((header) => {
      const headerLevel = header.level();
      return headerLevel >= minLevel && headerLevel <= maxLevel;
    });
  }
};

// src/markdown/resource-processor.ts
var path2 = __toESM2(require("path"));
var fs2 = __toESM2(require("fs"));
var ObsidianResourceProcessor = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  configureImageOutput(obImagesDir, sitePath, selectedFolderName) {
    this.obImagesDir = obImagesDir;
    this.sitePath = sitePath;
    this.selectedFolderName = selectedFolderName;
  }
  async processRelativeResources(html, basePath, options = {}) {
    const {
      processInternalLinks = true,
      processRelativePaths = true
    } = options;
    let processedHtml = html;
    if (processInternalLinks) {
      processedHtml = await this.processObsidianLinks(processedHtml, basePath);
    }
    if (processRelativePaths) {
      processedHtml = await this.processRelativePaths(processedHtml, basePath);
    }
    processedHtml = await this.processAppUrls(processedHtml);
    processedHtml = await this.processInternalLinks(processedHtml);
    return processedHtml;
  }
  async processAppUrls(html) {
    if (!this.obImagesDir || !this.sitePath) {
      return html;
    }
    const appUrlPattern = /<img([^>]*?)src=["'](app:\/\/[^"']+)["']([^>]*?)>/g;
    const matches = Array.from(html.matchAll(appUrlPattern));
    let processedHtml = html;
    for (const match of matches) {
      try {
        const [fullMatch, before, appUrl, after] = match;
        const urlParts = appUrl.match(/^app:\/\/[^\/]+(.+?)(?:\?.*)?$/);
        if (!urlParts || !urlParts[1]) {
          continue;
        }
        const imagePath = this.normalizeAppUrlPath(urlParts[1]);
        const imageName = path2.basename(imagePath);
        try {
          await fs2.promises.access(imagePath);
        } catch (error) {
          console.warn(`Image file not found: ${imagePath}`, error);
          continue;
        }
        const targetPath = path2.join(this.obImagesDir, imageName);
        try {
          await fs2.promises.copyFile(imagePath, targetPath);
        } catch (copyError) {
          console.error(`Failed to copy image: ${imagePath}`, copyError);
          continue;
        }
        const newSrc = path2.posix.join(this.sitePath, "ob-images", imageName);
        const newImgTag = `<img${before}src="${newSrc}"${after}>`;
        processedHtml = processedHtml.replace(fullMatch, newImgTag);
      } catch (error) {
        console.error(`Error processing app:// URL:`, error);
      }
    }
    return processedHtml;
  }
  async processInternalLinks(html) {
    if (!this.sitePath || !this.selectedFolderName) {
      return html;
    }
    let processedHtml = html;
    const aTagPattern = /<a[^>]*data-href=["'](app:\/\/[^"']+)["'][^>]*>.*?<\/a>/g;
    const replacements = [];
    let match;
    while ((match = aTagPattern.exec(html)) !== null) {
      try {
        const fullATag = match[0];
        const dataHref = match[1];
        const urlParts = dataHref.match(/^app:\/\/[^\/]+(.+?)(?:\?.*)?$/);
        if (!urlParts || !urlParts[1]) {
          continue;
        }
        const fullPath = this.normalizeAppUrlPath(urlParts[1]);
        const folderPattern = path2.sep + this.selectedFolderName + path2.sep;
        const folderIndex = fullPath.indexOf(folderPattern);
        if (folderIndex === -1) {
          continue;
        }
        const relativePath = fullPath.substring(folderIndex + this.selectedFolderName.length + 2);
        const htmlPath = relativePath.replace(/\.md$/, ".html");
        const newHref = path2.posix.join(this.sitePath, htmlPath);
        const openTagMatch = fullATag.match(/^<a[^>]*>/);
        if (!openTagMatch) {
          continue;
        }
        const openTag = openTagMatch[0];
        const hrefMatch = openTag.match(/(?<!data-)href=["']([^"']+)["']/);
        if (hrefMatch) {
          const currentHref = hrefMatch[1];
          const newOpenTag = openTag.replace(/(?<!data-)href=["'][^"']*["']/, `href="${newHref}"`);
          const newFullATag = fullATag.replace(openTag, newOpenTag);
          replacements.push({
            original: fullATag,
            replacement: newFullATag
          });
        }
      } catch (error) {
        console.error("Error processing internal link:", error);
      }
    }
    for (const replacement of replacements) {
      processedHtml = processedHtml.replace(replacement.original, replacement.replacement);
    }
    return processedHtml;
  }
  async processObsidianLinks(html, basePath) {
    html = html.replace(/!\[\[([^\]]+)\]\]/g, (match, filename) => {
      const linkedFile = this.findLinkedFile(filename, basePath);
      if (linkedFile) {
        const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
        return `<img src="${resourcePath}" alt="${filename}">`;
      }
      return match;
    });
    html = html.replace(/(?<!!)\[\[([^\]]+)\]\]/g, (match, filename) => {
      const linkedFile = this.findLinkedFile(filename, basePath);
      if (linkedFile) {
        const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
        return `<a href="${resourcePath}">${filename}</a>`;
      }
      return match;
    });
    return html;
  }
  async processRelativePaths(html, basePath) {
    html = html.replace(/<img([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<img${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    html = html.replace(/<a([^>]*?)href=["']([^"']+)["']([^>]*?)>/g, (match, before, href, after) => {
      if (!this.isAbsoluteOrDataUrl(href)) {
        const linkedFile = this.findLinkedFile(href, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<a${before}href="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    return html;
  }
  findLinkedFile(filename, basePath) {
    if (basePath) {
      const linkedFile = this.plugin.app.metadataCache.getFirstLinkpathDest(filename, basePath);
      if (linkedFile) {
        return linkedFile;
      }
    }
    const files = this.plugin.app.vault.getFiles();
    let foundFile = files.find((file) => file.name === filename);
    if (foundFile) {
      return foundFile;
    }
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, "");
    foundFile = files.find((file) => {
      const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
      return fileNameWithoutExt === nameWithoutExt;
    });
    if (foundFile) {
      return foundFile;
    }
    foundFile = files.find((file) => file.path.includes(filename));
    if (foundFile) {
      return foundFile;
    }
    return null;
  }
  normalizeAppUrlPath(rawPath) {
    let normalizedPath = decodeURIComponent(rawPath);
    if (process.platform === "win32") {
      if (/^\/[A-Za-z]:/.test(normalizedPath)) {
        normalizedPath = normalizedPath.substring(1);
      } else if (/^\\[A-Za-z]:/.test(normalizedPath)) {
        normalizedPath = normalizedPath.substring(1);
      } else if (/^[\/\\]+[A-Za-z]:/.test(normalizedPath)) {
        normalizedPath = normalizedPath.replace(/^[\/\\]+/, "");
      }
    }
    normalizedPath = path2.normalize(normalizedPath);
    return normalizedPath;
  }
  isAbsoluteOrDataUrl(url) {
    return url.startsWith("http") || url.startsWith("https") || url.startsWith("data:") || url.startsWith("app://") || url.startsWith("file://") || url.startsWith("//");
  }
  async processAllResources(html, baseFile) {
    const basePath = baseFile?.path;
    let processedHtml = await this.processRelativeResources(html, basePath, {
      processInternalLinks: true,
      processRelativePaths: true
    });
    processedHtml = await this.processMediaElements(processedHtml, basePath);
    return processedHtml;
  }
  async processMediaElements(html, basePath) {
    html = html.replace(/<audio([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<audio${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    html = html.replace(/<video([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<video${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    html = html.replace(/<source([^>]*?)src=["']([^"']+)["']([^>]*?)>/g, (match, before, src, after) => {
      if (!this.isAbsoluteOrDataUrl(src)) {
        const linkedFile = this.findLinkedFile(src, basePath);
        if (linkedFile) {
          const resourcePath = this.plugin.app.vault.adapter.getResourcePath(linkedFile.path);
          return `<source${before}src="${resourcePath}"${after}>`;
        }
      }
      return match;
    });
    return html;
  }
  getResourcePath(file) {
    return this.plugin.app.vault.adapter.getResourcePath(file.path);
  }
  isMediaFile(file) {
    const mediaExtensions = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "svg",
      "webp",
      "bmp",
      "ico",
      "mp3",
      "wav",
      "ogg",
      "flac",
      "m4a",
      "aac",
      "mp4",
      "webm",
      "ogv",
      "mov",
      "avi",
      "mkv"
    ];
    const extension = file.extension.toLowerCase();
    return mediaExtensions.includes(extension);
  }
  getAllMediaFiles() {
    return this.plugin.app.vault.getFiles().filter((file) => this.isMediaFile(file));
  }
};

// src/markdown/dom-utils.ts
function analyzeRenderingComplexity(source) {
  const detectedPatterns = [];
  let complexity = "simple" /* SIMPLE */;
  let suggestedTimeout = 50;
  const simplePatterns = [
    { pattern: /^[^$\[\]`%<]*$/, name: "\u7EAF\u6587\u672C", timeout: 0 }
  ];
  const basicPatterns = [
    { pattern: /\*\*.*?\*\*/, name: "\u7C97\u4F53", timeout: 50 },
    { pattern: /\*.*?\*/, name: "\u659C\u4F53", timeout: 50 },
    { pattern: /`.*?`/, name: "\u884C\u5185\u4EE3\u7801", timeout: 50 },
    { pattern: /^#+\s/, name: "\u6807\u9898", timeout: 50 },
    { pattern: /^\s*[-*+]\s/, name: "\u5217\u8868", timeout: 100 }
  ];
  const complexPatterns = [
    { pattern: /```[\s\S]*?```/, name: "\u4EE3\u7801\u5757", timeout: 200 },
    { pattern: /!\[.*?\]\(.*?\)/, name: "\u56FE\u7247\u94FE\u63A5", timeout: 300 },
    { pattern: /\[.*?\]\(.*?\)/, name: "\u94FE\u63A5", timeout: 150 },
    { pattern: /\|.*\|/, name: "\u8868\u683C", timeout: 200 },
    { pattern: /\[\[.*?\]\]/, name: "\u5185\u90E8\u94FE\u63A5", timeout: 300 }
  ];
  const heavyPatterns = [
    { pattern: /\$\$[\s\S]*?\$\$/, name: "\u6570\u5B66\u516C\u5F0F\u5757", timeout: 800 },
    { pattern: /\$[^$\n]+\$/, name: "\u884C\u5185\u6570\u5B66\u516C\u5F0F", timeout: 400 },
    { pattern: /```mermaid[\s\S]*?```/, name: "Mermaid\u56FE\u8868", timeout: 1e3 },
    { pattern: /```dataview[\s\S]*?```/, name: "Dataview\u67E5\u8BE2", timeout: 1200 },
    { pattern: /```chart[\s\S]*?```/, name: "\u56FE\u8868\u63D2\u4EF6", timeout: 800 },
    { pattern: /%%.+%%/, name: "\u63D2\u4EF6\u6CE8\u91CA", timeout: 300 },
    { pattern: /<canvas/, name: "Canvas\u5143\u7D20", timeout: 600 },
    { pattern: /class=".*plugin.*"/, name: "\u63D2\u4EF6\u7C7B\u540D", timeout: 500 },
    { pattern: /data-.*plugin/, name: "\u63D2\u4EF6\u6570\u636E\u5C5E\u6027", timeout: 500 }
  ];
  for (const { pattern, name, timeout } of heavyPatterns) {
    if (pattern.test(source)) {
      detectedPatterns.push(name);
      complexity = "heavy" /* HEAVY */;
      suggestedTimeout = Math.max(suggestedTimeout, timeout);
    }
  }
  if (complexity === "simple" /* SIMPLE */) {
    for (const { pattern, name, timeout } of complexPatterns) {
      if (pattern.test(source)) {
        detectedPatterns.push(name);
        complexity = "complex" /* COMPLEX */;
        suggestedTimeout = Math.max(suggestedTimeout, timeout);
      }
    }
  }
  if (complexity === "simple" /* SIMPLE */) {
    for (const { pattern, name, timeout } of basicPatterns) {
      if (pattern.test(source)) {
        detectedPatterns.push(name);
        complexity = "basic" /* BASIC */;
        suggestedTimeout = Math.max(suggestedTimeout, timeout);
      }
    }
  }
  if (complexity === "simple" /* SIMPLE */) {
    for (const { pattern, name, timeout } of simplePatterns) {
      if (pattern.test(source)) {
        detectedPatterns.push(name);
        suggestedTimeout = timeout;
        break;
      }
    }
  }
  return { complexity, suggestedTimeout, patterns: detectedPatterns };
}
function hasAsyncElements(container) {
  const asyncSelectors = [
    ".math",
    ".mermaid",
    ".dataview",
    ".chart",
    "canvas",
    "[data-plugin]",
    ".cm-editor",
    ".obsidian-search-match-highlight",
    ".internal-link"
  ];
  return asyncSelectors.some((selector) => container.querySelector(selector) !== null);
}
function waitForDomStable(container, timeout = 300, source) {
  return new Promise((resolve) => {
    let timer = null;
    let changeCount = 0;
    const startTime = Date.now();
    if (source) {
      const analysis = analyzeRenderingComplexity(source);
      if (analysis.complexity === "simple" /* SIMPLE */) {
        resolve();
        return;
      }
      if (analysis.complexity === "basic" /* BASIC */) {
        timeout = Math.min(timeout, 100);
      } else {
        timeout = Math.min(analysis.suggestedTimeout, timeout);
      }
    }
    if (!hasAsyncElements(container)) {
      resolve();
      return;
    }
    let maxWaitTime = 2e3;
    if (source) {
      const analysis = analyzeRenderingComplexity(source);
      switch (analysis.complexity) {
        case "basic" /* BASIC */:
          maxWaitTime = 500;
          break;
        case "complex" /* COMPLEX */:
          maxWaitTime = 1500;
          break;
        case "heavy" /* HEAVY */:
          maxWaitTime = 3e3;
          break;
      }
    }
    const observer = new MutationObserver((mutations) => {
      changeCount++;
      const hasSignificantChange = mutations.some((mutation) => mutation.type === "childList" || mutation.type === "characterData" && mutation.target.textContent?.trim() || mutation.type === "attributes" && ["class", "style", "data-plugin", "data-rendered"].includes(mutation.attributeName || ""));
      if (!hasSignificantChange) {
        return;
      }
      if (timer)
        clearTimeout(timer);
      timer = setTimeout(() => {
        observer.disconnect();
        resolve();
      }, timeout);
    });
    observer.observe(container, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true,
      attributeFilter: ["class", "style", "data-plugin", "data-rendered"]
    });
    const maxTimer = setTimeout(() => {
      observer.disconnect();
      if (timer)
        clearTimeout(timer);
      resolve();
    }, maxWaitTime);
    timer = setTimeout(() => {
      observer.disconnect();
      clearTimeout(maxTimer);
      resolve();
    }, timeout);
  });
}
function createRenderContainer(theme, width = "1000px") {
  const container = document.createElement("div");
  container.addClass("markdown-preview-view", "markdown-rendered");
  const bodyClasses = document.body.className;
  if (bodyClasses.includes("theme-light") || bodyClasses.includes("theme-dark")) {
    container.className += " " + bodyClasses;
  }
  if (theme) {
    container.addClass(theme);
  }
  container.style.position = "absolute";
  container.style.top = "-9999px";
  container.style.left = "-9999px";
  container.style.width = width;
  container.style.visibility = "hidden";
  document.body.appendChild(container);
  return container;
}
function cleanupContainer(container) {
  try {
    if (container && container.parentNode) {
      container.parentNode.removeChild(container);
    }
  } catch (error) {
    console.warn("\u6E05\u7406\u5BB9\u5668\u65F6\u51FA\u9519:", error);
  }
}
function getCurrentTheme() {
  return document.body.classList.contains("theme-dark") ? "theme-dark" : "theme-light";
}
function waitForResourcesLoaded(container, timeout = 3e3) {
  return new Promise((resolve) => {
    const images = container.querySelectorAll("img");
    const videos = container.querySelectorAll("video");
    const iframes = container.querySelectorAll("iframe");
    const allElements = [...Array.from(images), ...Array.from(videos), ...Array.from(iframes)];
    if (allElements.length === 0) {
      resolve();
      return;
    }
    let loadedCount = 0;
    const totalCount = allElements.length;
    const checkComplete = () => {
      loadedCount++;
      if (loadedCount >= totalCount) {
        resolve();
      }
    };
    const timeoutId = setTimeout(() => {
      resolve();
    }, timeout);
    allElements.forEach((element2) => {
      if (element2 instanceof HTMLImageElement) {
        if (element2.complete) {
          checkComplete();
        } else {
          element2.addEventListener("load", () => {
            checkComplete();
          });
          element2.addEventListener("error", () => {
            checkComplete();
          });
        }
      } else if (element2 instanceof HTMLVideoElement) {
        if (element2.readyState >= 2) {
          checkComplete();
        } else {
          element2.addEventListener("loadeddata", () => {
            checkComplete();
          });
          element2.addEventListener("error", () => {
            checkComplete();
          });
        }
      } else if (element2 instanceof HTMLIFrameElement) {
        element2.addEventListener("load", () => {
          checkComplete();
        });
        element2.addEventListener("error", () => {
          checkComplete();
        });
      }
    });
    if (loadedCount >= totalCount) {
      clearTimeout(timeoutId);
    }
  });
}

// src/markdown/base-renderer.ts
var BaseRenderer = class {
  constructor(plugin, options = {}) {
    this.plugin = plugin;
    this.options = {
      autoHeadingID: true,
      containerWidth: "800px",
      waitForStable: false,
      timeout: 100,
      baseFile: void 0,
      ...options
    };
    this.resourceProcessor = new ObsidianResourceProcessor(plugin);
  }
  async parse(source) {
    try {
      const virtualFile = this.createVirtualFile(source);
      return new ObsidianParsingResult(this.plugin, virtualFile, source);
    } catch (error) {
      console.error("BaseRenderer\u89E3\u6790\u5931\u8D25:", error);
      throw new Error(`\u89E3\u6790\u5931\u8D25: ${error.message}`);
    }
  }
  async renderWithObsidian(source, includeTheme, customContainerWidth, waitForResources) {
    const virtualFile = this.createVirtualFile(source);
    const theme = includeTheme ? getCurrentTheme() : void 0;
    const containerWidth = customContainerWidth || this.options.containerWidth;
    const container = createRenderContainer(theme, containerWidth);
    try {
      await import_obsidian.MarkdownRenderer.render(this.plugin.app, source, container, virtualFile.path, this.plugin);
      if (this.options.waitForStable) {
        await waitForDomStable(container, this.options.timeout, source);
      }
      if (waitForResources) {
        await waitForResourcesLoaded(container, 3e3);
      }
      return container.innerHTML;
    } finally {
      cleanupContainer(container);
    }
  }
  ensureHeadingIDs(html) {
    if (!this.options.autoHeadingID) {
      return html;
    }
    const idGenerator = new import_foundry.AutoIDGenerator();
    return html.replace(/<h([1-6])(?![^>]*\sid=)([^>]*)>([^<]+)<\/h[1-6]>/g, (match, level, attrs, text3) => {
      const id = idGenerator.generateID(text3.trim());
      return `<h${level}${attrs} id="${id}">${text3}</h${level}>`;
    });
  }
  async processResources(html, baseFile) {
    return await this.resourceProcessor.processAllResources(html, this.options.baseFile || baseFile);
  }
  createVirtualFile(source, customName) {
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(2, 8);
    const fileName = customName || `virtual_${timestamp}_${randomId}.md`;
    const baseName = fileName.replace(/\.md$/, "");
    return {
      path: fileName,
      name: fileName,
      basename: baseName,
      extension: "md",
      parent: null,
      vault: this.plugin.app.vault,
      stat: {
        ctime: timestamp,
        mtime: timestamp,
        size: source.length
      }
    };
  }
  getOptions() {
    return { ...this.options };
  }
  setBaseFile(file) {
    this.options.baseFile = file;
  }
  getResourceProcessor() {
    return this.resourceProcessor;
  }
  updateOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
};

// src/markdown/style-renderer.ts
var StyleRenderer = class extends BaseRenderer {
  constructor(plugin, options = {}) {
    const defaultOptions = {
      autoHeadingID: true,
      containerWidth: "800px",
      waitForStable: false,
      timeout: 100,
      ...options
    };
    super(plugin, defaultOptions);
  }
  async render(source) {
    try {
      let html = await this.renderWithObsidian(source, false);
      html = this.ensureHeadingIDs(html);
      html = await this.processResources(html);
      return html;
    } catch (error) {
      console.error("StyleRenderer\u6E32\u67D3\u5931\u8D25:", error);
      throw new Error(`\u6E32\u67D3\u5931\u8D25: ${error.message}`);
    }
  }
  getOptions() {
    return super.getOptions();
  }
};

// src/markdown/css-collector.ts
var ObsidianCSSCollector = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.options = {};
  }
  async getObsidianAppCSS() {
    if (!this.options.includeAppCSS) {
      return "";
    }
    try {
      const appCssUrl = "app://obsidian.md/app.css";
      try {
        const response = await fetch(appCssUrl);
        if (response.ok) {
          return await response.text();
        }
      } catch (e) {
        console.error("fetch app.css \u5931\u8D25\uFF0C\u5C1D\u8BD5\u5176\u4ED6\u65B9\u6CD5:", e.message);
      }
      return "";
    } catch (error) {
      console.error("\u83B7\u53D6 app.css \u65F6\u51FA\u9519:", error);
      return "";
    }
  }
  async getAllLoadedCSS() {
    let additionalCSS = "";
    let skippedSheets = [];
    const appCSS = await this.getObsidianAppCSS();
    for (const sheet of Array.from(document.styleSheets)) {
      try {
        const rules = sheet.cssRules || sheet.rules;
        if (!rules)
          continue;
        if (sheet.href && sheet.href.includes("app.css")) {
          continue;
        }
        for (const rule of Array.from(rules)) {
          additionalCSS += rule.cssText + "\n";
        }
      } catch (e) {
        if (sheet.href) {
          skippedSheets.push(sheet.href);
          console.warn("\u65E0\u6CD5\u8BFB\u53D6\u6837\u5F0F\u8868:", sheet.href, e);
        }
      }
    }
    const baseStyles = "";
    return {
      appCSS,
      additionalCSS,
      baseStyles,
      skippedSheets
    };
  }
  getObsidianBaseStyles() {
    return "";
  }
  async collectAllCSS(options = {}) {
    const {
      includeAppCSS = true,
      includeBaseStyles = true
    } = options;
    this.options = options;
    const result = await this.getAllLoadedCSS();
    let fullCSS = "";
    if (includeBaseStyles) {
      fullCSS += "/* Obsidian Base Styles (fallback styles with defaults) */\n";
      fullCSS += this.getObsidianBaseStyles() + "\n\n";
    }
    if (includeAppCSS && result.appCSS) {
      fullCSS += "/* Obsidian Core Styles (app.css) */\n";
      fullCSS += result.appCSS + "\n\n";
    }
    if (result.additionalCSS) {
      fullCSS += "/* Obsidian Plugin and Theme Styles */\n";
      fullCSS += result.additionalCSS + "\n\n";
    }
    return fullCSS;
  }
};

// src/markdown/obsidian-renderer.ts
var _OBStyleRenderer = class extends BaseRenderer {
  constructor(plugin, options = {}) {
    const defaultOptions = {
      autoHeadingID: true,
      includeCSS: true,
      waitForPlugins: true,
      waitForStable: true,
      timeout: 500,
      containerWidth: "1000px",
      includeTheme: true,
      ...options
    };
    super(plugin, defaultOptions);
    this.context = {
      plugin,
      options: defaultOptions
    };
    this.cssCollector = new ObsidianCSSCollector(plugin);
  }
  async render(source) {
    try {
      const tempFile = this.createVirtualFile(source);
      let html = await this.renderWithObsidian(source, this.context.options.includeTheme, this.context.options.containerWidth, this.context.options.waitForPlugins);
      html = this.ensureHeadingIDs(html);
      html = await this.processResources(html, tempFile);
      if (this.context.options.includeCSS) {
        html = await this.wrapWithCSS(html, tempFile.basename || "Document");
      }
      return html;
    } catch (error) {
      console.error("\u6E32\u67D3 Markdown \u65F6\u51FA\u9519:", error);
      throw new Error(`\u6E32\u67D3\u5931\u8D25: ${error.message}`);
    }
  }
  async wrapWithCSS(html, title) {
    const css = await this.cssCollector.collectAllCSS({
      includeAppCSS: false,
      includeBaseStyles: true
    });
    const currentTheme = getCurrentTheme();
    return `<style>
${css}

</style>

<div class="obsidian-content-wrapper ${currentTheme}">
  <div class="markdown-preview-view markdown-rendered">
    ${html}
  </div>
</div>`;
  }
  escapeHtml(text3) {
    return text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  setBaseFile(file) {
    super.setBaseFile(file);
    this.context.options.baseFile = file;
    this.context.file = file;
  }
  getOptions() {
    return { ...this.context.options };
  }
  updateOptions(options) {
    super.updateOptions(options);
    this.context.options = {
      ...this.context.options,
      ...options
    };
  }
  getCSSCollector() {
    return this.cssCollector;
  }
  getResourceProcessor() {
    return super.getResourceProcessor();
  }
  async renderHTML(source) {
    const originalIncludeCSS = this.context.options.includeCSS;
    try {
      this.context.options.includeCSS = false;
      return await this.render(source);
    } finally {
      this.context.options.includeCSS = originalIncludeCSS;
    }
  }
};
var OBStyleRenderer = _OBStyleRenderer;
OBStyleRenderer.ObsidianRenderer = _OBStyleRenderer;

// src/markdown/index.ts
function createStyleRenderer(plugin, options = {}) {
  const defaultOptions = {
    autoHeadingID: true,
    containerWidth: "800px",
    waitForStable: false,
    timeout: 100,
    ...options
  };
  return new StyleRenderer(plugin, defaultOptions);
}

// src/theme/themeApiService.ts
var import_obsidian2 = require("obsidian");
var THEMES_JSON_URLS = {
  global: "https://gohugo.net/themes.json",
  east: "https://sunwei.xyz/mdf/themes-zh.json"
};
var themesCache = {};
var allTagsCache = {};
var cacheTimestamp = {};
var CACHE_EXPIRY_MS = 2 * 60 * 60 * 1e3;
function mapRawThemeToThemeItem(rawTheme) {
  return {
    id: String(rawTheme.id),
    name: rawTheme.name,
    author: rawTheme.author,
    version: rawTheme.version,
    screenshot: rawTheme.screenshot,
    download_url: rawTheme.download_url,
    demo_url: rawTheme.demo_url,
    demo_notes_url: rawTheme.demo_notes_url,
    tags: Array.isArray(rawTheme.tags) ? rawTheme.tags : [],
    title: rawTheme.name || `Theme ${rawTheme.id}`,
    description: `${rawTheme.name} theme by ${rawTheme.author || "Unknown"}`,
    thumbnail: rawTheme.screenshot,
    demo: rawTheme.demo_url,
    asset: rawTheme.screenshot
  };
}
async function fetchAllThemes(themesUrl) {
  try {
    const timestamp = Date.now();
    const urlWithTimestamp = `${themesUrl}?_t=${timestamp}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url: urlWithTimestamp,
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (response.status !== 200) {
      throw new Error(`Failed to fetch themes: ${response.status}`);
    }
    const rawThemes = response.json;
    if (!Array.isArray(rawThemes)) {
      throw new Error("Invalid themes data format");
    }
    return rawThemes.map(mapRawThemeToThemeItem).filter((theme) => theme.name !== "Base");
  } catch (error) {
    console.error("Error fetching themes:", error);
    throw error;
  }
}
function extractAllTags(themes) {
  const allTags = themes.flatMap((theme) => theme.tags);
  const uniqueTags = [...new Set(allTags)];
  return uniqueTags.sort((a, b) => a.localeCompare(b));
}
function filterThemes(themes, searchTerm = "", selectedTags = []) {
  let filteredThemes = themes;
  if (searchTerm.trim()) {
    const term = searchTerm.trim().toLowerCase();
    filteredThemes = filteredThemes.filter((theme) => theme.name.toLowerCase().includes(term) || theme.author.toLowerCase().includes(term) || theme.tags.some((tag) => tag.toLowerCase().includes(term)));
  }
  if (selectedTags.length > 0) {
    filteredThemes = filteredThemes.filter((theme) => selectedTags.every((selectedTag) => theme.tags.some((tag) => tag === selectedTag)));
  }
  return filteredThemes;
}
function getThemesUrl(plugin) {
  if (!plugin) {
    return THEMES_JSON_URLS.global;
  }
  const downloadServer = plugin.settings.downloadServer || "global";
  return THEMES_JSON_URLS[downloadServer];
}
var themeApiService = {
  async initializeThemes(plugin) {
    const themesUrl = getThemesUrl(plugin);
    const serverKey = plugin?.settings.downloadServer || "global";
    const now = Date.now();
    const isCacheExpired = !cacheTimestamp[serverKey] || now - cacheTimestamp[serverKey] > CACHE_EXPIRY_MS;
    if (!themesCache[serverKey] || isCacheExpired) {
      themesCache[serverKey] = await fetchAllThemes(themesUrl);
      allTagsCache[serverKey] = extractAllTags(themesCache[serverKey]);
      cacheTimestamp[serverKey] = now;
    }
  },
  async getAllThemes(plugin) {
    await this.initializeThemes(plugin);
    const serverKey = plugin?.settings.downloadServer || "global";
    return themesCache[serverKey] || [];
  },
  async fetchThemes(page = 1, limit = 20, selectedTags = [], searchTerm = "", plugin) {
    return this.searchThemes(page, limit, searchTerm, selectedTags, plugin);
  },
  async searchThemes(page = 1, limit = 20, searchTerm = "", selectedTags = [], plugin) {
    try {
      await this.initializeThemes(plugin);
      const serverKey = plugin?.settings.downloadServer || "global";
      const allThemes = themesCache[serverKey] || [];
      const filteredThemes = filterThemes(allThemes, searchTerm, selectedTags);
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginatedThemes = filteredThemes.slice(startIndex, endIndex);
      const hasMore = endIndex < filteredThemes.length;
      return { themes: paginatedThemes, hasMore };
    } catch (error) {
      console.error("Error searching themes:", error);
      return { themes: [], hasMore: false };
    }
  },
  async fetchAllTags(plugin) {
    try {
      await this.initializeThemes(plugin);
      const serverKey = plugin?.settings.downloadServer || "global";
      return allTagsCache[serverKey] || [];
    } catch (error) {
      console.error("Error fetching theme tags:", error);
      return [];
    }
  },
  createThemeMetadata(theme) {
    return {
      id: parseInt(theme.id, 10),
      name: theme.title,
      template: "",
      uuid: theme.id,
      tags: theme.tags
    };
  },
  async getThemeById(themeId, plugin) {
    try {
      await this.initializeThemes(plugin);
      const serverKey = plugin?.settings.downloadServer || "global";
      const themes = themesCache[serverKey] || [];
      return themes.find((theme) => theme.id === themeId) || null;
    } catch (error) {
      console.error("Error getting theme by ID:", error);
      return null;
    }
  },
  async fetchThemeByName(name, plugin) {
    try {
      await this.initializeThemes(plugin);
      const serverKey = plugin?.settings.downloadServer || "global";
      const allThemes = themesCache[serverKey] || [];
      const theme = allThemes.find((t) => t.name.toLowerCase() === name.toLowerCase());
      return theme || null;
    } catch (error) {
      console.error(`Error fetching theme by name '${name}':`, error);
      return null;
    }
  },
  clearCache(serverKey) {
    if (serverKey) {
      delete themesCache[serverKey];
      delete allTagsCache[serverKey];
      delete cacheTimestamp[serverKey];
    } else {
      themesCache = {};
      allTagsCache = {};
      cacheTimestamp = {};
    }
  }
};

// src/svelte/Site.svelte
function add_css3(target) {
  append_styles(target, "svelte-1mea8le", `.site-builder.svelte-1mea8le.svelte-1mea8le{padding:20px;max-width:100%}.section.svelte-1mea8le.svelte-1mea8le{margin-bottom:20px}.section-label.svelte-1mea8le.svelte-1mea8le{display:block;margin-bottom:8px;font-weight:500;color:var(--text-normal);font-size:14px}.form-input.svelte-1mea8le.svelte-1mea8le{width:100%;padding:10px 12px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:14px;line-height:1.4;box-sizing:border-box;min-height:38px}.form-select.svelte-1mea8le.svelte-1mea8le{width:100%;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);color:var(--text-normal);font-size:14px;line-height:1.4;box-sizing:border-box;min-height:38px;appearance:none;background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right 12px center;background-size:16px;padding-right:40px}.theme-selector.svelte-1mea8le.svelte-1mea8le{width:100%}.current-theme.svelte-1mea8le.svelte-1mea8le{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary);min-height:38px;box-sizing:border-box}.theme-name.svelte-1mea8le.svelte-1mea8le{color:var(--text-normal);font-size:14px;flex:1}.theme-actions.svelte-1mea8le.svelte-1mea8le{display:flex;align-items:center;gap:8px}.change-theme-btn.svelte-1mea8le.svelte-1mea8le{padding:6px 12px;border:1px solid var(--interactive-accent);border-radius:3px;background:transparent;color:var(--interactive-accent);font-size:12px;cursor:pointer;transition:all 0.2s;white-space:nowrap}.change-theme-btn.svelte-1mea8le.svelte-1mea8le:hover{background:var(--interactive-accent);color:var(--text-on-accent)}.download-sample-btn.svelte-1mea8le.svelte-1mea8le{padding:6px 12px;border:1px solid var(--text-accent);border-radius:3px;background:transparent;color:var(--text-accent);font-size:12px;cursor:pointer;transition:all 0.2s;white-space:nowrap}.download-sample-btn.svelte-1mea8le.svelte-1mea8le:hover{background:var(--text-accent);color:var(--text-on-accent)}.sample-download-progress.svelte-1mea8le.svelte-1mea8le{display:flex;flex-direction:column;gap:4px;min-width:120px}.progress-text.svelte-1mea8le.svelte-1mea8le{font-size:11px;color:var(--text-muted);text-align:center}.section-title.svelte-1mea8le.svelte-1mea8le{margin:0 0 10px 0;font-size:16px;font-weight:600;color:var(--text-normal)}.preview-section.svelte-1mea8le.svelte-1mea8le,.publish-section.svelte-1mea8le.svelte-1mea8le{padding:15px;border:1px solid var(--background-modifier-border);border-radius:6px;background:var(--background-secondary)}.action-button.svelte-1mea8le.svelte-1mea8le{padding:10px 20px;border:none;border-radius:4px;background:var(--interactive-accent);color:var(--text-on-accent);font-size:14px;font-weight:500;cursor:pointer;transition:background-color 0.2s;min-height:38px}.action-button.svelte-1mea8le.svelte-1mea8le:hover:not(:disabled){background:var(--interactive-accent-hover)}.action-button.svelte-1mea8le.svelte-1mea8le:disabled{background:var(--background-modifier-border);color:var(--text-muted);cursor:not-allowed}.preview-button.svelte-1mea8le.svelte-1mea8le{margin-bottom:10px}.publish-button.svelte-1mea8le.svelte-1mea8le{margin-left:10px}.preview-link.svelte-1mea8le.svelte-1mea8le,.publish-success.svelte-1mea8le.svelte-1mea8le{margin-top:15px;padding:10px;background:var(--background-primary);border-radius:4px;border:1px solid var(--background-modifier-border)}.preview-url.svelte-1mea8le.svelte-1mea8le,.publish-url.svelte-1mea8le.svelte-1mea8le{display:block;color:var(--interactive-accent);text-decoration:none;word-break:break-all;margin-top:5px}.preview-url.svelte-1mea8le.svelte-1mea8le:hover,.publish-url.svelte-1mea8le.svelte-1mea8le:hover{text-decoration:underline}.progress-container.svelte-1mea8le.svelte-1mea8le{margin:10px 0}.progress-container.svelte-1mea8le p.svelte-1mea8le{margin:0 0 10px 0;color:var(--text-muted);font-size:14px}.publish-select-wrapper.svelte-1mea8le.svelte-1mea8le{margin-bottom:16px}.publish-config.svelte-1mea8le.svelte-1mea8le{background:var(--background-secondary);border:1px solid var(--background-modifier-border);border-radius:4px;padding:16px;margin-bottom:16px}.config-field.svelte-1mea8le.svelte-1mea8le{margin-bottom:16px}.config-field.svelte-1mea8le.svelte-1mea8le:last-child{margin-bottom:0}.checkbox-label.svelte-1mea8le.svelte-1mea8le{display:flex;align-items:center;gap:8px;cursor:pointer;font-size:14px;color:var(--text-normal)}.checkbox-label.svelte-1mea8le input[type="checkbox"].svelte-1mea8le{width:16px;height:16px;cursor:pointer}.publish-actions.svelte-1mea8le.svelte-1mea8le{margin-top:16px}.success-message.svelte-1mea8le.svelte-1mea8le{margin:0 0 5px 0;color:var(--text-success);font-weight:500}.ftp-success-info.svelte-1mea8le.svelte-1mea8le{margin:5px 0 0 0;color:var(--text-muted);font-size:14px}.preview-actions.svelte-1mea8le.svelte-1mea8le{margin-top:10px;display:flex;gap:10px}.export-button.svelte-1mea8le.svelte-1mea8le{background:var(--interactive-normal);color:var(--text-normal);border:1px solid var(--background-modifier-border)}.export-button.svelte-1mea8le.svelte-1mea8le:hover:not(:disabled){background:var(--interactive-hover)}.export-button.svelte-1mea8le.svelte-1mea8le:disabled{opacity:0.6}.advanced-settings.svelte-1mea8le.svelte-1mea8le{border:1px solid var(--background-modifier-border);border-radius:4px;overflow:hidden}.advanced-toggle.svelte-1mea8le.svelte-1mea8le{width:100%;padding:12px 16px;border:none;background:transparent;color:var(--text-normal);font-size:14px;font-weight:500;cursor:pointer;display:flex;align-items:center;gap:8px;transition:background-color 0.2s;box-shadow:none}.advanced-toggle.svelte-1mea8le.svelte-1mea8le:hover{background:var(--background-modifier-hover)}.toggle-icon.svelte-1mea8le.svelte-1mea8le{transition:transform 0.2s;font-size:12px;color:var(--text-muted)}.toggle-icon.expanded.svelte-1mea8le.svelte-1mea8le{transform:rotate(90deg)}.advanced-content.svelte-1mea8le.svelte-1mea8le{background:var(--background-secondary);padding:16px;border-top:1px solid var(--background-modifier-border)}.advanced-field.svelte-1mea8le.svelte-1mea8le{margin-bottom:16px}.advanced-field.svelte-1mea8le.svelte-1mea8le:last-child{margin-bottom:0}.field-hint.svelte-1mea8le.svelte-1mea8le{font-size:12px;color:var(--text-muted);margin-top:4px;line-height:1.4}.multilang-table.svelte-1mea8le.svelte-1mea8le{border:1px solid var(--background-modifier-border);border-radius:4px;overflow:hidden;background:var(--background-primary)}.multilang-header.svelte-1mea8le.svelte-1mea8le{display:grid;grid-template-columns:1fr 2fr;background:var(--background-secondary);border-bottom:1px solid var(--background-modifier-border)}.multilang-header-cell.svelte-1mea8le.svelte-1mea8le{padding:10px 12px;font-weight:500;font-size:14px;color:var(--text-normal);border-right:1px solid var(--background-modifier-border);display:flex;align-items:center;justify-content:space-between;overflow:hidden;min-width:0}.add-language-btn.svelte-1mea8le.svelte-1mea8le{padding:4px 8px;border:1px solid var(--interactive-accent);border-radius:3px;background:transparent;color:var(--interactive-accent);font-size:11px;cursor:pointer;transition:all 0.2s;white-space:nowrap;margin-left:8px}.add-language-btn.svelte-1mea8le.svelte-1mea8le:hover{background:var(--interactive-accent);color:var(--text-on-accent)}.multilang-header-cell.svelte-1mea8le.svelte-1mea8le:last-child{border-right:none}.multilang-row.svelte-1mea8le.svelte-1mea8le{display:grid;grid-template-columns:1fr 2fr;border-bottom:1px solid var(--background-modifier-border);transition:background-color 0.2s}.multilang-row.svelte-1mea8le.svelte-1mea8le:last-child{border-bottom:none}.multilang-row.svelte-1mea8le.svelte-1mea8le:hover{background:var(--background-modifier-hover)}.multilang-cell.svelte-1mea8le.svelte-1mea8le{padding:10px 12px;display:flex;align-items:center;border-right:1px solid var(--background-modifier-border);min-height:38px;box-sizing:border-box;overflow:hidden;min-width:0}.multilang-cell.svelte-1mea8le.svelte-1mea8le:last-child{border-right:none}.content-path-cell.svelte-1mea8le.svelte-1mea8le{gap:8px}.content-path.svelte-1mea8le.svelte-1mea8le{color:var(--text-normal);font-size:14px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;min-width:0}.default-badge.svelte-1mea8le.svelte-1mea8le{background:var(--interactive-accent);color:var(--text-on-accent);padding:2px 6px;border-radius:3px;font-size:11px;font-weight:500;white-space:nowrap}.language-cell.svelte-1mea8le.svelte-1mea8le{display:flex;align-items:center;gap:8px}.language-select.svelte-1mea8le.svelte-1mea8le{flex:1;max-width:180px;padding:4px 8px;border:1px solid var(--background-modifier-border);border-radius:3px;background:var(--background-primary);color:var(--text-normal);font-size:13px;appearance:none;background-image:url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right 6px center;background-size:12px;padding-right:24px}.remove-btn.svelte-1mea8le.svelte-1mea8le{width:20px;height:20px;border:none;border-radius:50%;background:transparent;color:var(--text-muted);font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.2s;opacity:0;margin-left:4px}.multilang-row.svelte-1mea8le:hover .remove-btn.svelte-1mea8le{opacity:1}.remove-btn.svelte-1mea8le.svelte-1mea8le:hover{background:var(--background-modifier-error);color:var(--text-on-accent);transform:scale(1.1)}.remove-icon.svelte-1mea8le.svelte-1mea8le{line-height:1;font-weight:bold}.multilang-empty.svelte-1mea8le.svelte-1mea8le{padding:20px;text-align:center;color:var(--text-muted);font-style:italic}.empty-message.svelte-1mea8le.svelte-1mea8le{font-size:14px}.site-assets-container.svelte-1mea8le.svelte-1mea8le{border:1px solid var(--background-modifier-border);border-radius:4px;background:var(--background-primary)}.assets-display.svelte-1mea8le.svelte-1mea8le{padding:10px 12px;display:flex;align-items:center;justify-content:space-between;min-height:38px;box-sizing:border-box}.assets-path.svelte-1mea8le.svelte-1mea8le{color:var(--text-normal);font-size:14px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;min-width:0}.assets-placeholder.svelte-1mea8le.svelte-1mea8le{color:var(--text-muted);font-size:14px;font-style:italic;flex:1}.clear-assets-btn.svelte-1mea8le.svelte-1mea8le{padding:4px 8px;border:1px solid var(--interactive-accent);border-radius:3px;background:transparent;color:var(--interactive-accent);font-size:11px;cursor:pointer;transition:all 0.2s;white-space:nowrap;margin-left:8px}.clear-assets-btn.svelte-1mea8le.svelte-1mea8le:hover{background:var(--interactive-accent);color:var(--text-on-accent)}.assets-hint.svelte-1mea8le.svelte-1mea8le{padding:8px 12px;background:var(--background-secondary);border-top:1px solid var(--background-modifier-border);font-size:12px;color:var(--text-muted);line-height:1.4}.ftp-test-btn.svelte-1mea8le.svelte-1mea8le{padding:10px 20px;border:1px solid var(--interactive-accent);border-radius:4px;background:transparent;color:var(--interactive-accent);font-size:14px;font-weight:500;cursor:pointer;transition:all 0.2s;min-height:38px}.ftp-test-btn.svelte-1mea8le.svelte-1mea8le:hover:not(:disabled){background:var(--interactive-accent);color:var(--text-on-accent)}.ftp-test-btn.svelte-1mea8le.svelte-1mea8le:disabled{opacity:0.6;cursor:not-allowed}.ftp-test-btn.ftp-test-success.svelte-1mea8le.svelte-1mea8le{background-color:var(--color-green) !important;color:white !important;border-color:var(--color-green) !important}.ftp-test-btn.ftp-test-error.svelte-1mea8le.svelte-1mea8le{background-color:var(--color-red) !important;color:white !important;border-color:var(--color-red) !important}.ftp-test-result.svelte-1mea8le.svelte-1mea8le{margin-top:8px;padding:8px 12px;border-radius:4px;font-size:13px;line-height:1.4;display:block;width:100%;box-sizing:border-box}.ftp-test-result-success.svelte-1mea8le.svelte-1mea8le{background-color:rgba(var(--color-green-rgb), 0.1);color:var(--color-green);border:1px solid rgba(var(--color-green-rgb), 0.3)}.ftp-test-result-error.svelte-1mea8le.svelte-1mea8le{background-color:rgba(var(--color-red-rgb), 0.1);color:var(--color-red);border:1px solid rgba(var(--color-red-rgb), 0.3)}`);
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[121] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[124] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[127] = list[i];
  return child_ctx;
}
function create_if_block_20(ctx) {
  let button;
  let t_1_value = ctx[10]("ui.clear") + "";
  let t_1;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "add-language-btn svelte-1mea8le");
      attr(button, "title", button_title_value = ctx[10]("ui.clear_all_content"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[39]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.clear") + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 1024 && button_title_value !== (button_title_value = ctx2[10]("ui.clear_all_content"))) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_19(ctx) {
  let span;
  let t_1_value = ctx[10]("ui.default") + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text2(t_1_value);
      attr(span, "class", "default-badge svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.default") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_2(ctx) {
  let option;
  let t0_value = ctx[127].name + "";
  let t0;
  let t1;
  let t2_value = ctx[127].englishName + "";
  let t2;
  let t3;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text2(t0_value);
      t1 = text2(" (");
      t2 = text2(t2_value);
      t3 = text2(")");
      option.__value = option_value_value = ctx[127].code;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
      append(option, t2);
      append(option, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_18(ctx) {
  let button;
  let span;
  let button_title_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[66](ctx[124]);
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = "\xD7";
      attr(span, "class", "remove-icon svelte-1mea8le");
      attr(button, "class", "remove-btn svelte-1mea8le");
      attr(button, "title", button_title_value = ctx[10]("ui.remove_language"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1024 && button_title_value !== (button_title_value = ctx[10]("ui.remove_language"))) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let div2;
  let div0;
  let span;
  let t0_value = (ctx[124].folder ? ctx[124].folder.name : ctx[124].file ? ctx[124].file.name : ctx[10]("ui.no_content_selected")) + "";
  let t0;
  let t1;
  let t2;
  let div1;
  let select;
  let select_value_value;
  let t3;
  let mounted;
  let dispose;
  let if_block0 = ctx[124].weight === 1 && create_if_block_19(ctx);
  let each_value_2 = ctx[36];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function change_handler(...args) {
    return ctx[65](ctx[124], ...args);
  }
  let if_block1 = ctx[9].length > 1 && create_if_block_18(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text2(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      div1 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(span, "class", "content-path svelte-1mea8le");
      attr(div0, "class", "multilang-cell content-path-cell svelte-1mea8le");
      attr(select, "class", "language-select svelte-1mea8le");
      attr(div1, "class", "multilang-cell language-cell svelte-1mea8le");
      attr(div2, "class", "multilang-row svelte-1mea8le");
      toggle_class(div2, "removable", ctx[9].length > 1);
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(span, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div2, t2);
      append(div2, div1);
      append(div1, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[124].languageCode);
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      if (!mounted) {
        dispose = listen(select, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1536 && t0_value !== (t0_value = (ctx[124].folder ? ctx[124].folder.name : ctx[124].file ? ctx[124].file.name : ctx[10]("ui.no_content_selected")) + ""))
        set_data(t0, t0_value);
      if (ctx[124].weight === 1) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_19(ctx);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[1] & 32) {
        each_value_2 = ctx[36];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & 512 | dirty[1] & 32 && select_value_value !== (select_value_value = ctx[124].languageCode)) {
        select_option(select, ctx[124].languageCode);
      }
      if (ctx[9].length > 1) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_18(ctx);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 512) {
        toggle_class(div2, "removable", ctx[9].length > 1);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_17(ctx) {
  let div;
  let span;
  let t_1_value = ctx[10]("ui.no_content_selected_hint") + "";
  let t_1;
  return {
    c() {
      div = element("div");
      span = element("span");
      t_1 = text2(t_1_value);
      attr(span, "class", "empty-message svelte-1mea8le");
      attr(div, "class", "multilang-empty svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.no_content_selected_hint") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block_4(ctx) {
  let span;
  let t_1_value = ctx[10]("ui.site_assets_placeholder") + "";
  let t_1;
  return {
    c() {
      span = element("span");
      t_1 = text2(t_1_value);
      attr(span, "class", "assets-placeholder svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.site_assets_placeholder") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_16(ctx) {
  let span;
  let t0_value = (ctx[30].folder?.name || ctx[30].path) + "";
  let t0;
  let t1;
  let button;
  let t2_value = ctx[10]("ui.clear_assets") + "";
  let t2;
  let button_title_value;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text2(t0_value);
      t1 = space();
      button = element("button");
      t2 = text2(t2_value);
      attr(span, "class", "assets-path svelte-1mea8le");
      attr(button, "class", "clear-assets-btn svelte-1mea8le");
      attr(button, "title", button_title_value = ctx[10]("ui.clear_assets"));
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      insert(target, button, anchor);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[40]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1073741824 && t0_value !== (t0_value = (ctx2[30].folder?.name || ctx2[30].path) + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1024 && t2_value !== (t2_value = ctx2[10]("ui.clear_assets") + ""))
        set_data(t2, t2_value);
      if (dirty[0] & 1024 && button_title_value !== (button_title_value = ctx2[10]("ui.clear_assets"))) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_15(ctx) {
  let div8;
  let div1;
  let label0;
  let t0_value = ctx[10]("ui.site_path") + "";
  let t0;
  let t1;
  let input0;
  let input0_placeholder_value;
  let input0_title_value;
  let t2;
  let div0;
  let t3_value = ctx[10]("ui.site_path_hint") + "";
  let t3;
  let t4;
  let div3;
  let label1;
  let t5_value = ctx[10]("ui.site_password") + "";
  let t5;
  let t6;
  let input1;
  let input1_placeholder_value;
  let input1_title_value;
  let t7;
  let div2;
  let t8_value = ctx[10]("ui.site_password_hint") + "";
  let t8;
  let t9;
  let div5;
  let label2;
  let t10_value = ctx[10]("ui.google_analytics_id") + "";
  let t10;
  let t11;
  let input2;
  let input2_placeholder_value;
  let input2_title_value;
  let t12;
  let div4;
  let t13_value = ctx[10]("ui.google_analytics_hint") + "";
  let t13;
  let t14;
  let div7;
  let label3;
  let t15_value = ctx[10]("ui.disqus_shortname") + "";
  let t15;
  let t16;
  let input3;
  let input3_placeholder_value;
  let input3_title_value;
  let t17;
  let div6;
  let t18_value = ctx[10]("ui.disqus_hint") + "";
  let t18;
  let mounted;
  let dispose;
  return {
    c() {
      div8 = element("div");
      div1 = element("div");
      label0 = element("label");
      t0 = text2(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      div0 = element("div");
      t3 = text2(t3_value);
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      t5 = text2(t5_value);
      t6 = space();
      input1 = element("input");
      t7 = space();
      div2 = element("div");
      t8 = text2(t8_value);
      t9 = space();
      div5 = element("div");
      label2 = element("label");
      t10 = text2(t10_value);
      t11 = space();
      input2 = element("input");
      t12 = space();
      div4 = element("div");
      t13 = text2(t13_value);
      t14 = space();
      div7 = element("div");
      label3 = element("label");
      t15 = text2(t15_value);
      t16 = space();
      input3 = element("input");
      t17 = space();
      div6 = element("div");
      t18 = text2(t18_value);
      attr(label0, "class", "section-label svelte-1mea8le");
      attr(label0, "for", "site-path");
      attr(input0, "type", "text");
      attr(input0, "class", "form-input svelte-1mea8le");
      attr(input0, "placeholder", input0_placeholder_value = ctx[10]("ui.site_path_placeholder"));
      attr(input0, "title", input0_title_value = ctx[10]("ui.site_path_hint"));
      attr(div0, "class", "field-hint svelte-1mea8le");
      attr(div1, "class", "advanced-field svelte-1mea8le");
      attr(label1, "class", "section-label svelte-1mea8le");
      attr(label1, "for", "site-password");
      attr(input1, "type", "password");
      attr(input1, "class", "form-input svelte-1mea8le");
      attr(input1, "placeholder", input1_placeholder_value = ctx[10]("ui.site_password_placeholder"));
      attr(input1, "title", input1_title_value = ctx[10]("ui.site_password_hint"));
      attr(div2, "class", "field-hint svelte-1mea8le");
      attr(div3, "class", "advanced-field svelte-1mea8le");
      attr(label2, "class", "section-label svelte-1mea8le");
      attr(label2, "for", "google-analytics");
      attr(input2, "type", "text");
      attr(input2, "class", "form-input svelte-1mea8le");
      attr(input2, "placeholder", input2_placeholder_value = ctx[10]("ui.google_analytics_placeholder"));
      attr(input2, "title", input2_title_value = ctx[10]("ui.google_analytics_hint"));
      attr(div4, "class", "field-hint svelte-1mea8le");
      attr(div5, "class", "advanced-field svelte-1mea8le");
      attr(label3, "class", "section-label svelte-1mea8le");
      attr(label3, "for", "disqus-shortname");
      attr(input3, "type", "text");
      attr(input3, "class", "form-input svelte-1mea8le");
      attr(input3, "placeholder", input3_placeholder_value = ctx[10]("ui.disqus_placeholder"));
      attr(input3, "title", input3_title_value = ctx[10]("ui.disqus_hint"));
      attr(div6, "class", "field-hint svelte-1mea8le");
      attr(div7, "class", "advanced-field svelte-1mea8le");
      attr(div8, "class", "advanced-content svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div1);
      append(div1, label0);
      append(label0, t0);
      append(div1, t1);
      append(div1, input0);
      set_input_value(input0, ctx[1]);
      append(div1, t2);
      append(div1, div0);
      append(div0, t3);
      append(div8, t4);
      append(div8, div3);
      append(div3, label1);
      append(label1, t5);
      append(div3, t6);
      append(div3, input1);
      set_input_value(input1, ctx[14]);
      append(div3, t7);
      append(div3, div2);
      append(div2, t8);
      append(div8, t9);
      append(div8, div5);
      append(div5, label2);
      append(label2, t10);
      append(div5, t11);
      append(div5, input2);
      set_input_value(input2, ctx[12]);
      append(div5, t12);
      append(div5, div4);
      append(div4, t13);
      append(div8, t14);
      append(div8, div7);
      append(div7, label3);
      append(label3, t15);
      append(div7, t16);
      append(div7, input3);
      set_input_value(input3, ctx[13]);
      append(div7, t17);
      append(div7, div6);
      append(div6, t18);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[68]),
          listen(input0, "blur", ctx[45]),
          listen(input1, "input", ctx[69]),
          listen(input2, "input", ctx[70]),
          listen(input3, "input", ctx[71])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10]("ui.site_path") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1024 && input0_placeholder_value !== (input0_placeholder_value = ctx2[10]("ui.site_path_placeholder"))) {
        attr(input0, "placeholder", input0_placeholder_value);
      }
      if (dirty[0] & 1024 && input0_title_value !== (input0_title_value = ctx2[10]("ui.site_path_hint"))) {
        attr(input0, "title", input0_title_value);
      }
      if (dirty[0] & 2 && input0.value !== ctx2[1]) {
        set_input_value(input0, ctx2[1]);
      }
      if (dirty[0] & 1024 && t3_value !== (t3_value = ctx2[10]("ui.site_path_hint") + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 1024 && t5_value !== (t5_value = ctx2[10]("ui.site_password") + ""))
        set_data(t5, t5_value);
      if (dirty[0] & 1024 && input1_placeholder_value !== (input1_placeholder_value = ctx2[10]("ui.site_password_placeholder"))) {
        attr(input1, "placeholder", input1_placeholder_value);
      }
      if (dirty[0] & 1024 && input1_title_value !== (input1_title_value = ctx2[10]("ui.site_password_hint"))) {
        attr(input1, "title", input1_title_value);
      }
      if (dirty[0] & 16384 && input1.value !== ctx2[14]) {
        set_input_value(input1, ctx2[14]);
      }
      if (dirty[0] & 1024 && t8_value !== (t8_value = ctx2[10]("ui.site_password_hint") + ""))
        set_data(t8, t8_value);
      if (dirty[0] & 1024 && t10_value !== (t10_value = ctx2[10]("ui.google_analytics_id") + ""))
        set_data(t10, t10_value);
      if (dirty[0] & 1024 && input2_placeholder_value !== (input2_placeholder_value = ctx2[10]("ui.google_analytics_placeholder"))) {
        attr(input2, "placeholder", input2_placeholder_value);
      }
      if (dirty[0] & 1024 && input2_title_value !== (input2_title_value = ctx2[10]("ui.google_analytics_hint"))) {
        attr(input2, "title", input2_title_value);
      }
      if (dirty[0] & 4096 && input2.value !== ctx2[12]) {
        set_input_value(input2, ctx2[12]);
      }
      if (dirty[0] & 1024 && t13_value !== (t13_value = ctx2[10]("ui.google_analytics_hint") + ""))
        set_data(t13, t13_value);
      if (dirty[0] & 1024 && t15_value !== (t15_value = ctx2[10]("ui.disqus_shortname") + ""))
        set_data(t15, t15_value);
      if (dirty[0] & 1024 && input3_placeholder_value !== (input3_placeholder_value = ctx2[10]("ui.disqus_placeholder"))) {
        attr(input3, "placeholder", input3_placeholder_value);
      }
      if (dirty[0] & 1024 && input3_title_value !== (input3_title_value = ctx2[10]("ui.disqus_hint"))) {
        attr(input3, "title", input3_title_value);
      }
      if (dirty[0] & 8192 && input3.value !== ctx2[13]) {
        set_input_value(input3, ctx2[13]);
      }
      if (dirty[0] & 1024 && t18_value !== (t18_value = ctx2[10]("ui.disqus_hint") + ""))
        set_data(t18, t18_value);
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_13(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_14, create_else_block_3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[27])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_3(ctx) {
  let button;
  let t_1_value = ctx[10]("ui.download_sample") + "";
  let t_1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "download-sample-btn svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[43]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.download_sample") + ""))
        set_data(t_1, t_1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let span;
  let t0_value = ctx[10]("ui.downloading_sample") + "";
  let t0;
  let t1;
  let progressbar;
  let current;
  progressbar = new ProgressBar_default({
    props: {
      progress: ctx[28]
    }
  });
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text2(t0_value);
      t1 = space();
      create_component(progressbar.$$.fragment);
      attr(span, "class", "progress-text svelte-1mea8le");
      attr(div, "class", "sample-download-progress svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(div, t1);
      mount_component(progressbar, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 1024) && t0_value !== (t0_value = ctx2[10]("ui.downloading_sample") + ""))
        set_data(t0, t0_value);
      const progressbar_changes = {};
      if (dirty[0] & 268435456)
        progressbar_changes.progress = ctx2[28];
      progressbar.$set(progressbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progressbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progressbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(progressbar);
    }
  };
}
function create_else_block_2(ctx) {
  let button;
  let t_1_value = (ctx[18] ? ctx[10]("ui.regenerate_preview") : ctx[10]("ui.generate_preview")) + "";
  let t_1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "action-button preview-button svelte-1mea8le");
      button.disabled = button_disabled_value = ctx[9].length === 0;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[46]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 263168 && t_1_value !== (t_1_value = (ctx2[18] ? ctx2[10]("ui.regenerate_preview") : ctx2[10]("ui.generate_preview")) + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 512 | dirty[1] & 32 && button_disabled_value !== (button_disabled_value = ctx2[9].length === 0)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  let p;
  let t0_value = ctx[10]("ui.preview_building") + "";
  let t0;
  let t1;
  let progressbar;
  let current;
  progressbar = new ProgressBar_default({
    props: { progress: ctx[16] }
  });
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      create_component(progressbar.$$.fragment);
      attr(p, "class", "svelte-1mea8le");
      attr(div, "class", "progress-container svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      mount_component(progressbar, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 1024) && t0_value !== (t0_value = ctx2[10]("ui.preview_building") + ""))
        set_data(t0, t0_value);
      const progressbar_changes = {};
      if (dirty[0] & 65536)
        progressbar_changes.progress = ctx2[16];
      progressbar.$set(progressbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progressbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progressbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(progressbar);
    }
  };
}
function create_if_block_11(ctx) {
  let div1;
  let p;
  let t0_value = ctx[10]("ui.preview_link") + "";
  let t0;
  let t1;
  let a;
  let t2;
  let t3;
  let div0;
  let button;
  let t4_value = (ctx[26] ? ctx[10]("ui.exporting") : ctx[10]("ui.export_site")) + "";
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      a = element("a");
      t2 = text2(ctx[17]);
      t3 = space();
      div0 = element("div");
      button = element("button");
      t4 = text2(t4_value);
      attr(a, "href", ctx[17]);
      attr(a, "target", "_blank");
      attr(a, "class", "preview-url svelte-1mea8le");
      attr(button, "class", "action-button export-button svelte-1mea8le");
      button.disabled = ctx[26];
      attr(div0, "class", "preview-actions svelte-1mea8le");
      attr(div1, "class", "preview-link svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, p);
      append(p, t0);
      append(div1, t1);
      append(div1, a);
      append(a, t2);
      append(div1, t3);
      append(div1, div0);
      append(div0, button);
      append(button, t4);
      if (!mounted) {
        dispose = listen(button, "click", ctx[49]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10]("ui.preview_link") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 131072)
        set_data(t2, ctx2[17]);
      if (dirty[0] & 131072) {
        attr(a, "href", ctx2[17]);
      }
      if (dirty[0] & 67109888 && t4_value !== (t4_value = (ctx2[26] ? ctx2[10]("ui.exporting") : ctx2[10]("ui.export_site")) + ""))
        set_data(t4, t4_value);
      if (dirty[0] & 67108864) {
        button.disabled = ctx2[26];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let option;
  let t_1_value = ctx[121].label + "";
  let t_1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t_1 = text2(t_1_value);
      option.__value = option_value_value = ctx[121].value;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[1] & 4 && t_1_value !== (t_1_value = ctx2[121].label + ""))
        set_data(t_1, t_1_value);
      if (dirty[1] & 4 && option_value_value !== (option_value_value = ctx2[121].value)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_10(ctx) {
  let div4;
  let div1;
  let label0;
  let t0_value = ctx[10]("settings.netlify_access_token") + "";
  let t0;
  let t1;
  let input0;
  let input0_placeholder_value;
  let t2;
  let div0;
  let t3_value = ctx[10]("settings.netlify_access_token_desc") + "";
  let t3;
  let t4;
  let div3;
  let label1;
  let t5_value = ctx[10]("settings.netlify_project_id") + "";
  let t5;
  let t6;
  let input1;
  let input1_placeholder_value;
  let t7;
  let div2;
  let t8_value = ctx[10]("settings.netlify_project_id_desc") + "";
  let t8;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      label0 = element("label");
      t0 = text2(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      div0 = element("div");
      t3 = text2(t3_value);
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      t5 = text2(t5_value);
      t6 = space();
      input1 = element("input");
      t7 = space();
      div2 = element("div");
      t8 = text2(t8_value);
      attr(label0, "class", "section-label svelte-1mea8le");
      attr(label0, "for", "netlify-token");
      attr(input0, "type", "password");
      attr(input0, "class", "form-input svelte-1mea8le");
      attr(input0, "placeholder", input0_placeholder_value = ctx[10]("settings.netlify_access_token_placeholder"));
      attr(div0, "class", "field-hint svelte-1mea8le");
      attr(div1, "class", "config-field svelte-1mea8le");
      attr(label1, "class", "section-label svelte-1mea8le");
      attr(label1, "for", "netlify-project");
      attr(input1, "type", "text");
      attr(input1, "class", "form-input svelte-1mea8le");
      attr(input1, "placeholder", input1_placeholder_value = ctx[10]("settings.netlify_project_id_placeholder"));
      attr(div2, "class", "field-hint svelte-1mea8le");
      attr(div3, "class", "config-field svelte-1mea8le");
      attr(div4, "class", "publish-config svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, label0);
      append(label0, t0);
      append(div1, t1);
      append(div1, input0);
      set_input_value(input0, ctx[23]);
      append(div1, t2);
      append(div1, div0);
      append(div0, t3);
      append(div4, t4);
      append(div4, div3);
      append(div3, label1);
      append(label1, t5);
      append(div3, t6);
      append(div3, input1);
      set_input_value(input1, ctx[24]);
      append(div3, t7);
      append(div3, div2);
      append(div2, t8);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[73]),
          listen(input1, "input", ctx[74])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10]("settings.netlify_access_token") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1024 && input0_placeholder_value !== (input0_placeholder_value = ctx2[10]("settings.netlify_access_token_placeholder"))) {
        attr(input0, "placeholder", input0_placeholder_value);
      }
      if (dirty[0] & 8388608 && input0.value !== ctx2[23]) {
        set_input_value(input0, ctx2[23]);
      }
      if (dirty[0] & 1024 && t3_value !== (t3_value = ctx2[10]("settings.netlify_access_token_desc") + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 1024 && t5_value !== (t5_value = ctx2[10]("settings.netlify_project_id") + ""))
        set_data(t5, t5_value);
      if (dirty[0] & 1024 && input1_placeholder_value !== (input1_placeholder_value = ctx2[10]("settings.netlify_project_id_placeholder"))) {
        attr(input1, "placeholder", input1_placeholder_value);
      }
      if (dirty[0] & 16777216 && input1.value !== ctx2[24]) {
        set_input_value(input1, ctx2[24]);
      }
      if (dirty[0] & 1024 && t8_value !== (t8_value = ctx2[10]("settings.netlify_project_id_desc") + ""))
        set_data(t8, t8_value);
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5(ctx) {
  let div9;
  let div0;
  let label0;
  let t0_value = ctx[10]("settings.ftp_server") + "";
  let t0;
  let t1;
  let input0;
  let input0_placeholder_value;
  let t2;
  let div1;
  let label1;
  let t3_value = ctx[10]("settings.ftp_username") + "";
  let t3;
  let t4;
  let input1;
  let input1_placeholder_value;
  let t5;
  let div2;
  let label2;
  let t6_value = ctx[10]("settings.ftp_password") + "";
  let t6;
  let t7;
  let input2;
  let input2_placeholder_value;
  let t8;
  let div4;
  let label3;
  let t9_value = ctx[10]("settings.ftp_remote_dir") + "";
  let t9;
  let t10;
  let input3;
  let input3_placeholder_value;
  let t11;
  let div3;
  let t12_value = ctx[10]("settings.ftp_remote_dir_desc") + "";
  let t12;
  let t13;
  let div6;
  let label4;
  let input4;
  let t14;
  let span;
  let t15_value = ctx[10]("settings.ftp_ignore_cert") + "";
  let t15;
  let t16;
  let div5;
  let t17_value = ctx[10]("settings.ftp_ignore_cert_desc") + "";
  let t17;
  let t18;
  let div8;
  let button;
  let button_disabled_value;
  let t19;
  let div7;
  let t20_value = ctx[10]("settings.ftp_test_connection_desc") + "";
  let t20;
  let t21;
  let mounted;
  let dispose;
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[8] === "testing")
      return create_if_block_7;
    if (ctx2[8] === "success")
      return create_if_block_8;
    if (ctx2[8] === "error")
      return create_if_block_9;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1, -1, -1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[25] && create_if_block_6(ctx);
  return {
    c() {
      div9 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text2(t0_value);
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      t3 = text2(t3_value);
      t4 = space();
      input1 = element("input");
      t5 = space();
      div2 = element("div");
      label2 = element("label");
      t6 = text2(t6_value);
      t7 = space();
      input2 = element("input");
      t8 = space();
      div4 = element("div");
      label3 = element("label");
      t9 = text2(t9_value);
      t10 = space();
      input3 = element("input");
      t11 = space();
      div3 = element("div");
      t12 = text2(t12_value);
      t13 = space();
      div6 = element("div");
      label4 = element("label");
      input4 = element("input");
      t14 = space();
      span = element("span");
      t15 = text2(t15_value);
      t16 = space();
      div5 = element("div");
      t17 = text2(t17_value);
      t18 = space();
      div8 = element("div");
      button = element("button");
      if_block0.c();
      t19 = space();
      div7 = element("div");
      t20 = text2(t20_value);
      t21 = space();
      if (if_block1)
        if_block1.c();
      attr(label0, "class", "section-label svelte-1mea8le");
      attr(label0, "for", "ftp-server");
      attr(input0, "type", "text");
      attr(input0, "class", "form-input svelte-1mea8le");
      attr(input0, "placeholder", input0_placeholder_value = ctx[10]("settings.ftp_server_placeholder"));
      attr(div0, "class", "config-field svelte-1mea8le");
      attr(label1, "class", "section-label svelte-1mea8le");
      attr(label1, "for", "ftp-username");
      attr(input1, "type", "text");
      attr(input1, "class", "form-input svelte-1mea8le");
      attr(input1, "placeholder", input1_placeholder_value = ctx[10]("settings.ftp_username_placeholder"));
      attr(div1, "class", "config-field svelte-1mea8le");
      attr(label2, "class", "section-label svelte-1mea8le");
      attr(label2, "for", "ftp-password");
      attr(input2, "type", "password");
      attr(input2, "class", "form-input svelte-1mea8le");
      attr(input2, "placeholder", input2_placeholder_value = ctx[10]("settings.ftp_password_placeholder"));
      attr(div2, "class", "config-field svelte-1mea8le");
      attr(label3, "class", "section-label svelte-1mea8le");
      attr(label3, "for", "ftp-remote-dir");
      attr(input3, "type", "text");
      attr(input3, "class", "form-input svelte-1mea8le");
      attr(input3, "placeholder", input3_placeholder_value = ctx[10]("settings.ftp_remote_dir_placeholder"));
      attr(div3, "class", "field-hint svelte-1mea8le");
      attr(div4, "class", "config-field svelte-1mea8le");
      attr(input4, "type", "checkbox");
      attr(input4, "class", "svelte-1mea8le");
      attr(label4, "class", "checkbox-label svelte-1mea8le");
      attr(div5, "class", "field-hint svelte-1mea8le");
      attr(div6, "class", "config-field svelte-1mea8le");
      attr(button, "class", "ftp-test-btn svelte-1mea8le");
      button.disabled = button_disabled_value = !ctx[31] || ctx[8] === "testing";
      toggle_class(button, "ftp-test-success", ctx[8] === "success");
      toggle_class(button, "ftp-test-error", ctx[8] === "error");
      attr(div7, "class", "field-hint svelte-1mea8le");
      attr(div8, "class", "config-field svelte-1mea8le");
      attr(div9, "class", "publish-config svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div0);
      append(div0, label0);
      append(label0, t0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(input0, ctx[3]);
      append(div9, t2);
      append(div9, div1);
      append(div1, label1);
      append(label1, t3);
      append(div1, t4);
      append(div1, input1);
      set_input_value(input1, ctx[4]);
      append(div9, t5);
      append(div9, div2);
      append(div2, label2);
      append(label2, t6);
      append(div2, t7);
      append(div2, input2);
      set_input_value(input2, ctx[5]);
      append(div9, t8);
      append(div9, div4);
      append(div4, label3);
      append(label3, t9);
      append(div4, t10);
      append(div4, input3);
      set_input_value(input3, ctx[6]);
      append(div4, t11);
      append(div4, div3);
      append(div3, t12);
      append(div9, t13);
      append(div9, div6);
      append(div6, label4);
      append(label4, input4);
      input4.checked = ctx[7];
      append(label4, t14);
      append(label4, span);
      append(span, t15);
      append(div6, t16);
      append(div6, div5);
      append(div5, t17);
      append(div9, t18);
      append(div9, div8);
      append(div8, button);
      if_block0.m(button, null);
      append(div8, t19);
      append(div8, div7);
      append(div7, t20);
      append(div8, t21);
      if (if_block1)
        if_block1.m(div8, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[75]),
          listen(input1, "input", ctx[76]),
          listen(input2, "input", ctx[77]),
          listen(input3, "input", ctx[78]),
          listen(input4, "change", ctx[79]),
          listen(button, "click", ctx[48])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10]("settings.ftp_server") + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1024 && input0_placeholder_value !== (input0_placeholder_value = ctx2[10]("settings.ftp_server_placeholder"))) {
        attr(input0, "placeholder", input0_placeholder_value);
      }
      if (dirty[0] & 8 && input0.value !== ctx2[3]) {
        set_input_value(input0, ctx2[3]);
      }
      if (dirty[0] & 1024 && t3_value !== (t3_value = ctx2[10]("settings.ftp_username") + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 1024 && input1_placeholder_value !== (input1_placeholder_value = ctx2[10]("settings.ftp_username_placeholder"))) {
        attr(input1, "placeholder", input1_placeholder_value);
      }
      if (dirty[0] & 16 && input1.value !== ctx2[4]) {
        set_input_value(input1, ctx2[4]);
      }
      if (dirty[0] & 1024 && t6_value !== (t6_value = ctx2[10]("settings.ftp_password") + ""))
        set_data(t6, t6_value);
      if (dirty[0] & 1024 && input2_placeholder_value !== (input2_placeholder_value = ctx2[10]("settings.ftp_password_placeholder"))) {
        attr(input2, "placeholder", input2_placeholder_value);
      }
      if (dirty[0] & 32 && input2.value !== ctx2[5]) {
        set_input_value(input2, ctx2[5]);
      }
      if (dirty[0] & 1024 && t9_value !== (t9_value = ctx2[10]("settings.ftp_remote_dir") + ""))
        set_data(t9, t9_value);
      if (dirty[0] & 1024 && input3_placeholder_value !== (input3_placeholder_value = ctx2[10]("settings.ftp_remote_dir_placeholder"))) {
        attr(input3, "placeholder", input3_placeholder_value);
      }
      if (dirty[0] & 64 && input3.value !== ctx2[6]) {
        set_input_value(input3, ctx2[6]);
      }
      if (dirty[0] & 1024 && t12_value !== (t12_value = ctx2[10]("settings.ftp_remote_dir_desc") + ""))
        set_data(t12, t12_value);
      if (dirty[0] & 128) {
        input4.checked = ctx2[7];
      }
      if (dirty[0] & 1024 && t15_value !== (t15_value = ctx2[10]("settings.ftp_ignore_cert") + ""))
        set_data(t15, t15_value);
      if (dirty[0] & 1024 && t17_value !== (t17_value = ctx2[10]("settings.ftp_ignore_cert_desc") + ""))
        set_data(t17, t17_value);
      if (current_block_type === (current_block_type = select_block_type_3(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, null);
        }
      }
      if (dirty[0] & 256 | dirty[1] & 1 && button_disabled_value !== (button_disabled_value = !ctx2[31] || ctx2[8] === "testing")) {
        button.disabled = button_disabled_value;
      }
      if (dirty[0] & 256) {
        toggle_class(button, "ftp-test-success", ctx2[8] === "success");
      }
      if (dirty[0] & 256) {
        toggle_class(button, "ftp-test-error", ctx2[8] === "error");
      }
      if (dirty[0] & 1024 && t20_value !== (t20_value = ctx2[10]("settings.ftp_test_connection_desc") + ""))
        set_data(t20, t20_value);
      if (ctx2[25]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          if_block1.m(div8, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1(ctx) {
  let t_1_value = ctx[10]("settings.ftp_test_connection") + "";
  let t_1;
  return {
    c() {
      t_1 = text2(t_1_value);
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("settings.ftp_test_connection") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_if_block_9(ctx) {
  let t_1_value = ctx[10]("settings.ftp_test_connection_failed") + "";
  let t_1;
  return {
    c() {
      t_1 = text2(t_1_value);
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("settings.ftp_test_connection_failed") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_if_block_8(ctx) {
  let t_1_value = ctx[10]("settings.ftp_test_connection_success") + "";
  let t_1;
  return {
    c() {
      t_1 = text2(t_1_value);
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("settings.ftp_test_connection_success") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_if_block_7(ctx) {
  let t_1_value = ctx[10]("settings.ftp_test_connection_testing") + "";
  let t_1;
  return {
    c() {
      t_1 = text2(t_1_value);
    },
    m(target, anchor) {
      insert(target, t_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("settings.ftp_test_connection_testing") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t_1);
    }
  };
}
function create_if_block_6(ctx) {
  let div;
  let t0_value = ctx[8] === "success" ? "\u2705" : "\u274C";
  let t0;
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text2(t0_value);
      t1 = space();
      t2 = text2(ctx[25]);
      attr(div, "class", "ftp-test-result svelte-1mea8le");
      toggle_class(div, "ftp-test-result-success", ctx[8] === "success");
      toggle_class(div, "ftp-test-result-error", ctx[8] === "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256 && t0_value !== (t0_value = ctx2[8] === "success" ? "\u2705" : "\u274C"))
        set_data(t0, t0_value);
      if (dirty[0] & 33554432)
        set_data(t2, ctx2[25]);
      if (dirty[0] & 256) {
        toggle_class(div, "ftp-test-result-success", ctx2[8] === "success");
      }
      if (dirty[0] & 256) {
        toggle_class(div, "ftp-test-result-error", ctx2[8] === "error");
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4(ctx) {
  let div1;
  let div0;
  let t_1_value = ctx[10]("ui.mdfriday_preview_hint") + "";
  let t_1;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t_1 = text2(t_1_value);
      attr(div0, "class", "field-hint svelte-1mea8le");
      attr(div1, "class", "publish-config svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.mdfriday_preview_hint") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_else_block(ctx) {
  let button;
  let t_1_value = ctx[10]("ui.publish") + "";
  let t_1;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t_1 = text2(t_1_value);
      attr(button, "class", "action-button publish-button svelte-1mea8le");
      button.disabled = button_disabled_value = !ctx[18];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t_1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[47]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("ui.publish") + ""))
        set_data(t_1, t_1_value);
      if (dirty[0] & 262144 && button_disabled_value !== (button_disabled_value = !ctx2[18])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let p;
  let t0_value = ctx[10]("ui.publish_building") + "";
  let t0;
  let t1;
  let progressbar;
  let current;
  progressbar = new ProgressBar_default({
    props: { progress: ctx[20] }
  });
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      create_component(progressbar.$$.fragment);
      attr(p, "class", "svelte-1mea8le");
      attr(div, "class", "progress-container svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      mount_component(progressbar, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 1024) && t0_value !== (t0_value = ctx2[10]("ui.publish_building") + ""))
        set_data(t0, t0_value);
      const progressbar_changes = {};
      if (dirty[0] & 1048576)
        progressbar_changes.progress = ctx2[20];
      progressbar.$set(progressbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progressbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progressbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(progressbar);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let p;
  let t0_value = ctx[10]("ui.published_successfully") + "";
  let t0;
  let t1;
  function select_block_type_5(ctx2, dirty) {
    if (ctx2[22])
      return create_if_block_1;
    if (ctx2[2] === "ftp")
      return create_if_block_2;
  }
  let current_block_type = select_block_type_5(ctx, [-1, -1, -1, -1, -1]);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(p, "class", "success-message svelte-1mea8le");
      attr(div, "class", "publish-success svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10]("ui.published_successfully") + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_5(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_if_block_2(ctx) {
  let p;
  let t_1_value = ctx[10]("messages.ftp_upload_success") + "";
  let t_1;
  return {
    c() {
      p = element("p");
      t_1 = text2(t_1_value);
      attr(p, "class", "ftp-success-info svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_1_value !== (t_1_value = ctx2[10]("messages.ftp_upload_success") + ""))
        set_data(t_1, t_1_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_1(ctx) {
  let a;
  let t_1;
  return {
    c() {
      a = element("a");
      t_1 = text2(ctx[22]);
      attr(a, "href", ctx[22]);
      attr(a, "target", "_blank");
      attr(a, "class", "publish-url svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4194304)
        set_data(t_1, ctx2[22]);
      if (dirty[0] & 4194304) {
        attr(a, "href", ctx2[22]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment3(ctx) {
  let div25;
  let div0;
  let button0;
  let t0_value = ctx[10]("projects.manage_projects") + "";
  let t0;
  let button0_aria_label_value;
  let t1;
  let div6;
  let div1;
  let t2_value = ctx[10]("ui.multilingual_content") + "";
  let t2;
  let t3;
  let div5;
  let div4;
  let div2;
  let t4_value = ctx[10]("ui.content_path") + "";
  let t4;
  let t5;
  let div3;
  let span0;
  let t6_value = ctx[10]("ui.language") + "";
  let t6;
  let t7;
  let t8;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let t9;
  let t10;
  let div7;
  let label0;
  let t11_value = ctx[10]("ui.site_name") + "";
  let t11;
  let t12;
  let input;
  let input_placeholder_value;
  let t13;
  let div12;
  let div8;
  let t14_value = ctx[10]("ui.site_assets") + "";
  let t14;
  let t15;
  let div11;
  let div9;
  let t16;
  let div10;
  let t17_value = ctx[10]("ui.site_assets_hint") + "";
  let t17;
  let t18;
  let div14;
  let div13;
  let button1;
  let span1;
  let t20;
  let t21_value = ctx[10]("ui.advanced_settings") + "";
  let t21;
  let t22;
  let t23;
  let div18;
  let label1;
  let t24_value = ctx[10]("ui.theme") + "";
  let t24;
  let t25;
  let div17;
  let div16;
  let span2;
  let t26;
  let t27;
  let div15;
  let button2;
  let t28_value = ctx[10]("ui.change_theme") + "";
  let t28;
  let t29;
  let t30;
  let div20;
  let h30;
  let t31_value = ctx[10]("ui.preview") + "";
  let t31;
  let t32;
  let div19;
  let current_block_type_index;
  let if_block5;
  let t33;
  let t34;
  let div24;
  let h31;
  let t35_value = ctx[10]("ui.publish") + "";
  let t35;
  let t36;
  let div23;
  let div21;
  let label2;
  let t37_value = ctx[10]("ui.publish_method") + "";
  let t37;
  let t38;
  let select;
  let t39;
  let t40;
  let t41;
  let t42;
  let div22;
  let current_block_type_index_1;
  let if_block10;
  let t43;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[9].length > 0 && create_if_block_20(ctx);
  let each_value_1 = ctx[9];
  const get_key = (ctx2) => ctx2[124].id;
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key2 = get_key(child_ctx);
    each0_lookup.set(key2, each_blocks_1[i] = create_each_block_1(key2, child_ctx));
  }
  let if_block1 = ctx[9].length === 0 && create_if_block_17(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[30])
      return create_if_block_16;
    return create_else_block_4;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1, -1, -1]);
  let if_block2 = current_block_type(ctx);
  let if_block3 = ctx[11] && create_if_block_15(ctx);
  let if_block4 = ctx[29] && ctx[29].demo_notes_url && create_if_block_13(ctx);
  const if_block_creators = [create_if_block_12, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[15])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1]);
  if_block5 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block6 = ctx[18] && ctx[17] && create_if_block_11(ctx);
  let each_value = ctx[33];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let if_block7 = ctx[2] === "netlify" && create_if_block_10(ctx);
  let if_block8 = ctx[2] === "ftp" && create_if_block_5(ctx);
  let if_block9 = ctx[2] === "mdf-preview" && create_if_block_4(ctx);
  const if_block_creators_1 = [create_if_block_3, create_else_block];
  const if_blocks_1 = [];
  function select_block_type_4(ctx2, dirty) {
    if (ctx2[19])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_4(ctx, [-1, -1, -1, -1, -1]);
  if_block10 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  let if_block11 = ctx[21] && create_if_block(ctx);
  return {
    c() {
      div25 = element("div");
      div0 = element("div");
      button0 = element("button");
      t0 = text2(t0_value);
      t1 = space();
      div6 = element("div");
      div1 = element("div");
      t2 = text2(t2_value);
      t3 = space();
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      t4 = text2(t4_value);
      t5 = space();
      div3 = element("div");
      span0 = element("span");
      t6 = text2(t6_value);
      t7 = space();
      if (if_block0)
        if_block0.c();
      t8 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t9 = space();
      if (if_block1)
        if_block1.c();
      t10 = space();
      div7 = element("div");
      label0 = element("label");
      t11 = text2(t11_value);
      t12 = space();
      input = element("input");
      t13 = space();
      div12 = element("div");
      div8 = element("div");
      t14 = text2(t14_value);
      t15 = space();
      div11 = element("div");
      div9 = element("div");
      if_block2.c();
      t16 = space();
      div10 = element("div");
      t17 = text2(t17_value);
      t18 = space();
      div14 = element("div");
      div13 = element("div");
      button1 = element("button");
      span1 = element("span");
      span1.textContent = "\u25B6";
      t20 = space();
      t21 = text2(t21_value);
      t22 = space();
      if (if_block3)
        if_block3.c();
      t23 = space();
      div18 = element("div");
      label1 = element("label");
      t24 = text2(t24_value);
      t25 = space();
      div17 = element("div");
      div16 = element("div");
      span2 = element("span");
      t26 = text2(ctx[32]);
      t27 = space();
      div15 = element("div");
      button2 = element("button");
      t28 = text2(t28_value);
      t29 = space();
      if (if_block4)
        if_block4.c();
      t30 = space();
      div20 = element("div");
      h30 = element("h3");
      t31 = text2(t31_value);
      t32 = space();
      div19 = element("div");
      if_block5.c();
      t33 = space();
      if (if_block6)
        if_block6.c();
      t34 = space();
      div24 = element("div");
      h31 = element("h3");
      t35 = text2(t35_value);
      t36 = space();
      div23 = element("div");
      div21 = element("div");
      label2 = element("label");
      t37 = text2(t37_value);
      t38 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t39 = space();
      if (if_block7)
        if_block7.c();
      t40 = space();
      if (if_block8)
        if_block8.c();
      t41 = space();
      if (if_block9)
        if_block9.c();
      t42 = space();
      div22 = element("div");
      if_block10.c();
      t43 = space();
      if (if_block11)
        if_block11.c();
      attr(button0, "class", "advanced-toggle svelte-1mea8le");
      attr(button0, "aria-label", button0_aria_label_value = ctx[10]("projects.manage_projects"));
      attr(div0, "class", "section advanced-settings svelte-1mea8le");
      attr(div1, "class", "section-label svelte-1mea8le");
      attr(div2, "class", "multilang-header-cell svelte-1mea8le");
      attr(div3, "class", "multilang-header-cell svelte-1mea8le");
      attr(div4, "class", "multilang-header svelte-1mea8le");
      attr(div5, "class", "multilang-table svelte-1mea8le");
      attr(div6, "class", "section svelte-1mea8le");
      attr(label0, "class", "section-label svelte-1mea8le");
      attr(label0, "for", "site-name");
      attr(input, "type", "text");
      attr(input, "class", "form-input svelte-1mea8le");
      attr(input, "placeholder", input_placeholder_value = ctx[10]("ui.site_name_placeholder"));
      attr(div7, "class", "section svelte-1mea8le");
      attr(div8, "class", "section-label svelte-1mea8le");
      attr(div9, "class", "assets-display svelte-1mea8le");
      attr(div10, "class", "assets-hint svelte-1mea8le");
      attr(div11, "class", "site-assets-container svelte-1mea8le");
      attr(div12, "class", "section svelte-1mea8le");
      attr(span1, "class", "toggle-icon svelte-1mea8le");
      toggle_class(span1, "expanded", ctx[11]);
      attr(button1, "class", "advanced-toggle svelte-1mea8le");
      attr(button1, "aria-expanded", ctx[11]);
      attr(div13, "class", "advanced-settings svelte-1mea8le");
      attr(div14, "class", "section svelte-1mea8le");
      attr(label1, "class", "section-label svelte-1mea8le");
      attr(label1, "for", "themes");
      attr(span2, "class", "theme-name svelte-1mea8le");
      attr(button2, "class", "change-theme-btn svelte-1mea8le");
      attr(div15, "class", "theme-actions svelte-1mea8le");
      attr(div16, "class", "current-theme svelte-1mea8le");
      attr(div17, "class", "theme-selector svelte-1mea8le");
      attr(div18, "class", "section svelte-1mea8le");
      attr(h30, "class", "section-title svelte-1mea8le");
      attr(div19, "class", "preview-section svelte-1mea8le");
      attr(div20, "class", "section svelte-1mea8le");
      attr(h31, "class", "section-title svelte-1mea8le");
      attr(label2, "class", "section-label svelte-1mea8le");
      attr(label2, "for", "publish-method");
      attr(select, "id", "publish-method");
      attr(select, "class", "form-select svelte-1mea8le");
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[72].call(select));
      attr(div21, "class", "publish-select-wrapper svelte-1mea8le");
      attr(div22, "class", "publish-actions svelte-1mea8le");
      attr(div23, "class", "publish-section svelte-1mea8le");
      attr(div24, "class", "section svelte-1mea8le");
      attr(div25, "class", "site-builder svelte-1mea8le");
    },
    m(target, anchor) {
      insert(target, div25, anchor);
      append(div25, div0);
      append(div0, button0);
      append(button0, t0);
      append(div25, t1);
      append(div25, div6);
      append(div6, div1);
      append(div1, t2);
      append(div6, t3);
      append(div6, div5);
      append(div5, div4);
      append(div4, div2);
      append(div2, t4);
      append(div4, t5);
      append(div4, div3);
      append(div3, span0);
      append(span0, t6);
      append(div3, t7);
      if (if_block0)
        if_block0.m(div3, null);
      append(div5, t8);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div5, null);
        }
      }
      append(div5, t9);
      if (if_block1)
        if_block1.m(div5, null);
      append(div25, t10);
      append(div25, div7);
      append(div7, label0);
      append(label0, t11);
      append(div7, t12);
      append(div7, input);
      set_input_value(input, ctx[0]);
      append(div25, t13);
      append(div25, div12);
      append(div12, div8);
      append(div8, t14);
      append(div12, t15);
      append(div12, div11);
      append(div11, div9);
      if_block2.m(div9, null);
      append(div11, t16);
      append(div11, div10);
      append(div10, t17);
      append(div25, t18);
      append(div25, div14);
      append(div14, div13);
      append(div13, button1);
      append(button1, span1);
      append(button1, t20);
      append(button1, t21);
      append(div13, t22);
      if (if_block3)
        if_block3.m(div13, null);
      append(div25, t23);
      append(div25, div18);
      append(div18, label1);
      append(label1, t24);
      append(div18, t25);
      append(div18, div17);
      append(div17, div16);
      append(div16, span2);
      append(span2, t26);
      append(div16, t27);
      append(div16, div15);
      append(div15, button2);
      append(button2, t28);
      append(div15, t29);
      if (if_block4)
        if_block4.m(div15, null);
      append(div25, t30);
      append(div25, div20);
      append(div20, h30);
      append(h30, t31);
      append(div20, t32);
      append(div20, div19);
      if_blocks[current_block_type_index].m(div19, null);
      append(div19, t33);
      if (if_block6)
        if_block6.m(div19, null);
      append(div25, t34);
      append(div25, div24);
      append(div24, h31);
      append(h31, t35);
      append(div24, t36);
      append(div24, div23);
      append(div23, div21);
      append(div21, label2);
      append(label2, t37);
      append(div21, t38);
      append(div21, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(select, ctx[2], true);
      append(div23, t39);
      if (if_block7)
        if_block7.m(div23, null);
      append(div23, t40);
      if (if_block8)
        if_block8.m(div23, null);
      append(div23, t41);
      if (if_block9)
        if_block9.m(div23, null);
      append(div23, t42);
      append(div23, div22);
      if_blocks_1[current_block_type_index_1].m(div22, null);
      append(div23, t43);
      if (if_block11)
        if_block11.m(div23, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[42]),
          listen(input, "input", ctx[67]),
          listen(button1, "click", ctx[44]),
          listen(button2, "click", ctx[41]),
          listen(select, "change", ctx[72])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 1024) && t0_value !== (t0_value = ctx2[10]("projects.manage_projects") + ""))
        set_data(t0, t0_value);
      if (!current || dirty[0] & 1024 && button0_aria_label_value !== (button0_aria_label_value = ctx2[10]("projects.manage_projects"))) {
        attr(button0, "aria-label", button0_aria_label_value);
      }
      if ((!current || dirty[0] & 1024) && t2_value !== (t2_value = ctx2[10]("ui.multilingual_content") + ""))
        set_data(t2, t2_value);
      if ((!current || dirty[0] & 1024) && t4_value !== (t4_value = ctx2[10]("ui.content_path") + ""))
        set_data(t4, t4_value);
      if ((!current || dirty[0] & 1024) && t6_value !== (t6_value = ctx2[10]("ui.language") + ""))
        set_data(t6, t6_value);
      if (ctx2[9].length > 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_20(ctx2);
          if_block0.c();
          if_block0.m(div3, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 1536 | dirty[1] & 224) {
        each_value_1 = ctx2[9];
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx2, each_value_1, each0_lookup, div5, destroy_block, create_each_block_1, t9, get_each_context_1);
      }
      if (ctx2[9].length === 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_17(ctx2);
          if_block1.c();
          if_block1.m(div5, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty[0] & 1024) && t11_value !== (t11_value = ctx2[10]("ui.site_name") + ""))
        set_data(t11, t11_value);
      if (!current || dirty[0] & 1024 && input_placeholder_value !== (input_placeholder_value = ctx2[10]("ui.site_name_placeholder"))) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty[0] & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if ((!current || dirty[0] & 1024) && t14_value !== (t14_value = ctx2[10]("ui.site_assets") + ""))
        set_data(t14, t14_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div9, null);
        }
      }
      if ((!current || dirty[0] & 1024) && t17_value !== (t17_value = ctx2[10]("ui.site_assets_hint") + ""))
        set_data(t17, t17_value);
      if (!current || dirty[0] & 2048) {
        toggle_class(span1, "expanded", ctx2[11]);
      }
      if ((!current || dirty[0] & 1024) && t21_value !== (t21_value = ctx2[10]("ui.advanced_settings") + ""))
        set_data(t21, t21_value);
      if (!current || dirty[0] & 2048) {
        attr(button1, "aria-expanded", ctx2[11]);
      }
      if (ctx2[11]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_15(ctx2);
          if_block3.c();
          if_block3.m(div13, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if ((!current || dirty[0] & 1024) && t24_value !== (t24_value = ctx2[10]("ui.theme") + ""))
        set_data(t24, t24_value);
      if (!current || dirty[1] & 2)
        set_data(t26, ctx2[32]);
      if ((!current || dirty[0] & 1024) && t28_value !== (t28_value = ctx2[10]("ui.change_theme") + ""))
        set_data(t28, t28_value);
      if (ctx2[29] && ctx2[29].demo_notes_url) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 536870912) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_13(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div15, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if ((!current || dirty[0] & 1024) && t31_value !== (t31_value = ctx2[10]("ui.preview") + ""))
        set_data(t31, t31_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block5 = if_blocks[current_block_type_index];
        if (!if_block5) {
          if_block5 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block5.c();
        } else {
          if_block5.p(ctx2, dirty);
        }
        transition_in(if_block5, 1);
        if_block5.m(div19, t33);
      }
      if (ctx2[18] && ctx2[17]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block_11(ctx2);
          if_block6.c();
          if_block6.m(div19, null);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if ((!current || dirty[0] & 1024) && t35_value !== (t35_value = ctx2[10]("ui.publish") + ""))
        set_data(t35, t35_value);
      if ((!current || dirty[0] & 1024) && t37_value !== (t37_value = ctx2[10]("ui.publish_method") + ""))
        set_data(t37, t37_value);
      if (dirty[1] & 4) {
        each_value = ctx2[33];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 4 | dirty[1] & 4) {
        select_option(select, ctx2[2]);
      }
      if (ctx2[2] === "netlify") {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
        } else {
          if_block7 = create_if_block_10(ctx2);
          if_block7.c();
          if_block7.m(div23, t40);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (ctx2[2] === "ftp") {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block_5(ctx2);
          if_block8.c();
          if_block8.m(div23, t41);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (ctx2[2] === "mdf-preview") {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
        } else {
          if_block9 = create_if_block_4(ctx2);
          if_block9.c();
          if_block9.m(div23, t42);
        }
      } else if (if_block9) {
        if_block9.d(1);
        if_block9 = null;
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_4(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block10 = if_blocks_1[current_block_type_index_1];
        if (!if_block10) {
          if_block10 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block10.c();
        } else {
          if_block10.p(ctx2, dirty);
        }
        transition_in(if_block10, 1);
        if_block10.m(div22, null);
      }
      if (ctx2[21]) {
        if (if_block11) {
          if_block11.p(ctx2, dirty);
        } else {
          if_block11 = create_if_block(ctx2);
          if_block11.c();
          if_block11.m(div23, null);
        }
      } else if (if_block11) {
        if_block11.d(1);
        if_block11 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block10);
      current = true;
    },
    o(local) {
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block10);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div25);
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      if (if_block1)
        if_block1.d();
      if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if_blocks[current_block_type_index].d();
      if (if_block6)
        if_block6.d();
      destroy_each(each_blocks, detaching);
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
      if_blocks_1[current_block_type_index_1].d();
      if (if_block11)
        if_block11.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
var BOOK_THEME_URL = "https://gohugo.net/book-ob.zip?version=1.1";
var BOOK_THEME_ID = "3";
var BOOK_THEME_NAME = "Obsidian Book";
var NOTE_THEME_URL = "https://gohugo.net/note.zip?version=1.2";
var NOTE_THEME_ID = "2";
var NOTE_THEME_NAME = "Note";
var FRIDAY_ROOT_FOLDER = "MDFriday";
var serverHost = "localhost";
var serverPort = 8090;
function normalizeSitePath(path8) {
  if (!path8.startsWith("/")) {
    path8 = "/" + path8;
  }
  if (path8.length > 1 && path8.endsWith("/")) {
    path8 = path8.slice(0, -1);
  }
  return path8;
}
function generateRandomId() {
  return Math.random().toString(36).substring(2, 8);
}
function instance3($$self, $$props, $$invalidate) {
  let site;
  let languageContents;
  let siteAssets;
  let t;
  let currentContents;
  let currentAssets;
  let isForSingleFile;
  let defaultContentLanguage;
  let publishOptions;
  let displayThemeName;
  let isFTPConfigured;
  let $siteAssets, $$unsubscribe_siteAssets = noop, $$subscribe_siteAssets = () => ($$unsubscribe_siteAssets(), $$unsubscribe_siteAssets = subscribe(siteAssets, ($$value) => $$invalidate(63, $siteAssets = $$value)), siteAssets);
  let $languageContents, $$unsubscribe_languageContents = noop, $$subscribe_languageContents = () => ($$unsubscribe_languageContents(), $$unsubscribe_languageContents = subscribe(languageContents, ($$value) => $$invalidate(64, $languageContents = $$value)), languageContents);
  $$self.$$.on_destroy.push(() => $$unsubscribe_siteAssets());
  $$self.$$.on_destroy.push(() => $$unsubscribe_languageContents());
  var _a, _b, _c, _d, _e;
  let { app } = $$props;
  let { plugin } = $$props;
  const isWindows = process.platform === "win32";
  let basePath = plugin.pluginDir;
  let absSelectedFolderPath = [];
  let absProjContentPath = [];
  let contentPath = "";
  let siteName = "";
  let previousContentLength = 0;
  let sitePath = "/";
  let selectedThemeDownloadUrl = BOOK_THEME_URL;
  let selectedThemeName = BOOK_THEME_NAME;
  let selectedThemeId = BOOK_THEME_ID;
  let userHasSelectedTheme = false;
  let showAdvancedSettings = false;
  let googleAnalyticsId = "";
  let disqusShortname = "";
  let sitePassword = "";
  let themesDir = "";
  let isBuilding = false;
  let buildProgress = 0;
  let previewUrl = "";
  let previewId = "";
  let hasPreview = false;
  let absPreviewDir = "";
  let isPublishing = false;
  let publishProgress = 0;
  let publishSuccess = false;
  let publishUrl = "";
  let selectedPublishOption = plugin.settings.publishMethod || "netlify";
  let netlifyAccessToken = "";
  let netlifyProjectId = "";
  let ftpServer = "";
  let ftpUsername = "";
  let ftpPassword = "";
  let ftpRemoteDir = "";
  let ftpIgnoreCert = true;
  let ftpPreferredSecure = void 0;
  let ftpTestState = "idle";
  let ftpTestMessage = "";
  let isExporting = false;
  let isDownloadingSample = false;
  let sampleDownloadProgress = 0;
  let currentThemeWithSample = null;
  let httpServer;
  let serverRunning = false;
  onMount(async () => {
    themesDir = path3.join(plugin.pluginDir, "themes");
    await createThemesDirectory();
    const adapter = app.vault.adapter;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      basePath = adapter.getBasePath();
    }
    $$invalidate(50, plugin.applyProjectConfigurationToPanel = applyProjectConfiguration, plugin);
  });
  onDestroy(() => {
    if (serverRunning) {
      httpServer.stopWatching();
      serverRunning = false;
    }
  });
  const SUPPORTED_LANGUAGES = [
    {
      code: "en",
      name: "English",
      direction: "ltr",
      englishName: "English"
    },
    {
      code: "zh",
      name: "\u4E2D\u6587",
      direction: "ltr",
      englishName: "Chinese"
    },
    {
      code: "es",
      name: "Espa\xF1ol",
      direction: "ltr",
      englishName: "Spanish"
    },
    {
      code: "fr",
      name: "Fran\xE7ais",
      direction: "ltr",
      englishName: "French"
    },
    {
      code: "de",
      name: "Deutsch",
      direction: "ltr",
      englishName: "German"
    },
    {
      code: "ja",
      name: "\u65E5\u672C\u8A9E",
      direction: "ltr",
      englishName: "Japanese"
    },
    {
      code: "ko",
      name: "\uD55C\uAD6D\uC5B4",
      direction: "ltr",
      englishName: "Korean"
    },
    {
      code: "pt",
      name: "Portugu\xEAs",
      direction: "ltr",
      englishName: "Portuguese"
    }
  ];
  function updateLanguageCode(contentId, newLanguageCode) {
    site.updateLanguageCode(contentId, newLanguageCode);
  }
  function removeLanguageContent(contentId) {
    site.removeLanguageContent(contentId);
  }
  function clearAllContent() {
    site.clearAllContent();
  }
  function clearSiteAssets() {
    site.clearSiteAssets();
  }
  function getLanguageName(code) {
    const lang = SUPPORTED_LANGUAGES.find((l) => l.code === code);
    return lang ? lang.name : code;
  }
  function showAddLanguageDialog() {
    new import_obsidian3.Notice(t("messages.add_language_instruction"), 5e3);
  }
  function loadDefaultPublishConfigIfNeeded() {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h;
    const projectId = getProjectId();
    if (!projectId) {
      return;
    }
    const existingProject = plugin.projectService.getProject(projectId);
    if (existingProject && existingProject.publishConfig) {
      $$invalidate(2, selectedPublishOption = existingProject.publishConfig.method || "netlify");
      $$invalidate(23, netlifyAccessToken = ((_a2 = existingProject.publishConfig.netlify) === null || _a2 === void 0 ? void 0 : _a2.accessToken) || "");
      $$invalidate(24, netlifyProjectId = ((_b2 = existingProject.publishConfig.netlify) === null || _b2 === void 0 ? void 0 : _b2.projectId) || "");
      $$invalidate(3, ftpServer = ((_c2 = existingProject.publishConfig.ftp) === null || _c2 === void 0 ? void 0 : _c2.server) || "");
      $$invalidate(4, ftpUsername = ((_d2 = existingProject.publishConfig.ftp) === null || _d2 === void 0 ? void 0 : _d2.username) || "");
      $$invalidate(5, ftpPassword = ((_e2 = existingProject.publishConfig.ftp) === null || _e2 === void 0 ? void 0 : _e2.password) || "");
      $$invalidate(6, ftpRemoteDir = ((_f = existingProject.publishConfig.ftp) === null || _f === void 0 ? void 0 : _f.remoteDir) || "");
      $$invalidate(7, ftpIgnoreCert = ((_g = existingProject.publishConfig.ftp) === null || _g === void 0 ? void 0 : _g.ignoreCert) !== void 0 ? existingProject.publishConfig.ftp.ignoreCert : true);
      ftpPreferredSecure = (_h = existingProject.publishConfig.ftp) === null || _h === void 0 ? void 0 : _h.preferredSecure;
    } else {
      $$invalidate(2, selectedPublishOption = plugin.settings.publishMethod || "netlify");
      $$invalidate(23, netlifyAccessToken = plugin.settings.netlifyAccessToken || "");
      $$invalidate(24, netlifyProjectId = plugin.settings.netlifyProjectId || "");
      $$invalidate(3, ftpServer = plugin.settings.ftpServer || "");
      $$invalidate(4, ftpUsername = plugin.settings.ftpUsername || "");
      $$invalidate(5, ftpPassword = plugin.settings.ftpPassword || "");
      $$invalidate(6, ftpRemoteDir = plugin.settings.ftpRemoteDir || "");
      $$invalidate(7, ftpIgnoreCert = plugin.settings.ftpIgnoreCert !== void 0 ? plugin.settings.ftpIgnoreCert : true);
      ftpPreferredSecure = void 0;
    }
    $$invalidate(8, ftpTestState = "idle");
    $$invalidate(25, ftpTestMessage = "");
  }
  function openThemeModal() {
    plugin.showThemeSelectionModal(selectedThemeId, async (themeUrl, themeName, themeId) => {
      $$invalidate(58, selectedThemeDownloadUrl = themeUrl);
      $$invalidate(59, selectedThemeName = themeName || (isForSingleFile ? "Note" : "Book"));
      selectedThemeId = themeId || selectedThemeId;
      $$invalidate(60, userHasSelectedTheme = true);
      if (themeId) {
        try {
          $$invalidate(29, currentThemeWithSample = await themeApiService.getThemeById(themeId, plugin));
        } catch (error) {
          console.warn("Failed to get theme info:", error);
          $$invalidate(29, currentThemeWithSample = null);
        }
      }
    }, isForSingleFile);
  }
  function openProjectsModal() {
    plugin.showProjectManagementModal(applyProjectConfiguration, exportHistoryBuild, clearPreviewHistory);
  }
  async function exportHistoryBuild(previewId2) {
    try {
      const previewDir = path3.join(plugin.pluginDir, "preview", previewId2);
      const publicDir = path3.join(previewDir, "public");
      const adapter = app.vault.adapter;
      if (!await adapter.exists(publicDir)) {
        new import_obsidian3.Notice(t("projects.preview_not_found"), 5e3);
        return;
      }
      const absPublicDir = path3.join(basePath, publicDir);
      const zipContent = await createZipFromDirectory(absPublicDir);
      const { dialog } = require("@electron/remote") || require("electron").remote;
      const { canceled, filePath } = await dialog.showSaveDialog({
        title: t("ui.export_site_dialog_title"),
        defaultPath: `mdfriday-site-${previewId2}.zip`,
        filters: [
          { name: "ZIP Files", extensions: ["zip"] },
          { name: "All Files", extensions: ["*"] }
        ]
      });
      if (!canceled && filePath) {
        await fs3.promises.writeFile(filePath, zipContent);
        new import_obsidian3.Notice(t("messages.site_exported_successfully", { path: filePath }), 3e3);
      }
    } catch (error) {
      console.error("Export history build failed:", error);
      new import_obsidian3.Notice(t("messages.export_failed", { error: error.message }), 5e3);
    }
  }
  async function clearPreviewHistory(projectId) {
    try {
      const confirmed = confirm(t("projects.confirm_clear_history"));
      if (!confirmed) {
        return;
      }
      const buildHistory = plugin.projectService.getBuildHistory(projectId, 1e3);
      const previewIds = buildHistory.filter((h) => h.previewId).map((h) => h.previewId);
      if (previewIds.length === 0) {
        new import_obsidian3.Notice(t("projects.no_preview_files"), 3e3);
        return;
      }
      const previewRoot = path3.join(plugin.pluginDir, "preview");
      const adapter = app.vault.adapter;
      if (!await adapter.exists(previewRoot)) {
        new import_obsidian3.Notice(t("projects.no_preview_files"), 3e3);
        return;
      }
      const absPreviewRoot = path3.join(basePath, previewRoot);
      let deletedCount = 0;
      for (const previewId2 of previewIds) {
        const previewDirPath = path3.join(absPreviewRoot, previewId2);
        try {
          if (await fs3.promises.access(previewDirPath).then(() => true).catch(() => false)) {
            await fs3.promises.rm(previewDirPath, { recursive: true, force: true });
            deletedCount++;
          }
        } catch (error) {
          console.warn(`Failed to delete preview directory ${previewId2}:`, error);
        }
      }
      await plugin.projectService.clearProjectBuildHistory(projectId);
      if (deletedCount > 0) {
        new import_obsidian3.Notice(t("projects.preview_history_cleared", { count: deletedCount }), 3e3);
      } else {
        new import_obsidian3.Notice(t("projects.no_preview_files"), 3e3);
      }
    } catch (error) {
      console.error("Clear preview history failed:", error);
      new import_obsidian3.Notice(t("messages.export_failed", { error: error.message }), 5e3);
    }
  }
  async function applyProjectConfiguration(project) {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h;
    try {
      site.clearAllContent();
      $$invalidate(0, siteName = project.name);
      $$invalidate(58, selectedThemeDownloadUrl = project.themeUrl);
      $$invalidate(59, selectedThemeName = project.themeName);
      selectedThemeId = project.themeId;
      $$invalidate(60, userHasSelectedTheme = true);
      $$invalidate(1, sitePath = project.sitePath);
      $$invalidate(12, googleAnalyticsId = project.googleAnalyticsId || "");
      $$invalidate(13, disqusShortname = project.disqusShortname || "");
      $$invalidate(14, sitePassword = project.sitePassword || "");
      if (project.publishConfig) {
        $$invalidate(2, selectedPublishOption = project.publishConfig.method || "netlify");
        $$invalidate(23, netlifyAccessToken = ((_a2 = project.publishConfig.netlify) === null || _a2 === void 0 ? void 0 : _a2.accessToken) || "");
        $$invalidate(24, netlifyProjectId = ((_b2 = project.publishConfig.netlify) === null || _b2 === void 0 ? void 0 : _b2.projectId) || "");
        $$invalidate(3, ftpServer = ((_c2 = project.publishConfig.ftp) === null || _c2 === void 0 ? void 0 : _c2.server) || "");
        $$invalidate(4, ftpUsername = ((_d2 = project.publishConfig.ftp) === null || _d2 === void 0 ? void 0 : _d2.username) || "");
        $$invalidate(5, ftpPassword = ((_e2 = project.publishConfig.ftp) === null || _e2 === void 0 ? void 0 : _e2.password) || "");
        $$invalidate(6, ftpRemoteDir = ((_f = project.publishConfig.ftp) === null || _f === void 0 ? void 0 : _f.remoteDir) || "");
        $$invalidate(7, ftpIgnoreCert = ((_g = project.publishConfig.ftp) === null || _g === void 0 ? void 0 : _g.ignoreCert) !== void 0 ? project.publishConfig.ftp.ignoreCert : true);
        ftpPreferredSecure = (_h = project.publishConfig.ftp) === null || _h === void 0 ? void 0 : _h.preferredSecure;
      } else {
        $$invalidate(2, selectedPublishOption = plugin.settings.publishMethod || "netlify");
        $$invalidate(23, netlifyAccessToken = plugin.settings.netlifyAccessToken || "");
        $$invalidate(24, netlifyProjectId = plugin.settings.netlifyProjectId || "");
        $$invalidate(3, ftpServer = plugin.settings.ftpServer || "");
        $$invalidate(4, ftpUsername = plugin.settings.ftpUsername || "");
        $$invalidate(5, ftpPassword = plugin.settings.ftpPassword || "");
        $$invalidate(6, ftpRemoteDir = plugin.settings.ftpRemoteDir || "");
        $$invalidate(7, ftpIgnoreCert = plugin.settings.ftpIgnoreCert !== void 0 ? plugin.settings.ftpIgnoreCert : true);
        ftpPreferredSecure = void 0;
      }
      $$invalidate(8, ftpTestState = "idle");
      $$invalidate(25, ftpTestMessage = "");
      let contentLoadedCount = 0;
      if (project.contents && project.contents.length > 0) {
        for (let i = 0; i < project.contents.length; i++) {
          const contentConfig = project.contents[i];
          const abstractFile = app.vault.getAbstractFileByPath(contentConfig.contentPath);
          if (abstractFile) {
            if (abstractFile instanceof import_obsidian3.TFolder) {
              if (i === 0) {
                site.initializeContentWithLanguage(abstractFile, null, contentConfig.languageCode);
              } else {
                site.addLanguageContentWithCode(abstractFile, null, contentConfig.languageCode);
              }
              contentLoadedCount++;
            } else if (abstractFile instanceof import_obsidian3.TFile && abstractFile.extension === "md") {
              if (i === 0) {
                site.initializeContentWithLanguage(null, abstractFile, contentConfig.languageCode);
              } else {
                site.addLanguageContentWithCode(null, abstractFile, contentConfig.languageCode);
              }
              contentLoadedCount++;
            }
          } else {
            console.warn(`Content path not found: ${contentConfig.contentPath}`);
          }
        }
      }
      if (project.assetsPath) {
        const assetsFile = app.vault.getAbstractFileByPath(project.assetsPath);
        if (assetsFile instanceof import_obsidian3.TFolder) {
          site.setSiteAssets(assetsFile);
        } else {
          console.warn(`Assets path not found: ${project.assetsPath}`);
        }
      }
      if (contentLoadedCount > 0) {
        const contentText = contentLoadedCount === 1 ? "content" : "contents";
        new import_obsidian3.Notice(t("projects.project_applied") + `
\u2705 ${contentLoadedCount} ${contentText} loaded`, 3e3);
      } else {
        new import_obsidian3.Notice(t("projects.project_applied_no_content"), 5e3);
      }
    } catch (error) {
      console.error("Failed to apply project configuration:", error);
      new import_obsidian3.Notice(t("messages.export_failed", { error: error.message }), 5e3);
    }
  }
  function getProjectId() {
    var _a2, _b2;
    if (currentContents.length === 0) {
      return "";
    }
    const firstContent = currentContents[0];
    let projectId = ((_a2 = firstContent.folder) === null || _a2 === void 0 ? void 0 : _a2.path) || ((_b2 = firstContent.file) === null || _b2 === void 0 ? void 0 : _b2.path) || "";
    const contentFolder = firstContent.folder || (firstContent.file ? firstContent.file.parent : null);
    if (contentFolder && contentFolder.parent) {
      const folderName = contentFolder.name.toLowerCase();
      if (folderName === "content" || folderName.startsWith("content.")) {
        projectId = contentFolder.parent.path;
      }
    }
    return projectId;
  }
  async function saveCurrentProjectConfiguration() {
    var _a2;
    if (currentContents.length === 0 || !siteName) {
      return;
    }
    try {
      const projectId = getProjectId();
      if (!projectId) {
        return;
      }
      const projectName = siteName;
      const existingProject = plugin.projectService.getProject(projectId);
      const now = Date.now();
      const hasNetlifyConfig = !!(netlifyAccessToken || netlifyProjectId);
      const hasFtpConfig = !!(ftpServer || ftpUsername || ftpPassword || ftpRemoteDir);
      const hasPublishConfig = hasNetlifyConfig || hasFtpConfig;
      const projectConfig = {
        id: projectId,
        name: projectName,
        contents: currentContents.map((content) => {
          var _a3, _b2;
          return {
            languageCode: content.languageCode,
            contentPath: ((_a3 = content.folder) === null || _a3 === void 0 ? void 0 : _a3.path) || ((_b2 = content.file) === null || _b2 === void 0 ? void 0 : _b2.path) || "",
            weight: content.weight
          };
        }),
        defaultContentLanguage,
        assetsPath: ((_a2 = currentAssets === null || currentAssets === void 0 ? void 0 : currentAssets.folder) === null || _a2 === void 0 ? void 0 : _a2.path) || void 0,
        sitePath,
        themeUrl: selectedThemeDownloadUrl,
        themeName: selectedThemeName,
        themeId: selectedThemeId,
        googleAnalyticsId: googleAnalyticsId || void 0,
        disqusShortname: disqusShortname || void 0,
        sitePassword: sitePassword || void 0,
        publishConfig: hasPublishConfig ? {
          method: selectedPublishOption,
          netlify: hasNetlifyConfig ? {
            accessToken: netlifyAccessToken || void 0,
            projectId: netlifyProjectId || void 0
          } : void 0,
          ftp: hasFtpConfig ? {
            server: ftpServer || void 0,
            username: ftpUsername || void 0,
            password: ftpPassword || void 0,
            remoteDir: ftpRemoteDir || void 0,
            ignoreCert: ftpIgnoreCert,
            preferredSecure: ftpPreferredSecure
          } : void 0
        } : void 0,
        createdAt: (existingProject === null || existingProject === void 0 ? void 0 : existingProject.createdAt) || now,
        updatedAt: now
      };
      await plugin.projectService.saveProject(projectConfig);
    } catch (error) {
      console.error("Failed to save project configuration:", error);
    }
  }
  async function downloadThemeSample() {
    if (!currentThemeWithSample || !currentThemeWithSample.demo_notes_url) {
      return;
    }
    $$invalidate(27, isDownloadingSample = true);
    $$invalidate(28, sampleDownloadProgress = 0);
    try {
      await ensureRootFolderExists();
      const baseName = currentThemeWithSample.name.toLowerCase().replace(/\s+/g, "-");
      const targetFolderName = await generateUniqueFolderName(baseName);
      const adapter = app.vault.adapter;
      let targetFolderPath;
      if (adapter instanceof import_obsidian3.FileSystemAdapter) {
        const vaultBasePath = adapter.getBasePath();
        targetFolderPath = path3.join(vaultBasePath, FRIDAY_ROOT_FOLDER, targetFolderName);
      } else {
        targetFolderPath = path3.join(FRIDAY_ROOT_FOLDER, targetFolderName);
      }
      if (isWindows) {
        targetFolderPath = path3.normalize(targetFolderPath);
      }
      await downloadAndUnzipSample(currentThemeWithSample.demo_notes_url, targetFolderPath, (progress) => {
        $$invalidate(28, sampleDownloadProgress = progress);
      });
      new import_obsidian3.Notice(t("messages.sample_downloaded_successfully", {
        themeName: currentThemeWithSample.name,
        folderName: targetFolderName
      }), 5e3);
    } catch (error) {
      console.error("Sample download failed:", error);
      console.error("Error details:", {
        themeName: currentThemeWithSample === null || currentThemeWithSample === void 0 ? void 0 : currentThemeWithSample.name,
        downloadUrl: currentThemeWithSample === null || currentThemeWithSample === void 0 ? void 0 : currentThemeWithSample.demo_notes_url,
        platform: process.platform,
        error: error.message
      });
      new import_obsidian3.Notice(t("messages.sample_download_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(27, isDownloadingSample = false);
      $$invalidate(28, sampleDownloadProgress = 0);
    }
  }
  function toggleAdvancedSettings() {
    $$invalidate(11, showAdvancedSettings = !showAdvancedSettings);
  }
  function handleSitePathChange() {
    $$invalidate(1, sitePath = normalizeSitePath(sitePath));
  }
  async function createRendererBasedOnTheme() {
    var _a2, _b2, _c2, _d2, _e2, _f, _g;
    try {
      const themeInfo = await themeApiService.getThemeById(selectedThemeId, plugin);
      const obImagesDir = path3.join(absPreviewDir, "public", "ob-images");
      const hasOBTag = ((_a2 = themeInfo === null || themeInfo === void 0 ? void 0 : themeInfo.tags) === null || _a2 === void 0 ? void 0 : _a2.some((tag) => tag.toLowerCase() === "obsidian")) || false;
      if (hasOBTag) {
        const renderer = new OBStyleRenderer(plugin, {
          includeCSS: true,
          waitForPlugins: true,
          timeout: 200,
          containerWidth: "1000px",
          includeTheme: true
        });
        renderer.getResourceProcessor().configureImageOutput(obImagesDir, sitePath, (_c2 = (_b2 = currentContents[0]) === null || _b2 === void 0 ? void 0 : _b2.folder) === null || _c2 === void 0 ? void 0 : _c2.name);
        return renderer;
      } else {
        const renderer = createStyleRenderer(plugin, {
          autoHeadingID: true,
          waitForStable: false
        });
        if (renderer.getResourceProcessor) {
          renderer.getResourceProcessor().configureImageOutput(obImagesDir, sitePath, (_e2 = (_d2 = currentContents[0]) === null || _d2 === void 0 ? void 0 : _d2.folder) === null || _e2 === void 0 ? void 0 : _e2.name);
        }
        return renderer;
      }
    } catch (error) {
      console.warn("Failed to get theme info, falling back to lightweight renderer:", error);
      const obImagesDir = path3.join(absPreviewDir, "public", "ob-images");
      const renderer = createStyleRenderer(plugin, {
        autoHeadingID: true,
        waitForStable: false
      });
      if (renderer.getResourceProcessor) {
        renderer.getResourceProcessor().configureImageOutput(obImagesDir, sitePath, (_g = (_f = currentContents[0]) === null || _f === void 0 ? void 0 : _f.folder) === null || _g === void 0 ? void 0 : _g.name);
      }
      return renderer;
    }
  }
  async function createSitePathStructure(previewDir) {
    if (sitePath === "/") {
      return path3.join(previewDir, "public");
    }
    const pathParts = sitePath.split("/").filter((part) => part !== "");
    if (pathParts.length === 0) {
      return path3.join(previewDir, "public");
    }
    let currentDir = previewDir;
    for (let i = 0; i < pathParts.length - 1; i++) {
      currentDir = path3.join(currentDir, pathParts[i]);
      if (!await app.vault.adapter.exists(currentDir)) {
        await app.vault.adapter.mkdir(currentDir);
      }
    }
    const finalDirName = pathParts[pathParts.length - 1];
    const finalDirPath = path3.join(currentDir, finalDirName);
    const publicDir = path3.join(previewDir, "public");
    if (await app.vault.adapter.exists(finalDirPath)) {
      await app.vault.adapter.rmdir(finalDirPath, true);
    }
    const adapter = app.vault.adapter;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      const absFinalDirPath = path3.join(adapter.getBasePath(), finalDirPath);
      const absPublicDir = path3.join(adapter.getBasePath(), publicDir);
      try {
        if (isWindows) {
          await fs3.promises.symlink(absPublicDir, absFinalDirPath, "junction");
        } else {
          await fs3.promises.symlink(absPublicDir, absFinalDirPath, "dir");
        }
      } catch (error) {
        console.error("Failed to create symlink for site path:", error);
        await fs3.promises.cp(absPublicDir, absFinalDirPath, { recursive: true });
      }
    }
    return previewDir;
  }
  async function startPreview() {
    if (currentContents.length === 0) {
      new import_obsidian3.Notice(t("messages.no_folder_or_file_selected"), 3e3);
      return;
    }
    $$invalidate(15, isBuilding = true);
    $$invalidate(16, buildProgress = 0);
    $$invalidate(18, hasPreview = false);
    try {
      if (serverRunning) {
        await httpServer.stopWatching();
        serverRunning = false;
      }
      absSelectedFolderPath = [];
      absProjContentPath = [];
      previewId = generateRandomId();
      const previewDir = path3.join(plugin.pluginDir, "preview", previewId);
      await createPreviewDirectory(previewDir);
      $$invalidate(16, buildProgress = 5);
      if (sitePath.startsWith("/preview")) {
        $$invalidate(1, sitePath = `/preview/${previewId}`);
      }
      await createConfigFile(previewDir);
      $$invalidate(16, buildProgress = 10);
      await linkMultiLanguageContents(previewDir);
      $$invalidate(16, buildProgress = 15);
      if (currentAssets && currentAssets.folder) {
        await copySiteAssetsToPreview(previewDir);
        $$invalidate(16, buildProgress = 18);
      }
      absPreviewDir = path3.join(basePath, previewDir);
      const absThemesDir = path3.join(basePath, themesDir);
      const serverRootDir = await createSitePathStructure(previewDir);
      const obImagesDir = path3.join(absPreviewDir, "public", "ob-images");
      const styleRenderer = await createRendererBasedOnTheme();
      const httpClient = {
        async download(url, targetPath, options) {
          try {
            if (options === null || options === void 0 ? void 0 : options.onProgress) {
              options.onProgress({ percentage: 0, loaded: 0 });
            }
            const response = await (0, import_obsidian3.requestUrl)({
              url,
              method: "GET",
              headers: options === null || options === void 0 ? void 0 : options.headers
            });
            if (response.status !== 200) {
              throw new Error(`Download failed with status: ${response.status}`);
            }
            if (options === null || options === void 0 ? void 0 : options.onProgress) {
              const arrayBuffer = response.arrayBuffer;
              const total = arrayBuffer.byteLength;
              options.onProgress({ percentage: 50, loaded: total / 2, total });
            }
            const targetDir = path3.dirname(targetPath);
            if (!await checkFolderExists(targetDir)) {
              if (path3.isAbsolute(targetDir)) {
                await fs3.promises.mkdir(targetDir, { recursive: true });
              } else {
                await app.vault.adapter.mkdir(targetDir);
              }
            }
            const fileContent = new Uint8Array(response.arrayBuffer);
            if (path3.isAbsolute(targetPath)) {
              await fs3.promises.writeFile(targetPath, fileContent);
            } else {
              await app.vault.adapter.writeBinary(targetPath, fileContent.buffer);
            }
            if (options === null || options === void 0 ? void 0 : options.onProgress) {
              const total = fileContent.length;
              options.onProgress({ percentage: 100, loaded: total, total });
            }
          } catch (error) {
            console.error("HTTP download failed:", error);
            throw error;
          }
        },
        async get(url, options) {
          try {
            const response = await (0, import_obsidian3.requestUrl)({
              url,
              method: "GET",
              headers: options === null || options === void 0 ? void 0 : options.headers
            });
            return {
              data: response.arrayBuffer,
              headers: response.headers || {},
              status: response.status
            };
          } catch (error) {
            console.error("HTTP get failed:", error);
            throw error;
          }
        }
      };
      httpServer = await (0, import_foundry2.startIncrementalBuild)({
        projDir: absPreviewDir,
        modulesDir: absThemesDir,
        contentDirs: absSelectedFolderPath,
        projContentDirs: absProjContentPath,
        publicDir: path3.join(basePath, serverRootDir),
        enableWatching: true,
        batchDelay: 500,
        progressCallback: (progress) => {
          $$invalidate(16, buildProgress = 15 + progress.percentage / 100 * 85);
        },
        markdown: styleRenderer,
        httpClient,
        liveReload: {
          enabled: true,
          port: serverPort,
          host: serverHost,
          livereloadPort: 35729
        }
      });
      serverRunning = true;
      $$invalidate(16, buildProgress = 100);
      if (sitePath === "/") {
        if (isForSingleFile) {
          $$invalidate(17, previewUrl = `${httpServer.getServerUrl()}/`);
        } else {
          $$invalidate(17, previewUrl = httpServer.getServerUrl());
        }
      } else {
        $$invalidate(17, previewUrl = `${httpServer.getServerUrl()}${sitePath}/`);
      }
      $$invalidate(18, hasPreview = true);
      window.open(previewUrl, "_blank");
      new import_obsidian3.Notice(t("messages.preview_generated_successfully"), 3e3);
      await saveCurrentProjectConfiguration();
      if (currentContents.length > 0 && siteName) {
        const projectId = getProjectId();
        if (projectId) {
          await plugin.projectService.addBuildHistory({
            projectId,
            timestamp: Date.now(),
            success: true,
            type: "preview",
            url: previewUrl,
            previewId
          });
        }
      }
      plugin.hugoverse.sendCounter("preview").catch((error) => {
        console.warn("Counter request failed (non-critical):", error);
      });
    } catch (error) {
      console.error("Preview generation failed:", error);
      new import_obsidian3.Notice(t("messages.preview_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(15, isBuilding = false);
    }
  }
  async function startPublish() {
    if (!hasPreview) {
      new import_obsidian3.Notice(t("messages.please_generate_preview_first"), 3e3);
      return;
    }
    if (!previewId || !absPreviewDir) {
      new import_obsidian3.Notice(t("messages.preview_data_missing"), 3e3);
      return;
    }
    if (selectedPublishOption === "netlify") {
      if (!netlifyAccessToken || !netlifyProjectId) {
        new import_obsidian3.Notice(t("messages.netlify_settings_missing"), 5e3);
        return;
      }
    } else if (selectedPublishOption === "ftp") {
      if (!ftpServer || !ftpUsername || !ftpPassword) {
        new import_obsidian3.Notice(t("messages.ftp_settings_missing"), 5e3);
        return;
      }
    }
    $$invalidate(19, isPublishing = true);
    $$invalidate(20, publishProgress = 0);
    $$invalidate(21, publishSuccess = false);
    try {
      $$invalidate(20, publishProgress = 5);
      const publicDir = path3.join(absPreviewDir, "public");
      if (selectedPublishOption === "netlify") {
        await publishToNetlify(publicDir);
      } else if (selectedPublishOption === "ftp") {
        await publishToFTP(publicDir);
      } else {
        const zipContent = await createZipFromDirectory(publicDir);
        $$invalidate(20, publishProgress = 50);
        const previewApiId = await plugin.hugoverse.createMDFPreview(previewId, zipContent);
        if (!previewApiId) {
          throw new Error("Failed to create MDFriday preview");
        }
        $$invalidate(20, publishProgress = 80);
        const deployPath = await plugin.hugoverse.deployMDFridayPreview(previewApiId);
        if (!deployPath) {
          throw new Error("Failed to deploy MDFriday preview");
        }
        $$invalidate(20, publishProgress = 100);
        const baseUrl = GetBaseUrl();
        $$invalidate(22, publishUrl = `${baseUrl}${deployPath}`);
        $$invalidate(21, publishSuccess = true);
        new import_obsidian3.Notice(t("messages.site_published_successfully"), 3e3);
        await saveCurrentProjectConfiguration();
        if (currentContents.length > 0 && siteName) {
          const projectId = getProjectId();
          if (projectId) {
            await plugin.projectService.addBuildHistory({
              projectId,
              timestamp: Date.now(),
              success: true,
              type: "publish",
              publishMethod: "mdf-preview",
              url: publishUrl
            });
          }
        }
        plugin.hugoverse.sendCounter("mdf-preview").catch((error) => {
          console.warn("Counter request failed (non-critical):", error);
        });
      }
    } catch (error) {
      console.error("Publishing failed:", error);
      new import_obsidian3.Notice(t("messages.publishing_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(19, isPublishing = false);
    }
  }
  async function publishToNetlify(publicDir) {
    try {
      const originalToken = plugin.settings.netlifyAccessToken;
      const originalProjectId = plugin.settings.netlifyProjectId;
      $$invalidate(50, plugin.settings.netlifyAccessToken = netlifyAccessToken, plugin);
      $$invalidate(50, plugin.settings.netlifyProjectId = netlifyProjectId, plugin);
      try {
        $$invalidate(22, publishUrl = await plugin.netlify.deployToNetlify(publicDir, (progress) => {
          $$invalidate(20, publishProgress = Math.round(progress));
        }));
      } finally {
        $$invalidate(50, plugin.settings.netlifyAccessToken = originalToken, plugin);
        $$invalidate(50, plugin.settings.netlifyProjectId = originalProjectId, plugin);
      }
      $$invalidate(21, publishSuccess = true);
      new import_obsidian3.Notice(t("messages.netlify_deploy_success"), 3e3);
      await saveCurrentProjectConfiguration();
      if (currentContents.length > 0 && siteName) {
        const projectId = getProjectId();
        if (projectId) {
          await plugin.projectService.addBuildHistory({
            projectId,
            timestamp: Date.now(),
            success: true,
            type: "publish",
            publishMethod: "netlify",
            url: publishUrl
          });
        }
      }
      plugin.hugoverse.sendCounter("netlify").catch((error) => {
        console.warn("Counter request failed (non-critical):", error);
      });
    } catch (error) {
      console.error("Netlify deployment failed:", error);
      throw new Error(t("messages.netlify_deploy_failed", { error: error.message }));
    }
  }
  async function publishToFTP(publicDir) {
    try {
      const originalServer = plugin.settings.ftpServer;
      const originalUsername = plugin.settings.ftpUsername;
      const originalPassword = plugin.settings.ftpPassword;
      const originalRemoteDir = plugin.settings.ftpRemoteDir;
      const originalIgnoreCert = plugin.settings.ftpIgnoreCert;
      $$invalidate(50, plugin.settings.ftpServer = ftpServer, plugin);
      $$invalidate(50, plugin.settings.ftpUsername = ftpUsername, plugin);
      $$invalidate(50, plugin.settings.ftpPassword = ftpPassword, plugin);
      $$invalidate(50, plugin.settings.ftpRemoteDir = ftpRemoteDir, plugin);
      $$invalidate(50, plugin.settings.ftpIgnoreCert = ftpIgnoreCert, plugin);
      plugin.initializeFTP(ftpPreferredSecure);
      if (!plugin.ftp) {
        throw new Error("FTP uploader not initialized - please check FTP settings");
      }
      plugin.ftp.setConnectionTypeCallback((usedSecure) => {
        ftpPreferredSecure = usedSecure;
      });
      plugin.ftp.setProgressCallback((progress) => {
        $$invalidate(20, publishProgress = Math.round(progress.percentage));
      });
      let result;
      try {
        const projectId = getProjectId();
        if (projectId) {
          const oldManifest = await plugin.projectService.loadManifest(projectId, "ftp");
          let incrementalResult;
          let shouldFallbackToFull = false;
          try {
            incrementalResult = await plugin.ftp.uploadDirectoryIncremental(publicDir, projectId, oldManifest);
            if (!incrementalResult.success) {
              shouldFallbackToFull = true;
              console.warn("[FTP] Incremental upload failed, will fallback to full upload");
              new import_obsidian3.Notice(t("messages.ftp_fallback_to_full") || "\u26A0\uFE0F Incremental upload failed, trying full upload as fallback...", 4e3);
            }
          } catch (err) {
            shouldFallbackToFull = true;
            console.error("[FTP] Incremental upload error, will fallback to full upload:", err);
            new import_obsidian3.Notice(t("messages.ftp_fallback_to_full") || "\u26A0\uFE0F Incremental upload failed, trying full upload as fallback...", 4e3);
          }
          if (shouldFallbackToFull) {
            console.log("[FTP] Starting full upload as fallback...");
            $$invalidate(20, publishProgress = 0);
            result = await plugin.ftp.uploadDirectory(publicDir);
            if (result.success) {
              console.log("[FTP] Full upload succeeded, generating manifest for next incremental upload");
              const newManifest = await plugin.ftp.generateManifest(publicDir, projectId);
              newManifest.uploadMethod = "ftp";
              newManifest.remoteDir = plugin.settings.ftpRemoteDir;
              await plugin.projectService.saveManifest(newManifest);
            }
          } else {
            result = {
              success: incrementalResult.success,
              usedSecure: incrementalResult.usedSecure,
              error: incrementalResult.error
            };
            if (incrementalResult.success && incrementalResult.newManifest) {
              await plugin.projectService.saveManifest(incrementalResult.newManifest);
              if (incrementalResult.stats) {
                const { uploaded, deleted, unchanged } = incrementalResult.stats;
                const totalFiles = uploaded + unchanged;
                const savedTime = totalFiles > 0 ? Math.round(unchanged / totalFiles * 100) : 0;
                new import_obsidian3.Notice(t("messages.incremental_upload_stats", {
                  uploaded,
                  deleted,
                  unchanged,
                  saved: savedTime
                }) || `\u2705 Incremental upload: ${uploaded} uploaded, ${deleted} deleted, ${unchanged} unchanged (${savedTime}% time saved)`, 4e3);
              }
            }
          }
        } else {
          result = await plugin.ftp.uploadDirectory(publicDir);
        }
      } finally {
        $$invalidate(50, plugin.settings.ftpServer = originalServer, plugin);
        $$invalidate(50, plugin.settings.ftpUsername = originalUsername, plugin);
        $$invalidate(50, plugin.settings.ftpPassword = originalPassword, plugin);
        $$invalidate(50, plugin.settings.ftpRemoteDir = originalRemoteDir, plugin);
        $$invalidate(50, plugin.settings.ftpIgnoreCert = originalIgnoreCert, plugin);
        plugin.initializeFTP();
      }
      if (result.success) {
        $$invalidate(21, publishSuccess = true);
        $$invalidate(22, publishUrl = "");
        if (!result.usedSecure) {
          new import_obsidian3.Notice(t("messages.ftp_fallback_to_plain"), 4e3);
        }
        new import_obsidian3.Notice(t("messages.ftp_upload_success"), 3e3);
        await saveCurrentProjectConfiguration();
        if (currentContents.length > 0 && siteName) {
          const projectId = getProjectId();
          if (projectId) {
            await plugin.projectService.addBuildHistory({
              projectId,
              timestamp: Date.now(),
              success: true,
              type: "publish",
              publishMethod: "ftp"
            });
          }
        }
        plugin.hugoverse.sendCounter("ftp").catch((error) => {
          console.warn("Counter request failed (non-critical):", error);
        });
      } else {
        throw new Error(result.error || "Unknown FTP error");
      }
    } catch (error) {
      console.error("FTP upload failed:", error);
      throw new Error(t("messages.ftp_upload_failed", { error: error.message }));
    }
  }
  async function testFTPConnection() {
    $$invalidate(8, ftpTestState = "testing");
    $$invalidate(25, ftpTestMessage = "");
    try {
      const originalServer = plugin.settings.ftpServer;
      const originalUsername = plugin.settings.ftpUsername;
      const originalPassword = plugin.settings.ftpPassword;
      const originalRemoteDir = plugin.settings.ftpRemoteDir;
      const originalIgnoreCert = plugin.settings.ftpIgnoreCert;
      $$invalidate(50, plugin.settings.ftpServer = ftpServer, plugin);
      $$invalidate(50, plugin.settings.ftpUsername = ftpUsername, plugin);
      $$invalidate(50, plugin.settings.ftpPassword = ftpPassword, plugin);
      $$invalidate(50, plugin.settings.ftpRemoteDir = ftpRemoteDir, plugin);
      $$invalidate(50, plugin.settings.ftpIgnoreCert = ftpIgnoreCert, plugin);
      plugin.initializeFTP(ftpPreferredSecure);
      if (plugin.ftp) {
        plugin.ftp.setConnectionTypeCallback((usedSecure) => {
          ftpPreferredSecure = usedSecure;
        });
      }
      let result;
      try {
        result = await plugin.testFTPConnection();
      } finally {
        $$invalidate(50, plugin.settings.ftpServer = originalServer, plugin);
        $$invalidate(50, plugin.settings.ftpUsername = originalUsername, plugin);
        $$invalidate(50, plugin.settings.ftpPassword = originalPassword, plugin);
        $$invalidate(50, plugin.settings.ftpRemoteDir = originalRemoteDir, plugin);
        $$invalidate(50, plugin.settings.ftpIgnoreCert = originalIgnoreCert, plugin);
        plugin.initializeFTP();
      }
      if (result.success) {
        $$invalidate(8, ftpTestState = "success");
        $$invalidate(25, ftpTestMessage = result.message || t("settings.ftp_test_connection_success"));
      } else {
        $$invalidate(8, ftpTestState = "error");
        $$invalidate(25, ftpTestMessage = result.message || t("settings.ftp_test_connection_failed"));
      }
    } catch (error) {
      console.error("FTP test error:", error);
      $$invalidate(8, ftpTestState = "error");
      $$invalidate(25, ftpTestMessage = error.message || t("settings.ftp_test_connection_failed"));
    }
  }
  let previousFtpConfig = "";
  async function createPreviewDirectory(previewDir) {
    const previewRoot = path3.join(plugin.pluginDir, "preview");
    if (!await app.vault.adapter.exists(previewRoot)) {
      await app.vault.adapter.mkdir(previewRoot);
    }
    if (!await app.vault.adapter.exists(previewDir)) {
      await app.vault.adapter.mkdir(previewDir);
    }
    const contentDir = path3.join(previewDir, "content");
    if (!await app.vault.adapter.exists(contentDir)) {
      await app.vault.adapter.mkdir(contentDir);
    }
    const publicDir = path3.join(previewDir, "public");
    if (!await app.vault.adapter.exists(publicDir)) {
      await app.vault.adapter.mkdir(publicDir);
    }
    const obImagesDir = path3.join(publicDir, "ob-images");
    if (!await app.vault.adapter.exists(obImagesDir)) {
      await app.vault.adapter.mkdir(obImagesDir);
    }
    if (currentAssets && currentAssets.folder) {
      const staticDir = path3.join(previewDir, "static");
      if (!await app.vault.adapter.exists(staticDir)) {
        await app.vault.adapter.mkdir(staticDir);
      }
    }
  }
  async function createThemesDirectory() {
    if (!await app.vault.adapter.exists(themesDir)) {
      await app.vault.adapter.mkdir(themesDir);
    }
  }
  async function createConfigFile(previewDir) {
    const config = {
      baseURL: sitePath,
      title: siteName,
      contentDir: "content",
      publishDir: "public",
      defaultContentLanguage,
      taxonomies: { tag: "tags", category: "categories" },
      module: {
        imports: [{ path: selectedThemeDownloadUrl }]
      },
      params: Object.assign({ branding: true }, sitePassword && sitePassword.trim() ? { password: sitePassword.trim() } : {})
    };
    const services = {};
    if (googleAnalyticsId && googleAnalyticsId.trim()) {
      services.googleAnalytics = { id: googleAnalyticsId.trim() };
    }
    if (disqusShortname && disqusShortname.trim()) {
      services.disqus = { shortname: disqusShortname.trim() };
    }
    if (Object.keys(services).length > 0) {
      config.services = services;
    }
    if (currentContents.length > 0) {
      const languages = {};
      currentContents.forEach((content, index) => {
        const contentDir = index === 0 ? "content" : `content.${content.languageCode}`;
        languages[content.languageCode] = { contentDir, weight: content.weight };
      });
      config.languages = languages;
    }
    const configPath = path3.join(previewDir, "config.json");
    await app.vault.adapter.write(configPath, JSON.stringify(config, null, 2));
  }
  async function exportSite() {
    if (!hasPreview || !absPreviewDir) {
      new import_obsidian3.Notice(t("messages.please_generate_preview_first"), 3e3);
      return;
    }
    $$invalidate(26, isExporting = true);
    try {
      const publicDir = path3.join(absPreviewDir, "public");
      const zipContent = await createZipFromDirectory(publicDir);
      const { dialog } = require("@electron/remote") || require("electron").remote;
      const { canceled, filePath } = await dialog.showSaveDialog({
        title: t("ui.export_site_dialog_title"),
        defaultPath: "mdfriday-site.zip",
        filters: [
          { name: "ZIP Files", extensions: ["zip"] },
          { name: "All Files", extensions: ["*"] }
        ]
      });
      if (!canceled && filePath) {
        await fs3.promises.writeFile(filePath, zipContent);
        new import_obsidian3.Notice(t("messages.site_exported_successfully", { path: filePath }), 3e3);
      }
    } catch (error) {
      console.error("Export failed:", error);
      new import_obsidian3.Notice(t("messages.export_failed", { error: error.message }), 5e3);
    } finally {
      $$invalidate(26, isExporting = false);
    }
  }
  async function linkMultiLanguageContents(previewDir) {
    for (let i = 0; i < currentContents.length; i++) {
      const content = currentContents[i];
      const contentDir = i === 0 ? "content" : `content.${content.languageCode}`;
      const targetPath = path3.join(previewDir, contentDir);
      if (content.folder) {
        await linkFolderContents(content.folder, targetPath);
      } else if (content.file) {
        await linkSingleFileContent(content.file, targetPath);
      }
    }
  }
  async function linkFolderContents(folder, targetPath) {
    const adapter = app.vault.adapter;
    let sourcePath;
    let absTargetPath;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      sourcePath = path3.join(adapter.getBasePath(), folder.path);
      absTargetPath = path3.join(adapter.getBasePath(), targetPath);
      absSelectedFolderPath.push(sourcePath);
      absProjContentPath.push(absTargetPath);
    } else {
      console.warn("Not using FileSystemAdapter, falling back to copying files");
      await copyFolderContents(folder, targetPath);
      return;
    }
    try {
      if (await app.vault.adapter.exists(targetPath)) {
        await app.vault.adapter.rmdir(targetPath, true);
      }
      if (isWindows) {
        await fs3.promises.symlink(sourcePath, absTargetPath, "junction");
        return;
      }
      await fs3.promises.symlink(sourcePath, absTargetPath, "dir");
    } catch (error) {
      console.error("Failed to create symbolic link, falling back to copying:", error);
      await copyFolderContents(folder, targetPath);
    }
  }
  async function copyFolderContents(folder, targetPath) {
    const copyRecursive = async (sourceFolder, destPath) => {
      for (const child of sourceFolder.children) {
        if (child instanceof import_obsidian3.TFolder) {
          const childDestPath = path3.join(destPath, child.name);
          if (!await app.vault.adapter.exists(childDestPath)) {
            await app.vault.adapter.mkdir(childDestPath);
          }
          await copyRecursive(child, childDestPath);
        } else if (child instanceof import_obsidian3.TFile) {
          const childDestPath = path3.join(destPath, child.name);
          try {
            const content = await app.vault.read(child);
            await app.vault.adapter.write(childDestPath, content);
          } catch (error) {
            console.warn(`Failed to copy file ${child.path}:`, error);
          }
        }
      }
    };
    await copyRecursive(folder, targetPath);
  }
  async function linkSingleFileContent(file, targetPath) {
    const adapter = app.vault.adapter;
    let sourcePath;
    let absTargetPath;
    let absContentDir;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      sourcePath = path3.join(adapter.getBasePath(), file.path);
      absContentDir = path3.join(adapter.getBasePath(), targetPath);
      absTargetPath = path3.join(absContentDir, "index.md");
      absSelectedFolderPath.push(path3.dirname(sourcePath));
      absProjContentPath.push(absContentDir);
    } else {
      console.warn("Not using FileSystemAdapter, falling back to copying file");
      await copySingleFileContent(file, targetPath);
      return;
    }
    try {
      if (!await app.vault.adapter.exists(targetPath)) {
        await app.vault.adapter.mkdir(targetPath);
      }
      if (await app.vault.adapter.exists(path3.join(targetPath, "index.md"))) {
        await app.vault.adapter.remove(path3.join(targetPath, "index.md"));
      }
      if (isWindows) {
        await fs3.promises.symlink(sourcePath, absTargetPath, "file");
      } else {
        await fs3.promises.symlink(sourcePath, absTargetPath);
      }
    } catch (error) {
      console.error("Failed to create symbolic link for file, falling back to copying:", error);
      await copySingleFileContent(file, targetPath);
    }
  }
  async function copySingleFileContent(file, targetPath) {
    if (!await app.vault.adapter.exists(targetPath)) {
      await app.vault.adapter.mkdir(targetPath);
    }
    const indexPath = path3.join(targetPath, "index.md");
    try {
      const fileContent = await app.vault.read(file);
      await app.vault.adapter.write(indexPath, fileContent);
    } catch (error) {
      console.error("Failed to copy file content:", error);
      throw error;
    }
  }
  async function copySiteAssetsToPreview(previewDir) {
    if (!currentAssets || !currentAssets.folder) {
      return;
    }
    const assetsSourceFolder = currentAssets.folder;
    const staticTargetDir = path3.join(previewDir, "static");
    try {
      const adapter = app.vault.adapter;
      if (adapter instanceof import_obsidian3.FileSystemAdapter) {
        const absSourcePath = path3.join(adapter.getBasePath(), assetsSourceFolder.path);
        const absTargetPath = path3.join(adapter.getBasePath(), staticTargetDir);
        await fs3.promises.cp(absSourcePath, absTargetPath, {
          recursive: true,
          force: true
        });
      } else {
        await copyAssetsUsingObsidianAPI(assetsSourceFolder, staticTargetDir);
      }
    } catch (error) {
      console.error("Failed to copy site assets:", error);
    }
  }
  async function copyAssetsUsingObsidianAPI(sourceFolder, targetDir) {
    const copyRecursive = async (sourceFolder2, destPath) => {
      for (const child of sourceFolder2.children) {
        if (child instanceof import_obsidian3.TFolder) {
          const childDestPath = path3.join(destPath, child.name);
          if (!await app.vault.adapter.exists(childDestPath)) {
            await app.vault.adapter.mkdir(childDestPath);
          }
          await copyRecursive(child, childDestPath);
        } else if (child instanceof import_obsidian3.TFile) {
          const childDestPath = path3.join(destPath, child.name);
          try {
            const content = await app.vault.readBinary(child);
            await app.vault.adapter.writeBinary(childDestPath, content);
          } catch (error) {
            console.warn(`Failed to copy asset file ${child.path}:`, error);
          }
        }
      }
    };
    await copyRecursive(sourceFolder, targetDir);
  }
  async function ensureRootFolderExists() {
    const adapter = app.vault.adapter;
    let rootFolderPath;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      const vaultBasePath = adapter.getBasePath();
      rootFolderPath = path3.join(vaultBasePath, FRIDAY_ROOT_FOLDER);
    } else {
      rootFolderPath = FRIDAY_ROOT_FOLDER;
    }
    if (isWindows) {
      rootFolderPath = path3.normalize(rootFolderPath);
    }
    if (!await adapter.exists(rootFolderPath)) {
      if (adapter instanceof import_obsidian3.FileSystemAdapter && path3.isAbsolute(rootFolderPath)) {
        await fs3.promises.mkdir(rootFolderPath, { recursive: true });
      } else {
        await adapter.mkdir(rootFolderPath);
      }
    }
  }
  async function generateUniqueFolderName(baseName) {
    let folderName = baseName;
    let counter = 0;
    const adapter = app.vault.adapter;
    let rootFolderPath;
    if (adapter instanceof import_obsidian3.FileSystemAdapter) {
      const vaultBasePath = adapter.getBasePath();
      rootFolderPath = path3.join(vaultBasePath, FRIDAY_ROOT_FOLDER);
    } else {
      rootFolderPath = FRIDAY_ROOT_FOLDER;
    }
    if (isWindows) {
      rootFolderPath = path3.normalize(rootFolderPath);
    }
    while (await checkFolderExists(path3.join(rootFolderPath, folderName))) {
      counter++;
      folderName = `${baseName} ${counter}`;
    }
    return folderName;
  }
  async function checkFolderExists(folderPath) {
    const adapter = app.vault.adapter;
    if (adapter instanceof import_obsidian3.FileSystemAdapter && path3.isAbsolute(folderPath)) {
      try {
        await fs3.promises.access(folderPath);
        return true;
      } catch (_a2) {
        return false;
      }
    } else {
      return await adapter.exists(folderPath);
    }
  }
  async function downloadAndUnzipSample(downloadUrl, targetFolderPath, progressCallback) {
    try {
      progressCallback(10);
      const response = await (0, import_obsidian3.requestUrl)({ url: downloadUrl, method: "GET" });
      if (response.status !== 200) {
        throw new Error(`Download failed with status: ${response.status}`);
      }
      progressCallback(50);
      const zip = new import_jszip.default();
      const zipData = await zip.loadAsync(response.arrayBuffer);
      progressCallback(70);
      if (!await checkFolderExists(targetFolderPath)) {
        if (path3.isAbsolute(targetFolderPath)) {
          await fs3.promises.mkdir(targetFolderPath, { recursive: true });
        } else {
          await app.vault.adapter.mkdir(targetFolderPath);
        }
      }
      const files = Object.keys(zipData.files);
      let processedFiles = 0;
      for (const fileName of files) {
        const file = zipData.files[fileName];
        let normalizedFileName = fileName;
        if (isWindows) {
          normalizedFileName = fileName.replace(/\//g, path3.sep);
        }
        normalizedFileName = path3.normalize(normalizedFileName);
        if (file.dir) {
          const dirPath = path3.join(targetFolderPath, normalizedFileName);
          if (!await checkFolderExists(dirPath)) {
            if (path3.isAbsolute(dirPath)) {
              await fs3.promises.mkdir(dirPath, { recursive: true });
            } else {
              await app.vault.adapter.mkdir(dirPath);
            }
          }
        } else {
          const filePath = path3.join(targetFolderPath, normalizedFileName);
          const parentDir = path3.dirname(filePath);
          if (parentDir !== targetFolderPath && !await checkFolderExists(parentDir)) {
            if (path3.isAbsolute(parentDir)) {
              await fs3.promises.mkdir(parentDir, { recursive: true });
            } else {
              await app.vault.adapter.mkdir(parentDir);
            }
          }
          const fileContent = await file.async("uint8array");
          if (path3.isAbsolute(filePath)) {
            await fs3.promises.writeFile(filePath, fileContent);
          } else {
            await app.vault.adapter.writeBinary(filePath, fileContent.buffer);
          }
        }
        processedFiles++;
        const extractProgress = 70 + processedFiles / files.length * 30;
        progressCallback(Math.round(extractProgress));
      }
      progressCallback(100);
    } catch (error) {
      console.error("Download and unzip failed:", error);
      throw error;
    }
  }
  async function createZipFromDirectory(sourceDir) {
    const zip = new import_jszip.default();
    const addDirectoryToZip = async (dirPath, zipFolder) => {
      const items = await fs3.promises.readdir(dirPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path3.join(dirPath, item.name);
        if (item.isDirectory()) {
          const subFolder = zipFolder.folder(item.name);
          if (subFolder) {
            await addDirectoryToZip(itemPath, subFolder);
          }
        } else if (item.isFile()) {
          const fileContent = await fs3.promises.readFile(itemPath);
          zipFolder.file(item.name, fileContent);
        }
      }
    };
    await addDirectoryToZip(sourceDir, zip);
    return await zip.generateAsync({ type: "uint8array" });
  }
  const change_handler = (content, e) => updateLanguageCode(content.id, e.currentTarget.value);
  const click_handler = (content) => removeLanguageContent(content.id);
  function input_input_handler() {
    siteName = this.value;
    $$invalidate(0, siteName), $$invalidate(9, currentContents), $$invalidate(57, previousContentLength), $$invalidate(55, _d), $$invalidate(56, _e), $$invalidate(64, $languageContents);
  }
  function input0_input_handler() {
    sitePath = this.value;
    $$invalidate(1, sitePath);
  }
  function input1_input_handler() {
    sitePassword = this.value;
    $$invalidate(14, sitePassword);
  }
  function input2_input_handler() {
    googleAnalyticsId = this.value;
    $$invalidate(12, googleAnalyticsId);
  }
  function input3_input_handler() {
    disqusShortname = this.value;
    $$invalidate(13, disqusShortname);
  }
  function select_change_handler() {
    selectedPublishOption = select_value(this);
    $$invalidate(2, selectedPublishOption), $$invalidate(1, sitePath), $$invalidate(50, plugin);
    $$invalidate(33, publishOptions), $$invalidate(10, t), $$invalidate(1, sitePath), $$invalidate(50, plugin), $$invalidate(52, _a);
  }
  function input0_input_handler_1() {
    netlifyAccessToken = this.value;
    $$invalidate(23, netlifyAccessToken), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  function input1_input_handler_1() {
    netlifyProjectId = this.value;
    $$invalidate(24, netlifyProjectId), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  function input0_input_handler_2() {
    ftpServer = this.value;
    $$invalidate(3, ftpServer), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  function input1_input_handler_2() {
    ftpUsername = this.value;
    $$invalidate(4, ftpUsername), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  function input2_input_handler_1() {
    ftpPassword = this.value;
    $$invalidate(5, ftpPassword), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  function input3_input_handler_1() {
    ftpRemoteDir = this.value;
    $$invalidate(6, ftpRemoteDir), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  function input4_change_handler() {
    ftpIgnoreCert = this.checked;
    $$invalidate(7, ftpIgnoreCert), $$invalidate(9, currentContents), $$invalidate(64, $languageContents);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(51, app = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(50, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 524288) {
      $:
        $$invalidate(62, site = plugin.site);
    }
    if ($$self.$$.dirty[2] & 1) {
      $:
        $$subscribe_languageContents($$invalidate(35, languageContents = site ? site.languageContents : null));
    }
    if ($$self.$$.dirty[2] & 1) {
      $:
        $$subscribe_siteAssets($$invalidate(34, siteAssets = site ? site.siteAssets : null));
    }
    if ($$self.$$.dirty[1] & 2621440) {
      $:
        $$invalidate(10, t = ($$invalidate(52, _a = plugin.i18n) === null || _a === void 0 ? void 0 : _a.t) || ((key2) => key2));
    }
    if ($$self.$$.dirty[2] & 4) {
      $:
        $$invalidate(9, currentContents = $languageContents || []);
    }
    if ($$self.$$.dirty[2] & 2) {
      $:
        $$invalidate(30, currentAssets = $siteAssets || null);
    }
    if ($$self.$$.dirty[2] & 1) {
      $:
        isForSingleFile = site ? site.isForSingleFile() : false;
    }
    if ($$self.$$.dirty[2] & 1) {
      $:
        defaultContentLanguage = site ? site.getDefaultContentLanguage() : "en";
    }
    if ($$self.$$.dirty[0] & 512) {
      $:
        if (currentContents.length === 0) {
          $$invalidate(18, hasPreview = false);
          $$invalidate(17, previewUrl = "");
          previewId = "";
          $$invalidate(0, siteName = "");
          $$invalidate(60, userHasSelectedTheme = false);
          $$invalidate(57, previousContentLength = 0);
          $$invalidate(23, netlifyAccessToken = "");
          $$invalidate(24, netlifyProjectId = "");
          $$invalidate(3, ftpServer = "");
          $$invalidate(4, ftpUsername = "");
          $$invalidate(5, ftpPassword = "");
          $$invalidate(6, ftpRemoteDir = "");
          $$invalidate(7, ftpIgnoreCert = true);
          ftpPreferredSecure = void 0;
          $$invalidate(8, ftpTestState = "idle");
          $$invalidate(25, ftpTestMessage = "");
        }
    }
    if ($$self.$$.dirty[0] & 512 | $$self.$$.dirty[1] & 671088640) {
      $: {
        if (currentContents.length > 0 && !userHasSelectedTheme) {
          const firstContent = currentContents[0];
          if (firstContent.file && !selectedThemeDownloadUrl.includes("note")) {
            $$invalidate(58, selectedThemeDownloadUrl = NOTE_THEME_URL);
            $$invalidate(59, selectedThemeName = NOTE_THEME_NAME);
            selectedThemeId = NOTE_THEME_ID;
          } else if (firstContent.folder && !selectedThemeDownloadUrl.includes("book")) {
            $$invalidate(58, selectedThemeDownloadUrl = BOOK_THEME_URL);
            $$invalidate(59, selectedThemeName = BOOK_THEME_NAME);
            selectedThemeId = BOOK_THEME_ID;
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & 1026) {
      $:
        $$invalidate(33, publishOptions = [
          {
            value: "netlify",
            label: t("ui.publish_option_netlify")
          },
          {
            value: "ftp",
            label: t("ui.publish_option_ftp")
          },
          ...sitePath.startsWith("/preview/") ? [
            {
              value: "mdf-preview",
              label: t("ui.publish_option_mdfriday")
            }
          ] : []
        ]);
    }
    if ($$self.$$.dirty[0] & 6 | $$self.$$.dirty[1] & 524288) {
      $:
        if (!sitePath.startsWith("/preview/") && selectedPublishOption === "mdf-preview") {
          $$invalidate(2, selectedPublishOption = plugin.settings.publishMethod || "netlify");
        }
    }
    if ($$self.$$.dirty[0] & 512 | $$self.$$.dirty[1] & 12582912) {
      $:
        contentPath = currentContents.length > 0 ? ($$invalidate(53, _b = currentContents[0].folder) === null || _b === void 0 ? void 0 : _b.name) || ($$invalidate(54, _c = currentContents[0].file) === null || _c === void 0 ? void 0 : _c.name) || "" : "";
    }
    if ($$self.$$.dirty[0] & 513 | $$self.$$.dirty[1] & 117440512) {
      $: {
        if (previousContentLength === 0 && currentContents.length > 0 && !siteName) {
          const firstContent = currentContents[0];
          let defaultName = ($$invalidate(55, _d = firstContent.folder) === null || _d === void 0 ? void 0 : _d.name) || ($$invalidate(56, _e = firstContent.file) === null || _e === void 0 ? void 0 : _e.basename) || "";
          if (firstContent.folder) {
            const folderName = firstContent.folder.name.toLowerCase();
            if ((folderName === "content" || folderName.startsWith("content.")) && firstContent.folder.parent) {
              defaultName = firstContent.folder.parent.name;
            }
          }
          $$invalidate(0, siteName = defaultName);
          loadDefaultPublishConfigIfNeeded();
        }
        $$invalidate(57, previousContentLength = currentContents.length);
      }
    }
    if ($$self.$$.dirty[1] & 268435456) {
      $:
        $$invalidate(32, displayThemeName = selectedThemeName || BOOK_THEME_NAME);
    }
    if ($$self.$$.dirty[0] & 56) {
      $:
        $$invalidate(31, isFTPConfigured = !!(ftpServer.trim() && ftpUsername.trim() && ftpPassword.trim()));
    }
    if ($$self.$$.dirty[0] & 504 | $$self.$$.dirty[1] & 1073741824) {
      $: {
        const currentFtpConfig = `${ftpServer}|${ftpUsername}|${ftpPassword}|${ftpRemoteDir}|${ftpIgnoreCert}`;
        if (previousFtpConfig && previousFtpConfig !== currentFtpConfig && ftpTestState !== "idle") {
          $$invalidate(8, ftpTestState = "idle");
          $$invalidate(25, ftpTestMessage = "");
        }
        $$invalidate(61, previousFtpConfig = currentFtpConfig);
      }
    }
  };
  return [
    siteName,
    sitePath,
    selectedPublishOption,
    ftpServer,
    ftpUsername,
    ftpPassword,
    ftpRemoteDir,
    ftpIgnoreCert,
    ftpTestState,
    currentContents,
    t,
    showAdvancedSettings,
    googleAnalyticsId,
    disqusShortname,
    sitePassword,
    isBuilding,
    buildProgress,
    previewUrl,
    hasPreview,
    isPublishing,
    publishProgress,
    publishSuccess,
    publishUrl,
    netlifyAccessToken,
    netlifyProjectId,
    ftpTestMessage,
    isExporting,
    isDownloadingSample,
    sampleDownloadProgress,
    currentThemeWithSample,
    currentAssets,
    isFTPConfigured,
    displayThemeName,
    publishOptions,
    siteAssets,
    languageContents,
    SUPPORTED_LANGUAGES,
    updateLanguageCode,
    removeLanguageContent,
    clearAllContent,
    clearSiteAssets,
    openThemeModal,
    openProjectsModal,
    downloadThemeSample,
    toggleAdvancedSettings,
    handleSitePathChange,
    startPreview,
    startPublish,
    testFTPConnection,
    exportSite,
    plugin,
    app,
    _a,
    _b,
    _c,
    _d,
    _e,
    previousContentLength,
    selectedThemeDownloadUrl,
    selectedThemeName,
    userHasSelectedTheme,
    previousFtpConfig,
    site,
    $siteAssets,
    $languageContents,
    change_handler,
    click_handler,
    input_input_handler,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler,
    select_change_handler,
    input0_input_handler_1,
    input1_input_handler_1,
    input0_input_handler_2,
    input1_input_handler_2,
    input2_input_handler_1,
    input3_input_handler_1,
    input4_change_handler
  ];
}
var Site = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { app: 51, plugin: 50 }, add_css3, [-1, -1, -1, -1, -1]);
  }
};
var Site_default = Site;

// src/svelte/Server.svelte
function add_css4(target) {
  append_styles(target, "svelte-1lauw5u", ".friday-plugin-main.svelte-1lauw5u{padding:initial;width:initial;height:initial;position:initial;overflow-y:initial;overflow-wrap:initial}.centered-line.svelte-1lauw5u{width:80%;margin:20px auto;border:none;border-top:1px solid rgb(64 64 64);height:1px;background-color:transparent}.friday-tab-content.svelte-1lauw5u{padding:10px 0}");
}
function create_else_block2(ctx) {
  let section;
  let div1;
  let div0;
  let site;
  let t0;
  let hr;
  let t1;
  let info;
  let current;
  site = new Site_default({
    props: {
      app: ctx[0],
      plugin: ctx[1]
    }
  });
  info = new Info_default({ props: { plugin: ctx[1] } });
  return {
    c() {
      section = element("section");
      div1 = element("div");
      div0 = element("div");
      create_component(site.$$.fragment);
      t0 = space();
      hr = element("hr");
      t1 = space();
      create_component(info.$$.fragment);
      attr(hr, "class", "centered-line svelte-1lauw5u");
      attr(div0, "role", "tabpanel");
      attr(div0, "id", "panel-site");
      attr(div0, "aria-labelledby", "tab-site");
      attr(div0, "tabindex", "0");
      attr(div1, "class", "friday-tab-content svelte-1lauw5u");
      attr(section, "id", "friday-plugin-main");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div1);
      append(div1, div0);
      mount_component(site, div0, null);
      append(div0, t0);
      append(div0, hr);
      append(div0, t1);
      mount_component(info, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const site_changes = {};
      if (dirty & 1)
        site_changes.app = ctx2[0];
      if (dirty & 2)
        site_changes.plugin = ctx2[1];
      site.$set(site_changes);
      const info_changes = {};
      if (dirty & 2)
        info_changes.plugin = ctx2[1];
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(site.$$.fragment, local);
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(site.$$.fragment, local);
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(site);
      destroy_component(info);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let p;
  let t0_value = ctx[3]("ui.desktop_only_message") + "";
  let t0;
  let t1;
  let br;
  let t2;
  let t3_value = ctx[3]("ui.mobile_coming_soon") + "";
  let t3;
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text2(t0_value);
      t1 = space();
      br = element("br");
      t2 = space();
      t3 = text2(t3_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(p, t1);
      append(p, br);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t0_value !== (t0_value = ctx2[3]("ui.desktop_only_message") + ""))
        set_data(t0, t0_value);
      if (dirty & 8 && t3_value !== (t3_value = ctx2[3]("ui.mobile_coming_soon") + ""))
        set_data(t3, t3_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment4(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "friday-plugin-main svelte-1lauw5u");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let t;
  var _a;
  let { app } = $$props;
  let { plugin } = $$props;
  let isClientSupported = false;
  onMount(async () => {
    $$invalidate(2, isClientSupported = import_obsidian4.Platform.isDesktop);
    if (!isClientSupported) {
      new import_obsidian4.Notice(t("messages.desktop_only_notice"), 5e3);
      return;
    }
  });
  onDestroy(() => {
  });
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 18) {
      $:
        $$invalidate(3, t = ($$invalidate(4, _a = plugin.i18n) === null || _a === void 0 ? void 0 : _a.t) || ((key2) => key2));
    }
  };
  return [app, plugin, isClientSupported, t, _a];
}
var Server = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { app: 0, plugin: 1 }, add_css4);
  }
};
var Server_default = Server;

// src/server.ts
var FRIDAY_SERVER_VIEW_TYPE = "Friday_Service";
var ServerView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this._app = null;
    this.plugin = plugin;
  }
  async onClose() {
    if (this._app) {
      this._app.$destroy();
      this._app = null;
    }
  }
  async onOpen() {
    this._app = new Server_default({
      target: this.contentEl,
      props: {
        app: this.app,
        plugin: this.plugin
      }
    });
  }
  getDisplayText() {
    return "Friday Service";
  }
  getViewType() {
    return FRIDAY_SERVER_VIEW_TYPE;
  }
  getIcon() {
    return FRIDAY_ICON;
  }
};

// src/user.ts
var import_obsidian6 = require("obsidian");
var User = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    this.apiUrl = this.plugin.apiUrl;
    this.name = this.plugin.settings.username;
    this.password = this.plugin.settings.password;
    this.token = this.plugin.settings.userToken;
  }
  getName() {
    return this.name;
  }
  async getToken() {
    return this.token;
  }
  async logout() {
    this.token = "";
    this.plugin.settings.userToken = "";
    await this.plugin.saveSettings();
  }
  async login() {
    this.name = this.plugin.settings.username;
    this.password = this.plugin.settings.password;
    if (!this.name || !this.password) {
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.enter_email_password"), 5e3);
      return;
    }
    try {
      const loginUrl = `${this.apiUrl}/api/login`;
      const response = await (0, import_obsidian6.requestUrl)({
        url: loginUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `email=${encodeURIComponent(this.name)}&password=${encodeURIComponent(this.password)}`
      });
      if (response.status !== 201) {
        throw new Error(`Login failed: ${response.text}`);
      }
      this.token = response.json.data[0];
      this.plugin.settings.userToken = this.token;
      await this.plugin.saveSettings();
    } catch (error) {
      console.error("Failed to login:", error);
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.login_failed"), 5e3);
    }
  }
  async register() {
    this.name = this.plugin.settings.username;
    this.password = this.plugin.settings.password;
    if (!this.name || !this.password) {
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.enter_email_password"), 5e3);
      return;
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(this.name)) {
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.enter_valid_email"), 5e3);
      return;
    }
    try {
      const registerUrl = `${this.apiUrl}/api/user`;
      const response = await (0, import_obsidian6.requestUrl)({
        url: registerUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `email=${encodeURIComponent(this.name)}&password=${encodeURIComponent(this.password)}`
      });
      if (response.status !== 201) {
        throw new Error(`Registration failed: ${response.text}`);
      }
      this.token = response.json.data[0];
      this.plugin.settings.userToken = this.token;
      await this.plugin.saveSettings();
    } catch (error) {
      console.error("Failed to register user:", error);
      new import_obsidian6.Notice(this.plugin.i18n.t("messages.register_failed"), 5e3);
    }
  }
};

// src/theme/modal.ts
var import_obsidian7 = require("obsidian");
var ThemeSelectionModal = class extends import_obsidian7.Modal {
  constructor(app, selectedTheme, onSelect, plugin, isForSingleFile = false) {
    super(app);
    this.themes = [];
    this.allThemes = [];
    this.allTags = [];
    this.selectedTags = [];
    this.searchTerm = "";
    this.loading = false;
    this.loadingTags = false;
    this.loadingError = null;
    this.loadingState = "idle";
    this.searchTimeout = null;
    this.isForSingleFile = false;
    this.selectedTheme = selectedTheme;
    this.onSelect = onSelect;
    this.plugin = plugin;
    this.isForSingleFile = isForSingleFile;
    this.setTitle(plugin.i18n.t("theme.choose_theme"));
  }
  t(key2, params) {
    return this.plugin.i18n.t(key2, params);
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("friday-theme-modal");
    contentEl.empty();
    this.loadingState = "initial";
    this.renderModal();
    try {
      await this.loadTags();
      await this.loadThemes();
      this.renderModal();
    } catch (error) {
      console.error("Failed to load initial data:", error);
      this.loadingState = "error";
      this.loadingError = error instanceof Error ? error.message : "Unknown error";
      this.renderModal();
    }
  }
  async loadTags() {
    this.loadingTags = true;
    this.loadingState = "tags";
    try {
      this.allThemes = await themeApiService.getAllThemes(this.plugin);
      if (this.isForSingleFile) {
        this.allThemes = this.allThemes.filter((theme) => theme.tags.some((tag) => tag.toLowerCase() === "page"));
      }
      this.allTags = this.extractTagsFromThemes(this.allThemes);
    } catch (error) {
      console.error("Failed to load tags:", error);
      throw error;
    } finally {
      this.loadingTags = false;
    }
  }
  extractTagsFromThemes(themes) {
    const allTags = themes.flatMap((theme) => theme.tags);
    const uniqueTags = [...new Set(allTags)];
    return uniqueTags.sort((a, b) => a.localeCompare(b));
  }
  async loadThemes() {
    this.loading = true;
    this.loadingState = this.searchTerm || this.selectedTags.length > 0 ? "search" : "themes";
    this.loadingError = null;
    try {
      let filteredThemes = [...this.allThemes];
      if (this.searchTerm.trim()) {
        const term = this.searchTerm.trim().toLowerCase();
        filteredThemes = filteredThemes.filter((theme) => theme.name.toLowerCase().includes(term) || theme.author.toLowerCase().includes(term) || theme.tags.some((tag) => tag.toLowerCase().includes(term)));
      }
      if (this.selectedTags.length > 0) {
        filteredThemes = filteredThemes.filter((theme) => this.selectedTags.every((selectedTag) => theme.tags.some((tag) => tag === selectedTag)));
      }
      this.themes = filteredThemes.slice(0, 20);
      this.loadingState = "idle";
    } catch (error) {
      console.error("Failed to load themes:", error);
      this.themes = [];
      this.loadingState = "error";
      this.loadingError = error instanceof Error ? error.message : "Unknown error";
    } finally {
      this.loading = false;
    }
  }
  renderModal() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.loadingState === "initial" || this.loadingState === "tags") {
      const themesSection2 = contentEl.createDiv("themes-section");
      this.renderLoadingState(themesSection2);
      return;
    }
    const searchSection = contentEl.createDiv("search-section");
    const searchWrapper = searchSection.createDiv("search-input-wrapper");
    const searchInput = searchWrapper.createEl("input", {
      type: "text",
      placeholder: this.t("theme.search_themes"),
      cls: "search-input"
    });
    searchWrapper.createDiv("search-icon").setText("\u{1F50D}");
    searchInput.addEventListener("input", async (e) => {
      this.searchTerm = e.target.value;
      if (this.searchTimeout) {
        clearTimeout(this.searchTimeout);
      }
      this.searchTimeout = setTimeout(async () => {
        await this.loadThemes();
        this.renderThemes();
      }, 300);
    });
    const tagsSection = searchSection.createDiv("tags-section");
    const tagsHeader = tagsSection.createDiv("tags-header");
    tagsHeader.createEl("span", { text: this.t("theme.filter_by_tags"), cls: "tags-label" });
    if (this.selectedTags.length > 0) {
      const clearBtn = tagsHeader.createEl("button", { text: this.t("theme.clear_filters"), cls: "clear-filters-btn" });
      clearBtn.addEventListener("click", async () => {
        this.selectedTags = [];
        this.searchTerm = "";
        searchInput.value = "";
        await this.loadThemes();
        this.renderModal();
      });
    }
    const tagsGrid = tagsSection.createDiv("tags-grid");
    this.allTags.forEach((tag) => {
      const tagBtn = tagsGrid.createEl("button", {
        text: tag,
        cls: `tag-btn ${this.selectedTags.includes(tag) ? "selected" : ""}`
      });
      tagBtn.addEventListener("click", async () => {
        if (this.selectedTags.includes(tag)) {
          this.selectedTags = this.selectedTags.filter((t) => t !== tag);
        } else {
          this.selectedTags.push(tag);
        }
        await this.loadThemes();
        this.renderModal();
      });
    });
    const themesSection = contentEl.createDiv("themes-section");
    this.renderThemes(themesSection);
  }
  renderThemes(container) {
    const themesSection = container || this.contentEl.querySelector(".themes-section");
    if (!themesSection)
      return;
    themesSection.empty();
    if (this.loadingState === "error") {
      this.renderErrorState(themesSection);
      return;
    }
    if (this.loading || this.loadingState !== "idle") {
      this.renderLoadingState(themesSection);
      return;
    }
    if (this.themes.length === 0) {
      const noResults = themesSection.createDiv("no-results");
      noResults.createEl("p", { text: this.t("theme.no_themes_found") });
      return;
    }
    const themesGrid = themesSection.createDiv("themes-grid");
    this.themes.forEach((theme) => {
      const themeCard = themesGrid.createDiv(`theme-card ${theme.id === this.selectedTheme ? "selected" : ""}`);
      const imageSection = themeCard.createDiv("theme-image-section");
      if (theme.thumbnail) {
        imageSection.style.backgroundImage = `url("${theme.thumbnail}")`;
      } else {
        const gradients = [
          "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
          "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)",
          "linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)",
          "linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)",
          "linear-gradient(135deg, #fa709a 0%, #fee140 100%)",
          "linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)",
          "linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)",
          "linear-gradient(135deg, #ff8a80 0%, #ea80fc 100%)"
        ];
        const hash = theme.name.split("").reduce((a, b) => {
          a = (a << 5) - a + b.charCodeAt(0);
          return a & a;
        }, 0);
        const gradientIndex = Math.abs(hash) % gradients.length;
        imageSection.style.background = gradients[gradientIndex];
      }
      if (theme.demo) {
        const liveDemoBtn = imageSection.createEl("a", {
          text: this.t("theme.live_demo"),
          cls: "live-demo-btn"
        });
        liveDemoBtn.href = theme.demo;
        liveDemoBtn.target = "_blank";
        liveDemoBtn.addEventListener("click", (e) => {
          e.stopPropagation();
        });
      }
      const infoSection = themeCard.createDiv("theme-info-section");
      const leftInfo = infoSection.createDiv("theme-info-left");
      leftInfo.createEl("h3", { text: theme.name, cls: "theme-title" });
      if (theme.author || theme.version) {
        const metaInfo = leftInfo.createDiv("theme-meta-info");
        if (theme.author) {
          metaInfo.createEl("span", { text: this.t("theme.by_author", { author: theme.author }), cls: "theme-author" });
        }
        if (theme.version) {
          if (theme.author) {
            metaInfo.createEl("span", { text: " \u2022 ", cls: "separator" });
          }
          metaInfo.createEl("span", { text: `v${theme.version}`, cls: "theme-version" });
        }
      }
      leftInfo.createEl("p", { text: theme.description || "", cls: "theme-description" });
      const rightInfo = infoSection.createDiv("theme-info-right");
      rightInfo.createEl("div", { text: this.t("theme.free"), cls: "theme-price" });
      const bottomSection = themeCard.createDiv("theme-bottom-section");
      if (theme.tags && theme.tags.length > 0) {
        const tags = bottomSection.createDiv("theme-tags");
        theme.tags.forEach((tag) => {
          tags.createEl("span", { text: tag, cls: "tag" });
        });
      }
      const useBtn = bottomSection.createEl("button", {
        text: theme.id === this.selectedTheme ? this.t("theme.current") : this.t("theme.use_it"),
        cls: `use-theme-btn ${theme.id === this.selectedTheme ? "current" : ""}`
      });
      useBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.onSelect(theme.download_url, theme.name, theme.id);
        this.close();
      });
      themeCard.addEventListener("click", () => {
        this.onSelect(theme.download_url, theme.name, theme.id);
        this.close();
      });
    });
  }
  renderLoadingState(container) {
    if (this.loadingState === "initial" || this.loadingState === "tags") {
      const loadingContainer = container.createDiv("loading-container");
      let loadingText = this.t("theme.loading_initial");
      if (this.loadingState === "tags") {
        loadingText = this.t("theme.loading_tags");
      }
      loadingContainer.createDiv("loading-spinner");
      loadingContainer.createDiv("loading-text").setText(loadingText);
      return;
    }
    if (this.loading) {
      let loadingText = this.t("theme.loading_themes");
      if (this.loadingState === "search") {
        loadingText = this.t("theme.loading_search");
      }
      container.createDiv("loading-message").setText(loadingText);
    }
  }
  renderErrorState(container) {
    const errorContainer = container.createDiv("error-container");
    errorContainer.createDiv("error-icon").setText("\u26A0\uFE0F");
    const errorMessage = this.loadingError || this.t("theme.loading_error");
    errorContainer.createDiv("error-message").setText(errorMessage);
    const retryButton = errorContainer.createEl("button", {
      text: this.t("theme.retry"),
      cls: "retry-button"
    });
    retryButton.addEventListener("click", async () => {
      try {
        await this.loadThemes();
      } catch (error) {
        console.error("Retry failed:", error);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
      this.searchTimeout = null;
    }
  }
};

// src/hugoverse.ts
var import_obsidian8 = require("obsidian");
var path4 = __toESM2(require("path"));
var NEW_ID = "-1";
var COUNTER_REQUEST_ID_KEY = "friday_counter_request_id";
var Hugoverse = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    this.apiUrl = this.plugin.apiUrl;
    this.user = this.plugin.user;
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian8.FileSystemAdapter) {
      this.basePath = adapter.getBasePath();
    }
  }
  generateDownloadUrl(filename) {
    return `${this.apiUrl}/api/uploads/themes/${filename}`;
  }
  generateUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  getOrCreateRequestId() {
    let requestId = localStorage.getItem(COUNTER_REQUEST_ID_KEY);
    if (!requestId) {
      requestId = this.generateUUID();
      localStorage.setItem(COUNTER_REQUEST_ID_KEY, requestId);
    }
    return requestId;
  }
  projectDirPath(filepath) {
    return path4.dirname(filepath);
  }
  async deployMDFridayPreview(id) {
    try {
      const createPostUrl = `${this.apiUrl}/api/mdf/preview/deploy?type=MDFPreview&id=${id}`;
      let body = new FormData();
      body.append("type", "MDFPreview");
      body.append("id", id);
      body.append("host_name", "MDFriday Preview");
      const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2, 9);
      const arrayBufferBody = await this.formDataToArrayBuffer(body, boundary);
      const response = await (0, import_obsidian8.requestUrl)({
        url: createPostUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBufferBody
      });
      if (response.status !== 200) {
        throw new Error(`Post creation failed: ${response.text}`);
      }
      return response.json.data[0];
    } catch (error) {
      console.error("Failed to create post:", error.toString());
      new import_obsidian8.Notice(this.plugin.i18n.t("messages.failed_to_create_post"), 5e3);
    }
  }
  async createMDFPreview(name, content) {
    try {
      const createResourceUrl = `${this.apiUrl}/api/mdf/preview?type=MDFPreview`;
      let body = new FormData();
      body.append("type", "MDFPreview");
      body.append("id", NEW_ID);
      body.append("name", name);
      body.append("size", content.byteLength.toString());
      const mimeType = "application/zip";
      const blob = new Blob([content], { type: mimeType });
      body.append(`asset`, blob, `${name}.zip`);
      const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2, 9);
      const arrayBufferBody = await this.formDataToArrayBuffer(body, boundary);
      const response = await (0, import_obsidian8.requestUrl)({
        url: createResourceUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBufferBody
      });
      if (response.status !== 200) {
        throw new Error(`Resource creation failed: ${response.text}`);
      }
      return response.json.data[0].id;
    } catch (error) {
      console.error("Failed to create resource:", error.toString());
      new import_obsidian8.Notice(this.plugin.i18n.t("messages.failed_to_create_resource"), 5e3);
    }
  }
  async formDataToArrayBuffer(formData, boundary) {
    let bodyParts = [];
    const formDataEntries = [];
    formData.forEach((value2, key2) => {
      formDataEntries.push({ value: value2, key: key2 });
    });
    for (const { value: value2, key: key2 } of formDataEntries) {
      bodyParts.push(`--${boundary}\r
`);
      if (typeof value2 === "string") {
        bodyParts.push(`Content-Disposition: form-data; name="${key2}"\r
\r
${value2}\r
`);
      } else if (value2 instanceof Blob) {
        bodyParts.push(`Content-Disposition: form-data; name="${key2}"; filename="${value2.name}"\r
`);
        bodyParts.push(`Content-Type: ${value2.type || "application/octet-stream"}\r
\r
`);
        const arrayBuffer = await value2.arrayBuffer();
        bodyParts.push(new Uint8Array(arrayBuffer));
        bodyParts.push(`\r
`);
      }
    }
    bodyParts.push(`--${boundary}--\r
`);
    const encoder = new TextEncoder();
    const encodedParts = bodyParts.map((part) => typeof part === "string" ? encoder.encode(part) : part);
    const totalLength = encodedParts.reduce((acc, curr) => acc + curr.length, 0);
    const combinedArray = new Uint8Array(totalLength);
    let offset = 0;
    for (const part of encodedParts) {
      combinedArray.set(part, offset);
      offset += part.length;
    }
    return combinedArray.buffer;
  }
  async sendCounter(kind = "preview") {
    try {
      const requestId = this.getOrCreateRequestId();
      const counterUrl = `${this.apiUrl}/api/counter?type=Counter`;
      let body = new FormData();
      body.append("id", NEW_ID);
      body.append("kind", kind);
      body.append("request_id", requestId);
      const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2, 9);
      const arrayBufferBody = await this.formDataToArrayBuffer(body, boundary);
      const response = await (0, import_obsidian8.requestUrl)({
        url: counterUrl,
        method: "POST",
        headers: {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBufferBody
      });
      if (response.status !== 200) {
        console.warn(`Counter request failed: ${response.text}`);
        return false;
      }
      return true;
    } catch (error) {
      console.warn("Failed to send counter:", error.toString());
      return false;
    }
  }
};

// src/netlify.ts
var import_obsidian9 = require("obsidian");
var path5 = __toESM2(require("path"));
var fs4 = __toESM2(require("fs"));
var import_jszip2 = __toESM2(require_jszip_min());
var NetlifyAPI = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian9.FileSystemAdapter) {
      this.basePath = adapter.getBasePath();
    }
  }
  async deployToNetlify(publicDir, progressCallback) {
    const { netlifyAccessToken, netlifyProjectId } = this.plugin.settings;
    if (!netlifyAccessToken || !netlifyProjectId) {
      throw new Error("Netlify access token and project ID are required");
    }
    try {
      progressCallback?.(5);
      const zipContent = await this.createZipFromDirectory(publicDir);
      progressCallback?.(30);
      const deployId = await this.uploadToNetlify(zipContent, netlifyAccessToken, netlifyProjectId, (uploadProgress) => {
        progressCallback?.(30 + uploadProgress * 0.6);
      });
      progressCallback?.(90);
      try {
        await this.waitForDeployment(deployId, netlifyAccessToken);
      } catch (error) {
        console.warn("Failed to confirm deployment status via API, but deployment may still be successful:", error.message);
      }
      progressCallback?.(100);
      return await this.getSiteUrl(netlifyProjectId, netlifyAccessToken);
    } catch (error) {
      console.error("Netlify deployment failed:", error);
      if (error.message.includes("401") || error.message.includes("Unauthorized")) {
        throw new Error("Invalid Netlify access token. Please check your settings.");
      } else if (error.message.includes("404") || error.message.includes("Not Found")) {
        throw new Error("Netlify site not found. Please check your project ID.");
      } else if (error.message.includes("network") || error.message.includes("CORS")) {
        throw new Error("Network error. Please check your internet connection.");
      }
      throw error;
    }
  }
  async createZipFromDirectory(sourceDir) {
    const zip = new import_jszip2.default();
    const addDirectoryToZip = async (dirPath, zipFolder) => {
      const items = await fs4.promises.readdir(dirPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path5.join(dirPath, item.name);
        if (item.isDirectory()) {
          const subFolder = zipFolder.folder(item.name);
          if (subFolder) {
            await addDirectoryToZip(itemPath, subFolder);
          }
        } else if (item.isFile()) {
          const fileContent = await fs4.promises.readFile(itemPath);
          zipFolder.file(item.name, fileContent);
        }
      }
    };
    await addDirectoryToZip(sourceDir, zip);
    return await zip.generateAsync({ type: "uint8array" });
  }
  async uploadToNetlify(zipContent, accessToken, siteId, progressCallback) {
    try {
      const progressInterval = this.simulateUploadProgress(zipContent.length, progressCallback);
      const response = await (0, import_obsidian9.requestUrl)({
        url: `https://api.netlify.com/api/v1/sites/${siteId}/deploys`,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/zip"
        },
        body: zipContent.buffer
      });
      clearInterval(progressInterval);
      progressCallback?.(100);
      if (response.status === 200) {
        return response.json.id;
      } else {
        throw new Error(`Upload failed with status: ${response.status} - ${response.text}`);
      }
    } catch (error) {
      console.error("Netlify upload error:", error);
      throw new Error(`Upload failed: ${error.message}`);
    }
  }
  simulateUploadProgress(fileSize, progressCallback) {
    let progress = 0;
    const totalTime = Math.min(Math.max(fileSize / 1024 / 1024 * 2e3, 3e3), 3e4);
    const interval = 500;
    const increment = interval / totalTime * 100;
    return setInterval(() => {
      progress = Math.min(progress + increment, 95);
      progressCallback?.(progress);
    }, interval);
  }
  async waitForDeployment(deployId, accessToken, maxAttempts = 30) {
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const checkUrl = `https://api.netlify.com/api/v1/deploys/${deployId}`;
        const response = await (0, import_obsidian9.requestUrl)({
          url: checkUrl,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${accessToken}`
          }
        });
        if (response.status === 200) {
          const deploy = response.json;
          if (deploy.state === "ready") {
            return;
          } else if (deploy.state === "error") {
            throw new Error(`Deployment failed: ${deploy.error_message || "Unknown error"}`);
          }
        } else {
          console.warn(`Unexpected status code: ${response.status}, response: ${response.text}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      } catch (error) {
        console.error(`Error checking deployment status (attempt ${i + 1}):`, error);
        if (i === maxAttempts - 1) {
          throw error;
        }
        await new Promise((resolve) => setTimeout(resolve, 2e3));
      }
    }
    throw new Error("Deployment timed out");
  }
  async getSiteUrl(siteId, accessToken) {
    try {
      const response = await (0, import_obsidian9.requestUrl)({
        url: `https://api.netlify.com/api/v1/sites/${siteId}`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`
        }
      });
      if (response.status === 200) {
        const site = response.json;
        return site.ssl_url || site.url;
      }
      throw new Error(`Failed to get site URL: ${response.status}`);
    } catch (error) {
      console.error("Failed to get site URL:", error);
      throw error;
    }
  }
};

// src/i18n/utils.ts
var AVAILABLE_LANGUAGES = [
  {
    code: "en",
    name: "English",
    nativeName: "English"
  },
  {
    code: "zh-cn",
    name: "Chinese (Simplified)",
    nativeName: "\u7B80\u4F53\u4E2D\u6587"
  },
  {
    code: "es",
    name: "Spanish",
    nativeName: "Espa\xF1ol"
  },
  {
    code: "fr",
    name: "French",
    nativeName: "Fran\xE7ais"
  },
  {
    code: "de",
    name: "German",
    nativeName: "Deutsch"
  },
  {
    code: "ja",
    name: "Japanese",
    nativeName: "\u65E5\u672C\u8A9E"
  },
  {
    code: "ko",
    name: "Korean",
    nativeName: "\uD55C\uAD6D\uC5B4"
  },
  {
    code: "pt",
    name: "Portuguese",
    nativeName: "Portugu\xEAs"
  }
];
var DEFAULT_LANGUAGE = "en";
function detectLanguage(app) {
  try {
    let obsidianLang = app.vault?.config?.lang;
    if (!obsidianLang) {
      obsidianLang = app.vault?.config?.language;
    }
    if (!obsidianLang && typeof window !== "undefined" && window.moment) {
      obsidianLang = window.moment.locale();
    }
    if (!obsidianLang && document.documentElement.lang) {
      obsidianLang = document.documentElement.lang;
    }
    if (obsidianLang) {
      const normalized = normalizeLanguageCode(obsidianLang);
      if (normalized && isValidLanguageCode(normalized)) {
        return normalized;
      }
    }
  } catch (error) {
    console.warn("Failed to get Obsidian language setting:", error);
  }
  try {
    const browserLang = navigator.language || navigator.languages?.[0];
    if (browserLang) {
      const normalized = normalizeLanguageCode(browserLang);
      if (normalized && isValidLanguageCode(normalized)) {
        return normalized;
      }
    }
  } catch (error) {
    console.warn("Failed to get browser language:", error);
  }
  return DEFAULT_LANGUAGE;
}
function normalizeLanguageCode(langCode) {
  if (!langCode)
    return null;
  const normalized = langCode.toLowerCase().replace(/[_]/g, "-");
  const mappings = {
    "zh": "zh-cn",
    "zh-cn": "zh-cn",
    "zh-hans": "zh-cn",
    "zh-hans-cn": "zh-cn",
    "zh-chs": "zh-cn",
    "zh-simplified": "zh-cn",
    "chinese": "zh-cn",
    "chinese-simplified": "zh-cn",
    "zh-hant": "zh-tw",
    "zh-tw": "zh-tw",
    "zh-cht": "zh-tw",
    "zh-traditional": "zh-tw",
    "chinese-traditional": "zh-tw",
    "en": "en",
    "en-us": "en",
    "en-gb": "en",
    "en-au": "en",
    "en-ca": "en",
    "english": "en",
    "es": "es",
    "es-es": "es",
    "es-mx": "es",
    "es-ar": "es",
    "spanish": "es",
    "fr": "fr",
    "fr-fr": "fr",
    "fr-ca": "fr",
    "french": "fr",
    "de": "de",
    "de-de": "de",
    "de-at": "de",
    "de-ch": "de",
    "german": "de",
    "ja": "ja",
    "ja-jp": "ja",
    "japanese": "ja",
    "ko": "ko",
    "ko-kr": "ko",
    "korean": "ko",
    "pt": "pt",
    "pt-pt": "pt",
    "pt-br": "pt",
    "portuguese": "pt"
  };
  if (mappings[normalized]) {
    return mappings[normalized];
  }
  for (const [key2, value2] of Object.entries(mappings)) {
    if (normalized.startsWith(key2 + "-") || normalized.startsWith(key2 + "_")) {
      return value2;
    }
  }
  return null;
}
function isValidLanguageCode(code) {
  return AVAILABLE_LANGUAGES.some((lang) => lang.code === code);
}
function interpolateTemplate(template, params) {
  if (!params)
    return template;
  return template.replace(/\{\{(\w+)\}\}/g, (match, key2) => {
    return params[key2] !== void 0 ? String(params[key2]) : match;
  });
}
function getNestedValue(obj, path8) {
  return path8.split(".").reduce((current, key2) => {
    return current && current[key2] !== void 0 ? current[key2] : void 0;
  }, obj);
}

// src/i18n/locales/en.ts
var en = {
  settings: {
    welcome_back: "Welcome Back!",
    welcome: "Welcome!",
    logged_in_as: "Logged in as: {{username}}",
    please_enter_credentials: "Please enter your credentials.",
    email: "Email",
    email_desc: "Enter your email address",
    email_placeholder: "your@email.com",
    password: "Password",
    password_desc: "Enter your password",
    password_placeholder: "password",
    register: "Register",
    login: "Login",
    logout: "Logout",
    publish_settings: "Publish Settings",
    publish_method: "Publish Method",
    publish_method_desc: "Choose how you want to publish your site",
    publish_method_netlify: "Netlify",
    publish_method_ftp: "FTP",
    netlify_settings: "Netlify Settings",
    netlify_access_token: "Personal Access Token",
    netlify_access_token_desc: "Your Netlify personal access token for API authentication",
    netlify_access_token_placeholder: "Enter your Netlify access token",
    netlify_project_id: "Project ID",
    netlify_project_id_desc: "The ID of your Netlify project/site",
    netlify_project_id_placeholder: "Enter your project ID",
    ftp_settings: "FTP Settings",
    ftp_server: "Server Address",
    ftp_server_desc: "FTP server domain or IP address",
    ftp_server_placeholder: "e.g. ftp.example.com",
    ftp_username: "Username",
    ftp_username_desc: "FTP login username",
    ftp_username_placeholder: "Enter username",
    ftp_password: "Password",
    ftp_password_desc: "FTP login password",
    ftp_password_placeholder: "Enter password",
    ftp_remote_dir: "Remote Directory",
    ftp_remote_dir_desc: "Target directory path for upload",
    ftp_remote_dir_placeholder: "e.g. /www/site",
    ftp_ignore_cert: "Ignore Certificate Verification",
    ftp_ignore_cert_desc: "Enable for self-signed certificates, recommended",
    ftp_test_connection: "Test FTP Connection",
    ftp_test_connection_desc: "Test if current FTP settings are correct",
    ftp_test_connection_testing: "Testing...",
    ftp_test_connection_success: "Connection Successful",
    ftp_test_connection_failed: "Connection Failed",
    general_settings: "General Settings",
    download_server: "Download Server",
    download_server_desc: "Choose the server for downloading themes and resources",
    download_server_global: "Global",
    download_server_east: "East",
    mdfriday_account: "MDFriday Account (Optional)",
    mdfriday_account_desc: "Sign in to access advanced features like theme marketplace and cloud publishing."
  },
  ui: {
    desktop_only_title: "Desktop Only",
    desktop_only_message: "We're sorry, only desktop is supported at this time.",
    mobile_coming_soon: "Mobile and Tablet is coming soon.\nThank you for your patience and understanding!",
    multilingual_content: "Multilingual Content",
    content_path: "Content Path",
    language: "Language",
    default_language: "Default Language",
    clear: "Clear",
    clear_all_content: "Clear all content",
    default: "Default",
    no_content_selected: "No content selected",
    no_content_selected_hint: 'Right-click on a folder or file and select "Publish to Web" to get started',
    remove_language: "Remove language",
    site_name: "Site Name",
    site_name_placeholder: "Enter site name",
    site_assets: "Site Assets",
    site_assets_placeholder: "No assets folder set",
    site_assets_hint: 'Right-click on a folder and select "Set as Site Assets" to configure',
    clear_assets: "Clear",
    advanced_settings: "Advanced Settings",
    site_path: "Site Path",
    site_path_placeholder: "/",
    site_path_hint: 'Specify the base path for your site. Use "/" for root deployment.',
    site_password: "Site Password",
    site_password_placeholder: "Enter site password",
    site_password_hint: "Set a site-level access password (optional)",
    google_analytics_id: "Google Analytics ID",
    google_analytics_placeholder: "G-XXXXXXXXXX",
    google_analytics_hint: "Your Google Analytics measurement ID (optional)",
    disqus_shortname: "Disqus Shortname",
    disqus_placeholder: "your-site-shortname",
    disqus_hint: "Your Disqus shortname for comments (optional)",
    theme: "Theme",
    change_theme: "Change Theme",
    download_sample: "Download Sample",
    downloading_sample: "Downloading...",
    preview: "Preview",
    preview_building: "Building preview...",
    preview_success: "Preview ready!",
    preview_failed: "Preview build failed",
    generate_preview: "Generate Preview",
    regenerate_preview: "Regenerate Preview",
    preview_link: "Preview link:",
    export_site: "Export Site",
    exporting: "Exporting...",
    export_site_dialog_title: "Save Site Archive",
    publish: "Publish",
    publish_method: "Publish Method",
    publish_option_mdfriday: "MDFriday Preview",
    publish_option_netlify: "Netlify",
    publish_option_ftp: "FTP Upload",
    mdfriday_preview_hint: "MDFriday Preview provides instant hosting without additional configuration. Your site will be published directly to our preview service.",
    publish_building: "Publishing...",
    publish_success: "Published successfully!",
    publish_failed: "Publish failed",
    published_successfully: "\u2705 Published successfully!",
    server_start: "Start Server",
    server_stop: "Stop Server",
    server_running: "Server Running",
    server_stopped: "Server Stopped"
  },
  menu: {
    publish_to_web: "Publish to Web",
    set_as_site_assets: "Set as Site Assets"
  },
  commands: {},
  theme: {
    choose_theme: "Choose a Theme",
    search_themes: "Search themes...",
    filter_by_tags: "Filter by tags:",
    clear_filters: "Clear filters",
    loading_themes: "Loading themes...",
    loading_tags: "Loading tags...",
    loading_initial: "Initializing theme library...",
    loading_search: "Searching themes...",
    loading_error: "Loading failed, please retry",
    no_themes_found: "No themes found",
    view_demo: "View Demo",
    live_demo: "Live Demo",
    use_it: "Use It",
    current: "Current",
    free: "Free",
    by_author: "by {{author}}",
    retry: "Retry"
  },
  projects: {
    manage_projects: "Manage Projects",
    project_list: "Projects",
    no_projects: "No projects saved yet",
    select_project_to_view: "Select a project to view details",
    configuration: "Configuration",
    build_history: "Build History",
    no_build_history: "No build history",
    apply_to_panel: "Apply to Panel",
    delete_project: "Delete",
    delete_project_permanent: "Delete this project",
    danger_zone: "Danger Zone",
    clear_history_title: "Clear preview history",
    clear_history_message: "This will permanently delete all preview directories and build history for this project. Exported sites and published sites will not be affected.",
    clear_preview_history: "Clear all previews",
    confirm_clear_history: "Are you sure you want to delete all preview files? This will free up disk space but cannot be undone.",
    preview_history_cleared: "Preview history cleared successfully. {{count}} directories deleted.",
    no_preview_files: "No preview files found to delete.",
    delete_warning_title: "Delete project",
    delete_warning_message: "Once you delete a project, all its configuration and build history will be permanently removed. This action cannot be undone.",
    confirm_delete: 'Are you sure you want to delete project "{{name}}"?',
    project_applied: "Project configuration applied successfully",
    project_applied_no_content: "Project configuration applied. Content paths not found - please right-click folders/files to add content.",
    project_deleted: "Project deleted successfully",
    view_site: "View Site",
    export_build: "Export",
    preview_not_found: "Preview directory not found. It may have been deleted.",
    just_now: "Just now",
    minutes_ago: "{{count}} minutes ago",
    hours_ago: "{{count}} hours ago",
    days_ago: "{{count}} days ago"
  },
  messages: {
    desktop_only_notice: "Only desktop is supported at this time.",
    preview_url_copied: "Preview URL copied to clipboard",
    publish_url_copied: "Publish URL copied to clipboard",
    build_started: "Build started",
    build_completed: "Build completed successfully",
    build_failed: "Build failed",
    publish_started: "Publishing started",
    publish_completed: "Published successfully",
    publish_failed: "Publishing failed",
    no_folder_selected: "No folder selected",
    no_folder_or_file_selected: "No folder or file selected",
    must_select_folder_type: 'Content type mismatch: You previously selected a folder, but now selected a file. To publish files, click the "Clear" button in the top-right to remove previous selections, then select files only.',
    must_select_file_type: 'Content type mismatch: You previously selected a file, but now selected a folder. To publish folders, click the "Clear" button in the top-right to remove previous selections, then select folders only.',
    all_content_cleared: "All content cleared successfully",
    language_added_successfully: "Language content added successfully",
    please_use_publish_first: 'Please use "Publish to Web" on a folder or file first to get started',
    add_language_instruction: 'Right-click on a folder or file and select "Publish to Web" to add more languages',
    preview_generated_successfully: "Preview generated successfully!",
    preview_failed: "Preview failed: {{error}}",
    please_generate_preview_first: "Please generate preview first",
    preview_data_missing: "Preview data is missing",
    site_published_successfully: "Site published successfully!",
    publishing_failed: "Publishing failed: {{error}}",
    site_exported_successfully: "Site exported successfully to: {{path}}",
    export_failed: "Export failed: {{error}}",
    incremental_upload_stats: "Incremental upload: {{uploaded}} uploaded, {{deleted}} deleted, {{unchanged}} unchanged (~{{saved}}% time saved)",
    netlify_settings_missing: "Please configure Netlify settings first",
    netlify_deploy_failed: "Netlify deployment failed: {{error}}",
    netlify_deploy_success: "Site deployed to Netlify successfully!",
    ftp_settings_missing: "Please configure FTP settings first",
    ftp_upload_failed: "FTP upload failed: {{error}}",
    ftp_upload_success: "Site uploaded to FTP server successfully!",
    ftp_fallback_to_plain: "Server does not support encryption, switched to plain FTP",
    ftp_fallback_to_full: "\u26A0\uFE0F Incremental upload failed, trying full upload as fallback...",
    enter_email_password: "Please enter your email and password",
    enter_valid_email: "Please enter a valid email address",
    login_failed: "Failed to login",
    register_failed: "Failed to register user",
    invalid_assets_folder: "Invalid assets folder",
    site_assets_set_successfully: "Site assets set successfully",
    site_assets_cleared: "Site assets cleared",
    sample_downloaded_successfully: 'Theme sample "{{themeName}}" downloaded successfully! Saved to folder: {{folderName}}',
    sample_download_failed: "Sample download failed: {{error}}",
    structured_folder_processed: 'Structured folder "{{folderName}}" detected, automatically added {{contentCount}} language contents',
    static_folder_detected: "and detected static assets folder",
    failed_to_create_post: "Failed to create post.",
    failed_to_create_resource: "Failed to create resource."
  },
  info: {
    service_description: "You own it \u2014 your notes, your themes, your cloud.\nMDFriday lets you build and publish with full control.",
    learn_more: "Learn more"
  },
  common: {
    loading: "Loading...",
    success: "Success",
    error: "Error",
    cancel: "Cancel",
    confirm: "Confirm",
    save: "Save",
    close: "Close",
    copy: "Copy",
    copied: "Copied!"
  }
};

// src/i18n/locales/zh-cn.ts
var zhCn = {
  settings: {
    welcome_back: "\u6B22\u8FCE\u56DE\u6765\uFF01",
    welcome: "\u6B22\u8FCE\uFF01",
    logged_in_as: "\u5DF2\u767B\u5F55\u7528\u6237\uFF1A{{username}}",
    please_enter_credentials: "\u8BF7\u8F93\u5165\u60A8\u7684\u767B\u5F55\u4FE1\u606F\u3002",
    email: "\u90AE\u7BB1",
    email_desc: "\u8BF7\u8F93\u5165\u60A8\u7684\u90AE\u7BB1\u5730\u5740",
    email_placeholder: "your@email.com",
    password: "\u5BC6\u7801",
    password_desc: "\u8BF7\u8F93\u5165\u60A8\u7684\u5BC6\u7801",
    password_placeholder: "\u5BC6\u7801",
    register: "\u6CE8\u518C",
    login: "\u767B\u5F55",
    logout: "\u9000\u51FA\u767B\u5F55",
    publish_settings: "\u53D1\u5E03\u8BBE\u7F6E",
    publish_method: "\u53D1\u5E03\u65B9\u5F0F",
    publish_method_desc: "\u9009\u62E9\u60A8\u60F3\u8981\u53D1\u5E03\u7F51\u7AD9\u7684\u65B9\u5F0F",
    publish_method_netlify: "Netlify",
    publish_method_ftp: "FTP",
    netlify_settings: "Netlify \u8BBE\u7F6E",
    netlify_access_token: "\u4E2A\u4EBA\u8BBF\u95EE\u4EE4\u724C",
    netlify_access_token_desc: "\u60A8\u7684 Netlify \u4E2A\u4EBA\u8BBF\u95EE\u4EE4\u724C\uFF0C\u7528\u4E8E API \u8BA4\u8BC1",
    netlify_access_token_placeholder: "\u8BF7\u8F93\u5165\u60A8\u7684 Netlify \u8BBF\u95EE\u4EE4\u724C",
    netlify_project_id: "\u9879\u76EE ID",
    netlify_project_id_desc: "\u60A8\u7684 Netlify \u9879\u76EE/\u7AD9\u70B9\u7684 ID",
    netlify_project_id_placeholder: "\u8BF7\u8F93\u5165\u60A8\u7684\u9879\u76EE ID",
    ftp_settings: "FTP \u8BBE\u7F6E",
    ftp_server: "\u670D\u52A1\u5668\u5730\u5740",
    ftp_server_desc: "FTP \u670D\u52A1\u5668\u57DF\u540D\u6216 IP \u5730\u5740",
    ftp_server_placeholder: "\u4F8B\u5982\uFF1Aftp.example.com",
    ftp_username: "\u7528\u6237\u540D",
    ftp_username_desc: "FTP \u767B\u5F55\u7528\u6237\u540D",
    ftp_username_placeholder: "\u8BF7\u8F93\u5165\u7528\u6237\u540D",
    ftp_password: "\u5BC6\u7801",
    ftp_password_desc: "FTP \u767B\u5F55\u5BC6\u7801",
    ftp_password_placeholder: "\u8BF7\u8F93\u5165\u5BC6\u7801",
    ftp_remote_dir: "\u8FDC\u7A0B\u76EE\u5F55",
    ftp_remote_dir_desc: "\u4E0A\u4F20\u7684\u76EE\u6807\u76EE\u5F55\u8DEF\u5F84",
    ftp_remote_dir_placeholder: "\u4F8B\u5982\uFF1A/www/site",
    ftp_ignore_cert: "\u5FFD\u7565\u8BC1\u4E66\u9A8C\u8BC1",
    ftp_ignore_cert_desc: "\u9002\u914D\u81EA\u7B7E\u540D\u8BC1\u4E66\uFF0C\u5EFA\u8BAE\u5F00\u542F",
    ftp_test_connection: "\u6D4B\u8BD5 FTP \u8FDE\u63A5",
    ftp_test_connection_desc: "\u6D4B\u8BD5\u5F53\u524D FTP \u8BBE\u7F6E\u662F\u5426\u6B63\u786E",
    ftp_test_connection_testing: "\u6D4B\u8BD5\u4E2D...",
    ftp_test_connection_success: "\u8FDE\u63A5\u6210\u529F",
    ftp_test_connection_failed: "\u8FDE\u63A5\u5931\u8D25",
    general_settings: "\u901A\u7528\u8BBE\u7F6E",
    download_server: "\u4E0B\u8F7D\u670D\u52A1\u5668",
    download_server_desc: "\u9009\u62E9\u4E0B\u8F7D\u4E3B\u9898\u548C\u8D44\u6E90\u7684\u670D\u52A1\u5668",
    download_server_global: "\u5168\u7403",
    download_server_east: "\u4E1C\u533A",
    mdfriday_account: "MDFriday \u8D26\u6237\uFF08\u53EF\u9009\uFF09",
    mdfriday_account_desc: "\u767B\u5F55\u4EE5\u4F7F\u7528\u9AD8\u7EA7\u529F\u80FD\uFF0C\u5982\u4E3B\u9898\u5E02\u573A\u548C\u4E91\u7AEF\u53D1\u5E03\u3002"
  },
  ui: {
    desktop_only_title: "\u4EC5\u652F\u6301\u684C\u9762\u7248",
    desktop_only_message: "\u62B1\u6B49\uFF0C\u76EE\u524D\u4EC5\u652F\u6301\u684C\u9762\u7248\u672C\u3002",
    mobile_coming_soon: "\u79FB\u52A8\u7AEF\u548C\u5E73\u677F\u7AEF\u5373\u5C06\u63A8\u51FA\u3002\n\u611F\u8C22\u60A8\u7684\u8010\u5FC3\u7B49\u5F85\u548C\u7406\u89E3\uFF01",
    multilingual_content: "\u591A\u8BED\u8A00\u5185\u5BB9",
    content_path: "\u5185\u5BB9\u8DEF\u5F84",
    language: "\u8BED\u8A00",
    default_language: "\u9ED8\u8BA4\u8BED\u8A00",
    clear: "\u6E05\u7A7A",
    clear_all_content: "\u6E05\u7A7A\u6240\u6709\u5185\u5BB9",
    default: "\u9ED8\u8BA4",
    no_content_selected: "\u672A\u9009\u62E9\u5185\u5BB9",
    no_content_selected_hint: '\u53F3\u952E\u70B9\u51FB\u6587\u4EF6\u5939\u6216\u6587\u4EF6\u5E76\u9009\u62E9"\u53D1\u5E03\u5230\u7F51\u7AD9"\u5F00\u59CB',
    remove_language: "\u79FB\u9664\u8BED\u8A00",
    site_name: "\u7AD9\u70B9\u540D\u79F0",
    site_name_placeholder: "\u8BF7\u8F93\u5165\u7AD9\u70B9\u540D\u79F0",
    site_assets: "\u7AD9\u70B9\u8D44\u6E90",
    site_assets_placeholder: "\u672A\u8BBE\u7F6E\u8D44\u6E90\u6587\u4EF6\u5939",
    site_assets_hint: '\u53F3\u952E\u70B9\u51FB\u6587\u4EF6\u5939\u5E76\u9009\u62E9"\u8BBE\u4E3A\u7AD9\u70B9\u8D44\u6E90"\u6765\u8BBE\u7F6E',
    clear_assets: "\u6E05\u9664",
    advanced_settings: "\u9AD8\u7EA7\u8BBE\u7F6E",
    site_path: "\u7AD9\u70B9\u8DEF\u5F84",
    site_path_placeholder: "/",
    site_path_hint: '\u6307\u5B9A\u7AD9\u70B9\u7684\u57FA\u7840\u8DEF\u5F84\u3002\u4F7F\u7528 "/" \u8868\u793A\u6839\u8DEF\u5F84\u90E8\u7F72\u3002',
    site_password: "\u7AD9\u70B9\u5BC6\u7801",
    site_password_placeholder: "\u8F93\u5165\u7AD9\u70B9\u5BC6\u7801",
    site_password_hint: "\u8BBE\u7F6E\u7AD9\u70B9\u7EA7\u522B\u7684\u8BBF\u95EE\u5BC6\u7801\uFF08\u53EF\u9009\uFF09",
    google_analytics_id: "Google Analytics ID",
    google_analytics_placeholder: "G-XXXXXXXXXX",
    google_analytics_hint: "\u60A8\u7684 Google Analytics \u6D4B\u91CF ID\uFF08\u53EF\u9009\uFF09",
    disqus_shortname: "Disqus \u77ED\u540D\u79F0",
    disqus_placeholder: "your-site-shortname",
    disqus_hint: "\u60A8\u7684 Disqus \u77ED\u540D\u79F0\uFF0C\u7528\u4E8E\u8BC4\u8BBA\u529F\u80FD\uFF08\u53EF\u9009\uFF09",
    theme: "\u4E3B\u9898",
    change_theme: "\u66F4\u6362\u4E3B\u9898",
    download_sample: "\u4E0B\u8F7D\u6837\u4F8B",
    downloading_sample: "\u4E0B\u8F7D\u4E2D...",
    preview: "\u9884\u89C8",
    preview_building: "\u6B63\u5728\u6784\u5EFA\u9884\u89C8...",
    preview_success: "\u9884\u89C8\u5DF2\u5C31\u7EEA\uFF01",
    preview_failed: "\u9884\u89C8\u6784\u5EFA\u5931\u8D25",
    generate_preview: "\u751F\u6210\u9884\u89C8",
    regenerate_preview: "\u91CD\u65B0\u751F\u6210\u9884\u89C8",
    preview_link: "\u9884\u89C8\u94FE\u63A5\uFF1A",
    export_site: "\u5BFC\u51FA\u7AD9\u70B9",
    exporting: "\u5BFC\u51FA\u4E2D...",
    export_site_dialog_title: "\u4FDD\u5B58\u7AD9\u70B9\u538B\u7F29\u5305",
    publish: "\u53D1\u5E03",
    publish_method: "\u53D1\u5E03\u65B9\u5F0F",
    publish_option_mdfriday: "MDFriday \u9884\u89C8",
    publish_option_netlify: "Netlify",
    publish_option_ftp: "FTP \u4E0A\u4F20",
    mdfriday_preview_hint: "MDFriday \u9884\u89C8\u63D0\u4F9B\u5373\u65F6\u6258\u7BA1\u670D\u52A1\uFF0C\u65E0\u9700\u989D\u5916\u914D\u7F6E\u3002\u60A8\u7684\u7AD9\u70B9\u5C06\u76F4\u63A5\u53D1\u5E03\u5230\u6211\u4EEC\u7684\u9884\u89C8\u670D\u52A1\u3002",
    publish_building: "\u6B63\u5728\u53D1\u5E03...",
    publish_success: "\u53D1\u5E03\u6210\u529F\uFF01",
    publish_failed: "\u53D1\u5E03\u5931\u8D25",
    published_successfully: "\u2705 \u53D1\u5E03\u6210\u529F\uFF01",
    server_start: "\u542F\u52A8\u670D\u52A1\u5668",
    server_stop: "\u505C\u6B62\u670D\u52A1\u5668",
    server_running: "\u670D\u52A1\u5668\u8FD0\u884C\u4E2D",
    server_stopped: "\u670D\u52A1\u5668\u5DF2\u505C\u6B62"
  },
  menu: {
    publish_to_web: "\u53D1\u5E03\u5230\u7F51\u7EDC",
    set_as_site_assets: "\u8BBE\u4E3A\u7AD9\u70B9\u8D44\u6E90"
  },
  commands: {},
  theme: {
    choose_theme: "\u9009\u62E9\u4E3B\u9898",
    search_themes: "\u641C\u7D22\u4E3B\u9898...",
    filter_by_tags: "\u6309\u6807\u7B7E\u7B5B\u9009\uFF1A",
    clear_filters: "\u6E05\u9664\u7B5B\u9009",
    loading_themes: "\u6B63\u5728\u52A0\u8F7D\u4E3B\u9898...",
    loading_tags: "\u6B63\u5728\u52A0\u8F7D\u6807\u7B7E...",
    loading_initial: "\u6B63\u5728\u521D\u59CB\u5316\u4E3B\u9898\u5E93...",
    loading_search: "\u6B63\u5728\u641C\u7D22\u4E3B\u9898...",
    loading_error: "\u52A0\u8F7D\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5",
    no_themes_found: "\u672A\u627E\u5230\u4E3B\u9898",
    view_demo: "\u67E5\u770B\u6F14\u793A",
    live_demo: "\u5728\u7EBF\u6F14\u793A",
    use_it: "\u4F7F\u7528",
    current: "\u5F53\u524D",
    free: "\u514D\u8D39",
    by_author: "\u4F5C\u8005\uFF1A{{author}}",
    retry: "\u91CD\u8BD5"
  },
  projects: {
    manage_projects: "\u7BA1\u7406\u9879\u76EE",
    project_list: "\u9879\u76EE\u5217\u8868",
    no_projects: "\u6682\u65E0\u5DF2\u4FDD\u5B58\u7684\u9879\u76EE",
    select_project_to_view: "\u8BF7\u9009\u62E9\u4E00\u4E2A\u9879\u76EE\u4EE5\u67E5\u770B\u8BE6\u60C5",
    configuration: "\u914D\u7F6E\u4FE1\u606F",
    build_history: "\u6784\u5EFA\u5386\u53F2",
    no_build_history: "\u6682\u65E0\u6784\u5EFA\u5386\u53F2",
    apply_to_panel: "\u5E94\u7528\u5230\u9762\u677F",
    delete_project: "\u5220\u9664",
    delete_project_permanent: "\u5220\u9664\u6B64\u9879\u76EE",
    danger_zone: "\u5371\u9669\u533A\u57DF",
    clear_history_title: "\u6E05\u7A7A\u9884\u89C8\u5386\u53F2",
    clear_history_message: "\u6B64\u64CD\u4F5C\u5C06\u6C38\u4E45\u5220\u9664\u8BE5\u9879\u76EE\u7684\u6240\u6709\u9884\u89C8\u76EE\u5F55\u548C\u6784\u5EFA\u5386\u53F2\u8BB0\u5F55\uFF0C\u4F46\u4E0D\u4F1A\u5F71\u54CD\u5DF2\u5BFC\u51FA\u548C\u5DF2\u53D1\u5E03\u7684\u7AD9\u70B9\u3002",
    clear_preview_history: "\u6E05\u7A7A\u6240\u6709\u9884\u89C8",
    confirm_clear_history: "\u786E\u5B9A\u8981\u5220\u9664\u6240\u6709\u9884\u89C8\u6587\u4EF6\u5417\uFF1F\u6B64\u64CD\u4F5C\u53EF\u91CA\u653E\u78C1\u76D8\u7A7A\u95F4\uFF0C\u4F46\u65E0\u6CD5\u64A4\u9500\u3002",
    preview_history_cleared: "\u9884\u89C8\u5386\u53F2\u5DF2\u6E05\u7A7A\uFF0C\u5171\u5220\u9664 {{count}} \u4E2A\u76EE\u5F55",
    no_preview_files: "\u672A\u627E\u5230\u9700\u8981\u5220\u9664\u7684\u9884\u89C8\u6587\u4EF6",
    delete_warning_title: "\u5220\u9664\u9879\u76EE",
    delete_warning_message: "\u5220\u9664\u9879\u76EE\u540E\uFF0C\u6240\u6709\u914D\u7F6E\u4FE1\u606F\u548C\u6784\u5EFA\u5386\u53F2\u5C06\u88AB\u6C38\u4E45\u79FB\u9664\uFF0C\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\u3002",
    confirm_delete: '\u786E\u5B9A\u8981\u5220\u9664\u9879\u76EE "{{name}}" \u5417\uFF1F',
    project_applied: "\u9879\u76EE\u914D\u7F6E\u5E94\u7528\u6210\u529F",
    project_applied_no_content: "\u9879\u76EE\u914D\u7F6E\u5DF2\u5E94\u7528\uFF0C\u4F46\u5185\u5BB9\u8DEF\u5F84\u672A\u627E\u5230 - \u8BF7\u53F3\u952E\u70B9\u51FB\u6587\u4EF6\u5939/\u6587\u4EF6\u6DFB\u52A0\u5185\u5BB9",
    project_deleted: "\u9879\u76EE\u5DF2\u6210\u529F\u5220\u9664",
    view_site: "\u67E5\u770B\u7AD9\u70B9",
    export_build: "\u5BFC\u51FA",
    preview_not_found: "\u9884\u89C8\u76EE\u5F55\u672A\u627E\u5230\uFF0C\u53EF\u80FD\u5DF2\u88AB\u5220\u9664",
    just_now: "\u521A\u521A",
    minutes_ago: "{{count}} \u5206\u949F\u524D",
    hours_ago: "{{count}} \u5C0F\u65F6\u524D",
    days_ago: "{{count}} \u5929\u524D"
  },
  messages: {
    desktop_only_notice: "\u76EE\u524D\u4EC5\u652F\u6301\u684C\u9762\u7248\u672C\u3002",
    preview_url_copied: "\u9884\u89C8\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    publish_url_copied: "\u53D1\u5E03\u94FE\u63A5\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
    build_started: "\u5F00\u59CB\u6784\u5EFA",
    build_completed: "\u6784\u5EFA\u6210\u529F\u5B8C\u6210",
    build_failed: "\u6784\u5EFA\u5931\u8D25",
    publish_started: "\u5F00\u59CB\u53D1\u5E03",
    publish_completed: "\u53D1\u5E03\u6210\u529F",
    publish_failed: "\u53D1\u5E03\u5931\u8D25",
    no_folder_selected: "\u672A\u9009\u62E9\u6587\u4EF6\u5939",
    no_folder_or_file_selected: "\u672A\u9009\u62E9\u6587\u4EF6\u5939\u6216\u6587\u4EF6",
    must_select_folder_type: '\u5185\u5BB9\u7C7B\u578B\u4E0D\u5339\u914D\uFF1A\u60A8\u4E4B\u524D\u9009\u62E9\u4E86\u6587\u4EF6\u5939\uFF0C\u73B0\u5728\u9009\u62E9\u4E86\u6587\u4EF6\u3002\u8981\u53D1\u5E03\u6587\u4EF6\uFF0C\u8BF7\u70B9\u51FB\u53F3\u4E0A\u89D2\u7684"\u6E05\u7A7A"\u6309\u94AE\u79FB\u9664\u4E4B\u524D\u7684\u9009\u62E9\uFF0C\u7136\u540E\u53EA\u9009\u62E9\u6587\u4EF6\u3002',
    must_select_file_type: '\u5185\u5BB9\u7C7B\u578B\u4E0D\u5339\u914D\uFF1A\u60A8\u4E4B\u524D\u9009\u62E9\u4E86\u6587\u4EF6\uFF0C\u73B0\u5728\u9009\u62E9\u4E86\u6587\u4EF6\u5939\u3002\u8981\u53D1\u5E03\u6587\u4EF6\u5939\uFF0C\u8BF7\u70B9\u51FB\u53F3\u4E0A\u89D2\u7684"\u6E05\u7A7A"\u6309\u94AE\u79FB\u9664\u4E4B\u524D\u7684\u9009\u62E9\uFF0C\u7136\u540E\u53EA\u9009\u62E9\u6587\u4EF6\u5939\u3002',
    all_content_cleared: "\u6240\u6709\u5185\u5BB9\u5DF2\u6210\u529F\u6E05\u7A7A",
    language_added_successfully: "\u8BED\u8A00\u5185\u5BB9\u6DFB\u52A0\u6210\u529F",
    please_use_publish_first: '\u8BF7\u5148\u5728\u6587\u4EF6\u5939\u6216\u6587\u4EF6\u4E0A\u4F7F\u7528"\u53D1\u5E03\u5230\u7F51\u7AD9"\u529F\u80FD',
    add_language_instruction: '\u53F3\u952E\u70B9\u51FB\u6587\u4EF6\u5939\u6216\u6587\u4EF6\u5E76\u9009\u62E9"\u53D1\u5E03\u5230\u7F51\u7AD9"\u4EE5\u6DFB\u52A0\u66F4\u591A\u8BED\u8A00',
    preview_generated_successfully: "\u9884\u89C8\u751F\u6210\u6210\u529F\uFF01",
    preview_failed: "\u9884\u89C8\u5931\u8D25\uFF1A{{error}}",
    please_generate_preview_first: "\u8BF7\u5148\u751F\u6210\u9884\u89C8",
    preview_data_missing: "\u9884\u89C8\u6570\u636E\u7F3A\u5931",
    site_published_successfully: "\u7AD9\u70B9\u53D1\u5E03\u6210\u529F\uFF01",
    publishing_failed: "\u53D1\u5E03\u5931\u8D25\uFF1A{{error}}",
    site_exported_successfully: "\u7AD9\u70B9\u5BFC\u51FA\u6210\u529F\u81F3\uFF1A{{path}}",
    export_failed: "\u5BFC\u51FA\u5931\u8D25\uFF1A{{error}}",
    incremental_upload_stats: "\u589E\u91CF\u4E0A\u4F20\uFF1A\u5DF2\u4E0A\u4F20 {{uploaded}} \u4E2A\uFF0C\u5DF2\u5220\u9664 {{deleted}} \u4E2A\uFF0C\u672A\u53D8\u5316 {{unchanged}} \u4E2A\uFF08\u8282\u7701\u7EA6 {{saved}}% \u65F6\u95F4\uFF09",
    netlify_settings_missing: "\u8BF7\u5148\u914D\u7F6E Netlify \u8BBE\u7F6E",
    netlify_deploy_failed: "Netlify \u90E8\u7F72\u5931\u8D25\uFF1A{{error}}",
    netlify_deploy_success: "\u7AD9\u70B9\u5DF2\u6210\u529F\u90E8\u7F72\u5230 Netlify\uFF01",
    ftp_settings_missing: "\u8BF7\u5148\u914D\u7F6E FTP \u8BBE\u7F6E",
    ftp_upload_failed: "FTP \u4E0A\u4F20\u5931\u8D25\uFF1A{{error}}",
    ftp_upload_success: "\u7AD9\u70B9\u5DF2\u6210\u529F\u4E0A\u4F20\u5230 FTP \u670D\u52A1\u5668\uFF01",
    ftp_fallback_to_plain: "\u670D\u52A1\u5668\u4E0D\u652F\u6301\u52A0\u5BC6\uFF0C\u5DF2\u5207\u6362\u5230\u666E\u901A FTP",
    ftp_fallback_to_full: "\u26A0\uFE0F \u589E\u91CF\u4E0A\u4F20\u5931\u8D25\uFF0C\u6B63\u5728\u5C1D\u8BD5\u5B8C\u6574\u4E0A\u4F20\u4F5C\u4E3A\u5907\u9009\u65B9\u6848...",
    enter_email_password: "\u8BF7\u8F93\u5165\u60A8\u7684\u90AE\u7BB1\u548C\u5BC6\u7801",
    enter_valid_email: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u90AE\u7BB1\u5730\u5740",
    login_failed: "\u767B\u5F55\u5931\u8D25",
    register_failed: "\u6CE8\u518C\u7528\u6237\u5931\u8D25",
    invalid_assets_folder: "\u65E0\u6548\u7684\u8D44\u6E90\u6587\u4EF6\u5939",
    site_assets_set_successfully: "\u7AD9\u70B9\u8D44\u6E90\u8BBE\u7F6E\u6210\u529F",
    site_assets_cleared: "\u7AD9\u70B9\u8D44\u6E90\u5DF2\u6E05\u9664",
    sample_downloaded_successfully: '\u4E3B\u9898\u6837\u4F8B "{{themeName}}" \u4E0B\u8F7D\u6210\u529F\uFF01\u5DF2\u4FDD\u5B58\u5230\u6587\u4EF6\u5939\uFF1A{{folderName}}',
    sample_download_failed: "\u6837\u4F8B\u4E0B\u8F7D\u5931\u8D25\uFF1A{{error}}",
    structured_folder_processed: '\u68C0\u6D4B\u5230\u7ED3\u6784\u5316\u6587\u4EF6\u5939 "{{folderName}}"\uFF0C\u5DF2\u81EA\u52A8\u6DFB\u52A0 {{contentCount}} \u4E2A\u8BED\u8A00\u5185\u5BB9',
    static_folder_detected: "\u5E76\u68C0\u6D4B\u5230\u9759\u6001\u8D44\u6E90\u6587\u4EF6\u5939",
    failed_to_create_post: "\u521B\u5EFA\u6587\u7AE0\u5931\u8D25\u3002",
    failed_to_create_resource: "\u521B\u5EFA\u8D44\u6E90\u5931\u8D25\u3002"
  },
  info: {
    service_description: "\u4F60\u7684\u6570\u636E\uFF0C\u4F60\u638C\u63A7 \u2014\u2014 \u4F60\u7684\u7B14\u8BB0\u3001\u4F60\u7684\u4E3B\u9898\u3001\u4F60\u7684\u4E91\u7AEF\u3002\nMDFriday \u8BA9\u4F60\u81EA\u7531\u6784\u5EFA\u4E0E\u53D1\u5E03\uFF0C\u5B8C\u5168\u638C\u63E1\u5168\u6D41\u7A0B\u3002",
    learn_more: "\u4E86\u89E3\u66F4\u591A"
  },
  common: {
    loading: "\u52A0\u8F7D\u4E2D...",
    success: "\u6210\u529F",
    error: "\u9519\u8BEF",
    cancel: "\u53D6\u6D88",
    confirm: "\u786E\u8BA4",
    save: "\u4FDD\u5B58",
    close: "\u5173\u95ED",
    copy: "\u590D\u5236",
    copied: "\u5DF2\u590D\u5236\uFF01"
  }
};

// src/i18n/service.ts
var I18nService = class {
  constructor(plugin) {
    this.currentLanguage = DEFAULT_LANGUAGE;
    this.translations = {
      "en": en,
      "zh-cn": zhCn,
      "es": en,
      "fr": en,
      "de": en,
      "ja": en,
      "ko": en,
      "pt": en
    };
    this.ready = false;
    this.t = (key2, params) => {
      if (!this.ready) {
        console.warn("I18n service not ready, returning key:", key2);
        return key2;
      }
      const currentTranslations = this.translations[this.currentLanguage];
      if (!currentTranslations) {
        console.warn(`No translations found for language '${this.currentLanguage}'`);
        return key2;
      }
      const translation = getNestedValue(currentTranslations, key2);
      if (translation === void 0) {
        if (this.currentLanguage !== "en") {
          const fallbackTranslation = getNestedValue(this.translations["en"], key2);
          if (fallbackTranslation !== void 0) {
            console.warn(`Missing translation for key '${key2}' in '${this.currentLanguage}', using English fallback`);
            return interpolateTemplate(fallbackTranslation, params);
          }
        }
        console.warn(`Missing translation for key '${key2}' in '${this.currentLanguage}'`);
        return key2;
      }
      if (typeof translation !== "string") {
        console.warn(`Translation for key '${key2}' is not a string:`, translation);
        return key2;
      }
      return interpolateTemplate(translation, params);
    };
    this.plugin = plugin;
    this.app = plugin.app;
  }
  async init() {
    try {
      const detectedLanguage = detectLanguage(this.app);
      this.setLanguageInternal(detectedLanguage);
      this.ready = true;
    } catch (error) {
      console.error("Failed to initialize i18n service:", error);
      this.currentLanguage = DEFAULT_LANGUAGE;
      this.ready = true;
    }
  }
  getCurrentLanguage() {
    return this.currentLanguage;
  }
  setLanguageInternal(language) {
    if (!this.translations[language]) {
      console.warn(`Language '${language}' not supported, falling back to '${DEFAULT_LANGUAGE}'`);
      language = DEFAULT_LANGUAGE;
    }
    this.currentLanguage = language;
    this.plugin.app.workspace.trigger("friday:language-changed", language);
  }
  async setLanguage(language) {
    this.setLanguageInternal(language);
  }
  getAvailableLanguages() {
    return [...AVAILABLE_LANGUAGES];
  }
  isReady() {
    return this.ready;
  }
  getTranslationForLanguage(key2, language, params) {
    const translations = this.translations[language];
    if (!translations) {
      return key2;
    }
    const translation = getNestedValue(translations, key2);
    if (translation === void 0 || typeof translation !== "string") {
      return key2;
    }
    return interpolateTemplate(translation, params);
  }
  async reload() {
    this.ready = false;
    await this.init();
  }
  getLanguageDisplayName(code) {
    const targetCode = code || this.currentLanguage;
    const info = AVAILABLE_LANGUAGES.find((lang) => lang.code === targetCode);
    return info ? info.nativeName === info.name ? info.name : `${info.name} (${info.nativeName})` : targetCode;
  }
  hasTranslation(key2, language) {
    const targetLanguage = language || this.currentLanguage;
    const translations = this.translations[targetLanguage];
    if (!translations)
      return false;
    const translation = getNestedValue(translations, key2);
    return translation !== void 0 && typeof translation === "string";
  }
};

// src/ftp.ts
var ftp = __toESM2(require_dist4());
var path6 = __toESM2(require("path"));
var fs5 = __toESM2(require("fs"));
var crypto = __toESM2(require("crypto"));
var FTPUploader = class {
  constructor(config) {
    this.totalSize = 0;
    this.transferredSize = 0;
    this.lastProgressUpdate = 0;
    this.client = new ftp.Client();
    this.config = config;
  }
  setConnectionTypeCallback(callback) {
    this.onConnectionTypeDiscovered = callback;
  }
  setProgressCallback(callback) {
    this.onProgress = callback;
  }
  async calculateFileHash(filePath) {
    return new Promise((resolve, reject) => {
      const hash = crypto.createHash("md5");
      const stream = fs5.createReadStream(filePath);
      stream.on("data", (data) => hash.update(data));
      stream.on("end", () => resolve(hash.digest("hex")));
      stream.on("error", reject);
    });
  }
  async generateManifest(localDir, projectId) {
    const files = {};
    const scanRecursive = async (currentPath, relativePath = "") => {
      const items = await fs5.promises.readdir(currentPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path6.join(currentPath, item.name);
        const itemRelativePath = relativePath ? path6.join(relativePath, item.name) : item.name;
        if (item.isDirectory()) {
          await scanRecursive(itemPath, itemRelativePath);
        } else if (item.isFile()) {
          const stats = await fs5.promises.stat(itemPath);
          const hash = await this.calculateFileHash(itemPath);
          const normalizedPath = itemRelativePath.replace(/\\/g, "/");
          files[normalizedPath] = {
            hash,
            size: stats.size,
            mtime: stats.mtimeMs,
            relativePath: normalizedPath
          };
        }
      }
    };
    await scanRecursive(localDir);
    return {
      projectId,
      lastUploadTime: Date.now(),
      uploadMethod: "ftp",
      remoteDir: this.config.remoteDir,
      files
    };
  }
  compareManifests(oldManifest, newManifest) {
    const toUpload = [];
    const toDelete = [];
    const unchanged = [];
    if (!oldManifest) {
      return {
        toUpload: Object.keys(newManifest.files),
        toDelete: [],
        unchanged: []
      };
    }
    for (const [filePath, newEntry] of Object.entries(newManifest.files)) {
      const oldEntry = oldManifest.files[filePath];
      if (!oldEntry) {
        toUpload.push(filePath);
      } else if (oldEntry.hash !== newEntry.hash) {
        toUpload.push(filePath);
      } else {
        unchanged.push(filePath);
      }
    }
    for (const filePath of Object.keys(oldManifest.files)) {
      if (!newManifest.files[filePath]) {
        toDelete.push(filePath);
      }
    }
    return { toUpload, toDelete, unchanged };
  }
  async calculateDirectorySize(dirPath) {
    let totalSize = 0;
    const calculateRecursive = async (currentPath) => {
      const items = await fs5.promises.readdir(currentPath, { withFileTypes: true });
      for (const item of items) {
        const itemPath = path6.join(currentPath, item.name);
        if (item.isDirectory()) {
          await calculateRecursive(itemPath);
        } else if (item.isFile()) {
          const stats = await fs5.promises.stat(itemPath);
          totalSize += stats.size;
        }
      }
    };
    await calculateRecursive(dirPath);
    return totalSize;
  }
  async connectWithFallback() {
    const isDevelopment = false;
    this.client.ftp.verbose = isDevelopment;
    this.client.ftp.ipFamily = 4;
    const trySecureFirst = this.config.preferredSecure === true;
    const tryPlainFirst = this.config.preferredSecure === false || this.config.preferredSecure === void 0;
    if (tryPlainFirst) {
      const plainStart = Date.now();
      try {
        const result = await this.tryPlainFTP();
        if (this.onConnectionTypeDiscovered) {
          this.onConnectionTypeDiscovered(false);
        }
        return result;
      } catch (err) {
        const ftpsStart = Date.now();
        try {
          this.client.close();
          this.client = new ftp.Client();
          this.client.ftp.verbose = isDevelopment;
          this.client.ftp.ipFamily = 4;
          const result = await this.trySecureFTP();
          const ftpsDuration = Date.now() - ftpsStart;
          if (this.onConnectionTypeDiscovered) {
            this.onConnectionTypeDiscovered(true);
          }
          return result;
        } catch (secureErr) {
          const ftpsDuration = Date.now() - ftpsStart;
          console.error(`[FTP Performance] \u274C FTPS also failed: ${ftpsDuration}ms`);
          console.error("[FTP Performance] \u274C Both plain FTP and FTPS failed");
          throw err;
        }
      }
    } else {
      try {
        const result = await this.trySecureFTP();
        if (this.onConnectionTypeDiscovered) {
          this.onConnectionTypeDiscovered(true);
        }
        return result;
      } catch (err) {
        const plainStart = Date.now();
        try {
          this.client.close();
          this.client = new ftp.Client();
          this.client.ftp.verbose = isDevelopment;
          this.client.ftp.ipFamily = 4;
          const result = await this.tryPlainFTP();
          if (this.onConnectionTypeDiscovered) {
            this.onConnectionTypeDiscovered(false);
          }
          return result;
        } catch (plainErr) {
          const plainDuration = Date.now() - plainStart;
          console.error(`[FTP Performance] \u274C Plain FTP also failed: ${plainDuration}ms`);
          console.error("[FTP Performance] \u274C Both FTPS and plain FTP failed");
          throw err;
        }
      }
    }
  }
  async tryPlainFTP() {
    const plainConfig = {
      host: this.config.server,
      user: this.config.username,
      password: this.config.password,
      secure: false,
      timeout: 9e4
    };
    await this.client.access(plainConfig);
    return { usedSecure: false };
  }
  async trySecureFTP() {
    const secureConfig = {
      host: this.config.server,
      user: this.config.username,
      password: this.config.password,
      secure: true,
      secureOptions: {
        rejectUnauthorized: !this.config.ignoreCert
      },
      timeout: 9e4
    };
    await this.client.access(secureConfig);
    return { usedSecure: true };
  }
  async uploadDirectory(localDir) {
    const startTime = Date.now();
    try {
      this.totalSize = 0;
      this.transferredSize = 0;
      const sizeCalculationPromise = this.calculateDirectorySize(localDir).then((size) => {
        this.totalSize = size;
      });
      const connectionResult = await this.connectWithFallback();
      if (this.onProgress) {
        this.onProgress({
          fileName: "Preparing upload...",
          bytesTransferred: 0,
          totalBytes: this.totalSize,
          percentage: 40
        });
      }
      const PROGRESS_THROTTLE_MS = 200;
      this.lastProgressUpdate = 0;
      this.client.trackProgress((info) => {
        this.transferredSize += info.bytes;
        const now = Date.now();
        if (now - this.lastProgressUpdate < PROGRESS_THROTTLE_MS) {
          return;
        }
        this.lastProgressUpdate = now;
        const realProgress = this.totalSize > 0 ? this.transferredSize / this.totalSize : 0;
        const BASE_PROGRESS = 40;
        const PROGRESS_RANGE = 60;
        const easedProgress = Math.sqrt(realProgress);
        const percentage = Math.round(BASE_PROGRESS + easedProgress * PROGRESS_RANGE);
        if (this.onProgress) {
          this.onProgress({
            fileName: info.name || "Unknown",
            bytesTransferred: this.transferredSize,
            totalBytes: this.totalSize,
            percentage
          });
        }
      });
      if (this.config.remoteDir && this.config.remoteDir !== "/") {
        try {
          await this.client.cd(this.config.remoteDir);
        } catch (err) {
          await this.client.ensureDir(this.config.remoteDir);
          await this.client.cd(this.config.remoteDir);
        }
      }
      await this.client.uploadFromDir(localDir);
      await sizeCalculationPromise;
      if (this.onProgress) {
        this.onProgress({
          fileName: "Complete",
          bytesTransferred: this.totalSize || this.transferredSize,
          totalBytes: this.totalSize || this.transferredSize,
          percentage: 100
        });
      }
      return {
        success: true,
        usedSecure: connectionResult.usedSecure
      };
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      console.error(`[FTP Performance] \u274C Upload failed after ${totalDuration}ms:`, error);
      return {
        success: false,
        usedSecure: false,
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      this.client.close();
    }
  }
  async uploadFileWithRetry(localFilePath, remoteFilePath, displayName, maxRetries = 2) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        try {
          await this.client.remove(remoteFilePath);
          console.log(`[FTP Incremental]   - \u{1F5D1}\uFE0F  Removed existing file before upload: ${displayName}`);
        } catch (removeErr) {
        }
        await this.client.uploadFrom(localFilePath, remoteFilePath);
        if (attempt > 1) {
          console.log(`[FTP Incremental]   - \u2705 Upload succeeded on attempt ${attempt}: ${displayName}`);
        }
        return;
      } catch (err) {
        lastError = err;
        if (attempt < maxRetries) {
          console.warn(`[FTP Incremental]   - \u26A0\uFE0F  Upload attempt ${attempt}/${maxRetries} failed for ${displayName}, retrying...`);
          console.warn(`[FTP Incremental]   - Error: ${lastError.message}`);
          const waitTime = 1e3 * attempt;
          await new Promise((resolve) => setTimeout(resolve, waitTime));
        } else {
          console.error(`[FTP Incremental]   - \u274C All upload attempts failed for ${displayName}`);
          throw lastError;
        }
      }
    }
    throw lastError || new Error("Upload failed with unknown error");
  }
  async testConnection() {
    const startTime = Date.now();
    try {
      const connectionResult = await this.connectWithFallback();
      this.client.close();
      return {
        success: true,
        usedSecure: connectionResult.usedSecure
      };
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      console.error(`[FTP Performance] \u274C Connection test failed after ${totalDuration}ms:`, error);
      return {
        success: false,
        usedSecure: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  async uploadDirectoryIncremental(localDir, projectId, oldManifest) {
    const startTime = Date.now();
    try {
      const newManifest = await this.generateManifest(localDir, projectId);
      const { toUpload, toDelete, unchanged } = this.compareManifests(oldManifest, newManifest);
      const stats = {
        uploaded: toUpload.length,
        deleted: toDelete.length,
        unchanged: unchanged.length,
        totalFiles: Object.keys(newManifest.files).length
      };
      if (toUpload.length === 0 && toDelete.length === 0) {
        return {
          success: true,
          usedSecure: false,
          newManifest,
          stats
        };
      }
      this.totalSize = toUpload.reduce((sum, filePath) => {
        return sum + (newManifest.files[filePath]?.size || 0);
      }, 0);
      this.transferredSize = 0;
      const connectionResult = await this.connectWithFallback();
      if (this.onProgress) {
        this.onProgress({
          fileName: "Preparing incremental upload...",
          bytesTransferred: 0,
          totalBytes: this.totalSize,
          percentage: 40
        });
      }
      const PROGRESS_THROTTLE_MS = 200;
      this.lastProgressUpdate = 0;
      this.client.trackProgress((info) => {
        this.transferredSize += info.bytes;
        const now = Date.now();
        if (now - this.lastProgressUpdate < PROGRESS_THROTTLE_MS) {
          return;
        }
        this.lastProgressUpdate = now;
        const realProgress = this.totalSize > 0 ? this.transferredSize / this.totalSize : 0;
        const BASE_PROGRESS = 40;
        const PROGRESS_RANGE = 60;
        const easedProgress = Math.sqrt(realProgress);
        const percentage = Math.round(BASE_PROGRESS + easedProgress * PROGRESS_RANGE);
        if (this.onProgress) {
          this.onProgress({
            fileName: info.name || "Unknown",
            bytesTransferred: this.transferredSize,
            totalBytes: this.totalSize,
            percentage
          });
        }
      });
      if (this.config.remoteDir && this.config.remoteDir !== "/") {
        try {
          await this.client.cd(this.config.remoteDir);
        } catch (err) {
          await this.client.ensureDir(this.config.remoteDir);
          await this.client.cd(this.config.remoteDir);
        }
      }
      if (toDelete.length > 0) {
        console.log(`[FTP Incremental] \u{1F5D1}\uFE0F  Attempting to delete ${toDelete.length} obsolete files...`);
        for (const filePath of toDelete) {
          try {
            const remoteFilePath = this.config.remoteDir && this.config.remoteDir !== "/" ? `${this.config.remoteDir}/${filePath}`.replace(/\\/g, "/") : filePath.replace(/\\/g, "/");
            await this.client.remove(remoteFilePath);
          } catch (err) {
            console.error(`[FTP Incremental]   - \u26A0\uFE0F  Failed to delete ${filePath} (non-critical):`, err);
          }
        }
      }
      const createdDirs = /* @__PURE__ */ new Set();
      for (const filePath of toUpload) {
        const localFilePath = path6.join(localDir, filePath);
        const remoteFilePath = this.config.remoteDir && this.config.remoteDir !== "/" ? `${this.config.remoteDir}/${filePath}`.replace(/\\/g, "/") : filePath.replace(/\\/g, "/");
        const remoteDir = path6.dirname(remoteFilePath).replace(/\\/g, "/");
        if (remoteDir && remoteDir !== "." && remoteDir !== "/") {
          if (!createdDirs.has(remoteDir)) {
            try {
              await this.client.ensureDir(remoteDir);
              createdDirs.add(remoteDir);
            } catch (err) {
              console.error(`[FTP Incremental]   - \u26A0\uFE0F  Failed to ensure directory ${remoteDir}:`, err);
              console.error(`[FTP Incremental]   - Will attempt upload anyway...`);
            }
          }
        }
        try {
          await this.uploadFileWithRetry(localFilePath, remoteFilePath, filePath, 2);
        } catch (err) {
          console.error(`[FTP Incremental]   - \u274C Upload failed for ${filePath} after retries:`, err);
          console.error(`[FTP Incremental]   - Local path: ${localFilePath}`);
          console.error(`[FTP Incremental]   - Remote path: ${remoteFilePath}`);
          throw err;
        }
      }
      if (this.onProgress) {
        this.onProgress({
          fileName: "Complete",
          bytesTransferred: this.totalSize,
          totalBytes: this.totalSize,
          percentage: 100
        });
      }
      return {
        success: true,
        usedSecure: connectionResult.usedSecure,
        newManifest,
        stats
      };
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      console.error(`[FTP Incremental] \u274C Incremental upload failed after ${totalDuration}ms:`, error);
      return {
        success: false,
        usedSecure: false,
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      this.client.close();
    }
  }
};

// src/site.ts
var import_obsidian10 = require("obsidian");

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value2, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value2));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/site.ts
var Site2 = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = this.plugin.app;
    this.languageContents = writable([]);
    this.siteAssets = writable(null);
  }
  generateRandomId() {
    return Math.random().toString(36).substr(2, 9);
  }
  initializeContent(folder, file) {
    this.languageContents.update((contents) => {
      if (contents.length > 0) {
        return contents;
      }
      const initialContent = {
        id: this.generateRandomId(),
        folder,
        file,
        languageCode: "en",
        weight: 1
      };
      return [initialContent];
    });
  }
  initializeContentWithLanguage(folder, file, languageCode) {
    this.languageContents.update((contents) => {
      if (contents.length > 0) {
        return contents;
      }
      const initialContent = {
        id: this.generateRandomId(),
        folder,
        file,
        languageCode,
        weight: 1
      };
      return [initialContent];
    });
  }
  addLanguageContent(folder, file) {
    let canAdd = false;
    let currentContents = [];
    this.languageContents.subscribe((contents) => {
      currentContents = contents;
    })();
    if (currentContents.length === 0) {
      new import_obsidian10.Notice(this.plugin.i18n.t("messages.please_use_publish_first"), 5e3);
      return false;
    }
    const firstContent = currentContents[0];
    const isFirstFolder = !!firstContent.folder;
    const isNewFolder = !!folder;
    if (isFirstFolder !== isNewFolder) {
      const errorMessage = isFirstFolder ? this.plugin.i18n.t("messages.must_select_folder_type") : this.plugin.i18n.t("messages.must_select_file_type");
      new import_obsidian10.Notice(errorMessage, 5e3);
      return false;
    }
    this.languageContents.update((contents) => {
      const newContent = {
        id: this.generateRandomId(),
        folder,
        file,
        languageCode: "en",
        weight: contents.length + 1
      };
      canAdd = true;
      return [...contents, newContent];
    });
    if (canAdd) {
      new import_obsidian10.Notice(this.plugin.i18n.t("messages.language_added_successfully"), 3e3);
    }
    return canAdd;
  }
  addLanguageContentWithCode(folder, file, languageCode) {
    let canAdd = false;
    let currentContents = [];
    this.languageContents.subscribe((contents) => {
      currentContents = contents;
    })();
    if (currentContents.length === 0) {
      new import_obsidian10.Notice(this.plugin.i18n.t("messages.please_use_publish_first"), 5e3);
      return false;
    }
    const firstContent = currentContents[0];
    const isFirstFolder = !!firstContent.folder;
    const isNewFolder = !!folder;
    if (isFirstFolder !== isNewFolder) {
      const errorMessage = isFirstFolder ? this.plugin.i18n.t("messages.must_select_folder_type") : this.plugin.i18n.t("messages.must_select_file_type");
      new import_obsidian10.Notice(errorMessage, 5e3);
      return false;
    }
    this.languageContents.update((contents) => {
      const newContent = {
        id: this.generateRandomId(),
        folder,
        file,
        languageCode,
        weight: contents.length + 1
      };
      canAdd = true;
      return [...contents, newContent];
    });
    return canAdd;
  }
  updateLanguageCode(contentId, newLanguageCode) {
    this.languageContents.update((contents) => {
      return contents.map((content) => content.id === contentId ? { ...content, languageCode: newLanguageCode } : content);
    });
  }
  removeLanguageContent(contentId) {
    this.languageContents.update((contents) => {
      const filteredContents = contents.filter((content) => content.id !== contentId);
      return filteredContents.map((content, index) => ({
        ...content,
        weight: index + 1
      }));
    });
  }
  clearAllContent() {
    this.languageContents.set([]);
    new import_obsidian10.Notice(this.plugin.i18n.t("messages.all_content_cleared"), 3e3);
  }
  hasContent() {
    let hasContent = false;
    this.languageContents.subscribe((contents) => {
      hasContent = contents.length > 0;
    })();
    return hasContent;
  }
  getCurrentContents() {
    let currentContents = [];
    this.languageContents.subscribe((contents) => {
      currentContents = contents;
    })();
    return currentContents;
  }
  getDefaultContentLanguage() {
    const contents = this.getCurrentContents();
    return contents.length > 0 ? contents[0].languageCode : "en";
  }
  isForSingleFile() {
    const contents = this.getCurrentContents();
    return contents.length > 0 && !!contents[0].file;
  }
  setSiteAssets(folder) {
    if (!folder) {
      new import_obsidian10.Notice(this.plugin.i18n.t("messages.invalid_assets_folder"), 3e3);
      return false;
    }
    this.siteAssets.set({
      folder,
      path: folder.path
    });
    new import_obsidian10.Notice(this.plugin.i18n.t("messages.site_assets_set_successfully"), 3e3);
    return true;
  }
  clearSiteAssets() {
    this.siteAssets.set(null);
    new import_obsidian10.Notice(this.plugin.i18n.t("messages.site_assets_cleared"), 3e3);
  }
  getCurrentAssets() {
    let currentAssets = null;
    this.siteAssets.subscribe((assets) => {
      currentAssets = assets;
    })();
    return currentAssets;
  }
  hasAssets() {
    const assets = this.getCurrentAssets();
    return assets !== null;
  }
};

// src/projects/modal.ts
var import_obsidian11 = require("obsidian");
var ProjectManagementModal = class extends import_obsidian11.Modal {
  constructor(app, plugin, projectService, onApply, onExport, onClearHistory) {
    super(app);
    this.selectedProjectId = null;
    this.projects = [];
    this.currentProject = null;
    this.buildHistory = [];
    this.plugin = plugin;
    this.projectService = projectService;
    this.onApply = onApply;
    this.onExport = onExport;
    this.onClearHistory = onClearHistory;
    this.setTitle(plugin.i18n.t("projects.manage_projects"));
  }
  t(key2, params) {
    return this.plugin.i18n.t(key2, params);
  }
  async onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("friday-projects-modal");
    contentEl.empty();
    await this.loadProjects();
    this.renderModal();
  }
  async loadProjects() {
    this.projects = this.projectService.getProjects();
    if (!this.selectedProjectId && this.projects.length > 0) {
      this.selectedProjectId = this.projects[0].id;
    }
    if (this.selectedProjectId) {
      this.currentProject = this.projectService.getProject(this.selectedProjectId) || null;
      this.buildHistory = this.projectService.getBuildHistory(this.selectedProjectId, 10);
    } else {
      this.currentProject = null;
      this.buildHistory = [];
    }
  }
  renderModal() {
    const { contentEl } = this;
    contentEl.empty();
    const mainContainer = contentEl.createDiv("projects-main-container");
    const leftSidebar = mainContainer.createDiv("projects-left-sidebar");
    this.renderProjectsList(leftSidebar);
    const rightContent = mainContainer.createDiv("projects-right-content");
    this.renderProjectDetails(rightContent);
  }
  renderProjectsList(container) {
    container.empty();
    const header = container.createDiv("projects-list-header");
    header.createEl("h3", { text: this.t("projects.project_list"), cls: "projects-list-title" });
    const listContainer = container.createDiv("projects-list-container");
    if (this.projects.length === 0) {
      const emptyState = listContainer.createDiv("projects-empty-state");
      emptyState.createEl("p", { text: this.t("projects.no_projects"), cls: "empty-message" });
      return;
    }
    this.projects.forEach((project) => {
      const projectItem = listContainer.createDiv(`project-item ${this.selectedProjectId === project.id ? "selected" : ""}`);
      projectItem.createEl("div", { text: project.name, cls: "project-name" });
      projectItem.createEl("div", { text: project.id, cls: "project-path" });
      projectItem.addEventListener("click", async () => {
        this.selectedProjectId = project.id;
        await this.loadProjects();
        this.renderModal();
      });
    });
  }
  renderProjectDetails(container) {
    container.empty();
    if (!this.currentProject) {
      const emptyState = container.createDiv("project-details-empty");
      emptyState.createEl("p", {
        text: this.t("projects.select_project_to_view"),
        cls: "empty-message"
      });
      return;
    }
    const header = container.createDiv("project-details-header");
    const titleSection = header.createDiv("project-details-title-section");
    titleSection.createEl("h2", { text: this.currentProject.name, cls: "project-details-title" });
    const actionsSection = header.createDiv("project-details-actions");
    const applyBtn = actionsSection.createEl("button", {
      text: this.t("projects.apply_to_panel"),
      cls: "apply-project-btn"
    });
    applyBtn.addEventListener("click", () => {
      if (this.currentProject) {
        this.onApply(this.currentProject);
        new import_obsidian11.Notice(this.t("projects.project_applied"));
        this.close();
      }
    });
    const detailsContent = container.createDiv("project-details-content");
    const configSection = detailsContent.createDiv("project-config-section");
    configSection.createEl("h3", { text: this.t("projects.configuration"), cls: "section-title" });
    const configGrid = configSection.createDiv("config-grid");
    this.renderConfigItem(configGrid, this.t("ui.site_name"), this.currentProject.name);
    const contentLabel = this.t("ui.multilingual_content");
    const contentValue = this.currentProject.contents.map((c) => {
      const folderName = c.contentPath.split("/").pop() || c.contentPath;
      return `${folderName} (${c.languageCode})`;
    }).join(", ");
    this.renderConfigItem(configGrid, contentLabel, contentValue);
    this.renderConfigItem(configGrid, this.t("ui.default_language"), this.currentProject.defaultContentLanguage);
    if (this.currentProject.assetsPath) {
      const assetsFolderName = this.currentProject.assetsPath.split("/").pop() || this.currentProject.assetsPath;
      this.renderConfigItem(configGrid, this.t("ui.site_assets"), assetsFolderName);
    }
    this.renderConfigItem(configGrid, this.t("ui.theme"), this.currentProject.themeName);
    const advancedSection = configSection.createDiv("advanced-config-section");
    advancedSection.createEl("h4", { text: this.t("ui.advanced_settings"), cls: "subsection-title" });
    const advancedGrid = advancedSection.createDiv("config-grid");
    this.renderConfigItem(advancedGrid, this.t("ui.site_path"), this.currentProject.sitePath);
    if (this.currentProject.googleAnalyticsId) {
      this.renderConfigItem(advancedGrid, this.t("ui.google_analytics_id"), this.currentProject.googleAnalyticsId);
    }
    if (this.currentProject.disqusShortname) {
      this.renderConfigItem(advancedGrid, this.t("ui.disqus_shortname"), this.currentProject.disqusShortname);
    }
    if (this.currentProject.sitePassword) {
      this.renderConfigItem(advancedGrid, this.t("ui.site_password"), this.currentProject.sitePassword);
    }
    if (this.currentProject.publishConfig) {
      const publishSection = configSection.createDiv("publish-config-section");
      publishSection.createEl("h4", { text: this.t("ui.publish"), cls: "subsection-title" });
      const publishGrid = publishSection.createDiv("config-grid");
      const methodLabel = this.currentProject.publishConfig.method === "netlify" ? this.t("ui.publish_option_netlify") : this.currentProject.publishConfig.method === "ftp" ? this.t("ui.publish_option_ftp") : this.t("ui.publish_option_mdfriday");
      this.renderConfigItem(publishGrid, this.t("ui.publish_method"), methodLabel);
      if (this.currentProject.publishConfig.netlify && (this.currentProject.publishConfig.netlify.accessToken || this.currentProject.publishConfig.netlify.projectId)) {
        if (this.currentProject.publishConfig.netlify.accessToken) {
          this.renderConfigItem(publishGrid, this.t("settings.netlify_access_token"), "\u2022\u2022\u2022\u2022\u2022\u2022" + this.currentProject.publishConfig.netlify.accessToken.slice(-4));
        }
        if (this.currentProject.publishConfig.netlify.projectId) {
          this.renderConfigItem(publishGrid, this.t("settings.netlify_project_id"), this.currentProject.publishConfig.netlify.projectId);
        }
      }
      if (this.currentProject.publishConfig.ftp && (this.currentProject.publishConfig.ftp.server || this.currentProject.publishConfig.ftp.username)) {
        if (this.currentProject.publishConfig.ftp.server) {
          this.renderConfigItem(publishGrid, this.t("settings.ftp_server"), this.currentProject.publishConfig.ftp.server);
        }
        if (this.currentProject.publishConfig.ftp.username) {
          this.renderConfigItem(publishGrid, this.t("settings.ftp_username"), this.currentProject.publishConfig.ftp.username);
        }
        if (this.currentProject.publishConfig.ftp.remoteDir) {
          this.renderConfigItem(publishGrid, this.t("settings.ftp_remote_dir"), this.currentProject.publishConfig.ftp.remoteDir);
        }
      }
    }
    const historySection = detailsContent.createDiv("project-history-section");
    historySection.createEl("h3", { text: this.t("projects.build_history"), cls: "section-title" });
    const historyList = historySection.createDiv("history-list");
    if (this.buildHistory.length === 0) {
      historyList.createEl("p", { text: this.t("projects.no_build_history"), cls: "empty-message" });
    } else {
      this.buildHistory.forEach((history) => {
        const historyItem = historyList.createDiv("history-item");
        const typeIcon = history.type === "preview" ? "\u{1F441}\uFE0F" : "\u{1F680}";
        const statusIcon = history.success ? "\u2705" : "\u274C";
        const typeText = history.type === "preview" ? this.t("ui.preview") : this.t("ui.publish");
        const typeStatus = historyItem.createDiv("history-type-status");
        typeStatus.createEl("span", { text: `${typeIcon} ${typeText} ${statusIcon}`, cls: "history-type" });
        const timeAgo = this.formatTimeAgo(history.timestamp);
        historyItem.createEl("span", { text: timeAgo, cls: "history-time" });
        if (history.type === "publish" && history.publishMethod) {
          const methodText = history.publishMethod === "netlify" ? "Netlify" : history.publishMethod === "ftp" ? "FTP" : "MDFriday";
          historyItem.createEl("span", { text: methodText, cls: "history-method" });
        }
        if (history.url && history.type === "publish") {
          const urlLink = historyItem.createEl("a", {
            text: this.t("projects.view_site"),
            cls: "history-url",
            href: history.url
          });
          urlLink.target = "_blank";
        }
        if (history.previewId && history.success) {
          const exportBtn = historyItem.createEl("button", {
            text: this.t("projects.export_build"),
            cls: "history-export-btn"
          });
          exportBtn.addEventListener("click", async () => {
            try {
              await this.onExport(history.previewId);
            } catch (error) {
              console.error("Export failed:", error);
              new import_obsidian11.Notice(this.t("messages.export_failed", { error: error.message }), 5e3);
            }
          });
        }
        if (!history.success && history.error) {
          historyItem.createEl("div", { text: history.error, cls: "history-error" });
        }
      });
    }
    const dangerZone = detailsContent.createDiv("project-danger-zone");
    dangerZone.createEl("h3", { text: this.t("projects.danger_zone"), cls: "danger-zone-title" });
    const clearHistoryContent = dangerZone.createDiv("danger-zone-content");
    const clearHistoryWarning = clearHistoryContent.createDiv("danger-zone-warning");
    clearHistoryWarning.createEl("strong", { text: this.t("projects.clear_history_title") });
    clearHistoryWarning.createEl("p", { text: this.t("projects.clear_history_message") });
    const clearHistoryBtn = clearHistoryContent.createEl("button", {
      text: this.t("projects.clear_preview_history"),
      cls: "danger-zone-action-btn"
    });
    clearHistoryBtn.addEventListener("click", async () => {
      if (this.currentProject) {
        try {
          await this.onClearHistory(this.currentProject.id);
          await this.loadProjects();
          this.renderModal();
        } catch (error) {
          console.error("Clear history failed:", error);
        }
      }
    });
    dangerZone.createDiv("danger-zone-separator");
    const deleteContent = dangerZone.createDiv("danger-zone-content");
    const deleteWarning = deleteContent.createDiv("danger-zone-warning");
    deleteWarning.createEl("strong", { text: this.t("projects.delete_warning_title") });
    deleteWarning.createEl("p", { text: this.t("projects.delete_warning_message") });
    const deleteBtn = deleteContent.createEl("button", {
      text: this.t("projects.delete_project_permanent"),
      cls: "danger-zone-delete-btn"
    });
    deleteBtn.addEventListener("click", async () => {
      if (this.currentProject && confirm(this.t("projects.confirm_delete", { name: this.currentProject.name }))) {
        await this.projectService.deleteProject(this.currentProject.id);
        this.selectedProjectId = null;
        await this.loadProjects();
        this.renderModal();
        new import_obsidian11.Notice(this.t("projects.project_deleted"));
      }
    });
  }
  renderConfigItem(container, label, value2) {
    const item = container.createDiv("config-item");
    item.createEl("div", { text: label, cls: "config-label" });
    item.createEl("div", { text: value2, cls: "config-value" });
  }
  formatTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 6e4);
    const hours = Math.floor(diff / 36e5);
    const days = Math.floor(diff / 864e5);
    if (minutes < 1) {
      return this.t("projects.just_now");
    } else if (minutes < 60) {
      return this.t("projects.minutes_ago", { count: minutes });
    } else if (hours < 24) {
      return this.t("projects.hours_ago", { count: hours });
    } else {
      return this.t("projects.days_ago", { count: days });
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/projects/service.ts
var path7 = __toESM2(require("path"));
var fs6 = __toESM2(require("fs"));
var ProjectService = class {
  constructor(plugin) {
    this.dataFilePath = "";
    this.plugin = plugin;
    this.data = {
      projects: [],
      buildHistory: []
    };
  }
  async initialize() {
    this.dataFilePath = `${this.plugin.pluginDir}/projects-data.json`;
    await this.loadData();
  }
  async loadData() {
    try {
      const adapter = this.plugin.app.vault.adapter;
      if (await adapter.exists(this.dataFilePath)) {
        const content = await adapter.read(this.dataFilePath);
        this.data = JSON.parse(content);
      }
    } catch (error) {
      console.error("Failed to load projects data:", error);
      this.data = {
        projects: [],
        buildHistory: []
      };
    }
  }
  async saveData() {
    try {
      const adapter = this.plugin.app.vault.adapter;
      await adapter.write(this.dataFilePath, JSON.stringify(this.data, null, 2));
    } catch (error) {
      console.error("Failed to save projects data:", error);
      console.error("Data file path:", this.dataFilePath);
      throw error;
    }
  }
  getProjects() {
    return this.data.projects;
  }
  getProject(id) {
    return this.data.projects.find((p) => p.id === id);
  }
  async saveProject(project) {
    const existingIndex = this.data.projects.findIndex((p) => p.id === project.id);
    if (existingIndex >= 0) {
      const existingProject = this.data.projects[existingIndex];
      project.createdAt = existingProject.createdAt;
      project.updatedAt = Date.now();
      this.data.projects[existingIndex] = project;
    } else {
      if (!project.createdAt) {
        project.createdAt = Date.now();
      }
      project.updatedAt = Date.now();
      this.data.projects.push(project);
    }
    await this.saveData();
  }
  async deleteProject(id) {
    this.data.projects = this.data.projects.filter((p) => p.id !== id);
    this.data.buildHistory = this.data.buildHistory.filter((h) => h.projectId !== id);
    await this.saveData();
  }
  async addBuildHistory(history) {
    this.data.buildHistory.unshift(history);
    const projectHistories = this.data.buildHistory.filter((h) => h.projectId === history.projectId);
    if (projectHistories.length > 50) {
      const toRemove = projectHistories.slice(50);
      this.data.buildHistory = this.data.buildHistory.filter((h) => !toRemove.includes(h));
    }
    await this.saveData();
  }
  getBuildHistory(projectId, limit = 10) {
    return this.data.buildHistory.filter((h) => h.projectId === projectId).slice(0, limit);
  }
  getAllBuildHistory(limit = 20) {
    return this.data.buildHistory.slice(0, limit);
  }
  async clearProjectBuildHistory(projectId) {
    this.data.buildHistory = this.data.buildHistory.filter((h) => h.projectId !== projectId);
    await this.saveData();
  }
  getManifestFilePath(projectId, uploadMethod = "ftp") {
    const sanitizedId = projectId.replace(/[^a-zA-Z0-9-_]/g, "_");
    const filename = `manifest-${uploadMethod}-${sanitizedId}.json`;
    return path7.join(this.plugin.pluginDir, filename);
  }
  async loadManifest(projectId, uploadMethod = "ftp") {
    try {
      const filePath = this.getManifestFilePath(projectId, uploadMethod);
      const adapter = this.plugin.app.vault.adapter;
      if (!await adapter.exists(filePath)) {
        return null;
      }
      const content = await adapter.read(filePath);
      const manifest = JSON.parse(content);
      return manifest;
    } catch (error) {
      console.error(`[ProjectService] Failed to load manifest for ${projectId}:`, error);
      return null;
    }
  }
  async saveManifest(manifest) {
    try {
      const filePath = this.getManifestFilePath(manifest.projectId, manifest.uploadMethod);
      const adapter = this.plugin.app.vault.adapter;
      const dirPath = path7.dirname(filePath);
      if (!await adapter.exists(dirPath)) {
        await fs6.promises.mkdir(dirPath, { recursive: true });
      }
      const content = JSON.stringify(manifest, null, 2);
      await adapter.write(filePath, content);
    } catch (error) {
      console.error(`[ProjectService] Failed to save manifest for ${manifest.projectId}:`, error);
      throw error;
    }
  }
  async deleteManifest(projectId, uploadMethod = "ftp") {
    try {
      const filePath = this.getManifestFilePath(projectId, uploadMethod);
      const adapter = this.plugin.app.vault.adapter;
      if (await adapter.exists(filePath)) {
        await adapter.remove(filePath);
      }
    } catch (error) {
      console.error(`[ProjectService] Failed to delete manifest for ${projectId}:`, error);
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  username: "",
  password: "",
  userToken: "",
  downloadServer: "global",
  publishMethod: "netlify",
  netlifyAccessToken: "",
  netlifyProjectId: "",
  ftpServer: "",
  ftpUsername: "",
  ftpPassword: "",
  ftpRemoteDir: "",
  ftpIgnoreCert: true
};
var FRIDAY_ICON = "dice-5";
var API_URL_DEV = "http://127.0.0.1:1314";
var API_URL_PRO = "https://mdfriday.sunwei.xyz";
function GetBaseUrl() {
  return false ? API_URL_DEV : API_URL_PRO;
}
var FridayPlugin2 = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.ftp = null;
    this.applyProjectConfigurationToPanel = null;
    this.previousDownloadServer = "global";
  }
  async onload() {
    this.pluginDir = `${this.manifest.dir}`;
    await this.loadSettings();
    await this.initFriday();
    this.initializeFTP();
    this.statusBar = this.addStatusBarItem();
    this.addSettingTab(new FridaySettingTab(this.app, this));
    this.registerView(FRIDAY_SERVER_VIEW_TYPE, (leaf) => new ServerView(leaf, this));
    this.app.workspace.onLayoutReady(() => this.initLeaf());
    this.addCommand({
      id: "export-current-note-with-css",
      name: this.i18n.t("menu.publish_to_web"),
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "md") {
          if (!checking) {
            this.openPublishPanel(null, file);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian12.TFolder) {
        menu.addItem((item) => {
          item.setTitle(this.i18n.t("menu.publish_to_web")).setIcon(FRIDAY_ICON).onClick(async () => {
            await this.openPublishPanel(file, null);
          });
        });
        menu.addItem((item) => {
          item.setTitle(this.i18n.t("menu.set_as_site_assets")).setIcon("folder-plus").onClick(async () => {
            await this.setSiteAssets(file);
          });
        });
      } else if (file instanceof import_obsidian12.TFile && file.extension === "md") {
        menu.addItem((item) => {
          item.setTitle(this.i18n.t("menu.publish_to_web")).setIcon(FRIDAY_ICON).onClick(async () => {
            await this.openPublishPanel(null, file);
          });
        });
      }
    }));
  }
  async openPublishPanel(folder, file) {
    const rightSplit = this.app.workspace.rightSplit;
    if (!rightSplit) {
      return;
    }
    if (rightSplit.collapsed) {
      rightSplit.expand();
    }
    const projectId = await this.tryGetProjectId(folder, file);
    if (projectId) {
      const existingProject = this.projectService.getProject(projectId);
      if (existingProject) {
        await this.applyExistingProjectToPanel(existingProject);
        return;
      }
    }
    if (this.site.hasContent()) {
      const success = this.site.addLanguageContent(folder, file);
      if (!success) {
        return;
      }
    } else {
      if (folder && await this.detectStructuredFolder(folder)) {
        await this.processStructuredFolder(folder);
      } else {
        this.site.initializeContent(folder, file);
      }
    }
    const leaves = this.app.workspace.getLeavesOfType(FRIDAY_SERVER_VIEW_TYPE);
    if (leaves.length > 0) {
      await this.app.workspace.revealLeaf(leaves[0]);
    } else {
      const leaf = this.app.workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: FRIDAY_SERVER_VIEW_TYPE,
          active: true
        });
      }
    }
  }
  async tryGetProjectId(folder, file) {
    if (!folder && !file) {
      return null;
    }
    let projectId = folder?.path || file?.path || "";
    const contentFolder = folder || (file ? file.parent : null);
    if (contentFolder && contentFolder.parent) {
      const folderName = contentFolder.name.toLowerCase();
      if (folderName === "content" || folderName.startsWith("content.")) {
        projectId = contentFolder.parent.path;
      }
    }
    return projectId || null;
  }
  async applyExistingProjectToPanel(project) {
    try {
      if (this.applyProjectConfigurationToPanel) {
        this.applyProjectConfigurationToPanel(project);
      } else {
        console.error("applyProjectConfigurationToPanel method not registered yet");
      }
    } catch (error) {
      console.error("Failed to apply project configuration:", error);
    }
  }
  async detectStructuredFolder(folder) {
    try {
      const children2 = folder.children;
      const childNames = children2.map((child) => child.name.toLowerCase());
      const hasContentDirs = childNames.some((name) => name === "content" || name.startsWith("content."));
      const hasStaticDir = childNames.includes("static");
      return hasContentDirs;
    } catch (error) {
      console.warn("Error detecting structured folder:", error);
      return false;
    }
  }
  async processStructuredFolder(folder) {
    try {
      const children2 = folder.children;
      const contentFolders = [];
      let staticFolder = null;
      for (const child of children2) {
        if (!(child instanceof import_obsidian12.TFolder))
          continue;
        const childName = child.name.toLowerCase();
        if (childName === "content") {
          contentFolders.push({
            folder: child,
            languageCode: "en",
            weight: 0
          });
        } else if (childName.startsWith("content.")) {
          const langCode = childName.split(".")[1];
          const mappedLangCode = this.mapLanguageCode(langCode);
          contentFolders.push({
            folder: child,
            languageCode: mappedLangCode,
            weight: 1
          });
        }
        if (childName === "static") {
          staticFolder = child;
        }
      }
      contentFolders.sort((a, b) => {
        if (a.weight !== b.weight) {
          return a.weight - b.weight;
        }
        return a.folder.name.localeCompare(b.folder.name);
      });
      if (contentFolders.length > 0) {
        this.site.initializeContentWithLanguage(contentFolders[0].folder, null, contentFolders[0].languageCode);
        for (let i = 1; i < contentFolders.length; i++) {
          this.site.addLanguageContentWithCode(contentFolders[i].folder, null, contentFolders[i].languageCode);
        }
      }
      if (staticFolder) {
        this.site.setSiteAssets(staticFolder);
      }
      const contentCount = contentFolders.length;
      const hasStatic = staticFolder !== null;
      let message = this.i18n.t("messages.structured_folder_processed", {
        contentCount,
        folderName: folder.name
      });
      if (hasStatic) {
        message += " " + this.i18n.t("messages.static_folder_detected");
      }
      new import_obsidian12.Notice(message, 5e3);
    } catch (error) {
      console.error("Error processing structured folder:", error);
      this.site.initializeContent(folder, null);
    }
  }
  mapLanguageCode(code) {
    const languageMap = {
      "en": "en",
      "zh": "zh",
      "zh-cn": "zh",
      "zh-hans": "zh",
      "es": "es",
      "fr": "fr",
      "de": "de",
      "ja": "ja",
      "ko": "ko",
      "pt": "pt"
    };
    return languageMap[code.toLowerCase()] || "en";
  }
  async setSiteAssets(folder) {
    const success = this.site.setSiteAssets(folder);
    if (success) {
      const rightSplit = this.app.workspace.rightSplit;
      if (!rightSplit) {
        return;
      }
      if (rightSplit.collapsed) {
        rightSplit.expand();
      }
      const leaves = this.app.workspace.getLeavesOfType(FRIDAY_SERVER_VIEW_TYPE);
      if (leaves.length > 0) {
        await this.app.workspace.revealLeaf(leaves[0]);
      } else {
        const leaf = this.app.workspace.getRightLeaf(false);
        if (leaf) {
          await leaf.setViewState({
            type: FRIDAY_SERVER_VIEW_TYPE,
            active: true
          });
        }
      }
    }
  }
  showThemeSelectionModal(selectedTheme, onSelect, isForSingleFile = false) {
    const modal = new ThemeSelectionModal(this.app, selectedTheme, onSelect, this, isForSingleFile);
    modal.open();
  }
  showProjectManagementModal(onApply, onExport, onClearHistory) {
    const modal = new ProjectManagementModal(this.app, this, this.projectService, onApply, onExport, onClearHistory);
    modal.open();
  }
  async initFriday() {
    this.apiUrl = false ? API_URL_DEV : API_URL_PRO;
    this.i18n = new I18nService(this);
    await this.i18n.init();
    this.user = new User(this);
    this.hugoverse = new Hugoverse(this);
    this.netlify = new NetlifyAPI(this);
    this.site = new Site2(this);
    this.projectService = new ProjectService(this);
    await this.projectService.initialize();
  }
  initLeaf() {
    if (this.app.workspace.getLeavesOfType(FRIDAY_SERVER_VIEW_TYPE).length > 0)
      return;
    this.app.workspace.getRightLeaf(false)?.setViewState({
      type: FRIDAY_SERVER_VIEW_TYPE,
      active: true
    }).then((r) => {
    });
  }
  async onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.previousDownloadServer = this.settings.downloadServer;
  }
  async saveSettings() {
    const downloadServerChanged = this.previousDownloadServer !== this.settings.downloadServer;
    await this.saveData(this.settings);
    if (downloadServerChanged) {
      themeApiService.clearCache();
      this.previousDownloadServer = this.settings.downloadServer;
    }
    this.initializeFTP();
  }
  initializeFTP(preferredSecure) {
    const { ftpServer, ftpUsername, ftpPassword, ftpRemoteDir, ftpIgnoreCert } = this.settings;
    if (ftpServer && ftpUsername && ftpPassword) {
      this.ftp = new FTPUploader({
        server: ftpServer,
        username: ftpUsername,
        password: ftpPassword,
        remoteDir: ftpRemoteDir || "/",
        ignoreCert: ftpIgnoreCert,
        preferredSecure
      });
    } else {
      this.ftp = null;
    }
  }
  async testFTPConnection() {
    if (!this.ftp) {
      return {
        success: false,
        message: "FTP not configured"
      };
    }
    try {
      const result = await this.ftp.testConnection();
      if (result.success) {
        const secureInfo = result.usedSecure ? "FTPS" : "FTP (Plain)";
        return {
          success: true,
          message: `Connection successful using ${secureInfo}`
        };
      } else {
        return {
          success: false,
          message: result.error || "Connection failed"
        };
      }
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : String(error)
      };
    }
  }
  async status(text3) {
    this.statusBar.setText(text3);
  }
};
var FridaySettingTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const { username, password, userToken, downloadServer, publishMethod, netlifyAccessToken, netlifyProjectId, ftpServer, ftpUsername, ftpPassword, ftpRemoteDir, ftpIgnoreCert } = this.plugin.settings;
    containerEl.createEl("h2", { text: this.plugin.i18n.t("settings.general_settings") });
    new import_obsidian12.Setting(containerEl).setName(this.plugin.i18n.t("settings.download_server")).setDesc(this.plugin.i18n.t("settings.download_server_desc")).addDropdown((dropdown) => {
      dropdown.addOption("global", this.plugin.i18n.t("settings.download_server_global")).addOption("east", this.plugin.i18n.t("settings.download_server_east")).setValue(downloadServer || "global").onChange(async (value2) => {
        this.plugin.settings.downloadServer = value2;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", { text: this.plugin.i18n.t("settings.publish_settings") });
    let netlifySettingsContainer;
    let ftpSettingsContainer;
    new import_obsidian12.Setting(containerEl).setName(this.plugin.i18n.t("settings.publish_method")).setDesc(this.plugin.i18n.t("settings.publish_method_desc")).addDropdown((dropdown) => {
      dropdown.addOption("netlify", this.plugin.i18n.t("settings.publish_method_netlify")).addOption("ftp", this.plugin.i18n.t("settings.publish_method_ftp")).setValue(publishMethod || "netlify").onChange(async (value2) => {
        this.plugin.settings.publishMethod = value2;
        await this.plugin.saveSettings();
        showPublishSettings(value2);
      });
    });
    netlifySettingsContainer = containerEl.createDiv("netlify-settings-container");
    ftpSettingsContainer = containerEl.createDiv("ftp-settings-container");
    const showPublishSettings = (method) => {
      if (method === "netlify") {
        netlifySettingsContainer.style.display = "block";
        ftpSettingsContainer.style.display = "none";
      } else {
        netlifySettingsContainer.style.display = "none";
        ftpSettingsContainer.style.display = "block";
      }
    };
    netlifySettingsContainer.createEl("h3", { text: this.plugin.i18n.t("settings.netlify_settings") });
    new import_obsidian12.Setting(netlifySettingsContainer).setName(this.plugin.i18n.t("settings.netlify_access_token")).setDesc(this.plugin.i18n.t("settings.netlify_access_token_desc")).addText((text3) => {
      text3.setPlaceholder(this.plugin.i18n.t("settings.netlify_access_token_placeholder")).setValue(netlifyAccessToken || "").onChange(async (value2) => {
        this.plugin.settings.netlifyAccessToken = value2;
        await this.plugin.saveSettings();
      });
      text3.inputEl.type = "password";
    });
    new import_obsidian12.Setting(netlifySettingsContainer).setName(this.plugin.i18n.t("settings.netlify_project_id")).setDesc(this.plugin.i18n.t("settings.netlify_project_id_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.netlify_project_id_placeholder")).setValue(netlifyProjectId || "").onChange(async (value2) => {
      this.plugin.settings.netlifyProjectId = value2;
      await this.plugin.saveSettings();
    }));
    ftpSettingsContainer.createEl("h3", { text: this.plugin.i18n.t("settings.ftp_settings") });
    let resetButtonState;
    new import_obsidian12.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_server")).setDesc(this.plugin.i18n.t("settings.ftp_server_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_server_placeholder")).setValue(ftpServer || "").onChange(async (value2) => {
      this.plugin.settings.ftpServer = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    new import_obsidian12.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_username")).setDesc(this.plugin.i18n.t("settings.ftp_username_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_username_placeholder")).setValue(ftpUsername || "").onChange(async (value2) => {
      this.plugin.settings.ftpUsername = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    new import_obsidian12.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_password")).setDesc(this.plugin.i18n.t("settings.ftp_password_desc")).addText((text3) => {
      text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_password_placeholder")).setValue(ftpPassword || "").onChange(async (value2) => {
        this.plugin.settings.ftpPassword = value2;
        await this.plugin.saveSettings();
        if (resetButtonState)
          resetButtonState();
      });
      text3.inputEl.type = "password";
    });
    new import_obsidian12.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_remote_dir")).setDesc(this.plugin.i18n.t("settings.ftp_remote_dir_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.ftp_remote_dir_placeholder")).setValue(ftpRemoteDir || "").onChange(async (value2) => {
      this.plugin.settings.ftpRemoteDir = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    new import_obsidian12.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_ignore_cert")).setDesc(this.plugin.i18n.t("settings.ftp_ignore_cert_desc")).addToggle((toggle) => toggle.setValue(ftpIgnoreCert).onChange(async (value2) => {
      this.plugin.settings.ftpIgnoreCert = value2;
      await this.plugin.saveSettings();
      if (resetButtonState)
        resetButtonState();
    }));
    const testConnectionSetting = new import_obsidian12.Setting(ftpSettingsContainer).setName(this.plugin.i18n.t("settings.ftp_test_connection")).setDesc(this.plugin.i18n.t("settings.ftp_test_connection_desc"));
    let testButton;
    let testResultEl = null;
    const isFTPConfigured = () => {
      return !!(this.plugin.settings.ftpServer?.trim() && this.plugin.settings.ftpUsername?.trim() && this.plugin.settings.ftpPassword?.trim());
    };
    const updateButtonState = (state, message) => {
      if (testResultEl) {
        testResultEl.remove();
        testResultEl = null;
      }
      switch (state) {
        case "idle":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection");
          testButton.disabled = !isFTPConfigured();
          testButton.removeClass("ftp-test-success", "ftp-test-error");
          break;
        case "testing":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection_testing");
          testButton.disabled = true;
          testButton.removeClass("ftp-test-success", "ftp-test-error");
          break;
        case "success":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection_success");
          testButton.disabled = false;
          testButton.removeClass("ftp-test-error");
          testButton.addClass("ftp-test-success");
          if (message) {
            testResultEl = ftpSettingsContainer.createEl("div", {
              text: `\u2705 ${message}`,
              cls: "ftp-test-result ftp-test-result-success"
            });
            testConnectionSetting.settingEl.insertAdjacentElement("afterend", testResultEl);
          }
          break;
        case "error":
          testButton.textContent = this.plugin.i18n.t("settings.ftp_test_connection_failed");
          testButton.disabled = false;
          testButton.removeClass("ftp-test-success");
          testButton.addClass("ftp-test-error");
          if (message) {
            testResultEl = ftpSettingsContainer.createEl("div", {
              text: `\u274C ${message}`,
              cls: "ftp-test-result ftp-test-result-error"
            });
            testConnectionSetting.settingEl.insertAdjacentElement("afterend", testResultEl);
          }
          break;
      }
    };
    resetButtonState = () => {
      updateButtonState("idle");
    };
    testConnectionSetting.addButton((button) => {
      testButton = button.buttonEl;
      updateButtonState("idle");
      button.onClick(async () => {
        updateButtonState("testing");
        try {
          this.plugin.initializeFTP();
          const result = await this.plugin.testFTPConnection();
          if (result.success) {
            updateButtonState("success", result.message);
          } else {
            updateButtonState("error", result.message);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          updateButtonState("error", errorMessage);
        }
      });
    });
    showPublishSettings(publishMethod || "netlify");
    containerEl.createEl("h2", { text: this.plugin.i18n.t("settings.mdfriday_account") });
    if (userToken) {
      containerEl.createEl("p", { text: this.plugin.i18n.t("settings.logged_in_as", { username }) });
      new import_obsidian12.Setting(containerEl).addButton((button) => button.setButtonText(this.plugin.i18n.t("settings.logout")).setCta().onClick(async () => {
        await this.plugin.user.logout();
        this.display();
      }));
    } else {
      containerEl.createEl("p", { text: this.plugin.i18n.t("settings.mdfriday_account_desc") });
      new import_obsidian12.Setting(containerEl).setName(this.plugin.i18n.t("settings.email")).setDesc(this.plugin.i18n.t("settings.email_desc")).addText((text3) => text3.setPlaceholder(this.plugin.i18n.t("settings.email_placeholder")).setValue(username || "").onChange(async (value2) => {
        this.plugin.settings.username = value2;
        await this.plugin.saveSettings();
      }));
      new import_obsidian12.Setting(containerEl).setName(this.plugin.i18n.t("settings.password")).setDesc(this.plugin.i18n.t("settings.password_desc")).addText((text3) => {
        text3.setPlaceholder(this.plugin.i18n.t("settings.password_placeholder")).setValue(password || "").onChange(async (value2) => {
          this.plugin.settings.password = value2;
          await this.plugin.saveSettings();
        });
        text3.inputEl.type = "password";
      });
      new import_obsidian12.Setting(containerEl).addButton((button) => button.setButtonText(this.plugin.i18n.t("settings.register")).setCta().onClick(async () => {
        await this.plugin.user.register();
        this.display();
      })).addButton((button) => button.setButtonText(this.plugin.i18n.t("settings.login")).setCta().onClick(async () => {
        await this.plugin.user.login();
        this.display();
      }));
    }
  }
};
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
/*!
 * Copyright (c) Squirrel Chat et al., All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */

/* nosourcemap */